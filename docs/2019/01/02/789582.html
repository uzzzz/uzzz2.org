<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Kubernetes部署（十）：储存之glusterfs和heketi部署 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Kubernetes部署（十）：储存之glusterfs和heketi部署" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="相关内容： Kubernetes部署（一）：架构及功能说明Kubernetes部署（二）：系统环境初始化Kubernetes部署（三）：CA证书制作Kubernetes部署（四）：ETCD集群部署Kubernetes部署（五）：Haproxy、Keppalived部署Kubernetes部署（六）：Master节点部署Kubernetes部署（七）：Node节点部署Kubernetes部署（八）：Flannel网络部署Kubernetes部署（九）：CoreDNS、Dashboard、Ingress部署Kubernetes部署（十）：储存之glusterfs和heketi部署Kubernetes部署（十一）：管理之Helm和Rancher部署Kubernetes部署（十二）：helm部署harbor企业级镜像仓库 概观 本指南支持在Kubernetes集群中集成，部署和管理GlusterFS容器化存储节点。这使Kubernetes管理员能够为其用户提供可靠的共享存储。 包括设置指南、其中包含一个示例服务器pod，它使用动态配置的GlusterFS卷进行存储。对于那些希望测试或了解有关此主题的更多信息的人，请按照主要自述文件中的快速入门说明 了解gluster-kubernetes 本指南旨在演示Heketi在Kubernetes环境中管理Gluster的最小示例。 基础设施要求 一个正在运行的Kubernetes集群，至少有三个Kubernetes工作节点，每个节点至少连接一个可用的原始块设备（如EBS卷或本地磁盘）。 #使用file -s 查看硬盘如果显示为data则为原始块设备。如果不是data类型，可先用pvcreate，pvremove来变更。 [root@node-04 ~]# file -s /dev/sdc /dev/sdc: x86 boot sector, code offset 0xb8 [root@node-04 ~]# pvcreate /dev/sdc WARNING: dos signature detected on /dev/sdc at offset 510. Wipe it? [y/n]: y Wiping dos signature on /dev/sdc. Physical volume &quot;/dev/sdc&quot; successfully created. [root@node-04 ~]# pvremove /dev/sdc Labels on physical volume &quot;/dev/sdc&quot; successfully wiped. [root@node-04 ~]# file -s /dev/sdc /dev/sdc: data 在glusterfs节点的宿主机需要安装glusterfs-client、glusterfs-fuse包和socat包。 yum install -y glusterfs-client glusterfs-fuse socat 每个kubetnetes节点的宿主机需要加载dm_thin_pool模块modprobe dm_thin_pool 客户端安装 Heketi提供CLI，为用户提供管理Kubernetes中GlusterFS的部署和配置的方法。 在您的客户端计算机上下载并安装下载并安装heketi-cli，下载的heketi-cli版本最好是和heketi服务端版本一致，不然可能会出现报错。 Kubernetes部署 部署GlusterFS DaemonSet { &quot;kind&quot;: &quot;DaemonSet&quot;, &quot;apiVersion&quot;: &quot;extensions/v1beta1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;glusterfs&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;deployment&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;GlusterFS Daemon Set&quot;, &quot;tags&quot;: &quot;glusterfs&quot; } }, &quot;spec&quot;: { &quot;template&quot;: { &quot;metadata&quot;: { &quot;name&quot;: &quot;glusterfs&quot;, &quot;labels&quot;: { &quot;glusterfs-node&quot;: &quot;daemonset&quot; } }, &quot;spec&quot;: { &quot;nodeSelector&quot;: { &quot;storagenode&quot; : &quot;glusterfs&quot; }, &quot;hostNetwork&quot;: true, &quot;containers&quot;: [ { &quot;image&quot;: &quot;gluster/gluster-centos:latest&quot;, &quot;imagePullPolicy&quot;: &quot;Always&quot;, &quot;name&quot;: &quot;glusterfs&quot;, &quot;volumeMounts&quot;: [ { &quot;name&quot;: &quot;glusterfs-heketi&quot;, &quot;mountPath&quot;: &quot;/var/lib/heketi&quot; }, { &quot;name&quot;: &quot;glusterfs-run&quot;, &quot;mountPath&quot;: &quot;/run&quot; }, { &quot;name&quot;: &quot;glusterfs-lvm&quot;, &quot;mountPath&quot;: &quot;/run/lvm&quot; }, { &quot;name&quot;: &quot;glusterfs-etc&quot;, &quot;mountPath&quot;: &quot;/etc/glusterfs&quot; }, { &quot;name&quot;: &quot;glusterfs-logs&quot;, &quot;mountPath&quot;: &quot;/var/log/glusterfs&quot; }, { &quot;name&quot;: &quot;glusterfs-config&quot;, &quot;mountPath&quot;: &quot;/var/lib/glusterd&quot; }, { &quot;name&quot;: &quot;glusterfs-dev&quot;, &quot;mountPath&quot;: &quot;/dev&quot; }, { &quot;name&quot;: &quot;glusterfs-cgroup&quot;, &quot;mountPath&quot;: &quot;/sys/fs/cgroup&quot; } ], &quot;securityContext&quot;: { &quot;capabilities&quot;: {}, &quot;privileged&quot;: true }, &quot;readinessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 60, &quot;exec&quot;: { &quot;command&quot;: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;systemctl status glusterd.service&quot; ] } }, &quot;livenessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 60, &quot;exec&quot;: { &quot;command&quot;: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;systemctl status glusterd.service&quot; ] } } } ], &quot;volumes&quot;: [ { &quot;name&quot;: &quot;glusterfs-heketi&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/var/lib/heketi&quot; } }, { &quot;name&quot;: &quot;glusterfs-run&quot; }, { &quot;name&quot;: &quot;glusterfs-lvm&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/run/lvm&quot; } }, { &quot;name&quot;: &quot;glusterfs-etc&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/etc/glusterfs&quot; } }, { &quot;name&quot;: &quot;glusterfs-logs&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/var/log/glusterfs&quot; } }, { &quot;name&quot;: &quot;glusterfs-config&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/var/lib/glusterd&quot; } }, { &quot;name&quot;: &quot;glusterfs-dev&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/dev&quot; } }, { &quot;name&quot;: &quot;glusterfs-cgroup&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/sys/fs/cgroup&quot; } } ] } } } } $ kubectl create -f glusterfs-daemonset.json 通过运行获取节点名称： $ kubectl get nodes 通过storagenode=glusterfs在该节点上设置标签，将gluster容器部署到指定节点上。 [root@node-01 heketi]# kubectl label node 10.31.90.204 storagenode=glusterfs [root@node-01 heketi]# kubectl label node 10.31.90.205 storagenode=glusterfs [root@node-01 heketi]# kubectl label node 10.31.90.206 storagenode=glusterfs 根据需要,验证pod正在节点上运行，至少应运行三个pod。 $ kubectl get pods 接下来我们将为Heketi创建一个ServiceAccount： { &quot;apiVersion&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;ServiceAccount&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi-service-account&quot; } } $ kubectl create -f heketi-service-account.json 我们现在必须建立该服务帐户控制gluster pod的能力。我们通过为新创建的服务帐户创建集群角色绑定来实现此目的。 $ kubectl create clusterrolebinding heketi-gluster-admin --clusterrole=edit --serviceaccount=default:heketi-service-account 现在我们需要创建一个Kubernetes secret，它将保存我们的Heketi实例的配置。必须将配置文件设置为使用 kubernetes执行程序，以便Heketi服务器控制gluster pod。除此之外，您可以随意尝试配置选项。 { &quot;_port_comment&quot;: &quot;Heketi Server Port Number&quot;, &quot;port&quot;: &quot;8080&quot;, &quot;_use_auth&quot;: &quot;Enable JWT authorization. Please enable for deployment&quot;, &quot;use_auth&quot;: false, &quot;_jwt&quot;: &quot;Private keys for access&quot;, &quot;jwt&quot;: { &quot;_admin&quot;: &quot;Admin has access to all APIs&quot;, &quot;admin&quot;: { &quot;key&quot;: &quot;My Secret&quot; }, &quot;_user&quot;: &quot;User only has access to /volumes endpoint&quot;, &quot;user&quot;: { &quot;key&quot;: &quot;My Secret&quot; } }, &quot;_glusterfs_comment&quot;: &quot;GlusterFS Configuration&quot;, &quot;glusterfs&quot;: { &quot;_executor_comment&quot;: &quot;Execute plugin. Possible choices: mock, kubernetes, ssh&quot;, &quot;executor&quot;: &quot;kubernetes&quot;, &quot;_db_comment&quot;: &quot;Database file name&quot;, &quot;db&quot;: &quot;/var/lib/heketi/heketi.db&quot;, &quot;kubeexec&quot;: { &quot;rebalance_on_expansion&quot;: true }, &quot;sshexec&quot;: { &quot;rebalance_on_expansion&quot;: true, &quot;keyfile&quot;: &quot;/etc/heketi/private_key&quot;, &quot;fstab&quot;: &quot;/etc/fstab&quot;, &quot;port&quot;: &quot;22&quot;, &quot;user&quot;: &quot;root&quot;, &quot;sudo&quot;: false } }, &quot;_backup_db_to_kube_secret&quot;: &quot;Backup the heketi database to a Kubernetes secret when running in Kubernetes. Default is off.&quot;, &quot;backup_db_to_kube_secret&quot;: false } $ kubectl create secret generic heketi-config-secret --from-file=./heketi.json 接下来，我们需要部署一个初始Pod和一个服务来访问该pod。如下会有一个heketi-bootstrap.json文件。提交文件并验证一切正常运行，如下所示： { &quot;kind&quot;: &quot;List&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;items&quot;: [ { &quot;kind&quot;: &quot;Service&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-service&quot;, &quot;deploy-heketi&quot;: &quot;support&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;Exposes Heketi Service&quot; } }, &quot;spec&quot;: { &quot;selector&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot; }, &quot;ports&quot;: [ { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;port&quot;: 8080, &quot;targetPort&quot;: 8080 } ] } }, { &quot;kind&quot;: &quot;Deployment&quot;, &quot;apiVersion&quot;: &quot;extensions/v1beta1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-deployment&quot;, &quot;deploy-heketi&quot;: &quot;deployment&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;Defines how to deploy Heketi&quot; } }, &quot;spec&quot;: { &quot;replicas&quot;: 1, &quot;template&quot;: { &quot;metadata&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;labels&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;glusterfs&quot;: &quot;heketi-pod&quot;, &quot;deploy-heketi&quot;: &quot;pod&quot; } }, &quot;spec&quot;: { &quot;serviceAccountName&quot;: &quot;heketi-service-account&quot;, &quot;containers&quot;: [ { &quot;image&quot;: &quot;heketi/heketi:8&quot;, &quot;imagePullPolicy&quot;: &quot;Always&quot;, &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;env&quot;: [ { &quot;name&quot;: &quot;HEKETI_EXECUTOR&quot;, &quot;value&quot;: &quot;kubernetes&quot; }, { &quot;name&quot;: &quot;HEKETI_DB_PATH&quot;, &quot;value&quot;: &quot;/var/lib/heketi/heketi.db&quot; }, { &quot;name&quot;: &quot;HEKETI_FSTAB&quot;, &quot;value&quot;: &quot;/var/lib/heketi/fstab&quot; }, { &quot;name&quot;: &quot;HEKETI_SNAPSHOT_LIMIT&quot;, &quot;value&quot;: &quot;14&quot; }, { &quot;name&quot;: &quot;HEKETI_KUBE_GLUSTER_DAEMONSET&quot;, &quot;value&quot;: &quot;y&quot; } ], &quot;ports&quot;: [ { &quot;containerPort&quot;: 8080 } ], &quot;volumeMounts&quot;: [ { &quot;name&quot;: &quot;db&quot;, &quot;mountPath&quot;: &quot;/var/lib/heketi&quot; }, { &quot;name&quot;: &quot;config&quot;, &quot;mountPath&quot;: &quot;/etc/heketi&quot; } ], &quot;readinessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 3, &quot;httpGet&quot;: { &quot;path&quot;: &quot;/hello&quot;, &quot;port&quot;: 8080 } }, &quot;livenessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 30, &quot;httpGet&quot;: { &quot;path&quot;: &quot;/hello&quot;, &quot;port&quot;: 8080 } } } ], &quot;volumes&quot;: [ { &quot;name&quot;: &quot;db&quot; }, { &quot;name&quot;: &quot;config&quot;, &quot;secret&quot;: { &quot;secretName&quot;: &quot;heketi-config-secret&quot; } } ] } } } } ] } # kubectl create -f heketi-bootstrap.json service &quot;deploy-heketi&quot; created deployment &quot;deploy-heketi&quot; created [root@node-01 heketi]# kubectl get pod NAME READY STATUS RESTARTS AGE deploy-heketi-8888799fd-cmfp6 1/1 Running 0 6m glusterfs-7t5ls 1/1 Running 0 8m glusterfs-drsx9 1/1 Running 0 8m glusterfs-pnnn8 1/1 Running 0 8m 现在Bootstrap Heketi服务正在运行，我们将配置端口转发，以便我们可以使用Heketi CLI与服务进行通信。使用Heketi pod的名称，运行以下命令： kubectl port-forward deploy-heketi-8888799fd-cmfp6 :8080 如果在运行命令的系统上本地端口8080空闲，则可以运行port-forward命令，以便它为了方便而绑定到8080： kubectl port-forward deploy-heketi-8888799fd-cmfp6 18080:8080 现在通过对Heketi服务运行示例查询来验证端口转发是否正常工作。该命令应该打印将要转发的本地端口。将其合并到URL中以测试服务，如下所示： curl http://localhost:18080/hello Handling connection for 18080 Hello from Heketi 最后，为Heketi CLI客户端设置环境变量，以便它知道如何到达Heketi Server。 export HEKETI_CLI_SERVER=http://localhost:18080 接下来，我们将向Heketi提供有关要管理的GlusterFS集群的信息。我们通过拓扑文件提供此信息 。您克隆的repo中有一个示例拓扑文件，名为topology-sample.json。拓扑指定运行GlusterFS容器的Kubernetes节点以及每个节点的相应原始块设备。 确保hostnames/manage指向下面显示的确切名称kubectl get nodes，并且hostnames/storage是存储网络的IP地址。 重要信息：此时，必须使用与服务器版本匹配的heketi-cli版本加载拓扑文件。作为最后的手段，Heketi容器附带了一份可以通过的方式访问的heketi-cli kubectl exec ...。 修改拓扑文件以反映您所做的选择，然后部署它，如下所示： { &quot;clusters&quot;: [ { &quot;nodes&quot;: [ { &quot;node&quot;: { &quot;hostnames&quot;: { &quot;manage&quot;: [ &quot;10.31.90.204&quot; ], &quot;storage&quot;:[ &quot;10.31.90.204&quot; ] }, &quot;zone&quot;: 1 }, &quot;devices&quot;: [ &quot;/dev/sdc&quot; ] }, { &quot;node&quot;: { &quot;hostnames&quot;: { &quot;manage&quot;: [ &quot;10.31.90.205&quot; ], &quot;storage&quot;:[ &quot;10.31.90.205&quot; ] }, &quot;zone&quot;: 1 }, &quot;devices&quot;: [ &quot;/dev/sdc&quot; ] }, { &quot;node&quot;: { &quot;hostnames&quot;: { &quot;manage&quot;: [ &quot;10.31.90.206&quot; ], &quot;storage&quot;:[ &quot;10.31.90.206&quot; ] }, &quot;zone&quot;: 1 }, &quot;devices&quot;: [ &quot;/dev/sdc&quot; ] } ] } ] } [root@node-01 ~]# heketi-cli topology load --json=top.json Creating cluster ... ID: e758afb77ee26d5f969d7efee1516e64 Allowing file volumes on cluster. Allowing block volumes on cluster. Creating node 10.31.90.204 ... ID: a6eedd58c118dcfe44a0db2af1a4f863 Adding device /dev/sdc ... OK Creating node 10.31.90.205 ... ID: 4066962c14bcdebd28aca193b5690792 Adding device /dev/sdc ... OK Creating node 10.31.90.206 ... ID: 91e42a2361f0266ae334354e5c34ce11 Adding device /dev/sdc ... OK 接下来我们将使用Heketi为它配置一个卷来存储其数据库： 执行此命令后会生成一个heketi-storage.json的文件，我们最好是将此文件里的&quot;image&quot;: &quot;heketi/heketi:dev&quot;改为&quot;image&quot;: &quot;heketi/heketi:8&quot; # heketi-client/bin/heketi-cli setup-openshift-heketi-storage 然后在创建heketi相关服务 # kubectl create -f heketi-storage.json 陷阱：如果heketi-cli在运行setup-openshift-heketi-storage子命令时报告“无空间”错误，则可能无意中运行topology load了服务器和heketi-cli的不匹配版本。停止正在运行的Heketi pod（kubectl scale deployment deploy-heketi --replicas=0），手动从存储块设备中删除任何签名，然后继续运行Heketi pod（kubectl scale deployment deploy-heketi --replicas=1）。然后使用匹配版本的heketi-cli重新加载拓扑并重试该步骤。 等到作业完成然后删除引导程序Heketi： # kubectl delete all,service,jobs,deployment,secret --selector=&quot;deploy-heketi&quot; 创建长期Heketi实例： { &quot;kind&quot;: &quot;List&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;items&quot;: [ { &quot;kind&quot;: &quot;Secret&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi-db-backup&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-db&quot;, &quot;heketi&quot;: &quot;db&quot; } }, &quot;data&quot;: { }, &quot;type&quot;: &quot;Opaque&quot; }, { &quot;kind&quot;: &quot;Service&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-service&quot;, &quot;deploy-heketi&quot;: &quot;support&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;Exposes Heketi Service&quot; } }, &quot;spec&quot;: { &quot;selector&quot;: { &quot;name&quot;: &quot;heketi&quot; }, &quot;ports&quot;: [ { &quot;name&quot;: &quot;heketi&quot;, &quot;port&quot;: 8080, &quot;targetPort&quot;: 8080 } ] } }, { &quot;kind&quot;: &quot;Deployment&quot;, &quot;apiVersion&quot;: &quot;extensions/v1beta1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-deployment&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;Defines how to deploy Heketi&quot; } }, &quot;spec&quot;: { &quot;replicas&quot;: 1, &quot;template&quot;: { &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi&quot;, &quot;labels&quot;: { &quot;name&quot;: &quot;heketi&quot;, &quot;glusterfs&quot;: &quot;heketi-pod&quot; } }, &quot;spec&quot;: { &quot;serviceAccountName&quot;: &quot;heketi-service-account&quot;, &quot;containers&quot;: [ { &quot;image&quot;: &quot;heketi/heketi:8&quot;, &quot;imagePullPolicy&quot;: &quot;Always&quot;, &quot;name&quot;: &quot;heketi&quot;, &quot;env&quot;: [ { &quot;name&quot;: &quot;HEKETI_EXECUTOR&quot;, &quot;value&quot;: &quot;kubernetes&quot; }, { &quot;name&quot;: &quot;HEKETI_DB_PATH&quot;, &quot;value&quot;: &quot;/var/lib/heketi/heketi.db&quot; }, { &quot;name&quot;: &quot;HEKETI_FSTAB&quot;, &quot;value&quot;: &quot;/var/lib/heketi/fstab&quot; }, { &quot;name&quot;: &quot;HEKETI_SNAPSHOT_LIMIT&quot;, &quot;value&quot;: &quot;14&quot; }, { &quot;name&quot;: &quot;HEKETI_KUBE_GLUSTER_DAEMONSET&quot;, &quot;value&quot;: &quot;y&quot; } ], &quot;ports&quot;: [ { &quot;containerPort&quot;: 8080 } ], &quot;volumeMounts&quot;: [ { &quot;mountPath&quot;: &quot;/backupdb&quot;, &quot;name&quot;: &quot;heketi-db-secret&quot; }, { &quot;name&quot;: &quot;db&quot;, &quot;mountPath&quot;: &quot;/var/lib/heketi&quot; }, { &quot;name&quot;: &quot;config&quot;, &quot;mountPath&quot;: &quot;/etc/heketi&quot; } ], &quot;readinessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 3, &quot;httpGet&quot;: { &quot;path&quot;: &quot;/hello&quot;, &quot;port&quot;: 8080 } }, &quot;livenessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 30, &quot;httpGet&quot;: { &quot;path&quot;: &quot;/hello&quot;, &quot;port&quot;: 8080 } } } ], &quot;volumes&quot;: [ { &quot;name&quot;: &quot;db&quot;, &quot;glusterfs&quot;: { &quot;endpoints&quot;: &quot;heketi-storage-endpoints&quot;, &quot;path&quot;: &quot;heketidbstorage&quot; } }, { &quot;name&quot;: &quot;heketi-db-secret&quot;, &quot;secret&quot;: { &quot;secretName&quot;: &quot;heketi-db-backup&quot; } }, { &quot;name&quot;: &quot;config&quot;, &quot;secret&quot;: { &quot;secretName&quot;: &quot;heketi-config-secret&quot; } } ] } } } } ] } # kubectl create -f heketi-deployment.json service &quot;heketi&quot; created deployment &quot;heketi&quot; created 现在这样做了，Heketi数据库将保留在GlusterFS卷中，并且每次重启Heketi pod时都不会重置。 使用诸如heketi-cli cluster list和之类的命令heketi-cli volume list 来确认先前建立的集群是否存在，以及Heketi是否知道在引导阶段创建的db存储卷。 演示测试 接下来就是建立存储卷，然后挂载测试。在测试之前我们需要先将heketi服务通过Ingress对外发布，将heketi.cnlinux.club的A记录解析为10.31.90.200。 apiVersion: extensions/v1beta1 kind: Ingress metadata: name: ingress-heketi annotations: nginx.ingress.kubernetes.io/rewrite-target: / kubernetes.io/ingress.class: nginx spec: rules: - host: heketi.cnlinux.club http: paths: - path: backend: serviceName: heketi servicePort: 8080 [root@node-01 heketi]# kubectl create -f ingress-heketi.yaml 在浏览器访问http://heketi.cnlinux.club/hello 创建StorageClass apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: gluster-heketi provisioner: kubernetes.io/glusterfs parameters: resturl: &quot;http://heketi.cnlinux.club&quot; restauthenabled: &quot;false&quot; volumetype: &quot;replicate:2&quot; [root@node-01 heketi]# kubectl create -f storageclass-gluster-heketi.yaml [root@node-01 heketi]# kubectl get sc NAME PROVISIONER AGE gluster-heketi kubernetes.io/glusterfs 10s 创建pvc apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc-gluster-heketi spec: storageClassName: gluster-heketi accessModes: - ReadWriteOnce resources: requests: storage: 1Gi [root@node-01 heketi]# kubectl create -f pvc-gluster-heketi.yaml [root@node-01 heketi]# kubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE pvc-gluster-heketi Bound pvc-d978f524-0b74-11e9-875c-005056826470 1Gi RWO gluster-heketi 30s 在pod里挂载pvc apiVersion: v1 kind: Pod metadata: name: pod-pvc spec: containers: - name: pod-pvc image: busybox:latest command: - sleep - &quot;3600&quot; volumeMounts: - name: gluster-volume mountPath: &quot;/pv-data&quot; volumes: - name: gluster-volume persistentVolumeClaim: claimName: pvc-gluster-heketi [root@node-01 heketi]# kubectl create -f pod-pvc.yaml 进入容器查看是否已经挂载成功 [root@node-01 heketi]# kubectl exec pod-pvc -it /bin/sh / # df -h Filesystem Size Used Available Use% Mounted on overlay 47.8G 4.3G 43.5G 9% / tmpfs 64.0M 0 64.0M 0% /dev tmpfs 1.9G 0 1.9G 0% /sys/fs/cgroup 10.31.90.204:vol_675cc9fe0e959157919c886ea7786d33 1014.0M 42.7M 971.3M 4% /pv-data /dev/sda3 47.8G 4.3G 43.5G 9% /dev/termination-log /dev/sda3 47.8G 4.3G 43.5G 9% /etc/resolv.conf /dev/sda3 47.8G 4.3G 43.5G 9% /etc/hostname /dev/sda3 47.8G 4.3G 43.5G 9% /etc/hosts #往/pv-data写文件，当容量超过1G时就自动退出了，证明容量限制是生效的。 / # cd /pv-data/ /pv-data # dd if=/dev/zero of=/pv-data/test.img bs=8M count=300 123+0 records in 122+0 records out 1030225920 bytes (982.5MB) copied, 24.255925 seconds, 40.5MB/s 在宿主机磁盘里查看是否创建了test.img文件 [root@node-04 cfg]# mount /dev/vg_2631413b8b87bbd6cb526568ab697d37/brick_1691ef862dd504e12e8384af76e5a9f2 /mnt [root@node-04 cfg]# ll -h /mnt/brick/ total 982M -rw-r--r-- 2 root 2001 982M Jan 2 15:14 test.img 至此，所有的操作都已完成。 转载于:https://blog.51cto.com/billy98/2337874" />
<meta property="og:description" content="相关内容： Kubernetes部署（一）：架构及功能说明Kubernetes部署（二）：系统环境初始化Kubernetes部署（三）：CA证书制作Kubernetes部署（四）：ETCD集群部署Kubernetes部署（五）：Haproxy、Keppalived部署Kubernetes部署（六）：Master节点部署Kubernetes部署（七）：Node节点部署Kubernetes部署（八）：Flannel网络部署Kubernetes部署（九）：CoreDNS、Dashboard、Ingress部署Kubernetes部署（十）：储存之glusterfs和heketi部署Kubernetes部署（十一）：管理之Helm和Rancher部署Kubernetes部署（十二）：helm部署harbor企业级镜像仓库 概观 本指南支持在Kubernetes集群中集成，部署和管理GlusterFS容器化存储节点。这使Kubernetes管理员能够为其用户提供可靠的共享存储。 包括设置指南、其中包含一个示例服务器pod，它使用动态配置的GlusterFS卷进行存储。对于那些希望测试或了解有关此主题的更多信息的人，请按照主要自述文件中的快速入门说明 了解gluster-kubernetes 本指南旨在演示Heketi在Kubernetes环境中管理Gluster的最小示例。 基础设施要求 一个正在运行的Kubernetes集群，至少有三个Kubernetes工作节点，每个节点至少连接一个可用的原始块设备（如EBS卷或本地磁盘）。 #使用file -s 查看硬盘如果显示为data则为原始块设备。如果不是data类型，可先用pvcreate，pvremove来变更。 [root@node-04 ~]# file -s /dev/sdc /dev/sdc: x86 boot sector, code offset 0xb8 [root@node-04 ~]# pvcreate /dev/sdc WARNING: dos signature detected on /dev/sdc at offset 510. Wipe it? [y/n]: y Wiping dos signature on /dev/sdc. Physical volume &quot;/dev/sdc&quot; successfully created. [root@node-04 ~]# pvremove /dev/sdc Labels on physical volume &quot;/dev/sdc&quot; successfully wiped. [root@node-04 ~]# file -s /dev/sdc /dev/sdc: data 在glusterfs节点的宿主机需要安装glusterfs-client、glusterfs-fuse包和socat包。 yum install -y glusterfs-client glusterfs-fuse socat 每个kubetnetes节点的宿主机需要加载dm_thin_pool模块modprobe dm_thin_pool 客户端安装 Heketi提供CLI，为用户提供管理Kubernetes中GlusterFS的部署和配置的方法。 在您的客户端计算机上下载并安装下载并安装heketi-cli，下载的heketi-cli版本最好是和heketi服务端版本一致，不然可能会出现报错。 Kubernetes部署 部署GlusterFS DaemonSet { &quot;kind&quot;: &quot;DaemonSet&quot;, &quot;apiVersion&quot;: &quot;extensions/v1beta1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;glusterfs&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;deployment&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;GlusterFS Daemon Set&quot;, &quot;tags&quot;: &quot;glusterfs&quot; } }, &quot;spec&quot;: { &quot;template&quot;: { &quot;metadata&quot;: { &quot;name&quot;: &quot;glusterfs&quot;, &quot;labels&quot;: { &quot;glusterfs-node&quot;: &quot;daemonset&quot; } }, &quot;spec&quot;: { &quot;nodeSelector&quot;: { &quot;storagenode&quot; : &quot;glusterfs&quot; }, &quot;hostNetwork&quot;: true, &quot;containers&quot;: [ { &quot;image&quot;: &quot;gluster/gluster-centos:latest&quot;, &quot;imagePullPolicy&quot;: &quot;Always&quot;, &quot;name&quot;: &quot;glusterfs&quot;, &quot;volumeMounts&quot;: [ { &quot;name&quot;: &quot;glusterfs-heketi&quot;, &quot;mountPath&quot;: &quot;/var/lib/heketi&quot; }, { &quot;name&quot;: &quot;glusterfs-run&quot;, &quot;mountPath&quot;: &quot;/run&quot; }, { &quot;name&quot;: &quot;glusterfs-lvm&quot;, &quot;mountPath&quot;: &quot;/run/lvm&quot; }, { &quot;name&quot;: &quot;glusterfs-etc&quot;, &quot;mountPath&quot;: &quot;/etc/glusterfs&quot; }, { &quot;name&quot;: &quot;glusterfs-logs&quot;, &quot;mountPath&quot;: &quot;/var/log/glusterfs&quot; }, { &quot;name&quot;: &quot;glusterfs-config&quot;, &quot;mountPath&quot;: &quot;/var/lib/glusterd&quot; }, { &quot;name&quot;: &quot;glusterfs-dev&quot;, &quot;mountPath&quot;: &quot;/dev&quot; }, { &quot;name&quot;: &quot;glusterfs-cgroup&quot;, &quot;mountPath&quot;: &quot;/sys/fs/cgroup&quot; } ], &quot;securityContext&quot;: { &quot;capabilities&quot;: {}, &quot;privileged&quot;: true }, &quot;readinessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 60, &quot;exec&quot;: { &quot;command&quot;: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;systemctl status glusterd.service&quot; ] } }, &quot;livenessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 60, &quot;exec&quot;: { &quot;command&quot;: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;systemctl status glusterd.service&quot; ] } } } ], &quot;volumes&quot;: [ { &quot;name&quot;: &quot;glusterfs-heketi&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/var/lib/heketi&quot; } }, { &quot;name&quot;: &quot;glusterfs-run&quot; }, { &quot;name&quot;: &quot;glusterfs-lvm&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/run/lvm&quot; } }, { &quot;name&quot;: &quot;glusterfs-etc&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/etc/glusterfs&quot; } }, { &quot;name&quot;: &quot;glusterfs-logs&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/var/log/glusterfs&quot; } }, { &quot;name&quot;: &quot;glusterfs-config&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/var/lib/glusterd&quot; } }, { &quot;name&quot;: &quot;glusterfs-dev&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/dev&quot; } }, { &quot;name&quot;: &quot;glusterfs-cgroup&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/sys/fs/cgroup&quot; } } ] } } } } $ kubectl create -f glusterfs-daemonset.json 通过运行获取节点名称： $ kubectl get nodes 通过storagenode=glusterfs在该节点上设置标签，将gluster容器部署到指定节点上。 [root@node-01 heketi]# kubectl label node 10.31.90.204 storagenode=glusterfs [root@node-01 heketi]# kubectl label node 10.31.90.205 storagenode=glusterfs [root@node-01 heketi]# kubectl label node 10.31.90.206 storagenode=glusterfs 根据需要,验证pod正在节点上运行，至少应运行三个pod。 $ kubectl get pods 接下来我们将为Heketi创建一个ServiceAccount： { &quot;apiVersion&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;ServiceAccount&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi-service-account&quot; } } $ kubectl create -f heketi-service-account.json 我们现在必须建立该服务帐户控制gluster pod的能力。我们通过为新创建的服务帐户创建集群角色绑定来实现此目的。 $ kubectl create clusterrolebinding heketi-gluster-admin --clusterrole=edit --serviceaccount=default:heketi-service-account 现在我们需要创建一个Kubernetes secret，它将保存我们的Heketi实例的配置。必须将配置文件设置为使用 kubernetes执行程序，以便Heketi服务器控制gluster pod。除此之外，您可以随意尝试配置选项。 { &quot;_port_comment&quot;: &quot;Heketi Server Port Number&quot;, &quot;port&quot;: &quot;8080&quot;, &quot;_use_auth&quot;: &quot;Enable JWT authorization. Please enable for deployment&quot;, &quot;use_auth&quot;: false, &quot;_jwt&quot;: &quot;Private keys for access&quot;, &quot;jwt&quot;: { &quot;_admin&quot;: &quot;Admin has access to all APIs&quot;, &quot;admin&quot;: { &quot;key&quot;: &quot;My Secret&quot; }, &quot;_user&quot;: &quot;User only has access to /volumes endpoint&quot;, &quot;user&quot;: { &quot;key&quot;: &quot;My Secret&quot; } }, &quot;_glusterfs_comment&quot;: &quot;GlusterFS Configuration&quot;, &quot;glusterfs&quot;: { &quot;_executor_comment&quot;: &quot;Execute plugin. Possible choices: mock, kubernetes, ssh&quot;, &quot;executor&quot;: &quot;kubernetes&quot;, &quot;_db_comment&quot;: &quot;Database file name&quot;, &quot;db&quot;: &quot;/var/lib/heketi/heketi.db&quot;, &quot;kubeexec&quot;: { &quot;rebalance_on_expansion&quot;: true }, &quot;sshexec&quot;: { &quot;rebalance_on_expansion&quot;: true, &quot;keyfile&quot;: &quot;/etc/heketi/private_key&quot;, &quot;fstab&quot;: &quot;/etc/fstab&quot;, &quot;port&quot;: &quot;22&quot;, &quot;user&quot;: &quot;root&quot;, &quot;sudo&quot;: false } }, &quot;_backup_db_to_kube_secret&quot;: &quot;Backup the heketi database to a Kubernetes secret when running in Kubernetes. Default is off.&quot;, &quot;backup_db_to_kube_secret&quot;: false } $ kubectl create secret generic heketi-config-secret --from-file=./heketi.json 接下来，我们需要部署一个初始Pod和一个服务来访问该pod。如下会有一个heketi-bootstrap.json文件。提交文件并验证一切正常运行，如下所示： { &quot;kind&quot;: &quot;List&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;items&quot;: [ { &quot;kind&quot;: &quot;Service&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-service&quot;, &quot;deploy-heketi&quot;: &quot;support&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;Exposes Heketi Service&quot; } }, &quot;spec&quot;: { &quot;selector&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot; }, &quot;ports&quot;: [ { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;port&quot;: 8080, &quot;targetPort&quot;: 8080 } ] } }, { &quot;kind&quot;: &quot;Deployment&quot;, &quot;apiVersion&quot;: &quot;extensions/v1beta1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-deployment&quot;, &quot;deploy-heketi&quot;: &quot;deployment&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;Defines how to deploy Heketi&quot; } }, &quot;spec&quot;: { &quot;replicas&quot;: 1, &quot;template&quot;: { &quot;metadata&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;labels&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;glusterfs&quot;: &quot;heketi-pod&quot;, &quot;deploy-heketi&quot;: &quot;pod&quot; } }, &quot;spec&quot;: { &quot;serviceAccountName&quot;: &quot;heketi-service-account&quot;, &quot;containers&quot;: [ { &quot;image&quot;: &quot;heketi/heketi:8&quot;, &quot;imagePullPolicy&quot;: &quot;Always&quot;, &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;env&quot;: [ { &quot;name&quot;: &quot;HEKETI_EXECUTOR&quot;, &quot;value&quot;: &quot;kubernetes&quot; }, { &quot;name&quot;: &quot;HEKETI_DB_PATH&quot;, &quot;value&quot;: &quot;/var/lib/heketi/heketi.db&quot; }, { &quot;name&quot;: &quot;HEKETI_FSTAB&quot;, &quot;value&quot;: &quot;/var/lib/heketi/fstab&quot; }, { &quot;name&quot;: &quot;HEKETI_SNAPSHOT_LIMIT&quot;, &quot;value&quot;: &quot;14&quot; }, { &quot;name&quot;: &quot;HEKETI_KUBE_GLUSTER_DAEMONSET&quot;, &quot;value&quot;: &quot;y&quot; } ], &quot;ports&quot;: [ { &quot;containerPort&quot;: 8080 } ], &quot;volumeMounts&quot;: [ { &quot;name&quot;: &quot;db&quot;, &quot;mountPath&quot;: &quot;/var/lib/heketi&quot; }, { &quot;name&quot;: &quot;config&quot;, &quot;mountPath&quot;: &quot;/etc/heketi&quot; } ], &quot;readinessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 3, &quot;httpGet&quot;: { &quot;path&quot;: &quot;/hello&quot;, &quot;port&quot;: 8080 } }, &quot;livenessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 30, &quot;httpGet&quot;: { &quot;path&quot;: &quot;/hello&quot;, &quot;port&quot;: 8080 } } } ], &quot;volumes&quot;: [ { &quot;name&quot;: &quot;db&quot; }, { &quot;name&quot;: &quot;config&quot;, &quot;secret&quot;: { &quot;secretName&quot;: &quot;heketi-config-secret&quot; } } ] } } } } ] } # kubectl create -f heketi-bootstrap.json service &quot;deploy-heketi&quot; created deployment &quot;deploy-heketi&quot; created [root@node-01 heketi]# kubectl get pod NAME READY STATUS RESTARTS AGE deploy-heketi-8888799fd-cmfp6 1/1 Running 0 6m glusterfs-7t5ls 1/1 Running 0 8m glusterfs-drsx9 1/1 Running 0 8m glusterfs-pnnn8 1/1 Running 0 8m 现在Bootstrap Heketi服务正在运行，我们将配置端口转发，以便我们可以使用Heketi CLI与服务进行通信。使用Heketi pod的名称，运行以下命令： kubectl port-forward deploy-heketi-8888799fd-cmfp6 :8080 如果在运行命令的系统上本地端口8080空闲，则可以运行port-forward命令，以便它为了方便而绑定到8080： kubectl port-forward deploy-heketi-8888799fd-cmfp6 18080:8080 现在通过对Heketi服务运行示例查询来验证端口转发是否正常工作。该命令应该打印将要转发的本地端口。将其合并到URL中以测试服务，如下所示： curl http://localhost:18080/hello Handling connection for 18080 Hello from Heketi 最后，为Heketi CLI客户端设置环境变量，以便它知道如何到达Heketi Server。 export HEKETI_CLI_SERVER=http://localhost:18080 接下来，我们将向Heketi提供有关要管理的GlusterFS集群的信息。我们通过拓扑文件提供此信息 。您克隆的repo中有一个示例拓扑文件，名为topology-sample.json。拓扑指定运行GlusterFS容器的Kubernetes节点以及每个节点的相应原始块设备。 确保hostnames/manage指向下面显示的确切名称kubectl get nodes，并且hostnames/storage是存储网络的IP地址。 重要信息：此时，必须使用与服务器版本匹配的heketi-cli版本加载拓扑文件。作为最后的手段，Heketi容器附带了一份可以通过的方式访问的heketi-cli kubectl exec ...。 修改拓扑文件以反映您所做的选择，然后部署它，如下所示： { &quot;clusters&quot;: [ { &quot;nodes&quot;: [ { &quot;node&quot;: { &quot;hostnames&quot;: { &quot;manage&quot;: [ &quot;10.31.90.204&quot; ], &quot;storage&quot;:[ &quot;10.31.90.204&quot; ] }, &quot;zone&quot;: 1 }, &quot;devices&quot;: [ &quot;/dev/sdc&quot; ] }, { &quot;node&quot;: { &quot;hostnames&quot;: { &quot;manage&quot;: [ &quot;10.31.90.205&quot; ], &quot;storage&quot;:[ &quot;10.31.90.205&quot; ] }, &quot;zone&quot;: 1 }, &quot;devices&quot;: [ &quot;/dev/sdc&quot; ] }, { &quot;node&quot;: { &quot;hostnames&quot;: { &quot;manage&quot;: [ &quot;10.31.90.206&quot; ], &quot;storage&quot;:[ &quot;10.31.90.206&quot; ] }, &quot;zone&quot;: 1 }, &quot;devices&quot;: [ &quot;/dev/sdc&quot; ] } ] } ] } [root@node-01 ~]# heketi-cli topology load --json=top.json Creating cluster ... ID: e758afb77ee26d5f969d7efee1516e64 Allowing file volumes on cluster. Allowing block volumes on cluster. Creating node 10.31.90.204 ... ID: a6eedd58c118dcfe44a0db2af1a4f863 Adding device /dev/sdc ... OK Creating node 10.31.90.205 ... ID: 4066962c14bcdebd28aca193b5690792 Adding device /dev/sdc ... OK Creating node 10.31.90.206 ... ID: 91e42a2361f0266ae334354e5c34ce11 Adding device /dev/sdc ... OK 接下来我们将使用Heketi为它配置一个卷来存储其数据库： 执行此命令后会生成一个heketi-storage.json的文件，我们最好是将此文件里的&quot;image&quot;: &quot;heketi/heketi:dev&quot;改为&quot;image&quot;: &quot;heketi/heketi:8&quot; # heketi-client/bin/heketi-cli setup-openshift-heketi-storage 然后在创建heketi相关服务 # kubectl create -f heketi-storage.json 陷阱：如果heketi-cli在运行setup-openshift-heketi-storage子命令时报告“无空间”错误，则可能无意中运行topology load了服务器和heketi-cli的不匹配版本。停止正在运行的Heketi pod（kubectl scale deployment deploy-heketi --replicas=0），手动从存储块设备中删除任何签名，然后继续运行Heketi pod（kubectl scale deployment deploy-heketi --replicas=1）。然后使用匹配版本的heketi-cli重新加载拓扑并重试该步骤。 等到作业完成然后删除引导程序Heketi： # kubectl delete all,service,jobs,deployment,secret --selector=&quot;deploy-heketi&quot; 创建长期Heketi实例： { &quot;kind&quot;: &quot;List&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;items&quot;: [ { &quot;kind&quot;: &quot;Secret&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi-db-backup&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-db&quot;, &quot;heketi&quot;: &quot;db&quot; } }, &quot;data&quot;: { }, &quot;type&quot;: &quot;Opaque&quot; }, { &quot;kind&quot;: &quot;Service&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-service&quot;, &quot;deploy-heketi&quot;: &quot;support&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;Exposes Heketi Service&quot; } }, &quot;spec&quot;: { &quot;selector&quot;: { &quot;name&quot;: &quot;heketi&quot; }, &quot;ports&quot;: [ { &quot;name&quot;: &quot;heketi&quot;, &quot;port&quot;: 8080, &quot;targetPort&quot;: 8080 } ] } }, { &quot;kind&quot;: &quot;Deployment&quot;, &quot;apiVersion&quot;: &quot;extensions/v1beta1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-deployment&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;Defines how to deploy Heketi&quot; } }, &quot;spec&quot;: { &quot;replicas&quot;: 1, &quot;template&quot;: { &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi&quot;, &quot;labels&quot;: { &quot;name&quot;: &quot;heketi&quot;, &quot;glusterfs&quot;: &quot;heketi-pod&quot; } }, &quot;spec&quot;: { &quot;serviceAccountName&quot;: &quot;heketi-service-account&quot;, &quot;containers&quot;: [ { &quot;image&quot;: &quot;heketi/heketi:8&quot;, &quot;imagePullPolicy&quot;: &quot;Always&quot;, &quot;name&quot;: &quot;heketi&quot;, &quot;env&quot;: [ { &quot;name&quot;: &quot;HEKETI_EXECUTOR&quot;, &quot;value&quot;: &quot;kubernetes&quot; }, { &quot;name&quot;: &quot;HEKETI_DB_PATH&quot;, &quot;value&quot;: &quot;/var/lib/heketi/heketi.db&quot; }, { &quot;name&quot;: &quot;HEKETI_FSTAB&quot;, &quot;value&quot;: &quot;/var/lib/heketi/fstab&quot; }, { &quot;name&quot;: &quot;HEKETI_SNAPSHOT_LIMIT&quot;, &quot;value&quot;: &quot;14&quot; }, { &quot;name&quot;: &quot;HEKETI_KUBE_GLUSTER_DAEMONSET&quot;, &quot;value&quot;: &quot;y&quot; } ], &quot;ports&quot;: [ { &quot;containerPort&quot;: 8080 } ], &quot;volumeMounts&quot;: [ { &quot;mountPath&quot;: &quot;/backupdb&quot;, &quot;name&quot;: &quot;heketi-db-secret&quot; }, { &quot;name&quot;: &quot;db&quot;, &quot;mountPath&quot;: &quot;/var/lib/heketi&quot; }, { &quot;name&quot;: &quot;config&quot;, &quot;mountPath&quot;: &quot;/etc/heketi&quot; } ], &quot;readinessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 3, &quot;httpGet&quot;: { &quot;path&quot;: &quot;/hello&quot;, &quot;port&quot;: 8080 } }, &quot;livenessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 30, &quot;httpGet&quot;: { &quot;path&quot;: &quot;/hello&quot;, &quot;port&quot;: 8080 } } } ], &quot;volumes&quot;: [ { &quot;name&quot;: &quot;db&quot;, &quot;glusterfs&quot;: { &quot;endpoints&quot;: &quot;heketi-storage-endpoints&quot;, &quot;path&quot;: &quot;heketidbstorage&quot; } }, { &quot;name&quot;: &quot;heketi-db-secret&quot;, &quot;secret&quot;: { &quot;secretName&quot;: &quot;heketi-db-backup&quot; } }, { &quot;name&quot;: &quot;config&quot;, &quot;secret&quot;: { &quot;secretName&quot;: &quot;heketi-config-secret&quot; } } ] } } } } ] } # kubectl create -f heketi-deployment.json service &quot;heketi&quot; created deployment &quot;heketi&quot; created 现在这样做了，Heketi数据库将保留在GlusterFS卷中，并且每次重启Heketi pod时都不会重置。 使用诸如heketi-cli cluster list和之类的命令heketi-cli volume list 来确认先前建立的集群是否存在，以及Heketi是否知道在引导阶段创建的db存储卷。 演示测试 接下来就是建立存储卷，然后挂载测试。在测试之前我们需要先将heketi服务通过Ingress对外发布，将heketi.cnlinux.club的A记录解析为10.31.90.200。 apiVersion: extensions/v1beta1 kind: Ingress metadata: name: ingress-heketi annotations: nginx.ingress.kubernetes.io/rewrite-target: / kubernetes.io/ingress.class: nginx spec: rules: - host: heketi.cnlinux.club http: paths: - path: backend: serviceName: heketi servicePort: 8080 [root@node-01 heketi]# kubectl create -f ingress-heketi.yaml 在浏览器访问http://heketi.cnlinux.club/hello 创建StorageClass apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: gluster-heketi provisioner: kubernetes.io/glusterfs parameters: resturl: &quot;http://heketi.cnlinux.club&quot; restauthenabled: &quot;false&quot; volumetype: &quot;replicate:2&quot; [root@node-01 heketi]# kubectl create -f storageclass-gluster-heketi.yaml [root@node-01 heketi]# kubectl get sc NAME PROVISIONER AGE gluster-heketi kubernetes.io/glusterfs 10s 创建pvc apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc-gluster-heketi spec: storageClassName: gluster-heketi accessModes: - ReadWriteOnce resources: requests: storage: 1Gi [root@node-01 heketi]# kubectl create -f pvc-gluster-heketi.yaml [root@node-01 heketi]# kubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE pvc-gluster-heketi Bound pvc-d978f524-0b74-11e9-875c-005056826470 1Gi RWO gluster-heketi 30s 在pod里挂载pvc apiVersion: v1 kind: Pod metadata: name: pod-pvc spec: containers: - name: pod-pvc image: busybox:latest command: - sleep - &quot;3600&quot; volumeMounts: - name: gluster-volume mountPath: &quot;/pv-data&quot; volumes: - name: gluster-volume persistentVolumeClaim: claimName: pvc-gluster-heketi [root@node-01 heketi]# kubectl create -f pod-pvc.yaml 进入容器查看是否已经挂载成功 [root@node-01 heketi]# kubectl exec pod-pvc -it /bin/sh / # df -h Filesystem Size Used Available Use% Mounted on overlay 47.8G 4.3G 43.5G 9% / tmpfs 64.0M 0 64.0M 0% /dev tmpfs 1.9G 0 1.9G 0% /sys/fs/cgroup 10.31.90.204:vol_675cc9fe0e959157919c886ea7786d33 1014.0M 42.7M 971.3M 4% /pv-data /dev/sda3 47.8G 4.3G 43.5G 9% /dev/termination-log /dev/sda3 47.8G 4.3G 43.5G 9% /etc/resolv.conf /dev/sda3 47.8G 4.3G 43.5G 9% /etc/hostname /dev/sda3 47.8G 4.3G 43.5G 9% /etc/hosts #往/pv-data写文件，当容量超过1G时就自动退出了，证明容量限制是生效的。 / # cd /pv-data/ /pv-data # dd if=/dev/zero of=/pv-data/test.img bs=8M count=300 123+0 records in 122+0 records out 1030225920 bytes (982.5MB) copied, 24.255925 seconds, 40.5MB/s 在宿主机磁盘里查看是否创建了test.img文件 [root@node-04 cfg]# mount /dev/vg_2631413b8b87bbd6cb526568ab697d37/brick_1691ef862dd504e12e8384af76e5a9f2 /mnt [root@node-04 cfg]# ll -h /mnt/brick/ total 982M -rw-r--r-- 2 root 2001 982M Jan 2 15:14 test.img 至此，所有的操作都已完成。 转载于:https://blog.51cto.com/billy98/2337874" />
<link rel="canonical" href="https://uzzz.org/2019/01/02/789582.html" />
<meta property="og:url" content="https://uzzz.org/2019/01/02/789582.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-02T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"相关内容： Kubernetes部署（一）：架构及功能说明Kubernetes部署（二）：系统环境初始化Kubernetes部署（三）：CA证书制作Kubernetes部署（四）：ETCD集群部署Kubernetes部署（五）：Haproxy、Keppalived部署Kubernetes部署（六）：Master节点部署Kubernetes部署（七）：Node节点部署Kubernetes部署（八）：Flannel网络部署Kubernetes部署（九）：CoreDNS、Dashboard、Ingress部署Kubernetes部署（十）：储存之glusterfs和heketi部署Kubernetes部署（十一）：管理之Helm和Rancher部署Kubernetes部署（十二）：helm部署harbor企业级镜像仓库 概观 本指南支持在Kubernetes集群中集成，部署和管理GlusterFS容器化存储节点。这使Kubernetes管理员能够为其用户提供可靠的共享存储。 包括设置指南、其中包含一个示例服务器pod，它使用动态配置的GlusterFS卷进行存储。对于那些希望测试或了解有关此主题的更多信息的人，请按照主要自述文件中的快速入门说明 了解gluster-kubernetes 本指南旨在演示Heketi在Kubernetes环境中管理Gluster的最小示例。 基础设施要求 一个正在运行的Kubernetes集群，至少有三个Kubernetes工作节点，每个节点至少连接一个可用的原始块设备（如EBS卷或本地磁盘）。 #使用file -s 查看硬盘如果显示为data则为原始块设备。如果不是data类型，可先用pvcreate，pvremove来变更。 [root@node-04 ~]# file -s /dev/sdc /dev/sdc: x86 boot sector, code offset 0xb8 [root@node-04 ~]# pvcreate /dev/sdc WARNING: dos signature detected on /dev/sdc at offset 510. Wipe it? [y/n]: y Wiping dos signature on /dev/sdc. Physical volume &quot;/dev/sdc&quot; successfully created. [root@node-04 ~]# pvremove /dev/sdc Labels on physical volume &quot;/dev/sdc&quot; successfully wiped. [root@node-04 ~]# file -s /dev/sdc /dev/sdc: data 在glusterfs节点的宿主机需要安装glusterfs-client、glusterfs-fuse包和socat包。 yum install -y glusterfs-client glusterfs-fuse socat 每个kubetnetes节点的宿主机需要加载dm_thin_pool模块modprobe dm_thin_pool 客户端安装 Heketi提供CLI，为用户提供管理Kubernetes中GlusterFS的部署和配置的方法。 在您的客户端计算机上下载并安装下载并安装heketi-cli，下载的heketi-cli版本最好是和heketi服务端版本一致，不然可能会出现报错。 Kubernetes部署 部署GlusterFS DaemonSet { &quot;kind&quot;: &quot;DaemonSet&quot;, &quot;apiVersion&quot;: &quot;extensions/v1beta1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;glusterfs&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;deployment&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;GlusterFS Daemon Set&quot;, &quot;tags&quot;: &quot;glusterfs&quot; } }, &quot;spec&quot;: { &quot;template&quot;: { &quot;metadata&quot;: { &quot;name&quot;: &quot;glusterfs&quot;, &quot;labels&quot;: { &quot;glusterfs-node&quot;: &quot;daemonset&quot; } }, &quot;spec&quot;: { &quot;nodeSelector&quot;: { &quot;storagenode&quot; : &quot;glusterfs&quot; }, &quot;hostNetwork&quot;: true, &quot;containers&quot;: [ { &quot;image&quot;: &quot;gluster/gluster-centos:latest&quot;, &quot;imagePullPolicy&quot;: &quot;Always&quot;, &quot;name&quot;: &quot;glusterfs&quot;, &quot;volumeMounts&quot;: [ { &quot;name&quot;: &quot;glusterfs-heketi&quot;, &quot;mountPath&quot;: &quot;/var/lib/heketi&quot; }, { &quot;name&quot;: &quot;glusterfs-run&quot;, &quot;mountPath&quot;: &quot;/run&quot; }, { &quot;name&quot;: &quot;glusterfs-lvm&quot;, &quot;mountPath&quot;: &quot;/run/lvm&quot; }, { &quot;name&quot;: &quot;glusterfs-etc&quot;, &quot;mountPath&quot;: &quot;/etc/glusterfs&quot; }, { &quot;name&quot;: &quot;glusterfs-logs&quot;, &quot;mountPath&quot;: &quot;/var/log/glusterfs&quot; }, { &quot;name&quot;: &quot;glusterfs-config&quot;, &quot;mountPath&quot;: &quot;/var/lib/glusterd&quot; }, { &quot;name&quot;: &quot;glusterfs-dev&quot;, &quot;mountPath&quot;: &quot;/dev&quot; }, { &quot;name&quot;: &quot;glusterfs-cgroup&quot;, &quot;mountPath&quot;: &quot;/sys/fs/cgroup&quot; } ], &quot;securityContext&quot;: { &quot;capabilities&quot;: {}, &quot;privileged&quot;: true }, &quot;readinessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 60, &quot;exec&quot;: { &quot;command&quot;: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;systemctl status glusterd.service&quot; ] } }, &quot;livenessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 60, &quot;exec&quot;: { &quot;command&quot;: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;systemctl status glusterd.service&quot; ] } } } ], &quot;volumes&quot;: [ { &quot;name&quot;: &quot;glusterfs-heketi&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/var/lib/heketi&quot; } }, { &quot;name&quot;: &quot;glusterfs-run&quot; }, { &quot;name&quot;: &quot;glusterfs-lvm&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/run/lvm&quot; } }, { &quot;name&quot;: &quot;glusterfs-etc&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/etc/glusterfs&quot; } }, { &quot;name&quot;: &quot;glusterfs-logs&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/var/log/glusterfs&quot; } }, { &quot;name&quot;: &quot;glusterfs-config&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/var/lib/glusterd&quot; } }, { &quot;name&quot;: &quot;glusterfs-dev&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/dev&quot; } }, { &quot;name&quot;: &quot;glusterfs-cgroup&quot;, &quot;hostPath&quot;: { &quot;path&quot;: &quot;/sys/fs/cgroup&quot; } } ] } } } } $ kubectl create -f glusterfs-daemonset.json 通过运行获取节点名称： $ kubectl get nodes 通过storagenode=glusterfs在该节点上设置标签，将gluster容器部署到指定节点上。 [root@node-01 heketi]# kubectl label node 10.31.90.204 storagenode=glusterfs [root@node-01 heketi]# kubectl label node 10.31.90.205 storagenode=glusterfs [root@node-01 heketi]# kubectl label node 10.31.90.206 storagenode=glusterfs 根据需要,验证pod正在节点上运行，至少应运行三个pod。 $ kubectl get pods 接下来我们将为Heketi创建一个ServiceAccount： { &quot;apiVersion&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;ServiceAccount&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi-service-account&quot; } } $ kubectl create -f heketi-service-account.json 我们现在必须建立该服务帐户控制gluster pod的能力。我们通过为新创建的服务帐户创建集群角色绑定来实现此目的。 $ kubectl create clusterrolebinding heketi-gluster-admin --clusterrole=edit --serviceaccount=default:heketi-service-account 现在我们需要创建一个Kubernetes secret，它将保存我们的Heketi实例的配置。必须将配置文件设置为使用 kubernetes执行程序，以便Heketi服务器控制gluster pod。除此之外，您可以随意尝试配置选项。 { &quot;_port_comment&quot;: &quot;Heketi Server Port Number&quot;, &quot;port&quot;: &quot;8080&quot;, &quot;_use_auth&quot;: &quot;Enable JWT authorization. Please enable for deployment&quot;, &quot;use_auth&quot;: false, &quot;_jwt&quot;: &quot;Private keys for access&quot;, &quot;jwt&quot;: { &quot;_admin&quot;: &quot;Admin has access to all APIs&quot;, &quot;admin&quot;: { &quot;key&quot;: &quot;My Secret&quot; }, &quot;_user&quot;: &quot;User only has access to /volumes endpoint&quot;, &quot;user&quot;: { &quot;key&quot;: &quot;My Secret&quot; } }, &quot;_glusterfs_comment&quot;: &quot;GlusterFS Configuration&quot;, &quot;glusterfs&quot;: { &quot;_executor_comment&quot;: &quot;Execute plugin. Possible choices: mock, kubernetes, ssh&quot;, &quot;executor&quot;: &quot;kubernetes&quot;, &quot;_db_comment&quot;: &quot;Database file name&quot;, &quot;db&quot;: &quot;/var/lib/heketi/heketi.db&quot;, &quot;kubeexec&quot;: { &quot;rebalance_on_expansion&quot;: true }, &quot;sshexec&quot;: { &quot;rebalance_on_expansion&quot;: true, &quot;keyfile&quot;: &quot;/etc/heketi/private_key&quot;, &quot;fstab&quot;: &quot;/etc/fstab&quot;, &quot;port&quot;: &quot;22&quot;, &quot;user&quot;: &quot;root&quot;, &quot;sudo&quot;: false } }, &quot;_backup_db_to_kube_secret&quot;: &quot;Backup the heketi database to a Kubernetes secret when running in Kubernetes. Default is off.&quot;, &quot;backup_db_to_kube_secret&quot;: false } $ kubectl create secret generic heketi-config-secret --from-file=./heketi.json 接下来，我们需要部署一个初始Pod和一个服务来访问该pod。如下会有一个heketi-bootstrap.json文件。提交文件并验证一切正常运行，如下所示： { &quot;kind&quot;: &quot;List&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;items&quot;: [ { &quot;kind&quot;: &quot;Service&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-service&quot;, &quot;deploy-heketi&quot;: &quot;support&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;Exposes Heketi Service&quot; } }, &quot;spec&quot;: { &quot;selector&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot; }, &quot;ports&quot;: [ { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;port&quot;: 8080, &quot;targetPort&quot;: 8080 } ] } }, { &quot;kind&quot;: &quot;Deployment&quot;, &quot;apiVersion&quot;: &quot;extensions/v1beta1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-deployment&quot;, &quot;deploy-heketi&quot;: &quot;deployment&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;Defines how to deploy Heketi&quot; } }, &quot;spec&quot;: { &quot;replicas&quot;: 1, &quot;template&quot;: { &quot;metadata&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;labels&quot;: { &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;glusterfs&quot;: &quot;heketi-pod&quot;, &quot;deploy-heketi&quot;: &quot;pod&quot; } }, &quot;spec&quot;: { &quot;serviceAccountName&quot;: &quot;heketi-service-account&quot;, &quot;containers&quot;: [ { &quot;image&quot;: &quot;heketi/heketi:8&quot;, &quot;imagePullPolicy&quot;: &quot;Always&quot;, &quot;name&quot;: &quot;deploy-heketi&quot;, &quot;env&quot;: [ { &quot;name&quot;: &quot;HEKETI_EXECUTOR&quot;, &quot;value&quot;: &quot;kubernetes&quot; }, { &quot;name&quot;: &quot;HEKETI_DB_PATH&quot;, &quot;value&quot;: &quot;/var/lib/heketi/heketi.db&quot; }, { &quot;name&quot;: &quot;HEKETI_FSTAB&quot;, &quot;value&quot;: &quot;/var/lib/heketi/fstab&quot; }, { &quot;name&quot;: &quot;HEKETI_SNAPSHOT_LIMIT&quot;, &quot;value&quot;: &quot;14&quot; }, { &quot;name&quot;: &quot;HEKETI_KUBE_GLUSTER_DAEMONSET&quot;, &quot;value&quot;: &quot;y&quot; } ], &quot;ports&quot;: [ { &quot;containerPort&quot;: 8080 } ], &quot;volumeMounts&quot;: [ { &quot;name&quot;: &quot;db&quot;, &quot;mountPath&quot;: &quot;/var/lib/heketi&quot; }, { &quot;name&quot;: &quot;config&quot;, &quot;mountPath&quot;: &quot;/etc/heketi&quot; } ], &quot;readinessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 3, &quot;httpGet&quot;: { &quot;path&quot;: &quot;/hello&quot;, &quot;port&quot;: 8080 } }, &quot;livenessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 30, &quot;httpGet&quot;: { &quot;path&quot;: &quot;/hello&quot;, &quot;port&quot;: 8080 } } } ], &quot;volumes&quot;: [ { &quot;name&quot;: &quot;db&quot; }, { &quot;name&quot;: &quot;config&quot;, &quot;secret&quot;: { &quot;secretName&quot;: &quot;heketi-config-secret&quot; } } ] } } } } ] } # kubectl create -f heketi-bootstrap.json service &quot;deploy-heketi&quot; created deployment &quot;deploy-heketi&quot; created [root@node-01 heketi]# kubectl get pod NAME READY STATUS RESTARTS AGE deploy-heketi-8888799fd-cmfp6 1/1 Running 0 6m glusterfs-7t5ls 1/1 Running 0 8m glusterfs-drsx9 1/1 Running 0 8m glusterfs-pnnn8 1/1 Running 0 8m 现在Bootstrap Heketi服务正在运行，我们将配置端口转发，以便我们可以使用Heketi CLI与服务进行通信。使用Heketi pod的名称，运行以下命令： kubectl port-forward deploy-heketi-8888799fd-cmfp6 :8080 如果在运行命令的系统上本地端口8080空闲，则可以运行port-forward命令，以便它为了方便而绑定到8080： kubectl port-forward deploy-heketi-8888799fd-cmfp6 18080:8080 现在通过对Heketi服务运行示例查询来验证端口转发是否正常工作。该命令应该打印将要转发的本地端口。将其合并到URL中以测试服务，如下所示： curl http://localhost:18080/hello Handling connection for 18080 Hello from Heketi 最后，为Heketi CLI客户端设置环境变量，以便它知道如何到达Heketi Server。 export HEKETI_CLI_SERVER=http://localhost:18080 接下来，我们将向Heketi提供有关要管理的GlusterFS集群的信息。我们通过拓扑文件提供此信息 。您克隆的repo中有一个示例拓扑文件，名为topology-sample.json。拓扑指定运行GlusterFS容器的Kubernetes节点以及每个节点的相应原始块设备。 确保hostnames/manage指向下面显示的确切名称kubectl get nodes，并且hostnames/storage是存储网络的IP地址。 重要信息：此时，必须使用与服务器版本匹配的heketi-cli版本加载拓扑文件。作为最后的手段，Heketi容器附带了一份可以通过的方式访问的heketi-cli kubectl exec ...。 修改拓扑文件以反映您所做的选择，然后部署它，如下所示： { &quot;clusters&quot;: [ { &quot;nodes&quot;: [ { &quot;node&quot;: { &quot;hostnames&quot;: { &quot;manage&quot;: [ &quot;10.31.90.204&quot; ], &quot;storage&quot;:[ &quot;10.31.90.204&quot; ] }, &quot;zone&quot;: 1 }, &quot;devices&quot;: [ &quot;/dev/sdc&quot; ] }, { &quot;node&quot;: { &quot;hostnames&quot;: { &quot;manage&quot;: [ &quot;10.31.90.205&quot; ], &quot;storage&quot;:[ &quot;10.31.90.205&quot; ] }, &quot;zone&quot;: 1 }, &quot;devices&quot;: [ &quot;/dev/sdc&quot; ] }, { &quot;node&quot;: { &quot;hostnames&quot;: { &quot;manage&quot;: [ &quot;10.31.90.206&quot; ], &quot;storage&quot;:[ &quot;10.31.90.206&quot; ] }, &quot;zone&quot;: 1 }, &quot;devices&quot;: [ &quot;/dev/sdc&quot; ] } ] } ] } [root@node-01 ~]# heketi-cli topology load --json=top.json Creating cluster ... ID: e758afb77ee26d5f969d7efee1516e64 Allowing file volumes on cluster. Allowing block volumes on cluster. Creating node 10.31.90.204 ... ID: a6eedd58c118dcfe44a0db2af1a4f863 Adding device /dev/sdc ... OK Creating node 10.31.90.205 ... ID: 4066962c14bcdebd28aca193b5690792 Adding device /dev/sdc ... OK Creating node 10.31.90.206 ... ID: 91e42a2361f0266ae334354e5c34ce11 Adding device /dev/sdc ... OK 接下来我们将使用Heketi为它配置一个卷来存储其数据库： 执行此命令后会生成一个heketi-storage.json的文件，我们最好是将此文件里的&quot;image&quot;: &quot;heketi/heketi:dev&quot;改为&quot;image&quot;: &quot;heketi/heketi:8&quot; # heketi-client/bin/heketi-cli setup-openshift-heketi-storage 然后在创建heketi相关服务 # kubectl create -f heketi-storage.json 陷阱：如果heketi-cli在运行setup-openshift-heketi-storage子命令时报告“无空间”错误，则可能无意中运行topology load了服务器和heketi-cli的不匹配版本。停止正在运行的Heketi pod（kubectl scale deployment deploy-heketi --replicas=0），手动从存储块设备中删除任何签名，然后继续运行Heketi pod（kubectl scale deployment deploy-heketi --replicas=1）。然后使用匹配版本的heketi-cli重新加载拓扑并重试该步骤。 等到作业完成然后删除引导程序Heketi： # kubectl delete all,service,jobs,deployment,secret --selector=&quot;deploy-heketi&quot; 创建长期Heketi实例： { &quot;kind&quot;: &quot;List&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;items&quot;: [ { &quot;kind&quot;: &quot;Secret&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi-db-backup&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-db&quot;, &quot;heketi&quot;: &quot;db&quot; } }, &quot;data&quot;: { }, &quot;type&quot;: &quot;Opaque&quot; }, { &quot;kind&quot;: &quot;Service&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-service&quot;, &quot;deploy-heketi&quot;: &quot;support&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;Exposes Heketi Service&quot; } }, &quot;spec&quot;: { &quot;selector&quot;: { &quot;name&quot;: &quot;heketi&quot; }, &quot;ports&quot;: [ { &quot;name&quot;: &quot;heketi&quot;, &quot;port&quot;: 8080, &quot;targetPort&quot;: 8080 } ] } }, { &quot;kind&quot;: &quot;Deployment&quot;, &quot;apiVersion&quot;: &quot;extensions/v1beta1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi&quot;, &quot;labels&quot;: { &quot;glusterfs&quot;: &quot;heketi-deployment&quot; }, &quot;annotations&quot;: { &quot;description&quot;: &quot;Defines how to deploy Heketi&quot; } }, &quot;spec&quot;: { &quot;replicas&quot;: 1, &quot;template&quot;: { &quot;metadata&quot;: { &quot;name&quot;: &quot;heketi&quot;, &quot;labels&quot;: { &quot;name&quot;: &quot;heketi&quot;, &quot;glusterfs&quot;: &quot;heketi-pod&quot; } }, &quot;spec&quot;: { &quot;serviceAccountName&quot;: &quot;heketi-service-account&quot;, &quot;containers&quot;: [ { &quot;image&quot;: &quot;heketi/heketi:8&quot;, &quot;imagePullPolicy&quot;: &quot;Always&quot;, &quot;name&quot;: &quot;heketi&quot;, &quot;env&quot;: [ { &quot;name&quot;: &quot;HEKETI_EXECUTOR&quot;, &quot;value&quot;: &quot;kubernetes&quot; }, { &quot;name&quot;: &quot;HEKETI_DB_PATH&quot;, &quot;value&quot;: &quot;/var/lib/heketi/heketi.db&quot; }, { &quot;name&quot;: &quot;HEKETI_FSTAB&quot;, &quot;value&quot;: &quot;/var/lib/heketi/fstab&quot; }, { &quot;name&quot;: &quot;HEKETI_SNAPSHOT_LIMIT&quot;, &quot;value&quot;: &quot;14&quot; }, { &quot;name&quot;: &quot;HEKETI_KUBE_GLUSTER_DAEMONSET&quot;, &quot;value&quot;: &quot;y&quot; } ], &quot;ports&quot;: [ { &quot;containerPort&quot;: 8080 } ], &quot;volumeMounts&quot;: [ { &quot;mountPath&quot;: &quot;/backupdb&quot;, &quot;name&quot;: &quot;heketi-db-secret&quot; }, { &quot;name&quot;: &quot;db&quot;, &quot;mountPath&quot;: &quot;/var/lib/heketi&quot; }, { &quot;name&quot;: &quot;config&quot;, &quot;mountPath&quot;: &quot;/etc/heketi&quot; } ], &quot;readinessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 3, &quot;httpGet&quot;: { &quot;path&quot;: &quot;/hello&quot;, &quot;port&quot;: 8080 } }, &quot;livenessProbe&quot;: { &quot;timeoutSeconds&quot;: 3, &quot;initialDelaySeconds&quot;: 30, &quot;httpGet&quot;: { &quot;path&quot;: &quot;/hello&quot;, &quot;port&quot;: 8080 } } } ], &quot;volumes&quot;: [ { &quot;name&quot;: &quot;db&quot;, &quot;glusterfs&quot;: { &quot;endpoints&quot;: &quot;heketi-storage-endpoints&quot;, &quot;path&quot;: &quot;heketidbstorage&quot; } }, { &quot;name&quot;: &quot;heketi-db-secret&quot;, &quot;secret&quot;: { &quot;secretName&quot;: &quot;heketi-db-backup&quot; } }, { &quot;name&quot;: &quot;config&quot;, &quot;secret&quot;: { &quot;secretName&quot;: &quot;heketi-config-secret&quot; } } ] } } } } ] } # kubectl create -f heketi-deployment.json service &quot;heketi&quot; created deployment &quot;heketi&quot; created 现在这样做了，Heketi数据库将保留在GlusterFS卷中，并且每次重启Heketi pod时都不会重置。 使用诸如heketi-cli cluster list和之类的命令heketi-cli volume list 来确认先前建立的集群是否存在，以及Heketi是否知道在引导阶段创建的db存储卷。 演示测试 接下来就是建立存储卷，然后挂载测试。在测试之前我们需要先将heketi服务通过Ingress对外发布，将heketi.cnlinux.club的A记录解析为10.31.90.200。 apiVersion: extensions/v1beta1 kind: Ingress metadata: name: ingress-heketi annotations: nginx.ingress.kubernetes.io/rewrite-target: / kubernetes.io/ingress.class: nginx spec: rules: - host: heketi.cnlinux.club http: paths: - path: backend: serviceName: heketi servicePort: 8080 [root@node-01 heketi]# kubectl create -f ingress-heketi.yaml 在浏览器访问http://heketi.cnlinux.club/hello 创建StorageClass apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: gluster-heketi provisioner: kubernetes.io/glusterfs parameters: resturl: &quot;http://heketi.cnlinux.club&quot; restauthenabled: &quot;false&quot; volumetype: &quot;replicate:2&quot; [root@node-01 heketi]# kubectl create -f storageclass-gluster-heketi.yaml [root@node-01 heketi]# kubectl get sc NAME PROVISIONER AGE gluster-heketi kubernetes.io/glusterfs 10s 创建pvc apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc-gluster-heketi spec: storageClassName: gluster-heketi accessModes: - ReadWriteOnce resources: requests: storage: 1Gi [root@node-01 heketi]# kubectl create -f pvc-gluster-heketi.yaml [root@node-01 heketi]# kubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE pvc-gluster-heketi Bound pvc-d978f524-0b74-11e9-875c-005056826470 1Gi RWO gluster-heketi 30s 在pod里挂载pvc apiVersion: v1 kind: Pod metadata: name: pod-pvc spec: containers: - name: pod-pvc image: busybox:latest command: - sleep - &quot;3600&quot; volumeMounts: - name: gluster-volume mountPath: &quot;/pv-data&quot; volumes: - name: gluster-volume persistentVolumeClaim: claimName: pvc-gluster-heketi [root@node-01 heketi]# kubectl create -f pod-pvc.yaml 进入容器查看是否已经挂载成功 [root@node-01 heketi]# kubectl exec pod-pvc -it /bin/sh / # df -h Filesystem Size Used Available Use% Mounted on overlay 47.8G 4.3G 43.5G 9% / tmpfs 64.0M 0 64.0M 0% /dev tmpfs 1.9G 0 1.9G 0% /sys/fs/cgroup 10.31.90.204:vol_675cc9fe0e959157919c886ea7786d33 1014.0M 42.7M 971.3M 4% /pv-data /dev/sda3 47.8G 4.3G 43.5G 9% /dev/termination-log /dev/sda3 47.8G 4.3G 43.5G 9% /etc/resolv.conf /dev/sda3 47.8G 4.3G 43.5G 9% /etc/hostname /dev/sda3 47.8G 4.3G 43.5G 9% /etc/hosts #往/pv-data写文件，当容量超过1G时就自动退出了，证明容量限制是生效的。 / # cd /pv-data/ /pv-data # dd if=/dev/zero of=/pv-data/test.img bs=8M count=300 123+0 records in 122+0 records out 1030225920 bytes (982.5MB) copied, 24.255925 seconds, 40.5MB/s 在宿主机磁盘里查看是否创建了test.img文件 [root@node-04 cfg]# mount /dev/vg_2631413b8b87bbd6cb526568ab697d37/brick_1691ef862dd504e12e8384af76e5a9f2 /mnt [root@node-04 cfg]# ll -h /mnt/brick/ total 982M -rw-r--r-- 2 root 2001 982M Jan 2 15:14 test.img 至此，所有的操作都已完成。 转载于:https://blog.51cto.com/billy98/2337874","@type":"BlogPosting","url":"https://uzzz.org/2019/01/02/789582.html","headline":"Kubernetes部署（十）：储存之glusterfs和heketi部署","dateModified":"2019-01-02T00:00:00+08:00","datePublished":"2019-01-02T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/01/02/789582.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Kubernetes部署（十）：储存之glusterfs和heketi部署</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-cd6c485e8b.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-cd6c485e8b.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="con artical-content editor-preview-side">
   <h3>相关内容：</h3> 
   <p><a href="https://blog.51cto.com/billy98/2334654" rel="nofollow">Kubernetes部署（一）：架构及功能说明</a><br><a href="https://blog.51cto.com/billy98/2334685" rel="nofollow">Kubernetes部署（二）：系统环境初始化</a><br><a href="https://blog.51cto.com/billy98/2334704" rel="nofollow">Kubernetes部署（三）：CA证书制作</a><br><a href="https://blog.51cto.com/billy98/2334706" rel="nofollow">Kubernetes部署（四）：ETCD集群部署</a><br><a href="https://blog.51cto.com/billy98/2335056" rel="nofollow">Kubernetes部署（五）：Haproxy、Keppalived部署</a><br><a href="https://blog.51cto.com/billy98/2335161" rel="nofollow">Kubernetes部署（六）：Master节点部署</a><br><a href="https://blog.51cto.com/billy98/2335575" rel="nofollow">Kubernetes部署（七）：Node节点部署</a><br><a href="https://blog.51cto.com/billy98/2335580" rel="nofollow">Kubernetes部署（八）：Flannel网络部署</a><br><a href="https://blog.51cto.com/billy98/2336724" rel="nofollow">Kubernetes部署（九）：CoreDNS、Dashboard、Ingress部署</a><br><a href="https://blog.51cto.com/billy98/2337874" rel="nofollow">Kubernetes部署（十）：储存之glusterfs和heketi部署</a><br><a href="https://blog.51cto.com/billy98/2338415" rel="nofollow">Kubernetes部署（十一）：管理之Helm和Rancher部署</a><br><a href="https://blog.51cto.com/billy98/2345517" rel="nofollow">Kubernetes部署（十二）：helm部署harbor企业级镜像仓库</a></p> 
   <pre><code></code></pre> 
   <h2>概观</h2> 
   <p>本指南支持在Kubernetes集群中集成，部署和管理GlusterFS容器化存储节点。这使Kubernetes管理员能够为其用户提供可靠的共享存储。</p> 
   <p>包括设置指南、其中包含一个示例服务器pod，它使用动态配置的GlusterFS卷进行存储。对于那些希望测试或了解有关此主题的更多信息的人，请按照主要自述文件中的快速入门说明 了解gluster-kubernetes</p> 
   <p>本指南旨在演示Heketi在Kubernetes环境中管理Gluster的最小示例。</p> 
   <h2>基础设施要求</h2> 
   <ul>
    <li>一个正在运行的Kubernetes集群，至少有三个Kubernetes工作节点，每个节点至少连接一个可用的原始块设备（如EBS卷或本地磁盘）。 <pre><code>#使用file -s 查看硬盘如果显示为data则为原始块设备。如果不是data类型，可先用pvcreate，pvremove来变更。
[root@node-04 ~]# file -s /dev/sdc
/dev/sdc: x86 boot sector, code offset 0xb8
[root@node-04 ~]# pvcreate /dev/sdc
WARNING: dos signature detected on /dev/sdc at offset 510. Wipe it? [y/n]: y
Wiping dos signature on /dev/sdc.
Physical volume "/dev/sdc" successfully created.
[root@node-04 ~]# pvremove /dev/sdc
Labels on physical volume "/dev/sdc" successfully wiped.
[root@node-04 ~]# file -s /dev/sdc 
/dev/sdc: data</code></pre></li> 
    <li>在glusterfs节点的宿主机需要安装glusterfs-client、glusterfs-fuse包和socat包。 <pre><code>yum install -y glusterfs-client glusterfs-fuse socat</code></pre></li> 
    <li>每个kubetnetes节点的宿主机需要加载dm_thin_pool模块<code>modprobe dm_thin_pool</code></li> 
   </ul>
   <h2>客户端安装</h2> 
   <p>Heketi提供CLI，为用户提供管理Kubernetes中GlusterFS的部署和配置的方法。 在您的客户端计算机上下载并安装<a href="https://github.com/heketi/heketi/releases" rel="nofollow">下载并安装heketi-cli</a>，下载的heketi-cli版本最好是和heketi服务端版本一致，不然可能会出现报错。</p> 
   <h2>Kubernetes部署</h2> 
   <ul>
    <li> <p>部署GlusterFS DaemonSet</p> <pre><code>{
"kind": "DaemonSet",
"apiVersion": "extensions/v1beta1",
"metadata": {
    "name": "glusterfs",
    "labels": {
        "glusterfs": "deployment"
    },
    "annotations": {
        "description": "GlusterFS Daemon Set",
        "tags": "glusterfs"
    }
},
"spec": {
    "template": {
        "metadata": {
            "name": "glusterfs",
            "labels": {
                "glusterfs-node": "daemonset"
            }
        },
        "spec": {
            "nodeSelector": {
                "storagenode" : "glusterfs"
            },
            "hostNetwork": true,
            "containers": [
                {
                    "image": "gluster/gluster-centos:latest",
                    "imagePullPolicy": "Always",
                    "name": "glusterfs",
                    "volumeMounts": [
                        {
                            "name": "glusterfs-heketi",
                            "mountPath": "/var/lib/heketi"
                        },
                        {
                            "name": "glusterfs-run",
                            "mountPath": "/run"
                        },
                        {
                            "name": "glusterfs-lvm",
                            "mountPath": "/run/lvm"
                        },
                        {
                            "name": "glusterfs-etc",
                            "mountPath": "/etc/glusterfs"
                        },
                        {
                            "name": "glusterfs-logs",
                            "mountPath": "/var/log/glusterfs"
                        },
                        {
                            "name": "glusterfs-config",
                            "mountPath": "/var/lib/glusterd"
                        },
                        {
                            "name": "glusterfs-dev",
                            "mountPath": "/dev"
                        },
                        {
                            "name": "glusterfs-cgroup",
                            "mountPath": "/sys/fs/cgroup"
                        }
                    ],
                    "securityContext": {
                        "capabilities": {},
                        "privileged": true
                    },
                    "readinessProbe": {
                        "timeoutSeconds": 3,
                        "initialDelaySeconds": 60,
                        "exec": {
                            "command": [
                                "/bin/bash",
                                "-c",
                                "systemctl status glusterd.service"
                            ]
                        }
                    },
                    "livenessProbe": {
                        "timeoutSeconds": 3,
                        "initialDelaySeconds": 60,
                        "exec": {
                            "command": [
                                "/bin/bash",
                                "-c",
                                "systemctl status glusterd.service"
                            ]
                        }
                    }
                }
            ],
            "volumes": [
                {
                    "name": "glusterfs-heketi",
                    "hostPath": {
                        "path": "/var/lib/heketi"
                    }
                },
                {
                    "name": "glusterfs-run"
                },
                {
                    "name": "glusterfs-lvm",
                    "hostPath": {
                        "path": "/run/lvm"
                    }
                },
                {
                    "name": "glusterfs-etc",
                    "hostPath": {
                        "path": "/etc/glusterfs"
                    }
                },
                {
                    "name": "glusterfs-logs",
                    "hostPath": {
                        "path": "/var/log/glusterfs"
                    }
                },
                {
                    "name": "glusterfs-config",
                    "hostPath": {
                        "path": "/var/lib/glusterd"
                    }
                },
                {
                    "name": "glusterfs-dev",
                    "hostPath": {
                        "path": "/dev"
                    }
                },
                {
                    "name": "glusterfs-cgroup",
                    "hostPath": {
                        "path": "/sys/fs/cgroup"
                    }
                }
            ]
        }
    }
}
}</code></pre> <pre><code>$ kubectl create -f glusterfs-daemonset.json</code></pre> </li> 
    <li>通过运行获取节点名称：</li> 
   </ul>
   <pre><code>$ kubectl get nodes</code></pre> 
   <ul>
    <li>通过<code>storagenode=glusterfs</code>在该节点上设置标签，将gluster容器部署到指定节点上。</li> 
   </ul>
   <pre><code>[root@node-01 heketi]# kubectl label node 10.31.90.204 storagenode=glusterfs
[root@node-01 heketi]# kubectl label node 10.31.90.205 storagenode=glusterfs
[root@node-01 heketi]# kubectl label node 10.31.90.206 storagenode=glusterfs</code></pre> 
   <p>根据需要,验证pod正在节点上运行，至少应运行三个pod。</p> 
   <pre><code>$ kubectl get pods</code></pre> 
   <ul>
    <li> <p>接下来我们将为Heketi创建一个ServiceAccount：</p> <pre><code>{
"apiVersion": "v1",
"kind": "ServiceAccount",
"metadata": {
"name": "heketi-service-account"
}
}</code></pre> <pre><code>$ kubectl create -f heketi-service-account.json</code></pre> </li> 
    <li> <p>我们现在必须建立该服务帐户控制gluster pod的能力。我们通过为新创建的服务帐户创建集群角色绑定来实现此目的。</p> <pre><code>$ kubectl create clusterrolebinding heketi-gluster-admin --clusterrole=edit --serviceaccount=default:heketi-service-account</code></pre> </li> 
    <li>现在我们需要创建一个Kubernetes secret，它将保存我们的Heketi实例的配置。必须将配置文件设置为使用 kubernetes执行程序，以便Heketi服务器控制gluster pod。除此之外，您可以随意尝试配置选项。</li> 
   </ul>
   <pre><code>{
  "_port_comment": "Heketi Server Port Number",
  "port": "8080",

  "_use_auth": "Enable JWT authorization. Please enable for deployment",
  "use_auth": false,

  "_jwt": "Private keys for access",
  "jwt": {
    "_admin": "Admin has access to all APIs",
    "admin": {
      "key": "My Secret"
    },
    "_user": "User only has access to /volumes endpoint",
    "user": {
      "key": "My Secret"
    }
  },

  "_glusterfs_comment": "GlusterFS Configuration",
  "glusterfs": {
    "_executor_comment": "Execute plugin. Possible choices: mock, kubernetes, ssh",
    "executor": "kubernetes",

    "_db_comment": "Database file name",
    "db": "/var/lib/heketi/heketi.db",

    "kubeexec": {
      "rebalance_on_expansion": true
    },

    "sshexec": {
      "rebalance_on_expansion": true,
      "keyfile": "/etc/heketi/private_key",
      "fstab": "/etc/fstab",
      "port": "22",
      "user": "root",
      "sudo": false
    }
  },

  "_backup_db_to_kube_secret": "Backup the heketi database to a Kubernetes secret when running in Kubernetes. Default is off.",
  "backup_db_to_kube_secret": false
}
</code></pre> 
   <pre><code>$ kubectl create secret generic heketi-config-secret --from-file=./heketi.json</code></pre> 
   <ul>
    <li>接下来，我们需要部署一个初始Pod和一个服务来访问该pod。如下会有一个heketi-bootstrap.json文件。<br>提交文件并验证一切正常运行，如下所示： <pre><code>{
"kind": "List",
"apiVersion": "v1",
"items": [
{
  "kind": "Service",
  "apiVersion": "v1",
  "metadata": {
    "name": "deploy-heketi",
    "labels": {
      "glusterfs": "heketi-service",
      "deploy-heketi": "support"
    },
    "annotations": {
      "description": "Exposes Heketi Service"
    }
  },
  "spec": {
    "selector": {
      "name": "deploy-heketi"
    },
    "ports": [
      {
        "name": "deploy-heketi",
        "port": 8080,
        "targetPort": 8080
      }
    ]
  }
},
{
  "kind": "Deployment",
  "apiVersion": "extensions/v1beta1",
  "metadata": {
    "name": "deploy-heketi",
    "labels": {
      "glusterfs": "heketi-deployment",
      "deploy-heketi": "deployment"
    },
    "annotations": {
      "description": "Defines how to deploy Heketi"
    }
  },
  "spec": {
    "replicas": 1,
    "template": {
      "metadata": {
        "name": "deploy-heketi",
        "labels": {
          "name": "deploy-heketi",
          "glusterfs": "heketi-pod",
          "deploy-heketi": "pod"
        }
      },
      "spec": {
        "serviceAccountName": "heketi-service-account",
        "containers": [
          {
            "image": "heketi/heketi:8",
            "imagePullPolicy": "Always",
            "name": "deploy-heketi",
            "env": [
              {
                "name": "HEKETI_EXECUTOR",
                "value": "kubernetes"
              },
              {
                "name": "HEKETI_DB_PATH",
                "value": "/var/lib/heketi/heketi.db"
              },
              {
                "name": "HEKETI_FSTAB",
                "value": "/var/lib/heketi/fstab"
              },
              {
                "name": "HEKETI_SNAPSHOT_LIMIT",
                "value": "14"
              },
              {
                "name": "HEKETI_KUBE_GLUSTER_DAEMONSET",
                "value": "y"
              }
            ],
            "ports": [
              {
                "containerPort": 8080
              }
            ],
            "volumeMounts": [
              {
                "name": "db",
                "mountPath": "/var/lib/heketi"
              },
              {
                "name": "config",
                "mountPath": "/etc/heketi"
              }
            ],
            "readinessProbe": {
              "timeoutSeconds": 3,
              "initialDelaySeconds": 3,
              "httpGet": {
                "path": "/hello",
                "port": 8080
              }
            },
            "livenessProbe": {
              "timeoutSeconds": 3,
              "initialDelaySeconds": 30,
              "httpGet": {
                "path": "/hello",
                "port": 8080
              }
            }
          }
        ],
        "volumes": [
          {
            "name": "db"
          },
          {
            "name": "config",
            "secret": {
              "secretName": "heketi-config-secret"
            }
          }
        ]
      }
    }
  }
}
]
}</code></pre></li> 
   </ul>
   <pre><code># kubectl create -f heketi-bootstrap.json
service "deploy-heketi" created
deployment "deploy-heketi" created

[root@node-01 heketi]# kubectl get pod
NAME                            READY     STATUS    RESTARTS   AGE
deploy-heketi-8888799fd-cmfp6   1/1       Running   0          6m
glusterfs-7t5ls                 1/1       Running   0          8m
glusterfs-drsx9                 1/1       Running   0          8m
glusterfs-pnnn8                 1/1       Running   0          8m</code></pre> 
   <ul>
    <li>现在Bootstrap Heketi服务正在运行，我们将配置端口转发，以便我们可以使用Heketi CLI与服务进行通信。使用Heketi pod的名称，运行以下命令：</li> 
   </ul>
   <pre><code>kubectl port-forward deploy-heketi-8888799fd-cmfp6 :8080</code></pre> 
   <p>如果在运行命令的系统上本地端口8080空闲，则可以运行port-forward命令，以便它为了方便而绑定到8080：</p> 
   <pre><code>kubectl port-forward deploy-heketi-8888799fd-cmfp6 18080:8080</code></pre> 
   <p>现在通过对Heketi服务运行示例查询来验证端口转发是否正常工作。该命令应该打印将要转发的本地端口。将其合并到URL中以测试服务，如下所示：</p> 
   <pre><code>curl http://localhost:18080/hello
Handling connection for 18080
Hello from Heketi</code></pre> 
   <p>最后，为Heketi CLI客户端设置环境变量，以便它知道如何到达Heketi Server。</p> 
   <pre><code>export HEKETI_CLI_SERVER=http://localhost:18080</code></pre> 
   <ul>
    <li> <p>接下来，我们将向Heketi提供有关要管理的GlusterFS集群的信息。我们通过拓扑文件提供此信息 。您克隆的repo中有一个示例拓扑文件，名为topology-sample.json。拓扑指定运行GlusterFS容器的Kubernetes节点以及每个节点的相应原始块设备。</p> </li> 
    <li> <p>确保hostnames/manage指向下面显示的确切名称kubectl get nodes，并且hostnames/storage是存储网络的IP地址。</p> </li> 
    <li>重要信息：此时，必须使用与服务器版本匹配的heketi-cli版本加载拓扑文件。作为最后的手段，Heketi容器附带了一份可以通过的方式访问的heketi-cli kubectl exec ...。</li> 
   </ul>
   <p>修改拓扑文件以反映您所做的选择，然后部署它，如下所示：</p> 
   <pre><code>{
  "clusters": [
    {
      "nodes": [
        {
          "node": {
            "hostnames": {
              "manage": [
                "10.31.90.204"
              ],
              "storage":[
                "10.31.90.204"
              ]
            },
            "zone": 1
          },
          "devices": [
            "/dev/sdc"
          ]
        },
        {
          "node": {
            "hostnames": {
              "manage": [
                "10.31.90.205"
              ],
              "storage":[
                "10.31.90.205"
              ]
            },
            "zone": 1
          },
          "devices": [
            "/dev/sdc"
          ]
        },
        {
          "node": {
            "hostnames": {
              "manage": [
                "10.31.90.206"
              ],
              "storage":[
                "10.31.90.206"
              ]
            },
            "zone": 1
          },
          "devices": [
            "/dev/sdc"
          ]
        }
      ]
    }
  ]
}
</code></pre> 
   <pre><code>[root@node-01 ~]# heketi-cli topology load --json=top.json
Creating cluster ... ID: e758afb77ee26d5f969d7efee1516e64
        Allowing file volumes on cluster.
        Allowing block volumes on cluster.
        Creating node 10.31.90.204 ... ID: a6eedd58c118dcfe44a0db2af1a4f863
                Adding device /dev/sdc ... OK
        Creating node 10.31.90.205 ... ID: 4066962c14bcdebd28aca193b5690792
                Adding device /dev/sdc ... OK
        Creating node 10.31.90.206 ... ID: 91e42a2361f0266ae334354e5c34ce11
                Adding device /dev/sdc ... OK</code></pre> 
   <ul>
    <li>接下来我们将使用Heketi为它配置一个卷来存储其数据库：</li> 
   </ul>
   <p>执行此命令后会生成一个heketi-storage.json的文件，我们最好是将此文件里的<br><code>"image": "heketi/heketi:dev"</code><br>改为<br><code>"image": "heketi/heketi:8"</code></p> 
   <pre><code># heketi-client/bin/heketi-cli setup-openshift-heketi-storage</code></pre> 
   <p>然后在创建heketi相关服务</p> 
   <pre><code># kubectl create -f heketi-storage.json</code></pre> 
   <blockquote> 
    <p>陷阱：如果heketi-cli在运行setup-openshift-heketi-storage子命令时报告“无空间”错误，则可能无意中运行topology load了服务器和heketi-cli的不匹配版本。停止正在运行的Heketi pod（kubectl scale deployment deploy-heketi --replicas=0），手动从存储块设备中删除任何签名，然后继续运行Heketi pod（kubectl scale deployment deploy-heketi --replicas=1）。然后使用匹配版本的heketi-cli重新加载拓扑并重试该步骤。</p> 
   </blockquote> 
   <ul>
    <li>等到作业完成然后删除引导程序Heketi：</li> 
   </ul>
   <pre><code># kubectl delete all,service,jobs,deployment,secret --selector="deploy-heketi"</code></pre> 
   <ul>
    <li>创建长期Heketi实例： <pre><code>{
"kind": "List",
"apiVersion": "v1",
"items": [
{
  "kind": "Secret",
  "apiVersion": "v1",
  "metadata": {
    "name": "heketi-db-backup",
    "labels": {
      "glusterfs": "heketi-db",
      "heketi": "db"
    }
  },
  "data": {
  },
  "type": "Opaque"
},
{
  "kind": "Service",
  "apiVersion": "v1",
  "metadata": {
    "name": "heketi",
    "labels": {
      "glusterfs": "heketi-service",
      "deploy-heketi": "support"
    },
    "annotations": {
      "description": "Exposes Heketi Service"
    }
  },
  "spec": {
    "selector": {
      "name": "heketi"
    },
    "ports": [
      {
        "name": "heketi",
        "port": 8080,
        "targetPort": 8080
      }
    ]
  }
},
{
  "kind": "Deployment",
  "apiVersion": "extensions/v1beta1",
  "metadata": {
    "name": "heketi",
    "labels": {
      "glusterfs": "heketi-deployment"
    },
    "annotations": {
      "description": "Defines how to deploy Heketi"
    }
  },
  "spec": {
    "replicas": 1,
    "template": {
      "metadata": {
        "name": "heketi",
        "labels": {
          "name": "heketi",
          "glusterfs": "heketi-pod"
        }
      },
      "spec": {
        "serviceAccountName": "heketi-service-account",
        "containers": [
          {
            "image": "heketi/heketi:8",
            "imagePullPolicy": "Always",
            "name": "heketi",
            "env": [
              {
                "name": "HEKETI_EXECUTOR",
                "value": "kubernetes"
              },
              {
                "name": "HEKETI_DB_PATH",
                "value": "/var/lib/heketi/heketi.db"
              },
              {
                "name": "HEKETI_FSTAB",
                "value": "/var/lib/heketi/fstab"
              },
              {
                "name": "HEKETI_SNAPSHOT_LIMIT",
                "value": "14"
              },
              {
                "name": "HEKETI_KUBE_GLUSTER_DAEMONSET",
                "value": "y"
              }
            ],
            "ports": [
              {
                "containerPort": 8080
              }
            ],
            "volumeMounts": [
              {
                "mountPath": "/backupdb",
                "name": "heketi-db-secret"
              },
              {
                "name": "db",
                "mountPath": "/var/lib/heketi"
              },
              {
                "name": "config",
                "mountPath": "/etc/heketi"
              }
            ],
            "readinessProbe": {
              "timeoutSeconds": 3,
              "initialDelaySeconds": 3,
              "httpGet": {
                "path": "/hello",
                "port": 8080
              }
            },
            "livenessProbe": {
              "timeoutSeconds": 3,
              "initialDelaySeconds": 30,
              "httpGet": {
                "path": "/hello",
                "port": 8080
              }
            }
          }
        ],
        "volumes": [
          {
            "name": "db",
            "glusterfs": {
              "endpoints": "heketi-storage-endpoints",
              "path": "heketidbstorage"
            }
          },
          {
            "name": "heketi-db-secret",
            "secret": {
              "secretName": "heketi-db-backup"
            }
          },
          {
            "name": "config",
            "secret": {
              "secretName": "heketi-config-secret"
            }
          }
        ]
      }
    }
  }
}
]
}</code></pre></li> 
   </ul>
   <pre><code># kubectl create -f heketi-deployment.json
service "heketi" created
deployment "heketi" created</code></pre> 
   <ul>
    <li>现在这样做了，Heketi数据库将保留在GlusterFS卷中，并且每次重启Heketi pod时都不会重置。</li> 
   </ul>
   <p>使用诸如<code>heketi-cli cluster list</code>和之类的命令<code>heketi-cli volume list</code> 来确认先前建立的集群是否存在，以及Heketi是否知道在引导阶段创建的db存储卷。</p> 
   <h3>演示测试</h3> 
   <ol>
    <li>接下来就是建立存储卷，然后挂载测试。<br>在测试之前我们需要先将heketi服务通过Ingress对外发布，将<code>heketi.cnlinux.club</code>的<code>A记录</code>解析为<code>10.31.90.200</code>。 <pre><code>apiVersion: extensions/v1beta1
kind: Ingress
metadata:
name: ingress-heketi
annotations:
nginx.ingress.kubernetes.io/rewrite-target: /
kubernetes.io/ingress.class: nginx
spec:
rules:
- host: heketi.cnlinux.club
  http:
    paths:
      - path: 
        backend:
          serviceName: heketi
          servicePort: 8080</code></pre> <pre><code>[root@node-01 heketi]# kubectl create -f ingress-heketi.yaml</code></pre> <p>在浏览器访问http://heketi.cnlinux.club/hello<br><img src="https://s1.51cto.com/images/blog/201901/02/dbb15dc886f0ae01dca86eb6132cc23b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="Kubernetes部署（十）：储存之glusterfs和heketi部署"></p></li> 
    <li>创建StorageClass</li> 
   </ol>
   <pre><code>apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: gluster-heketi
provisioner: kubernetes.io/glusterfs
parameters:
  resturl: "http://heketi.cnlinux.club"
  restauthenabled: "false" 
  volumetype: "replicate:2"</code></pre> 
   <pre><code>[root@node-01 heketi]# kubectl create -f storageclass-gluster-heketi.yaml
[root@node-01 heketi]# kubectl get sc
NAME             PROVISIONER               AGE
gluster-heketi   kubernetes.io/glusterfs   10s</code></pre> 
   <ol start="3">
    <li>创建pvc <pre><code>apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: pvc-gluster-heketi
spec:
storageClassName: gluster-heketi
accessModes:
- ReadWriteOnce
resources:
requests:
  storage: 1Gi</code></pre> <pre><code>[root@node-01 heketi]# kubectl create -f pvc-gluster-heketi.yaml 
[root@node-01 heketi]# kubectl get pvc
NAME                 STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS     AGE
pvc-gluster-heketi   Bound     pvc-d978f524-0b74-11e9-875c-005056826470   1Gi        RWO            gluster-heketi   30s</code></pre></li> 
    <li>在pod里挂载pvc <pre><code>apiVersion: v1
kind: Pod
metadata:
name: pod-pvc
spec:
containers:
- name: pod-pvc
image: busybox:latest
command:
- sleep
- "3600"
volumeMounts:
- name: gluster-volume
  mountPath: "/pv-data"
volumes:
- name: gluster-volume
  persistentVolumeClaim:
    claimName: pvc-gluster-heketi</code></pre> <pre><code>[root@node-01 heketi]# kubectl create -f pod-pvc.yaml </code></pre> <p>进入容器查看是否已经挂载成功</p> <pre><code>[root@node-01 heketi]# kubectl exec pod-pvc -it /bin/sh
/ # df -h
Filesystem                Size      Used Available Use% Mounted on
overlay                  47.8G      4.3G     43.5G   9% /
tmpfs                    64.0M         0     64.0M   0% /dev
tmpfs                     1.9G         0      1.9G   0% /sys/fs/cgroup
10.31.90.204:vol_675cc9fe0e959157919c886ea7786d33
                   1014.0M     42.7M    971.3M   4% /pv-data
/dev/sda3                47.8G      4.3G     43.5G   9% /dev/termination-log
/dev/sda3                47.8G      4.3G     43.5G   9% /etc/resolv.conf
/dev/sda3                47.8G      4.3G     43.5G   9% /etc/hostname
/dev/sda3                47.8G      4.3G     43.5G   9% /etc/hosts</code></pre> <p>#往/pv-data写文件，当容量超过1G时就自动退出了，证明容量限制是生效的。</p> <pre><code>/ # cd /pv-data/
/pv-data # dd if=/dev/zero of=/pv-data/test.img bs=8M count=300
123+0 records in
122+0 records out
1030225920 bytes (982.5MB) copied, 24.255925 seconds, 40.5MB/s</code></pre> <p>在宿主机磁盘里查看是否创建了test.img文件</p> <pre><code>[root@node-04 cfg]# mount /dev/vg_2631413b8b87bbd6cb526568ab697d37/brick_1691ef862dd504e12e8384af76e5a9f2 /mnt
[root@node-04 cfg]# ll -h /mnt/brick/
total 982M
-rw-r--r-- 2 root 2001 982M Jan  2 15:14 test.img</code></pre> <p>至此，所有的操作都已完成。</p></li> 
   </ol>
  </div> 
  <p>转载于:https://blog.51cto.com/billy98/2337874</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
