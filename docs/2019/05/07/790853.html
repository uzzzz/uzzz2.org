<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Linux环境Spark安装配置及使用 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Linux环境Spark安装配置及使用" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="原文链接： https://juejin.im/post/5cd16c00e51d453a51433062 Linux环境Spark安装配置及使用 1. 认识Spark (1) Spark介绍 大数据计算引擎 官网：spark.apache.org/ 官方介绍：Apache Spark™ is a unified analytics engine for large-scale data processing.（Apache Spark™是一个用于大规模数据处理的统一分析引擎。） Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab，2010年开源，2013年6月成为Apache孵化项目，2014年2月成为Apache顶级项目。目前，Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、Spark Streaming、GraphX、MLlib等子项目，Spark是基于内存计算的大数据并行计算框架。Spark基于内存计算，提高了在大数据环境下数据处理的实时性，同时保证了高容错性和高可伸缩性，允许用户将Spark部署在大量廉价硬件之上，形成集群。 Spark生态圈： Spark Core：RDD（弹性分布式数据集） Spark SQL Spark Streaming Spark MLLib：协同过滤，ALS，逻辑回归等等 --&gt; 机器学习 Spark Graphx：图计算 (2) 为什么要学习Spark Hadoop的MapReduce计算模型存在的问题： MapReduce的核心是Shuffle（洗牌）。在整个Shuffle的过程中，至少会产生6次的I/O。 中间结果输出：基于MapReduce的计算引擎通常会将中间结果输出到磁盘上，进行存储和容错。另外，当一些查询（如：Hive）翻译到MapReduce任务时，往往会产生多个Stage（阶段），而这些串联的Stage又依赖于底层文件系统（如HDFS）来存储每一个Stage的输出结果，而I/O的效率往往较低，从而影响了MapReduce的运行速度。 Spark的最大特点：基于内存 Spark是MapReduce的替代方案，而且兼容HDFS、Hive，可融入Hadoop的生态系统，弥补MapReduce的不足。 (3) Spark的特点：快、易用、通用、兼容 快——与Hadoop的MapReduce相比，Spark基于内存的运算速度要快100倍以上，即使，Spark基于硬盘的运算也要快10倍。Spark实现了高效的DAG执行引擎，从而可以通过内存来高效处理数据流。 易用——Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的shell，可以非常方便地在这些shell中使用Spark集群来验证解决问题的方法。 通用——Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。Spark统一的解决方案非常具有吸引力，毕竟任何公司都想用统一的平台去处理遇到的问题，减少开发和维护的人力成本和部署平台的物力成本。另外Spark还可以很好的融入Hadoop的体系结构中可以直接操作HDFS，并提供Hive on Spark、Pig on Spark的框架集成Hadoop。 兼容——Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和ApacheMesos作为它的资源管理和调度器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase和Cassandra等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力。Spark也可以不依赖于第三方的资源管理和调度器，它实现了Standalone作为其内置的资源管理和调度框架，这样进一步降低了Spark的使用门槛，使得所有人都可以非常容易地部署和使用Spark。此外，Spark还提供了在EC2上部署Standalone的Spark集群的工具。 2. Spark体系架构 Spark的运行方式 Yarn Standalone：本机调试（demo） Worker(从节点)：每个服务器上，资源和任务的管理者，只负责管理一个节点。 执行过程： 一个Worker 有多个 Executor。 Executor是任务的执行者，按阶段（stage）划分任务。—&gt; RDD 客户端：Driver Program 提交任务到集群中。 spark-submit spark-shell 3. Spark-2.1.0安装流程 (1) 准备工作 具备java环境 配置主机名 配置免密码登录 防火墙关闭 (2) 解压spark-2.1.0-bin-hadoop2.7.tgz安装包到目标目录下： tar -zxvf .tar.gz -C 目标目录 (3) 为后续方便，重命名Spark文件夹： mv spark-2.1.0-bin-hadoop2.7/ spark-2.1.0 (4) Spark目录介绍 bin —— Spark操作命令 conf —— 配置文件 data —— Spark测试文件 examples —— Spark示例程序 jars LICENSE licenses NOTICE python R README.md RELEASE sbin —— Spark集群命令 yarn —— Spark-yarn配置 (5) 修改配置文件： &lt;1&gt;. 配置spark-env.sh： 进入spark-2.1.0/conf路径，重命名配置文件： mv spark-env.sh.template spark-env.sh 修改spark-env.sh信息： vi spark-env.sh export JAVA_HOME=/opt/module/jdk1.8.0_144 export SPARK_MASTER_HOST=bigdata01 export SPARK_MASTER_PORT=7077 复制代码 &lt;2&gt;. 配置slaves： 进入spark-2.1.0/conf路径，重命名配置文件： mv slaves.template slaves 修改slaves信息： vi slaves bigdata02 bigdata03 复制代码 (6) 配置环境变量： 修改配置文件： vi /etc/profile 增加以下内容： export SPARK_HOME=spark安装路径 export PATH=$PATH:$SPARK_HOME/bin export PATH=$PATH:$SPARK_HOME/sbin 声明环境变量： source /etc/profile (6) 集群配置： 拷贝配置好的spark到其他机器上 scp -r spark-2.1.0/ bigdata02:$PWD scp -r spark-2.1.0/ bigdata03:$PWD (7) 启动： 启动主节点： start-master.sh 启动从节点： start-slaves.sh 启动shell： spark-shell 通过网页端查看： http://bigdata01:8080/ Spark中内置有Tomcat，故端口号默认为8080 (8) 关闭： 关闭主节点： stop-master.sh 关闭从节点： stop-slaves.sh 4. Spark HA的实现 (1) 基于文件系统的单点恢复 主要用于开发或测试环境。 当spark提供目录保存spark Application和worker的注册信息，并将他们的恢复状态写入该目录中，一旦Master发生故障，就可以通过重新启动Master进程（sbin/start-master.sh），恢复已运行的spark Application和worker的注册信息。 基于文件系统的单点恢复，主要是在spark-env.sh里对SPARK_DAEMON_JAVA_OPTS设置 创建存放文件夹：mkdir /opt/module/spark-2.1.0/recovery 修改配置信息： vi spark-env.sh 增加内容：export SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=FILESYSTEM -Dspark.deploy.recoveryDirectory=/opt/module/spark-2.1.0/recovery&quot; (2) 基于Zookeeper的Standby Masters 适用于现实生产。 ZooKeeper提供了一个Leader Election机制，利用这个机制可以保证虽然集群存在多个Master，但是只有一个是Active的，其他的都是Standby。当Active的Master出现故障时，另外的一个Standby Master会被选举出来。由于集群的信息，包括Worker，Driver和Application的信息都已经持久化到ZooKeeper，因此在切换的过程中只会影响新Job的提交，对于正在进行的Job没有任何的影响。加入ZooKeeper的集群整体架构如下图所示： 修改配置信息： vi spark-env.sh 增加内容：export SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=bigdata01:2181,bigdata02:2181,bigdata03:2181 -Dspark.deploy.zookeeper.dir=/spark&quot; 注释掉：export SPARK_MASTER_HOST和export SPARK_MASTER_PORT 发送新的配置文件到集群其余节点： scp spark-env.sh bigdata02:$PWD scp spark-env.sh bigdata03:$PWD 5. 执行Spark的任务 (1) spark-submit 用于提交Spark的任务（任务即相关jar包） e.g.: 蒙特卡洛求PI（圆周率） 原理：如下图所示，随机向正方形内落点，通过统计正方形内所有点数和落入圆内的点数来计算占比，得出正方形与圆的面积近似比值，进而近似出PI值。 命令： spark-submit --master spark://XXXX:7077 （指明master地址） --class org.apache.spark.examples.SparkPi （指明主程序的名字） /XXXX/spark/examples/jars/spark-examples_2.11-2.1.0.jar（指明jar包地址） 100（指明运行次数） (2) spark-shell 相当于REPL，作为一个独立的Application运行 spark-shell是Spark自带的交互式Shell程序，方便用户进行交互式编程，用户可以在该命令行下用scala编写spark程序。 参数说明： --master spark://XXXX:7077 指定Master的地址 --executor-memory 2g 指定每个worker可用内存为2G --total-executor-cores 2 指定整个集群使用的cup核数为2个 Spark Session 是 2.0 以后提供的，利用 SparkSession 可以访问spark所有组件 两种运行模式： &lt;1&gt;. 本地模式 启动：spark-shell（后面不接任何参数） &lt;2&gt;. 集群模式 启动：spark-shell --master spark://XXXX:7077（指明master地址） e.g.: 编写WordCount程序 &lt;1&gt;. 处理本地文件，把结果打印到屏幕上 启动：spark-shell 传入文件：sc.textFile(&quot;/XXXX/WordCount.txt&quot;)（本地文件路径）.flatMap(_.split(&quot; &quot;))（按照空格分割）.map((_,1))（单词遍历）.reduceByKey(_+_)（单词计数）.collect &lt;2&gt;. 处理HDFS文件，结果保存在hdfs上 启动：spark-shell --master spark://XXXX:7077（指 sc.textFile(&quot;hdfs://XXXX:9000/sp_wc.txt&quot;).flatMap(.split(&quot; &quot;)).map((,1)).reduceByKey(+).saveAsTextFile(&quot;hdfs://XXXX:9000/output/spark/WordCount&quot;) (3) 单步运行WordCount -&gt; RDD 启动shell：spark-shell scala&gt; val rdd1 = sc.textFile(&quot;/root/sp_wc.txt&quot;) rdd1: org.apache.spark.rdd.RDD[String] = /root/sp_wc.txt MapPartitionsRDD[1] at textFile at &lt;console&gt;:24 scala&gt; rdd1.collect res0: Array[String] = Array(I love Scala, I love Skark, 2019/5/8) scala&gt; val rdd2 = rdd1.flatMap(_.split(&quot; &quot;)) rdd2: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[2] at flatMap at &lt;console&gt;:26 scala&gt; rdd2.collect res1: Array[String] = Array(I, love, Scala, I, love, Skark, 2019/5/8) scala&gt; val rdd3 = rdd2.map((_,1)) rdd3: org.apache.spark.rdd.RDD[(String, Int)] = MapPartitionsRDD[3] at map at &lt;console&gt;:28 scala&gt; rdd3.collect res2: Array[(String, Int)] = Array((I,1), (love,1), (Scala,1), (I,1), (love,1), (Skark,1), (2019/5/8,1)) scala&gt; val rdd4 = rdd3.reduceByKey(_+_) rdd4: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[4] at reduceByKey at &lt;console&gt;:30 scala&gt; rdd4.collect res3: Array[(String, Int)] = Array((2019/5/8,1), (love,2), (I,2), (Skark,1), (Scala,1)) 复制代码 (4) 在IDE中运行WorkCount &lt;1&gt;. scala版本 import org.apache.spark.SparkConf import org.apache.spark.SparkContext object WordCount { def main(args: Array[String]): Unit = { //创建一个Spark配置文件 val conf = new SparkConf().setAppName(&quot;Scala WordCount&quot;).setMaster(&quot;local&quot;) //创建Spark对象 val sc = new SparkContext(conf) val result = sc.textFile(args(0)) .flatMap(_.split(&quot; &quot;)) .map((_, 1)) .reduceByKey(_ + _) .saveAsTextFile(args(1)) sc.stop() } } 复制代码 &lt;2&gt;. Java版本 import java.util.Arrays; import java.util.Iterator; import java.util.List; import org.apache.spark.SparkConf; import org.apache.spark.api.java.JavaPairRDD; import org.apache.spark.api.java.JavaRDD; import org.apache.spark.api.java.JavaSparkContext; import org.apache.spark.api.java.function.FlatMapFunction; import org.apache.spark.api.java.function.Function2; import org.apache.spark.api.java.function.PairFunction; import parquet.format.PageHeader; import scala.Tuple2; public class WordCount { public static void main(String[] args) { // TODO Auto-generated method stub SparkConf conf = new SparkConf() .setAppName(&quot;JavaWordCount&quot;) .setMaster(&quot;local&quot;) ; //新建SparkContext对象 JavaSparkContext sc = new JavaSparkContext(conf) ; //读入数据 JavaRDD&lt;String&gt; lines = sc.textFile(&quot;hdfs://XXXX:9000/WordCount.txt&quot;) ; //分词 第一个参数表示读进来的话 第二个参数表示 返回值 JavaRDD&lt;String&gt; words = lines.flatMap(new FlatMapFunction&lt;String, String&gt;() { @Override public Iterator&lt;String&gt; call(String input) throws Exception { return Arrays.asList(input.split(&quot; &quot;)).iterator() ; } }) ; //每个单词记一次数 /* * String, String, Integer * input &lt;key value&gt; */ JavaPairRDD&lt;String, Integer&gt; ones = words.mapToPair(new PairFunction&lt;String, String, Integer&gt;() { @Override public Tuple2&lt;String, Integer&gt; call(String input) throws Exception { return new Tuple2&lt;String, Integer&gt;(input, 1) ; } }) ; //执行reduce操作 /* * Integer, Integer, Integer * nteger arg0, Integer arg1 返回值 */ JavaPairRDD&lt;String,Integer&gt; counts = ones.reduceByKey(new Function2&lt;Integer, Integer, Integer&gt;() { @Override public Integer call(Integer arg0, Integer arg1) throws Exception { // TODO Auto-generated method stub return arg0 + arg1 ; } }) ; //打印结果 List&lt;Tuple2&lt;String, Integer&gt;&gt; output = counts.collect() ; for (Tuple2&lt;String, Integer&gt; tuple :output) { System.out.println(tuple._1 + &quot; : &quot; + tuple._2) ; } sc.stop() ; } } 复制代码 (5) WordCount程序处理过程 (6) Spark提交任务的流程 6. Spark的算子 (1) RDD基础 &lt;1&gt;. 什么是RDD RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合。RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度。 &lt;2&gt;. RDD的属性（源码中的一段话） **一组分片（Partition）。**即数据集的基本组成单位。对于RDD来说，每个分片都会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的分片个数，如果没有指定，那么就会采用默认值。默认值就是程序所分配到的CPU Core的数目。 **一个计算每个分区的函数。**Spark中RDD的计算是以分片为单位的，每个RDD都会实现compute函数以达到这个目的。compute函数会对迭代器进行复合，不需要保存每次计算的结果。 **RDD之间的依赖关系。**RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。 **一个Partitioner，即RDD的分片函数。**当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。只有对于于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。 **一个列表。**存储存取每个Partition的优先位置（preferred location）。对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。 &lt;3&gt;. RDD的创建方式 通过外部的数据文件创建，如HDFS： val rdd1 = sc.textFile(“hdfs://XXXX:9000/data.txt”) 通过sc.parallelize进行创建： val rdd1 = sc.parallelize(Array(1,2,3,4,5,6,7,8)) DD的类型：Transformation和Action &lt;4&gt;. RDD的基本原理 (2) Transformation RDD中的所有转换都是延迟加载的，也就是说，它们并不会直接计算结果。相反的，它们只是记住这些应用到基础数据集（例如一个文件）上的转换动作。只有当发生一个要求返回结果给Driver的动作时，这些转换才会真正运行。这种设计让Spark更加有效率地运行。 (3) Action (4) RDD的缓存机制 RDD通过persist方法或cache方法可以将前面的计算结果缓存，但是并不是这两个方法被调用时立即缓存，而是触发后面的action时，该RDD将会被缓存在计算节点的内存中，并供后面重用。 通过查看源码发现cache最终也是调用了persist方法，默认的存储级别都是仅在内存存储一份，Spark的存储级别还有好多种，存储级别在object StorageLevel中定义的。 缓存有可能丢失，或者存储存储于内存的数据由于内存不足而被删除，RDD的缓存容错机制保证了即使缓存丢失也能保证计算的正确执行。通过基于RDD的一系列转换，丢失的数据会被重算，由于RDD的各个Partition是相对独立的，因此只需要计算丢失的部分即可，并不需要重算全部Partition。 Demo示例： 通过UI进行监控： (5) RDD的Checkpoint（检查点）机制：容错机制 检查点（本质是通过将RDD写入Disk做检查点）是为了通过lineage（血统）做容错的辅助，lineage过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果之后有节点出现问题而丢失分区，从做检查点的RDD开始重做Lineage，就会减少开销。 设置checkpoint的目录，可以是本地的文件夹、也可以是HDFS。一般是在具有容错能力，高可靠的文件系统上(比如HDFS, S3等)设置一个检查点路径，用于保存检查点数据。 分别举例说明： &lt;1&gt;. 本地目录 注意：这种模式，需要将spark-shell运行在本地模式上 &lt;2&gt;. HDFS的目录 注意：这种模式，需要将spark-shell运行在集群模式上 (6) RDD的依赖关系和Spark任务中的Stage RDD的依赖关系 RDD和它依赖的父RDD（s）的关系有两种不同的类型，即窄依赖（narrow dependency）和宽依赖（wide dependency）。 窄依赖指的是每一个父RDD的Partition最多被子RDD的一个Partition使用 总结：窄依赖我们形象的比喻为独生子女 宽依赖指的是多个子RDD的Partition会依赖同一个父RDD的Partition 总结：窄依赖我们形象的比喻为超生 Spark任务中的Stage DAG(Directed Acyclic Graph)叫做有向无环图，原始的RDD通过一系列的转换就就形成了DAG，根据RDD之间的依赖关系的不同将DAG划分成不同的Stage，对于窄依赖，partition的转换处理在Stage中完成计算。对于宽依赖，由于有Shuffle的存在，只能在parent RDD处理完成后，才能开始接下来的计算，因此宽依赖是划分Stage的依据。 (7) RDD基础练习 练习1： //通过并行化生成rdd val rdd1 = sc.parallelize(List(5, 6, 4, 7, 3, 8, 2, 9, 1, 10)) //对rdd1里的每一个元素乘2然后排序 val rdd2 = rdd1.map(_ * 2).sortBy(x =&gt; x, true) //过滤出大于等于十的元素 val rdd3 = rdd2.filter(_ &gt;= 10) //将元素以数组的方式在客户端显示 rdd3.collect 复制代码 练习2： val rdd1 = sc.parallelize(Array(&quot;a b c&quot;, &quot;d e f&quot;, &quot;h i j&quot;)) //将rdd1里面的每一个元素先切分在压平 val rdd2 = rdd1.flatMap(_.split(&#39; &#39;)) rdd2.collect 复制代码 练习3： val rdd1 = sc.parallelize(List(5, 6, 4, 3)) val rdd2 = sc.parallelize(List(1, 2, 3, 4)) //求并集 val rdd3 = rdd1.union(rdd2) //求交集 val rdd4 = rdd1.intersection(rdd2) //去重 rdd3.distinct.collect rdd4.collect 复制代码 练习4： val rdd1 = sc.parallelize(List((&quot;tom&quot;, 1), (&quot;jerry&quot;, 3), (&quot;kitty&quot;, 2))) val rdd2 = sc.parallelize(List((&quot;jerry&quot;, 2), (&quot;tom&quot;, 1), (&quot;shuke&quot;, 2))) //求jion val rdd3 = rdd1.join(rdd2) rdd3.collect //求并集 val rdd4 = rdd1 union rdd2 //按key进行分组 rdd4.groupByKey rdd4.collect 复制代码 练习5： val rdd1 = sc.parallelize(List((&quot;tom&quot;, 1), (&quot;tom&quot;, 2), (&quot;jerry&quot;, 3), (&quot;kitty&quot;, 2))) val rdd2 = sc.parallelize(List((&quot;jerry&quot;, 2), (&quot;tom&quot;, 1), (&quot;shuke&quot;, 2))) //cogroup val rdd3 = rdd1.cogroup(rdd2) //注意cogroup与groupByKey的区别 rdd3.collect 复制代码 练习6： val rdd1 = sc.parallelize(List(1, 2, 3, 4, 5)) //reduce聚合 val rdd2 = rdd1.reduce(_ + _) rdd2.collect 复制代码 练习7： val rdd1 = sc.parallelize(List((&quot;tom&quot;, 1), (&quot;jerry&quot;, 3), (&quot;kitty&quot;, 2), (&quot;shuke&quot;, 1))) val rdd2 = sc.parallelize(List((&quot;jerry&quot;, 2), (&quot;tom&quot;, 3), (&quot;shuke&quot;, 2), (&quot;kitty&quot;, 5))) val rdd3 = rdd1.union(rdd2) //按key进行聚合 val rdd4 = rdd3.reduceByKey(_ + _) rdd4.collect //按value的降序排序 val rdd5 = rdd4.map(t =&gt; (t._2, t._1)).sortByKey(false).map(t =&gt; (t._2, t._1)) rdd5.collect 复制代码7. Spark RDD的高级算子 (1) mapPartitionsWithIndex 把每个partition中的分区号和对应的值拿出来 def mapPartitionsWithIndex[U](f: (Int, Iterator[T]) ⇒ Iterator[U], preservesPartitioning: Boolean = false)(implicit arg0: ClassTag[U]): RDD[U] f中函数参数： 第一个参数是Int，代表分区号 第二个Iterator[T]代表分区中的元素 e.g.: 将每个分区中的元素和分区号打印出来 val rdd1 = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 2) 创建一个函数返回RDD中的每个分区号和元素： def func1(index:Int, iter:Iterator[Int]):Iterator[String] ={ iter.toList.map( x =&gt; &quot;[PartID:&quot; + index + &quot;, value=&quot; + x + &quot;]&quot; ).iterator } 复制代码 调用：rdd1.mapPartitionsWithIndex(func1).collect (2) aggregate 先对局部聚合，再对全局聚合 e.g.: val rdd1 = sc.parallelize(List(1,2,3,4,5), 2) 查看每个分区中的元素： scala&gt; rdd1.mapPartitionsWithIndex(fun1).collect res4: Array[String] = Array( [partId : 0 , value = 1 ], [partId : 0 , value = 2 ], [partId : 1 , value = 3 ], [partId : 1 , value = 4 ], [partId : 1 , value = 5 ]) 复制代码 将每个分区中的最大值求和，注意初始值是0: scala&gt; rdd2.aggregate(0)(max(_,_),_+_) res6: Int = 7 复制代码 如果初始值时候100，则结果为300: scala&gt; rdd2.aggregate(100)(max(_,_),_+_) res8: Int = 300 ``` 复制代码 如果是求和，注意初始值是0： scala&gt; rdd2.aggregate(0)(_+_,_+_) res9: Int = 15 复制代码 如果初始值是10，则结果是45 scala&gt; rdd2.aggregate(10)(_+_,_+_) res10: Int = 45 复制代码 e.g. —— 字符串： val rdd2 = sc.parallelize(List(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;),2) 修改一下刚才的查看分区元素的函数 def func2(index: Int, iter: Iterator[(String)]) : Iterator[String] = { iter.toList.map(x =&gt; &quot;[partID:&quot; + index + &quot;, val: &quot; + x + &quot;]&quot;).iterator } 复制代码 两个分区中的元素： [partID:0, val: a], [partID:0, val: b], [partID:0, val: c], [partID:1, val: d], [partID:1, val: e], [partID:1, val: f] 复制代码 运行结果： e.g.: val rdd3 = sc.parallelize(List(&quot;12&quot;,&quot;23&quot;,&quot;345&quot;,&quot;4567&quot;),2) rdd3.aggregate(&quot;&quot;)((x,y) =&gt; math.max(x.length, y.length).toString, (x,y) =&gt; x + y) 复制代码 结果可能是24，也可能是42 val rdd4 = sc.parallelize(List(&quot;12&quot;,&quot;23&quot;,&quot;345&quot;,&quot;&quot;),2) rdd4.aggregate(&quot;&quot;)((x,y) =&gt; math.min(x.length, y.length).toString, (x,y) =&gt; x + y) 复制代码 结果是10，也可能是01 原因：注意有个初始值&quot;&quot;，其长度0，然后0.toString变成字符串 val rdd5 = sc.parallelize(List(&quot;12&quot;,&quot;23&quot;,&quot;&quot;,&quot;345&quot;),2) rdd5.aggregate(&quot;&quot;)((x,y) =&gt; math.min(x.length, y.length).toString, (x,y) =&gt; x + y) 复制代码 结果是11，原因同上。 (3) aggregateByKey 准备数据： val pairRDD = sc.parallelize(List( (&quot;cat&quot;,2), (&quot;cat&quot;, 5), (&quot;mouse&quot;, 4),(&quot;cat&quot;, 12), (&quot;dog&quot;, 12), (&quot;mouse&quot;, 2)), 2) def func3(index: Int, iter: Iterator[(String, Int)]) : Iterator[String] = { iter.toList.map(x =&gt; &quot;[partID:&quot; + index + &quot;, val: &quot; + x + &quot;]&quot;).iterator } 复制代码 两个分区中的元素： e.g.: 将每个分区中的动物最多的个数求和 scala&gt; pairRDD.aggregateByKey(0)(math.max(_, _), _ + _).collect res69: Array[(String, Int)] = Array((dog,12), (cat,17), (mouse,6)) 复制代码 将每种动物个数求和 scala&gt; pairRDD.aggregateByKey(0)(_+_, _ + _).collect res71: Array[(String, Int)] = Array((dog,12), (cat,19), (mouse,6)) 复制代码 这个例子也可以使用：reduceByKey scala&gt; pairRDD.reduceByKey(_+_).collect res73: Array[(String, Int)] = Array((dog,12), (cat,19), (mouse,6)) 复制代码 (4) coalesce与repartition 都是将RDD中的分区进行重分区。 区别： coalesce默认不会进行shuffle（false）； repartition会进行shuffle（true），会将数据真正通过网络进行重分区。 e.g.: def func4(index: Int, iter: Iterator[(Int)]) : Iterator[String] = { iter.toList.map(x =&gt; &quot;[partID:&quot; + index + &quot;, val: &quot; + x + &quot;]&quot;).iterator } val rdd1 = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 2) 下面两句话是等价的： val rdd2 = rdd1.repartition(3) val rdd3 = rdd1.coalesce(3,true) -&gt; 如果是false，查看RDD的length依然是2 复制代码 (5) 其他高级算子 参考：homepage.cs.latrobe.edu.au/zhe/ZhenHeS… 8. Spark 基础编程案例 (1) 求网站的访问量 Tomcat的访问日志如下： 需求：找到访问量最高的两个网页，要求显示网页名称和访问量 步骤分析： &lt;1&gt;. 对网页的访问量求和 &lt;2&gt;. 降序排序 代码： import org.apache.spark.SparkConf import org.apache.spark.SparkContext object TomcatLogCount { def main(args: Array[String]): Unit = { val conf = new SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;TomcatLogCount&quot;) val sc = new SparkContext(conf) /* * 读入日志并解析 * * 192.168.88.1 - - [30/Jul/2017:12:54:37 +0800] &quot;GET /MyDemoWeb/oracle.jsp HTTP/1.1&quot; 200 242 * */ val rdd1 = sc.textFile(&quot; &quot;).map( line =&gt; { //解析字符串，得到jsp的名字 //1. 解析两个引号间的字符串 val index1 = line.indexOf(&quot;\&quot;&quot;) val index2 = line.lastIndexOf(&quot;\&quot;&quot;) //line1 = GET /MyDemoWeb/oracle.jsp HTTP/1.1 val line1 = line.substring(index1 + 1, index2) val index3 = line1.indexOf(&quot; &quot;) val index4 = line1.lastIndexOf(&quot; &quot;) //line2 = /MyDemoWeb/oracle.jsp val line2 = line1.substring(index3 + 1, index4) //得到jsp的名字 oracle.jsp val jspName = line2.substring(line2.lastIndexOf(&quot;/&quot;)) (jspName, 1) } ) //统计每个jsp的次数 val rdd2 = rdd1.reduceByKey(_+_) //使用Value排序 val rdd3 = rdd2.sortBy(_._2, false) //得到次数最多的两个jsp rdd3.take(2).foreach(println) sc.stop() } } 复制代码 (2) 创建自定义分区 根据jsp文件的名字，将各自的访问日志放入到不同的分区文件中，如下： 生成的分区文件 如：part-00000文件中的内容：只包含了web.jsp的访问日志 代码： import org.apache.spark.SparkConf import org.apache.spark.SparkContext import scala.collection.mutable.HashMap object TomcatLogPartitioner { def main(args: Array[String]): Unit = { val conf = new SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;TomcatLogPartitioner&quot;) val sc = new SparkContext(conf) /* * 读入日志并解析 * * 192.168.88.1 - - [30/Jul/2017:12:54:37 +0800] &quot;GET /MyDemoWeb/oracle.jsp HTTP/1.1&quot; 200 242 * */ val rdd1 = sc.textFile(&quot; &quot;).map( line =&gt; { //解析字符串，得到jsp的名字 //1. 解析两个引号间的字符串 val index1 = line.indexOf(&quot;\&quot;&quot;) val index2 = line.lastIndexOf(&quot;\&quot;&quot;) //line1 = GET /MyDemoWeb/oracle.jsp HTTP/1.1 val line1 = line.substring(index1 + 1, index2) val index3 = line1.indexOf(&quot; &quot;) val index4 = line1.lastIndexOf(&quot; &quot;) //line2 = /MyDemoWeb/oracle.jsp val line2 = line1.substring(index3 + 1, index4) //得到jsp的名字 oracle.jsp val jspName = line2.substring(line2.lastIndexOf(&quot;/&quot;)) (jspName, line) } ) //得到不重复的jsp名字 val rdd2 = rdd1.map(_._1).distinct().collect() //创建分区规则 val wepPartitioner = new WepPartitioner(rdd2) val rdd3 = rdd1.partitionBy(wepPartitioner) //输出rdd3 rdd3.saveAsTextFile(&quot; &quot;) } //定义分区规则 class WepPartitioner(jspList : Array[String]) extends Partitioner { /* * 定义集合来保存分区条件: * String 代表jsp的名字 * Int 代表序号 * */ val partitionMap = new HashMap[String, Int]() //初始分区号 val partID = 0 //填值 for (jsp &lt;- jspList) { patitionMap.put(jsp, partID) partID += 1 } //返回分区个数 def numPartitioners : Int = partitionMap.size //根据jsp，返回对应的分区 def getPartition(key : Any) : Int = partitionMap.getOrElse(key.toString(), 0) } } 复制代码 (3) 使用JDBCRDD 访问数据库 JdbcRDD参数说明： 从上面的参数说明可以看出，JdbcRDD有以下两个缺点： &lt;1&gt;. 执行的SQL必须有两个参数，并类型都是Long &lt;2&gt;. 得到的结果是ResultSet，即：只支持select操作 代码： import org.apache.spark.SparkConf import org.apache.spark.SparkContext import java.sql.Connection import java.sql.DriverManager import java.sql.PreparedStatement /* * 把Spark结果存放到mysql数据库中 * */ object TomcatLogCountToMysql { def main(args: Array[String]): Unit = { //创建SparkContext val conf = new SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;MyTomcatLogCountToMysql&quot;) val sc = new SparkContext(conf) /* * * 读入日志 解析： * * 192.168.88.1 - - [30/Jul/2017:12:54:37 +0800] &quot;GET /MyDemoWeb/oracle.jsp HTTP/1.1&quot; 200 242 */ val rdd1 = sc.textFile(&quot;H:\\tmp_files\\localhost_access_log.txt&quot;) .map( line =&gt; { //解析字符串，得到jsp的名字 //1、解析两个引号之间的字符串 val index1 = line.indexOf(&quot;\&quot;&quot;) val index2 = line.lastIndexOf(&quot;\&quot;&quot;) val line1 = line.substring(index1 + 1, index2) // GET /MyDemoWeb/oracle.jsp HTTP/1.1 //得到两个空格的位置 val index3 = line1.indexOf(&quot; &quot;) val index4 = line1.lastIndexOf(&quot; &quot;) val line2 = line1.substring(index3 + 1, index4) // /MyDemoWeb/oracle.jsp //得到jsp的名字 val jspName = line2.substring(line2.lastIndexOf(&quot;/&quot;)) // oracle.jsp (jspName, 1) }) // // try { // /* // * create table mydata(jsname varchar(50),countNumber Int) // * // * foreach 没有返回值，在本需求中，只需要写数据库，不需要返回新的RDD，所以用foreach即可 // * // * // * 运行 Task not serializable // */ // conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;123456&quot;) // pst = conn.prepareStatement(&quot;insert into mydata values(?,?)&quot;) // // rdd1.foreach(f =&gt; { // pst.setString(1, f._1) // pst.setInt(2, f._2) // // pst.executeUpdate() // }) // } catch { // case t: Throwable =&gt; t.printStackTrace() // } finally { // if (pst != null) pst.close() // if (conn != null) conn.close() // } // // sc.stop() // //存入数据库 // var conn: Connection = null // var pst: PreparedStatement = null // //第一种修改方法 // /* // * 修改思路： // * conn pst 让每一个节点都是用到，需要在不同的节点上传输，实现sericalizable接口 // */ // try { // rdd1.foreach(f =&gt; { // conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;123456&quot;) // pst = conn.prepareStatement(&quot;insert into mydata values(?,?)&quot;) // // pst.setString(1, f._1) // pst.setInt(2, f._2) // // pst.executeUpdate() // }) // } catch { // case t: Throwable =&gt; t.printStackTrace() // } finally { // if (pst != null) pst.close() // if (conn != null) conn.close() // } // // sc.stop() /* * 第一种修改方式，功能上可以实现，但每条数据都会创建连接，对数据库造成很大压力 * * 针对分区来操作：一个分区，建立一个连接即可 */ rdd1.foreachPartition(saveToMysql) sc.stop() } def saveToMysql(it: Iterator[(String, Int)]) = { var conn: Connection = null var pst: PreparedStatement = null try { conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;123456&quot;) pst = conn.prepareStatement(&quot;insert into mydata values(?,?)&quot;) it.foreach(f =&gt; { pst.setString(1, f._1) pst.setInt(2, f._2) pst.executeUpdate() }) } catch { case t: Throwable =&gt; t.printStackTrace() } finally { if (pst != null) pst.close() if (conn != null) conn.close() } } } 复制代码9. 认识 Spark SQL (1) 什么是Spark SQL Spark SQL is Apache Spark&#39;s module for working with structured data.（Spark SQL 是spark 的一个模块，用来处理 结构化的数据。&lt;不能处理非结构化的数据&gt;） Spark SQL是Spark用来处理结构化数据的一个模块，它提供了一个编程抽象叫做DataFrame并且作为分布式SQL查询引擎的作用。 (2) 为什么要学习Spark SQL Hive是将HQL转换成MapReduce然后提交到集群上执行，大大简化了编写MapReduce的程序的复杂性，但是MapReduce这种计算模型执行效率比较慢。所以Spark SQL的应运而生，它是将Spark SQL转换成RDD，然后提交到集群执行，执行效率非常快，同时Spark SQL也支持从Hive中读取数据，Hive 2.x 执行引擎可以使用Spark。 (3) Spark SQL的特点： &lt;1&gt;. 容易集成 不需要单独安装。 &lt;2&gt;. 统一的数据访问方式 结构化数据（JDBC、JSon、Hive、parquer文件）都可以作为Spark SQL 的数据源。 对接多种数据源，且使用方式类似。 &lt;3&gt;. 兼容Hive 把Hive中的数据，读取到Spark SQL中运行。 &lt;4&gt;. 支持标准的数据连接（JDBC） 10. Spark SQL 基础 (1) 基本概念：Datasets和DataFrames &lt;1&gt;. DataFrame DataFrame是组织成命名列的数据集。它在概念上等同于关系数据库中的表，但在底层具有更丰富的优化。DataFrames可以从各种来源构建， 例如： 结构化数据文件 Hive中的表 外部数据库或现有RDDs DataFrame API支持的语言有Scala，Java，Python和R。 从上图可以看出，DataFrame多了数据的结构信息，即schema。RDD是分布式的 Java对象的集合。DataFrame是分布式的Row对象的集合。DataFrame除了提供了比RDD更丰富的算子以外，更重要的特点是提升执行效率、减少数据读取以及执行计划的优化。 &lt;2&gt;. Datasets Dataset是数据的分布式集合。Dataset是在Spark 1.6中添加的一个新接口，是DataFrame之上更高一级的抽象。它提供了RDD的优点（强类型化，使用强大的lambda函数的能力）以及Spark SQL优化后的执行引擎的优点。一个Dataset 可以从JVM对象构造，然后使用函数转换（map， flatMap，filter等）去操作。Dataset API 支持Scala和Java，Python不支持Dataset API。 (2) DataFrames &lt;1&gt;. 创建 DataFrames a. 通过Case Class创建DataFrames ① 定义case class（相当于表的结构：Schema） case class Emp(empno:Int,ename:String,job:String,mgr:Int,hiredate:String,sal:Int,comm:Int,deptno:Int) 注意：由于mgr和comm列中包含null值，简单起见，将对应的case class类型定义为String ② 将HDFS上的数据读入RDD，并将RDD与case Class关联 val lines = sc.textFile(&quot;/XXXX/emp.csv&quot;).map(_.split(&quot;,&quot;)) ③ 将RDD转换成DataFrames val allEmp = lines.map(x =&gt; Emp(x(0).toInt,x(1),x(2),x(3).toInt,x(4),x(5).toInt,x(6).toInt,x(7).toInt)) ④ 通过DataFrames查询数据 val df1 = allEmp.toDF df1.show b. 使用SparkSession 什么是SparkSession Apache Spark 2.0引入了SparkSession，其为用户提供了一个统一的切入点来使用Spark的各项功能，并且允许用户通过它调用DataFrame和Dataset相关API来编写Spark程序。最重要的是，它减少了用户需要了解的一些概念，使得我们可以很容易地与Spark交互。 在2.0版本之前，与Spark交互之前必须先创建SparkConf和SparkContext。然而在Spark 2.0中，我们可以通过SparkSession来实现同样的功能，而不需要显式地创建SparkConf, SparkContext 以及 SQLContext，因为这些对象已经封装在SparkSession中。   - 创建StructType，来定义Schema结构信息 注意：需要import org.apache.spark.sql.types._，import org.apache.spark.sql.Row import org.apache.spark.sql.types._ val myschema = StructType( List( StructField(&quot;empno&quot;,DataTypes.IntegerType), StructField(&quot;ename&quot;,DataTypes.StringType), StructField(&quot;job&quot;,DataTypes.StringType), StructField(&quot;mgr&quot;,DataTypes.IntegerType), StructField(&quot;hiredate&quot;,DataTypes.StringType), StructField(&quot;sal&quot;,DataTypes.IntegerType), StructField(&quot;comm&quot;,DataTypes.IntegerType), StructField(&quot;deptno&quot;,DataTypes.IntegerType), )) val allEmp = lines.map(x =&gt; Row(x(0).toInt,x(1),x(2),x(3).toInt,x(4),x(5).toInt,x(6).toInt,x(7).toInt)) import org.apache.spark.sql.Row val df2 = spark.createDataFrame(allEmp,myschema) 复制代码 c. 使用JSon文件来创建DataFame val df3 = spark.read 读文件，默认是Parquet文件 val df3 = spark.read.json(&quot;/XXXX/people.json&quot;) 读json文件 df3.show val df4 = spark.read.format(&quot;json&quot;).load(&quot;/XXXX/people.json&quot;) 复制代码 &lt;2&gt;. DataFrame 操作 DataFrame操作也称为无类型的Dataset操作 a. DSL语句 查询所有的员工姓名 查询所有的员工姓名和薪水，并给薪水加100块钱 查询工资大于2000的员工 求每个部门的员工人数 参考：spark.apache.org/docs/2.1.0/… b. SQL语句 **注意：**不能直接执行SQL，需要生成一个视图，再执行sql。 ① 将DataFrame注册成表（视图）：df.createOrReplaceTempView(&quot;emp&quot;) ② 执行查询： spark.sql(&quot;select * from emp&quot;).show spark.sql(&quot;select * from emp where deptno=10&quot;).show spark.sql(&quot;select deptno,sum(sal) from emp group by deptno&quot;).show (3) Spark SQL 中的视图 视图是一个虚表，不存储数据。 两种类型： &lt;1&gt;. 普通视图（本地视图）——createOrReplaceTempView 只在当前Session中有效。 &lt;2&gt;. 全局视图： ——createGlobalTempView 在Spark SQL中，如果想拥有一个临时的view，并想在不同的Session中共享，而且在application的运行周期内可用，那么就需要创建一个全局的临时view。并记得使用的时候加上global_temp作为前缀来引用它，因为全局的临时view是绑定到系统保留的数据库global_temp上。 e.g.: ``` 创建一个新session，读取不到emp视图 spark.newSession.sql(&quot;select * from emp&quot;) 以下两种方式均可读到 全局视图 中的数据: df1.createGlobalTempView(&quot;emp1&quot;) spark.newSession.sql(&quot;select * from global_temp.emp1&quot;).show spark.sql(&quot;select * from global_temp.emp1&quot;).show 复制代码 复制代码 (4) 创建Datasets DataFrame的引入，可以让Spark更好的处理结构数据的计算，但其中一个主要的问题是：缺乏编译时类型安全。为了解决这个问题，Spark采用新的Dataset API (DataFrame API的类型扩展)。 Dataset是一个分布式的数据收集器。这是在Spark1.6之后新加的一个接口，兼顾了RDD的优点（强类型，可以使用功能强大的lambda）以及Spark SQL的执行器高效性的优点。所以可以把DataFrames看成是一种特殊的Datasets，即：Dataset(Row) 创建DataSet： &lt;1&gt;. 使用序列 ① 定义case class: case class MyData(a:Int,b:String) ② 生成序列并创建DataSet: val ds = Seq(MyData(1,&quot;Tom&quot;),MyData(2,&quot;Mary&quot;)).toDS ③ 查看结果 ds.show &lt;2&gt;. 使用JSON数据 ① 定义case class: case class Person(name: String, gender: String) ② 通过JSON数据生成DataFrame: val df = spark.read.json(sc.parallelize(&quot;&quot;&quot;{&quot;gender&quot;: &quot;Male&quot;, &quot;name&quot;: &quot;Tom&quot;}&quot;&quot;&quot; :: Nil)) ③ 将DataFrame转成DataSet: df.as[Person].show df.as[Person].collect &lt;3&gt;. 使用HDFS数据 ① 读取HDFS数据，并创建DataSet: val linesDS = spark.read.text(&quot;hdfs://XXXX:9000/XXXX/data.txt&quot;).as[String] ② 对DataSet进行操作：分词后，查询长度大于3的单词 val words = linesDS.flatMap(_.split(&quot; &quot;)).filter(_.length &gt; 3) words.show words.collect 复制代码 ③ 执行WordCount程序 val result = linesDS.flatMap(_.split(&quot; &quot;)).map((_,1)).groupByKey(x =&gt; x._1).count result.show 排序：result.orderBy($&quot;value&quot;).show 复制代码 (5) Datasets 的操作案例 &lt;1&gt;. 使用emp.json 生成DataFrame: val empDF = spark.read.json(&quot;/XXXX/emp.json&quot;) 查询工资大于3000的员工 empDF.where($&quot;sal&quot; &gt;= 3000).show 复制代码 &lt;2&gt;. 创建case class: case class Emp(empno:Long,ename:String,job:String,hiredate:String,mgr:String,sal:Long,comm:String,deptno:Long) &lt;3&gt;. 生成DataSets并查询数据: val empDS = empDF.as[Emp] 查询工资大于3000的员工 empDS.filter(_.sal &gt; 3000).show 查看10号部门的员工 empDS.filter(_.deptno == 10).show 复制代码 &lt;4&gt;. 多表查询: a. 创建部门表: val deptRDD=sc.textFile(&quot;/XXXX/dept.csv&quot;).map(_.split(&quot;,&quot;)) case class Dept(deptno:Int,dname:String,loc:String) val deptDS = deptRDD.map(x=&gt;Dept(x(0).toInt,x(1),x(2))).toDS 复制代码 复制代码 b. 创建员工表: case class Emp(empno:Int,ename:String,job:String,mgr:String,hiredate:String,sal:Int,comm:String,deptno:Int) val empRDD = sc.textFile(&quot;/XXXX/emp.csv&quot;).map(_.split(&quot;,&quot;)) val empDS = empRDD.map(x =&gt; Emp(x(0).toInt,x(1),x(2),x(3),x(4),x(5).toInt,x(6),x(7).toInt)).toDS 复制代码 c. 执行多表查询：等值链接 val result = deptDS.join(empDS,&quot;deptno&quot;) 另一种写法：注意有三个等号 val result = deptDS.joinWith(empDS,deptDS(&quot;deptno&quot;)=== empDS(&quot;deptno&quot;)) joinWith和join的区别是连接后的新Dataset的schema会不一样 复制代码 &lt;5&gt;. 查看执行计划： result.explain 11. Spark SQL 进阶 (1) 使用数据源 &lt;1&gt;. 什么是parquet文件 Parquet是列式存储格式的一种文件类型，列式存储有以下的核心： 可以跳过不符合条件的数据，只读取需要的数据，降低IO数据量。 压缩编码可以降低磁盘存储空间。由于同一列的数据类型是一样的，可以使用更高效的压缩编码（例如Run Length Encoding和Delta Encoding）进一步节约存储空间。 只读取需要的列，支持向量运算，能够获取更好的扫描性能。 Parquet格式是Spark SQL的默认数据源，可通过spark.sql.sources.default配置 &lt;2&gt;. 使用Load/Save函数 load函数是加载数据，save是存储数据。 e.g.: 读取 users.parquet 文件（Spark自带的示例文件） val userDF = spark.read.load(&quot;/root/users.parquet&quot;) 查看结构： userDF.printSchema 查看内容： userDF.show 读取json文件： val userDF = spark.read.load(&quot;/root/emp.json&quot;) ——&gt;报错 正确方法： val userDF = spark.read.format(&quot;json&quot;).load(&quot;/root/emp.json&quot;) val userDF = spark.read.json(&quot;/root/emp.json&quot;) 保存parquet文件到本地路径： userDF.select($&quot;name&quot;,$&quot;favorite_color&quot;).write.save(&quot;/root/parquet&quot;) 读取刚写入的文件： val userDF1 = spark.read.load(&quot;/root/parquet/part-00000-888d505a-7d51-4a50-aaf5-2bbdb56e67a1.snappy.parquet&quot;) --&gt; 不推荐 生产：（直接读目录） val userDF2 = spark.read.load(&quot;/usr/local/tmp_files/parquet&quot;) 复制代码 关于save函数： 调用save函数的时候，可以指定存储模式，追加、覆盖等等 可以采用SaveMode执行存储操作，SaveMode定义了对数据的处理模式。需要注意的是，这些保存模式不使用任何锁定，不是原子操作。此外，当使用Overwrite方式执行时，在输出新数据之前原数据就已经被删除。SaveMode详细介绍如下表： userDF2.write.save(&quot;/root/parquet&quot;) ——&gt;报错 save的时候覆盖： userDF2.write.mode(&quot;overwrite&quot;).save(&quot;/root/parquet&quot;) 将结果保存成表： userDF2.select($&quot;name&quot;).write.saveAsTable(&quot;table1&quot;) 查看数据： spark.sql(&quot;select * from table2&quot;).show 也可以进行分区、分桶等操作：partitionBy、bucketBy 复制代码 &lt;3&gt;. Parquet文件 Parquet是一个列格式而且用于多个数据处理系统中。Spark SQL提供支持对于Parquet文件的读写，也就是自动保存原始数据的schema。当写Parquet文件时，所有的列被自动转化为nullable，因为兼容性的缘故。 e.g.: 读入json格式的数据，将其转换成parquet格式，并创建相应的表来使用SQL进行查询。（把数据读进来，再写出去，就是Parquet文件） 读入文件： val empDF = spark.read.json(&quot;/root/emp.json&quot;) 写出文件： empDF.write.mode(&quot;overwrite&quot;).save(&quot;/root/parquet&quot;) empDF.write.mode(&quot;overwrite&quot;).parquet(&quot;/root/parquet&quot;) 建表查询： val emp1 = spark.read.parquet(&quot;/root/parquet&quot;) emp1.createOrReplaceTempView(&quot;emp1&quot;) spark.sql(&quot;select * from emp1&quot;).show 复制代码 &lt;4&gt;. Schema的合并： Parquet支持Schema evolution（Schema演变，即：合并）。用户可以先定义一个简单的Schema，然后逐渐的向Schema中增加列描述。通过这种方式，用户可以获取多个有不同Schema但相互兼容的Parquet文件。 e.g.: 通过RDD来创建DataFrame: val df1 = sc.makeRDD(1 to 5).map( i =&gt; (i,i*2)).toDF(&quot;single&quot;,&quot;double&quot;) ——&gt;&quot;single&quot;,&quot;double&quot; 是表结构 df1.show df1.write.mode(&quot;overwrite&quot;).save(&quot;/root/test_table/key=1&quot;) val df2 = sc.makeRDD(6 to 10).map( i =&gt; (i,i*3)).toDF(&quot;single&quot;,&quot;triple&quot;) df2.show df2.write.mode(&quot;overwrite&quot;).save(&quot;/root/test_table/key=2&quot;) 合并两个部分: val df3 = spark.read.parquet(&quot;/root/tmp_files/test_table&quot;) val df3 = spark.read.option(&quot;mergeSchema&quot;,true).parquet(&quot;/root/tmp_files/test_table&quot;) 复制代码 &lt;5&gt;. JSON Datasets Spark SQL能自动解析JSON数据集的Schema，读取JSON数据集为DataFrame格式。读取JSON数据集方法为SQLContext.read().json()。该方法将String格式的RDD或JSON文件转换为DataFrame。 需要注意的是，这里的JSON文件不是常规的JSON格式。JSON文件每一行必须包含一个独立的、自满足有效的JSON对象。如果用多行描述一个JSON对象，会导致读取出错。读取JSON数据集示例如下： 读取Json文件，生成DataFrame: val peopleDF = spark.read.json(&quot;/usr/local/tmp_files/people.json&quot;) 打印Schema结构信息： peopleDF.printSchema 创建临时视图： peopleDF.createOrReplaceTempView(&quot;peopleView&quot;) 执行查询： spark.sql(&quot;select * from peopleView&quot;).show Spark SQL 支持统一的访问接口。对于不同的数据源，读取进来，生成DataFrame后，操作完全一样。 复制代码 &lt;6&gt;. 使用JDBC Spark SQL同样支持通过JDBC读取其他数据库的数据作为数据源。 Spark加载MySQL： spark-shell --master spark://XXXX:7077 --jars /XXXX/.jar --driver-class-path /XXXX/.jar Spark连接MySQL： 方法一： val mysqlDF = spark.read.format(&quot;jdbc&quot;).option(&quot;url&quot;,&quot;jdbc:mysql://XXXX:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;).option(&quot;user&quot;,&quot;root&quot;).option(&quot;password&quot;,&quot;123456&quot;).option(&quot;driver&quot;,&quot;com.mysql.cj.jdbc.Driver&quot;).option(&quot;dbtable&quot;,&quot;emp&quot;).load mysqlDF.show``` 复制代码 方式二：定义一个Properties类 import java.util.Properties val mysqlProps = new Properties() mysqlProps.setProperty(&quot;user&quot;,&quot;root&quot;) mysqlProps.setProperty(&quot;password&quot;,&quot;123456&quot;) val mysqlDF1 = spark.read.jdbc(&quot;jdbc:mysql://XXXX:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;,&quot;emp&quot;,mysqlProps) mysqlDF1.show ``` 复制代码 &lt;7&gt;. 使用Hive Table a. 准备工作： 搭建好Hive的环境（需要Hadoop） 配置Spark SQL支持Hive： 将以下文件拷贝到$SPARK_HOME/conf的目录下，即可 $HIVE_HOME/conf/hive-site.xml $HADOOP_CONF_DIR/core-site.xml $HADOOP_CONF_DIR/hdfs-site.xml 重启Spark b. 使用Spark Shell操作Hive 启动Hadoop、Hive 启动Spark 启动spark-sql的时候，需要使用--jars指定mysql的驱动程序 创建表：spark.sql(&quot;create table spark.emp1(empno Int,ename String,job String,mgr String,hiredate String,sal Int,comm String,deptno Int)row format delimited fields terminated by &#39;,&#39;&quot;) 导入数据：spark.sql(&quot;load data local inpath &#39;/root/emp.csv&#39; overwrite into table spark.emp1&quot;) 查询数据：spark.sql(&quot;select * from spark.emp1&quot;).show (2) 在IDE中开发Spark SQL &lt;1&gt;. 创建DataFrame a. StructType方式 package Demo import org.apache.spark.sql.SparkSession import org.apache.spark.sql.types.StructType import org.apache.spark.sql.types.StructField import org.apache.spark.sql.types.IntegerType import org.apache.spark.sql.types.StringType import org.apache.spark.sql.Row import org.apache.log4j.Logger import org.apache.log4j.Level /*创建DataFrame StructType方式*/ object Demo01 { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) // 创建Spark Session对象 val spark = SparkSession.builder().master(&quot;local&quot;).appName(&quot;Demo1&quot;).getOrCreate() // 从指定的地址创建RDD对象 /*1 Tom 12 *2 Mary 13 *3 Lily 15 * */ val personRDD = spark.sparkContext.textFile(&quot;/Users/apple/Documents/student.txt&quot;).map(_.split(&quot;\t&quot;)) // 通过StructType方式指定Schema val schema = StructType( List( StructField(&quot;id&quot;, IntegerType), StructField(&quot;name&quot;, StringType), StructField(&quot;age&quot;, IntegerType))) // 将RDD映射到rowRDD上，映射到Schema上 val rowRDD = personRDD.map(p =&gt; Row(p(0).toInt, p(1), p(2).toInt)) val personDataFrame = spark.createDataFrame(rowRDD, schema) // 注册视图 personDataFrame.createOrReplaceTempView(&quot;t_person&quot;) //执行SQL语句 val df = spark.sql(&quot;select * from t_person order by age desc&quot;) df.show() spark.stop() } 复制代码 }复制代码 b. case Class方式 package Demo import org.apache.spark.sql.SparkSession import org.apache.spark.sql.types.StructType import org.apache.spark.sql.types.StructField import org.apache.spark.sql.types.IntegerType import org.apache.spark.sql.types.StringType import org.apache.spark.sql.Row import org.apache.log4j.Logger import org.apache.log4j.Level /*使用case Class来创建DataFrame*/ object Demo02 { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建Spark Session对象 val spark = SparkSession.builder().master(&quot;local&quot;).appName(&quot;Demo2&quot;).getOrCreate() //从指定的地址创建RDD对象 val lineRDD = spark.sparkContext.textFile(&quot;&quot;).map(_.split(&quot;\t&quot;)) //把数据与case class做匹配 val studentRDD = lineRDD.map(x =&gt; Student(x(0).toInt, x(1), x(2).toInt)) //生成DataFrame import spark.sqlContext.implicits._ val studentDF = studentRDD.toDF //注册视图 执行SQL studentDF.createOrReplaceTempView(&quot;student&quot;) spark.sql(&quot;select * from student&quot;).show spark.stop() } } //定义case class case class Student(stuId: Int, stuName: String, stuAge: Int) 复制代码 &lt;2&gt;. 写入MySQL package Demo import org.apache.spark.sql.SparkSession import org.apache.spark.sql.types.StructType import org.apache.spark.sql.types.StructField import org.apache.spark.sql.types.IntegerType import org.apache.spark.sql.types.StringType import org.apache.spark.sql.Row import org.apache.log4j.Logger import org.apache.log4j.Level import java.util.Properties /*写入MySQL*/ object Demo03 { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建Spark Session对象 val spark = SparkSession.builder().master(&quot;local&quot;).appName(&quot;Demo3&quot;).getOrCreate() //从指定的地址创建RDD对象 val lineRDD = spark.sparkContext.textFile(&quot;&quot;).map(_.split(&quot;\t&quot;)) //通过StructType方式指定Schema val schema = StructType( List( //字段与MySQL表中字段对应一致 StructField(&quot;personID&quot;, IntegerType), StructField(&quot;personName&quot;, StringType), StructField(&quot;personAge&quot;, IntegerType))) //将RDD映射到rowRDD上，映射到Schema上 val rowRDD = lineRDD.map(p =&gt; Row(p(0).toInt,p(1),p(2).toInt)) val personDataFrame = spark.createDataFrame(rowRDD, schema) personDataFrame.createOrReplaceTempView(&quot;myperson&quot;) val result = spark.sql(&quot;select * from myperson&quot;) result.show() //把结果存入到mysql中 val props = new Properties() props.setProperty(&quot;user&quot;, &quot;root&quot;) props.setProperty(&quot;password&quot;, &quot;123456&quot;) //append追加模式 result.write.mode(&quot;append&quot;).jdbc(&quot;jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;student&quot;, props) spark.stop() } } 复制代码 &lt;3&gt;. 使用Spark SQL 读取Hive中的数据，将计算结果存入mysql package Demo import org.apache.spark.sql.SparkSession import java.util.Properties /*使用Spark SQL 读取Hive中的数据，将计算结果存入mysql*/ //命令：./bin/spark-submit --master spark://node3:7077 --jars /usr/local/tmp_files/mysql-connector-java-8.0.11.jar --driver-class-path /usr/local/tmp_files/mysql-connector-java-8.0.11.jar --class day0410.Demo4 /usr/local/tmp_files/Demo4.jar object Demo4 { def main(args: Array[String]): Unit = { //创建SparkSession val spark = SparkSession.builder().appName(&quot;Demo4&quot;).enableHiveSupport().getOrCreate() //执行SQL val result = spark.sql(&quot;select deptno,count(1) from company.emp group by deptno&quot;) //将结果保存到mysql中 val props = new Properties() props.setProperty(&quot;user&quot;, &quot;root&quot;) props.setProperty(&quot;password&quot;, &quot;123456&quot;) result.write.mode(&quot;append&quot;).jdbc(&quot;jdbc:mysql://192.168.109.1:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;emp_stat&quot;, props) spark.stop() } } 复制代码 (3) Spark SQL 性能优化 &lt;1&gt;. 在内存中缓存数据 直接读取内存的值来提高性能。 通过spark.cacheTable(&quot;tableName&quot;)或者dataFrame.cache()。使用spark.uncacheTable(&quot;tableName&quot;)来从内存中去除table。 e.g.： 操作mysql，启动spark shell 时，需要： ./bin/spark-shell --master spark://node3:7077 --jars /usr/local/tmp_files/mysql-connector-java-8.0.11.jar --driver-class-path /usr/local/tmp_files/mysql-connector-java-8.0.11.jar val mysqlDF = spark.read.format(&quot;jdbc&quot;).option(&quot;driver&quot;,&quot;com.mysql.jdbc.Driver&quot;).option(&quot;url&quot;,&quot;jdbc:mysql://192.168.109.1:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;).option(&quot;user&quot;,&quot;root&quot;).option(&quot;password&quot;,&quot;123456&quot;).option(&quot;dbtable&quot;,&quot;emp&quot;).load mysqlDF.show mysqlDF.createOrReplaceTempView(&quot;emp&quot;) spark.sqlContext.cacheTable(&quot;emp&quot;) ----&gt; 标识这张表可以被缓存，数据还没有真正被缓存 spark.sql(&quot;select * from emp&quot;).show ----&gt; 依然读取mysql spark.sql(&quot;select * from emp&quot;).show ----&gt; 从缓存中读取数据 spark.sqlContext.clearCache 清空缓存后，执行查询，会触发查询mysql数据库。 复制代码 &lt;2&gt;. 性能优化相关参数 a. 将数据缓存到内存中的相关优化参数： spark.sql.inMemoryColumnarStorage.compressed 默认为 true Spark SQL 将会基于统计信息自动地为每一列选择一种压缩编码方式。 spark.sql.inMemoryColumnarStorage.batchSize 默认值：10000 缓存批处理大小。缓存数据时, 较大的批处理大小可以提高内存利用率和压缩率，但同时也会带来 OOM（Out Of Memory）的风险。 b. 其他性能相关的配置选项（不过不推荐手动修改，可能在后续版本自动的自适应修改） spark.sql.files.maxPartitionBytes 默认值：128 MB 读取文件时单个分区可容纳的最大字节数 spark.sql.files.openCostInBytes 默认值：4M 打开文件的估算成本, 按照同一时间能够扫描的字节数来测量。当往一个分区写入多个文件的时候会使用。高估更好, 这样的话小文件分区将比大文件分区更快 (先被调度)。 spark.sql.autoBroadcastJoinThreshold 默认值：10M 用于配置一个表在执行 join 操作时能够广播给所有 worker 节点的最大字节大小。通过将这个值设置为 -1 可以禁用广播。注意，当前数据统计仅支持已经运行了 ANALYZE TABLE COMPUTE STATISTICS noscan 命令的 Hive Metastore 表。 spark.sql.shuffle.partitions 默认值：200 用于配置 join 或聚合操作混洗（shuffle）数据时使用的分区数。 12. 认识 Spark Streaming (1) Spark Streaming 简介 流式计算框架（类似于Storm） 常用的实时计算引擎（流式计算） &lt;1&gt;. Apache Storm：真正的流式计算 &lt;2&gt;. Spark Streaming ：严格上来说不是真正的流式计算（实时计算），把连续的流式数据，当成不连续的RDD，本质是一个离散计算（不连续） &lt;3&gt;. Apache Flink：真正的流式计算，与Spark Streaming相反， 把离散的数据，当成流式数据来处理 &lt;4&gt;. JStorm Spark Streaming makes it easy to build scalable fault-tolerant streaming applications.（易于构建灵活的、高容错的流式系统） Spark Streaming是核心Spark API的扩展，可实现可扩展、高吞吐量、可容错的实时数据流处理。数据可以从诸如Kafka，Flume，Kinesis或TCP套接字等众多来源获取，并且可以使用由高级函数（如map，reduce，join和window）开发的复杂算法进行流数据处理。最后，处理后的数据可以被推送到文件系统，数据库和实时仪表板。而且，还可以在数据流上应用Spark提供的机器学习和图处理算法。 (2) Spark Streaming 的特点 &lt;1&gt;. 易用，已经集成到Spark中 &lt;2&gt;. 容错性：底层RDD，RDD本身具有容错机制 &lt;3&gt;. 支持多种语言：Java Scala Python (3) Spark Streaming的内部结构 在内部，它的工作原理如下。Spark Streaming接收实时输入数据流，并将数据切分成批，然后由Spark引擎对其进行处理，最后生成“批”形式的结果流。 Spark Streaming将连续的数据流抽象为discretizedstream或DStream。在内部DStream 由一个RDD序列表示。 13. Spark Streaming 基础 (1) Spark Streaming 官方示例 &lt;1&gt;. 介绍： 向Spark Streaming中发送字符串，Spark 接收到以后进行计数 &lt;2&gt;. 准备工作： netcat网络工具（yum install nc.x86_64） **注意：**总核数大于等于2，一个核心用于接收数据，另一个用于处理数据 &lt;3&gt;. 操作： 启动同一Linux系统的两个窗口，一个负责输入，一个负责监听 窗口1：nc -l 1234 （-l监听模式；1234端口号） 窗口2：run-example streaming.NetworkWordCount localhost 1234 在窗口1输入文本信息，窗口2监听并进行计数统计 (2) 自写 Spark Streaming 官方示例 MyNetworkWordCount.scala /** * * @ClassName: MyNetworkWordCount * @Description * @Author: YBCarry * @Date2019-05-13 20:49 * @Version: V1.0 * **/ import org.apache.spark.streaming.StreamingContext import org.apache.spark.SparkConf import org.apache.spark.streaming.Seconds import org.apache.spark.storage.StorageLevel import org.apache.log4j.Logger import org.apache.log4j.Level import org.apache.spark.internal.Logging /* * 自写流式计算程序 * * 知识点： * 1、创建一个StreamingContext对象 --&gt; 核心：创建一个DStream * 2、DStream的表现形式：就是一个RDD * 3、使用DStream把连续的数据流变成不连续的RDD * * spark Streaming 最核心的内容 */ object MyNetworkWordCount { def main(args: Array[String]): Unit = { //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyNetworkWordCount&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //创建DStream 从netcat服务器上接收数据 val lines = ssc.socketTextStream(&quot;172.16.194.128&quot;, 1234, StorageLevel.MEMORY_ONLY) //lines中包含了netcat服务器发送过来的数据 //分词操作 val words = lines.flatMap(_.split(&quot; &quot;)) //计数 val wordPair = words.transform(x =&gt; x.map(x =&gt; (x, 1))) //打印结果 wordPair.print() //启动StreamingContext 进行计算 ssc.start() //等待任务结束 ssc.awaitTermination() } } 复制代码 14. Spark Streaming 进阶 (1) StreamingContext对象详解 初始化StreamingContext： 方式一：从SparkConf对象中创建： 方式二：从一个现有的SparkContext实例中创建 程序中的几点说明： appName参数是应用程序在集群UI上显示的名称。 master是Spark，Mesos或YARN集群的URL，或者一个特殊的“local [*]”字符串来让程序以本地模式运行。 当在集群上运行程序时，不需要在程序中硬编码master参数，而是使用spark-submit提交应用程序并将master的URL以脚本参数的形式传入。但是，对于本地测试和单元测试，您可以通过“local[*]”来运行Spark Streaming程序（请确保本地系统中的cpu核心数够用）。 StreamingContext会内在的创建一个SparkContext的实例（所有Spark功能的起始点），你可以通过ssc.sparkContext访问到这个实例。 批处理的时间窗口长度必须根据应用程序的延迟要求和可用的集群资源进行设置。 注意： 一旦一个StreamingContextt开始运作，就不能设置或添加新的流计算。 一旦一个上下文被停止，它将无法重新启动。 同一时刻，一个JVM中只能有一个StreamingContext处于活动状态。 StreamingContext上的stop()方法也会停止SparkContext。 要仅停止StreamingContext（保持SparkContext活跃），请将stop() 方法的可选参数stopSparkContext设置为false。 只要前一个StreamingContext在下一个StreamingContext被创建之前停止（不停止SparkContext），SparkContext就可以被重用来创建多个StreamingContext。 (2) 离散流（DStreams）：Discretized Streams 把连续的数据变成不连续的RDD 因为DStream的特性，导致，Spark Streaming不是真正的流式计算 DiscretizedStream或DStream 是Spark Streaming对流式数据的基本抽象。它表示连续的数据流，这些连续的数据流可以是从数据源接收的输入数据流，也可以是通过对输入数据流执行转换操作而生成的经处理的数据流。在内部，DStream由一系列连续的RDD表示，如下图： 举例分析：在之前的NetworkWordCount的例子中，我们将一行行文本组成的流转换为单词流，具体做法为：将flatMap操作应用于名为lines的DStream中的每个RDD上，以生成words DStream的RDD。如下图所示： 但是DStream和RDD也有区别，下面画图说明： (3) 转换操作（transformation） transform(func) 通过RDD-to-RDD函数作用于源DStream中的各个RDD，可以是任意的RDD操作，从而返回一个新的RDD 举例：在NetworkWordCount中，也可以使用transform来生成元组对 updateStateByKey(func) 操作允许不断用新信息更新它的同时保持任意状态。 定义状态：状态可以是任何的数据类型 定义状态更新函数：怎样利用更新前的状态和从输入流里面获取的新值更新状态 重写NetworkWordCount程序，累计每个单词出现的频率（注意：累计） TotalNetworkWordCount.scala package test.Network import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.storage.StorageLevel import org.apache.spark.streaming.{Seconds, StreamingContext} /** * * @ClassName: TotalNetworkWordCount * @Description: 实现累加操作 * @Author: YBCarry * @Date2019-05-15 16:05 * @Version: V1.0 * **/ object TotalNetworkWordCount { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyNetworkWordCount&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //设置检查点目录，保存之前都的状态信息 ssc.checkpoint(&quot;&quot;) //创建DStream val lines = ssc.socketTextStream(&quot;bigdata01&quot;, 1234, StorageLevel.MEMORY_ONLY) //分割 val words = lines.flatMap(_.split(&quot; &quot;)) //计数 // val wordPair = words.map((_, 1)) val wordPair = words.transform( x =&gt; x.map(x =&gt; (x, 1))) //定义一个值函数 ；累加计数 /* * 接收两个参数 * currentValues —— 当前值 * previousValue ——历史值 * */ val addFunc = (currentValues : Seq[Int], previousValues : Option[Int]) =&gt; { //累加当前的序列 val currrentTotal = currentValues.sum //累加历史值 Some(currrentTotal + previousValues.getOrElse(0)) } //累加运算 val total = wordPair.updateStateByKey(addFunc) total.print() ssc.start() ssc.awaitTermination() } } 复制代码 复制代码 (4) 窗口操作 Spark Streaming还提供了窗口计算功能，允许在数据的滑动窗口上应用转换操作。下图说明了滑动窗口的工作方式： 如图所示，每当窗口滑过originalDStream时，落在窗口内的源RDD被组合并被执行操作以产生windowed DStream的RDD。在上面的例子中，操作应用于最近3个时间单位的数据，并以2个时间单位滑动。这表明任何窗口操作都需要指定两个参数。 窗口长度（windowlength） - 窗口的时间长度（上图的示例中为：3）。 滑动间隔（slidinginterval） - 两次相邻的窗口操作的间隔（即每次滑动的时间长度）（上图示例中为：2）。 这两个参数必须是源DStream的批间隔的倍数（上图示例中为：1）。 e.g.: 假设对之前的单词计数的示例进行扩展，每10秒钟对过去30秒的数据进行wordcount。则在最近30秒的pairs DStream数据中对(word, 1)键值对应用reduceByKey操作。这是通过使用reduceByKeyAndWindow操作完成的。 package test.NetworkByWindow import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.storage.StorageLevel import org.apache.spark.streaming.{Seconds, StreamingContext} /** * * @ClassName: NetworkWordCountByWindow * @Description: 每10秒读取过去30秒的数据 * @Author: YBCarry * @Date2019-05-15 17:00 * @Version: V1.0 * **/ object NetworkWordCountByWindow { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyNetworkWordCount&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //设置检查点目录，保存之前都的状态信息 ssc.checkpoint(&quot;&quot;) //创建DStream val lines = ssc.socketTextStream(&quot;bigdata01&quot;, 1234, StorageLevel.MEMORY_ONLY) //分割 每个单词计数 val words = lines.flatMap(_.split(&quot; &quot;)).map((_, 1)) /* * 窗口操作 * 参数说明：要进行的操作 窗口的大小(30s) 窗口移动距离(12s) ——&gt; 采样时间(3)的整数倍 * */ val result = words.reduceByKeyAndWindow((x : Int, y : Int) =&gt; (x + y), Seconds(30), Seconds(12)) } } 复制代码 15. Spark 数据源 (1) 输入DStreams和接收器 输入DStreams表示从数据源获取输入数据流的DStreams。在NetworkWordCount例子中，lines表示输入DStream，它代表从netcat服务器获取的数据流。每一个输入流DStream和一个Receiver对象相关联，这个Receiver从源中获取数据，并将数据存入内存中用于处理。 输入DStreams表示从数据源获取的原始数据流。Spark Streaming拥有两类数据源： 基本源（Basic sources）：这些源在StreamingContext API中直接可用。例如文件系统、套接字连接、Akka的actor等 高级源（Advanced sources）：这些源包括Kafka,Flume,Kinesis,Twitter等等。 下面通过具体的案例，详细说明： (2) 基本源 &lt;1&gt;. 文件流：通过监控文件系统的变化，若有新文件添加，则将它读入并作为数据流 注意： ① 这些文件具有相同的格式 ② 这些文件通过原子移动或重命名文件的方式在dataDirectory创建 ③ 如果在文件中追加内容，这些追加的新数据也不会被读取。 Spark Streaming监控一个文件夹，如果有变化，则把变化采集过来 import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.streaming.{Seconds, StreamingContext} /** * * @ClassName: FileStreaming * @Description * @Author: YBCarry * @Date2019-05-16 09:24 * @Version: V1.0 * **/ object FileStreaming { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyFileStreaming&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(10)) //监控目录，读取产生的新文件 val lines = ssc.textFileStream(&quot;\\Users\\apple\\学习\\SparkFiles&quot;) lines.print() ssc.start() ssc.awaitTermination() } } 复制代码 注意：需要在原文件中编辑，然后拷贝一份。 &lt;2&gt;. RDD队列流 使用streamingContext.queueStream(queueOfRDD)创建基于RDD队列的DStream，用于调试Spark Streaming应用程序。 package test.RDDQueue import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.rdd.RDD import org.apache.spark.streaming.{Seconds, StreamingContext} import scala.collection.mutable.Queue /** * * @ClassName: RDDQueueStream * @Description: RDD队列流 * @Author: YBCarry * @Date2019-05-16 10:48 * @Version: V1.0 * **/ object RDDQueueStream { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyRDDQueueStream&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //创建队列 RDD[Int] val rddQueue = new Queue[RDD[Int]]() //向队列里添加数据 (创建数据源) for (i &lt;- 1 to 3) { rddQueue += ssc.sparkContext.makeRDD(1 to 10) //便于观察 Thread.sleep(1000) } //从队列中接收数据，创建DStream val inputDStream = ssc.queueStream(rddQueue) //处理数据 val result = inputDStream.map(x =&gt; (x, x * 2)) result.print() ssc.start() ssc.awaitTermination() } } 复制代码 &lt;3&gt;. 套接字流：通过监听Socket端口来接收数据 (3) 高级源 &lt;1&gt;. Spark Streaming接收Flume数据 a. 基于Flume的Push模式: Flume被用于在Flume agents之间推送数据，在这种方式下，Spark Streaming可以很方便的建立一个receiver，起到一个Avro agent的作用。Flume可以将数据推送到改receiver。 以下为配置步骤： **第一步：**Flume的配置文件 MyFlumeStream01.conf #定义agent名， source、channel、sink的名称 a4.sources = r1 a4.channels = c1 a4.sinks = k1 #具体定义source a4.sources.r1.type = spooldir a4.sources.r1.spoolDir = /usr/local/tmp_files/logs #具体定义channel a4.channels.c1.type = memory a4.channels.c1.capacity = 10000 a4.channels.c1.transactionCapacity = 100 #具体定义sink a4.sinks = k1 a4.sinks.k1.type = avro a4.sinks.k1.channel = c1 a4.sinks.k1.hostname = bigdata01 a4.sinks.k1.port = 1234 #组装source、channel、sink a4.sources.r1.channels = c1 a4.sinks.k1.channel = c1 复制代码 **第二步：**Spark Streaming程序 package test.Flume import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.streaming.flume.FlumeUtils import org.apache.spark.streaming.{Seconds, StreamingContext} /** * * @ClassName: MyFlumeStream * @Description: flume将数据推送给Spark Streaming 使用push * @Author: YBCarry * @Date2019-05-16 14:01 * @Version: V1.0 * **/ object MyFlumeStream01 { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyRDDQueueStream&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //对接Flume //创建一个Flumeevent从flume中接收puch来的数据（也是DStream） //flume将数据push到localhost:1234，Spark Stream在这里监听 val flumeEventDStream = FlumeUtils.createStream(ssc, &quot;bigdata01&quot;, 1234) //将Flumeevent中的事件转换成字符串 val lineDStream = flumeEventDStream.map(e =&gt; { new String(e.event.getBody.array) }) //输出结果 lineDStream.print() ssc.start() ssc.awaitTermination() } } 复制代码 **第三步：**测试 启动Flume flume-ng agent -n a4 -f Spark/MyFlumeStream01.conf -c conf -Dflume.root.logger=INFO,console 启动Spark Streaming程序 拷贝日志文件到/root/training/logs目录 观察输出，采集到数据 b. 基于Custom Sink的Pull模式 不同于Flume直接将数据推送到Spark Streaming中，第二种模式通过以下条件运行一个正常的Flume sink。Flume将数据推送到sink中，并且数据保持buffered状态。Spark Streaming使用一个可靠的Flume接收器和转换器从sink拉取数据。只要当数据被接收并且被Spark Streaming备份后，转换器才运行成功。 这样,与第一种模式相比，保证了很好的健壮性和容错能力，这种模式需要为Flume配置一个正常的sink。 以下为配置步骤： **第一步：**Flume的配置文件 FlumeLogPull.conf a1.channels = c1 a1.sinks = k1 a1.sources = r1 a1.sources.r1.type = spooldir a1.sources.r1.spoolDir = /usr/local/tmp_files/logs a1.channels.c1.type = memory a1.channels.c1.capacity = 100000 a1.channels.c1.transactionCapacity = 100000 a1.sinks.k1.type = org.apache.spark.streaming.flume.sink.SparkSink a1.sinks.k1.channel = c1 a1.sinks.k1.hostname = bigdata01 a1.sinks.k1.port = 1234 #组装source、channel、sink a1.sources.r1.channels = c1 a1.sinks.k1.channel = c1 复制代码 **第二步：**Spark Streaming程序 复制代码 package test.Flume import org.apache.spark.streaming.StreamingContext import org.apache.spark.SparkConf import org.apache.spark.streaming.Seconds import org.apache.spark.storage.StorageLevel import org.apache.log4j.Logger import org.apache.log4j.Level import org.apache.spark.streaming.flume.FlumeUtils /** * @ClassName: FlumePutSink @Description: 测试pull方式 使用Spark sink @Author: YBCarry @Date2019-05-16 15:23 @Version: V1.0 **/ object FlumeLogPull { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;FlumeLogPull&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf,Seconds(3)) //创建FlumeEvent的DStream，采用pull的方式 val flumeEvent = FlumeUtils.createPollingStream(ssc, &quot;172.16.194.128&quot;,1234, StorageLevel.MEMORY_ONLY) //将FlumeEvent的事件准换成字符串 val lineDStream = flumeEvent.map( e =&gt; { new String(e.event.getBody.array) }) //输出结果 lineDStream.print() ssc.start() ssc.awaitTermination() } 复制代码 } 复制代码 **第三步：**需要的jar包 将spark-streaming-flume-sink_2.11-2.1.0.jar拷贝到Flume的lib目录下。 **第四步：**测试 启动Flume 启动Spark Streaming程序 将测试数据拷贝到/root/training/logs 观察输出 16. Spark 性能优化 (1) 概述 Spark的计算本质是分布式计算，所以，Spark程序的性能可能因为集群中的任何因素出现瓶颈：CPU、网络带宽、或者内存。如果在持久化RDD的时候，持久化了大量的数据，那么Java虚拟机的垃圾回收就可能成为一个瓶颈。Java虚拟机会定期进行垃圾回收，此时会追踪所有Java对象，并且在垃圾回收时，找到那些已经不再使用的对象。 核心：清理旧对象，给新对象腾出空间。垃圾回收的性能开销，是与内存中的对象数量成正比。 (2) spark内存分配 (3) Spark GC原理 (4) 减少批数据的执行时间 在Spark中有几个优化可以减少批处理的时间： &lt;1&gt;. 减少批数据的执行时间 在Spark中有几个优化可以减少批处理的时间： ① 数据接收的并行水平 通过网络(如kafka，flume，socket等)接收数据需要这些数据反序列化并被保存到Spark中。如果数据接收成为系统的瓶颈，就要考虑并行地接收数据。注意，每个输入DStream创建一个receiver（运行在worker机器上）接收单个数据流。创建多个输入DStream并配置它们可以从源中接收不同分区的数据流，从而实现多数据流接收。例如，接收两个topic数据的单个输入DStream可以被切分为两个kafka输入流，每个接收一个topic。这将在两个worker上运行两个receiver，因此允许数据并行接收，提高整体的吞吐量。多个DStream可以被合并生成单个DStream，这样运用在单个输入DStream的transformation操作可以运用在合并的DStream上。 ② 数据处理的并行水平 如果运行在计算stage上的并发任务数不足够大，就不会充分利用集群的资源。默认的并发任务数通过配置属性来确定spark.default.parallelism。 ③ 数据序列化 可以通过改变序列化格式来减少数据序列化的开销。在流式传输的情况下，有两种类型的数据会被序列化： 输入数据 由流操作生成的持久RDD 在上述两种情况下，使用Kryo序列化格式可以减少CPU和内存开销。 (5) 设置正确的批容量 为了Spark Streaming应用程序能够在集群中稳定运行，系统应该能够以足够的速度处理接收的数据（即处理速度应该大于或等于接收数据的速度）。这可以通过流的网络UI观察得到。批处理时间应该小于批间隔时间。 根据流计算的性质，批间隔时间可能显著的影响数据处理速率，这个速率可以通过应用程序维持。可以考虑WordCountNetwork这个例子，对于一个特定的数据处理速率，系统可能可以每2秒打印一次单词计数（批间隔时间为2秒），但无法每500毫秒打印一次单词计数。所以，为了在生产环境中维持期望的数据处理速率，就应该设置合适的批间隔时间(即批数据的容量)。 找出正确的批容量的一个好的办法是用一个保守的批间隔时间（5-10,秒）和低数据速率来测试你的应用程序。 (6) 内存调优 介绍几个比较推荐的自定义选项，它们可以减少Spark Streaming应用程序垃圾回收的相关暂停，获得更稳定的批处理时间。 **Default persistence level of DStreams：**和RDDs不同的是，默认的持久化级别是序列化数据到内存中（DStream是StorageLevel.MEMORY_ONLY_SER，RDD是StorageLevel.MEMORY_ONLY）。即使保存数据为序列化形态会增加序列化/反序列化的开销，但是可以明显的减少垃圾回收的暂停。 **Clearing persistent RDDs：**默认情况下，通过Spark内置策略（LUR），Spark Streaming生成的持久化RDD将会从内存中清理掉。如果spark.cleaner.ttl已经设置了，比这个时间存在更老的持久化RDD将会被定时的清理掉。正如前面提到的那样，这个值需要根据Spark Streaming应用程序的操作小心设置。然而，可以设置配置选项spark.streaming.unpersist为true来更智能的去持久化（unpersist）RDD。这个配置使系统找出那些不需要经常保有的RDD，然后去持久化它们。这可以减少Spark RDD的内存使用，也可能改善垃圾回收的行为。 **Concurrent garbage collector：**使用并发的标记-清除垃圾回收可以进一步减少垃圾回收的暂停时间。尽管并发的垃圾回收会减少系统的整体吞吐量，但是仍然推荐使用它以获得更稳定的批处理时间。 (7) shuffle原理 &lt;1&gt;. 优化前 &lt;2&gt;. 优化后 17. Spark MLlib库 (1) 概述 MLlib is Apache Spark&#39;s scalable machine learning library.(MLlib 是 Spark 支持 Scala 的可以扩展的机器学习库。) Spark在机器学习方面具有得天独厚的有事，有以下几个原因： &lt;1&gt;. 机器学习算法一般都有多个步骤迭代计算，需要在多次迭代后，获得足够小的误差或者收敛才会停止。 e.g.: double wucha = 1.0 while ( wucha &gt;= 0.00001 ) { 建模 wucha -= 某个值 } 模型计算完毕 复制代码 当迭代使用Hadoop的MapReduce计算框架时，每次都要读写硬盘以及任务启动工作，导致很大的IO开销。而Spark基于内存的计算模型天生擅长迭代计算，只有在必要时，才会读写硬盘，所以Spark是机器学习比较理想的平台。 &lt;2&gt;. 通信角度 Hadoop的MapReduce计算框架通过heartbeat方式来进行通信和传递数据，执行速度慢。 Spark有高效的Akka和Netty通信系统，通信效率高。 SPark MLlib 是Spark 对常用的机器学习算法的实现库，同时包括相关测试和数据生成器。 (2) 什么是机器学习 &lt;1&gt;. 定义 A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E。 机器学习(Machine Learning, ML)是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。（通过算法使计算机能够模拟人类的判别能力） **三个关键词：**算法、经验、模型评价 **应用：**金融反欺诈、语音识别、自然语言处理、翻译、模式识别、智能控制等等。 &lt;2&gt;. 机器学习工作流程 在数据的基础上，通过算法构建出模型，并进行评价 如果达到要求，则用该模型测试其他数据 如果不达到要求，要调整算法来重新建立模型，再次进行评估 循环往复，直到获得满意的经验 &lt;3&gt;. 基于大数据的机器学习 传统的机器学习算法，由于技术和单机存储的限制，依赖于数据抽样，只能在少量数据上使用。所以存在的问题是很难做好随机，从而导致学习的模型不准确。 在大数据上进行机器学习，可以直接处理全量数据并进行大量迭代计算。Spark本身计算优势，适合机器学习。此外spark-shell、pyspark都可以提供及时查询工具。 (3) MLlib MLlib是Spark机器学习库，简化机器学习的工程实践工作，方便扩展到更大规模。集成了通用的学习算法：分类、回归、聚类、协同过滤、降维等等。另外，MLlib本身在Spark中，数据清洗、SQL、建模放在一起。 转载于:https://juejin.im/post/5cd16c00e51d453a51433062" />
<meta property="og:description" content="原文链接： https://juejin.im/post/5cd16c00e51d453a51433062 Linux环境Spark安装配置及使用 1. 认识Spark (1) Spark介绍 大数据计算引擎 官网：spark.apache.org/ 官方介绍：Apache Spark™ is a unified analytics engine for large-scale data processing.（Apache Spark™是一个用于大规模数据处理的统一分析引擎。） Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab，2010年开源，2013年6月成为Apache孵化项目，2014年2月成为Apache顶级项目。目前，Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、Spark Streaming、GraphX、MLlib等子项目，Spark是基于内存计算的大数据并行计算框架。Spark基于内存计算，提高了在大数据环境下数据处理的实时性，同时保证了高容错性和高可伸缩性，允许用户将Spark部署在大量廉价硬件之上，形成集群。 Spark生态圈： Spark Core：RDD（弹性分布式数据集） Spark SQL Spark Streaming Spark MLLib：协同过滤，ALS，逻辑回归等等 --&gt; 机器学习 Spark Graphx：图计算 (2) 为什么要学习Spark Hadoop的MapReduce计算模型存在的问题： MapReduce的核心是Shuffle（洗牌）。在整个Shuffle的过程中，至少会产生6次的I/O。 中间结果输出：基于MapReduce的计算引擎通常会将中间结果输出到磁盘上，进行存储和容错。另外，当一些查询（如：Hive）翻译到MapReduce任务时，往往会产生多个Stage（阶段），而这些串联的Stage又依赖于底层文件系统（如HDFS）来存储每一个Stage的输出结果，而I/O的效率往往较低，从而影响了MapReduce的运行速度。 Spark的最大特点：基于内存 Spark是MapReduce的替代方案，而且兼容HDFS、Hive，可融入Hadoop的生态系统，弥补MapReduce的不足。 (3) Spark的特点：快、易用、通用、兼容 快——与Hadoop的MapReduce相比，Spark基于内存的运算速度要快100倍以上，即使，Spark基于硬盘的运算也要快10倍。Spark实现了高效的DAG执行引擎，从而可以通过内存来高效处理数据流。 易用——Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的shell，可以非常方便地在这些shell中使用Spark集群来验证解决问题的方法。 通用——Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。Spark统一的解决方案非常具有吸引力，毕竟任何公司都想用统一的平台去处理遇到的问题，减少开发和维护的人力成本和部署平台的物力成本。另外Spark还可以很好的融入Hadoop的体系结构中可以直接操作HDFS，并提供Hive on Spark、Pig on Spark的框架集成Hadoop。 兼容——Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和ApacheMesos作为它的资源管理和调度器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase和Cassandra等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力。Spark也可以不依赖于第三方的资源管理和调度器，它实现了Standalone作为其内置的资源管理和调度框架，这样进一步降低了Spark的使用门槛，使得所有人都可以非常容易地部署和使用Spark。此外，Spark还提供了在EC2上部署Standalone的Spark集群的工具。 2. Spark体系架构 Spark的运行方式 Yarn Standalone：本机调试（demo） Worker(从节点)：每个服务器上，资源和任务的管理者，只负责管理一个节点。 执行过程： 一个Worker 有多个 Executor。 Executor是任务的执行者，按阶段（stage）划分任务。—&gt; RDD 客户端：Driver Program 提交任务到集群中。 spark-submit spark-shell 3. Spark-2.1.0安装流程 (1) 准备工作 具备java环境 配置主机名 配置免密码登录 防火墙关闭 (2) 解压spark-2.1.0-bin-hadoop2.7.tgz安装包到目标目录下： tar -zxvf .tar.gz -C 目标目录 (3) 为后续方便，重命名Spark文件夹： mv spark-2.1.0-bin-hadoop2.7/ spark-2.1.0 (4) Spark目录介绍 bin —— Spark操作命令 conf —— 配置文件 data —— Spark测试文件 examples —— Spark示例程序 jars LICENSE licenses NOTICE python R README.md RELEASE sbin —— Spark集群命令 yarn —— Spark-yarn配置 (5) 修改配置文件： &lt;1&gt;. 配置spark-env.sh： 进入spark-2.1.0/conf路径，重命名配置文件： mv spark-env.sh.template spark-env.sh 修改spark-env.sh信息： vi spark-env.sh export JAVA_HOME=/opt/module/jdk1.8.0_144 export SPARK_MASTER_HOST=bigdata01 export SPARK_MASTER_PORT=7077 复制代码 &lt;2&gt;. 配置slaves： 进入spark-2.1.0/conf路径，重命名配置文件： mv slaves.template slaves 修改slaves信息： vi slaves bigdata02 bigdata03 复制代码 (6) 配置环境变量： 修改配置文件： vi /etc/profile 增加以下内容： export SPARK_HOME=spark安装路径 export PATH=$PATH:$SPARK_HOME/bin export PATH=$PATH:$SPARK_HOME/sbin 声明环境变量： source /etc/profile (6) 集群配置： 拷贝配置好的spark到其他机器上 scp -r spark-2.1.0/ bigdata02:$PWD scp -r spark-2.1.0/ bigdata03:$PWD (7) 启动： 启动主节点： start-master.sh 启动从节点： start-slaves.sh 启动shell： spark-shell 通过网页端查看： http://bigdata01:8080/ Spark中内置有Tomcat，故端口号默认为8080 (8) 关闭： 关闭主节点： stop-master.sh 关闭从节点： stop-slaves.sh 4. Spark HA的实现 (1) 基于文件系统的单点恢复 主要用于开发或测试环境。 当spark提供目录保存spark Application和worker的注册信息，并将他们的恢复状态写入该目录中，一旦Master发生故障，就可以通过重新启动Master进程（sbin/start-master.sh），恢复已运行的spark Application和worker的注册信息。 基于文件系统的单点恢复，主要是在spark-env.sh里对SPARK_DAEMON_JAVA_OPTS设置 创建存放文件夹：mkdir /opt/module/spark-2.1.0/recovery 修改配置信息： vi spark-env.sh 增加内容：export SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=FILESYSTEM -Dspark.deploy.recoveryDirectory=/opt/module/spark-2.1.0/recovery&quot; (2) 基于Zookeeper的Standby Masters 适用于现实生产。 ZooKeeper提供了一个Leader Election机制，利用这个机制可以保证虽然集群存在多个Master，但是只有一个是Active的，其他的都是Standby。当Active的Master出现故障时，另外的一个Standby Master会被选举出来。由于集群的信息，包括Worker，Driver和Application的信息都已经持久化到ZooKeeper，因此在切换的过程中只会影响新Job的提交，对于正在进行的Job没有任何的影响。加入ZooKeeper的集群整体架构如下图所示： 修改配置信息： vi spark-env.sh 增加内容：export SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=bigdata01:2181,bigdata02:2181,bigdata03:2181 -Dspark.deploy.zookeeper.dir=/spark&quot; 注释掉：export SPARK_MASTER_HOST和export SPARK_MASTER_PORT 发送新的配置文件到集群其余节点： scp spark-env.sh bigdata02:$PWD scp spark-env.sh bigdata03:$PWD 5. 执行Spark的任务 (1) spark-submit 用于提交Spark的任务（任务即相关jar包） e.g.: 蒙特卡洛求PI（圆周率） 原理：如下图所示，随机向正方形内落点，通过统计正方形内所有点数和落入圆内的点数来计算占比，得出正方形与圆的面积近似比值，进而近似出PI值。 命令： spark-submit --master spark://XXXX:7077 （指明master地址） --class org.apache.spark.examples.SparkPi （指明主程序的名字） /XXXX/spark/examples/jars/spark-examples_2.11-2.1.0.jar（指明jar包地址） 100（指明运行次数） (2) spark-shell 相当于REPL，作为一个独立的Application运行 spark-shell是Spark自带的交互式Shell程序，方便用户进行交互式编程，用户可以在该命令行下用scala编写spark程序。 参数说明： --master spark://XXXX:7077 指定Master的地址 --executor-memory 2g 指定每个worker可用内存为2G --total-executor-cores 2 指定整个集群使用的cup核数为2个 Spark Session 是 2.0 以后提供的，利用 SparkSession 可以访问spark所有组件 两种运行模式： &lt;1&gt;. 本地模式 启动：spark-shell（后面不接任何参数） &lt;2&gt;. 集群模式 启动：spark-shell --master spark://XXXX:7077（指明master地址） e.g.: 编写WordCount程序 &lt;1&gt;. 处理本地文件，把结果打印到屏幕上 启动：spark-shell 传入文件：sc.textFile(&quot;/XXXX/WordCount.txt&quot;)（本地文件路径）.flatMap(_.split(&quot; &quot;))（按照空格分割）.map((_,1))（单词遍历）.reduceByKey(_+_)（单词计数）.collect &lt;2&gt;. 处理HDFS文件，结果保存在hdfs上 启动：spark-shell --master spark://XXXX:7077（指 sc.textFile(&quot;hdfs://XXXX:9000/sp_wc.txt&quot;).flatMap(.split(&quot; &quot;)).map((,1)).reduceByKey(+).saveAsTextFile(&quot;hdfs://XXXX:9000/output/spark/WordCount&quot;) (3) 单步运行WordCount -&gt; RDD 启动shell：spark-shell scala&gt; val rdd1 = sc.textFile(&quot;/root/sp_wc.txt&quot;) rdd1: org.apache.spark.rdd.RDD[String] = /root/sp_wc.txt MapPartitionsRDD[1] at textFile at &lt;console&gt;:24 scala&gt; rdd1.collect res0: Array[String] = Array(I love Scala, I love Skark, 2019/5/8) scala&gt; val rdd2 = rdd1.flatMap(_.split(&quot; &quot;)) rdd2: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[2] at flatMap at &lt;console&gt;:26 scala&gt; rdd2.collect res1: Array[String] = Array(I, love, Scala, I, love, Skark, 2019/5/8) scala&gt; val rdd3 = rdd2.map((_,1)) rdd3: org.apache.spark.rdd.RDD[(String, Int)] = MapPartitionsRDD[3] at map at &lt;console&gt;:28 scala&gt; rdd3.collect res2: Array[(String, Int)] = Array((I,1), (love,1), (Scala,1), (I,1), (love,1), (Skark,1), (2019/5/8,1)) scala&gt; val rdd4 = rdd3.reduceByKey(_+_) rdd4: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[4] at reduceByKey at &lt;console&gt;:30 scala&gt; rdd4.collect res3: Array[(String, Int)] = Array((2019/5/8,1), (love,2), (I,2), (Skark,1), (Scala,1)) 复制代码 (4) 在IDE中运行WorkCount &lt;1&gt;. scala版本 import org.apache.spark.SparkConf import org.apache.spark.SparkContext object WordCount { def main(args: Array[String]): Unit = { //创建一个Spark配置文件 val conf = new SparkConf().setAppName(&quot;Scala WordCount&quot;).setMaster(&quot;local&quot;) //创建Spark对象 val sc = new SparkContext(conf) val result = sc.textFile(args(0)) .flatMap(_.split(&quot; &quot;)) .map((_, 1)) .reduceByKey(_ + _) .saveAsTextFile(args(1)) sc.stop() } } 复制代码 &lt;2&gt;. Java版本 import java.util.Arrays; import java.util.Iterator; import java.util.List; import org.apache.spark.SparkConf; import org.apache.spark.api.java.JavaPairRDD; import org.apache.spark.api.java.JavaRDD; import org.apache.spark.api.java.JavaSparkContext; import org.apache.spark.api.java.function.FlatMapFunction; import org.apache.spark.api.java.function.Function2; import org.apache.spark.api.java.function.PairFunction; import parquet.format.PageHeader; import scala.Tuple2; public class WordCount { public static void main(String[] args) { // TODO Auto-generated method stub SparkConf conf = new SparkConf() .setAppName(&quot;JavaWordCount&quot;) .setMaster(&quot;local&quot;) ; //新建SparkContext对象 JavaSparkContext sc = new JavaSparkContext(conf) ; //读入数据 JavaRDD&lt;String&gt; lines = sc.textFile(&quot;hdfs://XXXX:9000/WordCount.txt&quot;) ; //分词 第一个参数表示读进来的话 第二个参数表示 返回值 JavaRDD&lt;String&gt; words = lines.flatMap(new FlatMapFunction&lt;String, String&gt;() { @Override public Iterator&lt;String&gt; call(String input) throws Exception { return Arrays.asList(input.split(&quot; &quot;)).iterator() ; } }) ; //每个单词记一次数 /* * String, String, Integer * input &lt;key value&gt; */ JavaPairRDD&lt;String, Integer&gt; ones = words.mapToPair(new PairFunction&lt;String, String, Integer&gt;() { @Override public Tuple2&lt;String, Integer&gt; call(String input) throws Exception { return new Tuple2&lt;String, Integer&gt;(input, 1) ; } }) ; //执行reduce操作 /* * Integer, Integer, Integer * nteger arg0, Integer arg1 返回值 */ JavaPairRDD&lt;String,Integer&gt; counts = ones.reduceByKey(new Function2&lt;Integer, Integer, Integer&gt;() { @Override public Integer call(Integer arg0, Integer arg1) throws Exception { // TODO Auto-generated method stub return arg0 + arg1 ; } }) ; //打印结果 List&lt;Tuple2&lt;String, Integer&gt;&gt; output = counts.collect() ; for (Tuple2&lt;String, Integer&gt; tuple :output) { System.out.println(tuple._1 + &quot; : &quot; + tuple._2) ; } sc.stop() ; } } 复制代码 (5) WordCount程序处理过程 (6) Spark提交任务的流程 6. Spark的算子 (1) RDD基础 &lt;1&gt;. 什么是RDD RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合。RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度。 &lt;2&gt;. RDD的属性（源码中的一段话） **一组分片（Partition）。**即数据集的基本组成单位。对于RDD来说，每个分片都会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的分片个数，如果没有指定，那么就会采用默认值。默认值就是程序所分配到的CPU Core的数目。 **一个计算每个分区的函数。**Spark中RDD的计算是以分片为单位的，每个RDD都会实现compute函数以达到这个目的。compute函数会对迭代器进行复合，不需要保存每次计算的结果。 **RDD之间的依赖关系。**RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。 **一个Partitioner，即RDD的分片函数。**当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。只有对于于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。 **一个列表。**存储存取每个Partition的优先位置（preferred location）。对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。 &lt;3&gt;. RDD的创建方式 通过外部的数据文件创建，如HDFS： val rdd1 = sc.textFile(“hdfs://XXXX:9000/data.txt”) 通过sc.parallelize进行创建： val rdd1 = sc.parallelize(Array(1,2,3,4,5,6,7,8)) DD的类型：Transformation和Action &lt;4&gt;. RDD的基本原理 (2) Transformation RDD中的所有转换都是延迟加载的，也就是说，它们并不会直接计算结果。相反的，它们只是记住这些应用到基础数据集（例如一个文件）上的转换动作。只有当发生一个要求返回结果给Driver的动作时，这些转换才会真正运行。这种设计让Spark更加有效率地运行。 (3) Action (4) RDD的缓存机制 RDD通过persist方法或cache方法可以将前面的计算结果缓存，但是并不是这两个方法被调用时立即缓存，而是触发后面的action时，该RDD将会被缓存在计算节点的内存中，并供后面重用。 通过查看源码发现cache最终也是调用了persist方法，默认的存储级别都是仅在内存存储一份，Spark的存储级别还有好多种，存储级别在object StorageLevel中定义的。 缓存有可能丢失，或者存储存储于内存的数据由于内存不足而被删除，RDD的缓存容错机制保证了即使缓存丢失也能保证计算的正确执行。通过基于RDD的一系列转换，丢失的数据会被重算，由于RDD的各个Partition是相对独立的，因此只需要计算丢失的部分即可，并不需要重算全部Partition。 Demo示例： 通过UI进行监控： (5) RDD的Checkpoint（检查点）机制：容错机制 检查点（本质是通过将RDD写入Disk做检查点）是为了通过lineage（血统）做容错的辅助，lineage过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果之后有节点出现问题而丢失分区，从做检查点的RDD开始重做Lineage，就会减少开销。 设置checkpoint的目录，可以是本地的文件夹、也可以是HDFS。一般是在具有容错能力，高可靠的文件系统上(比如HDFS, S3等)设置一个检查点路径，用于保存检查点数据。 分别举例说明： &lt;1&gt;. 本地目录 注意：这种模式，需要将spark-shell运行在本地模式上 &lt;2&gt;. HDFS的目录 注意：这种模式，需要将spark-shell运行在集群模式上 (6) RDD的依赖关系和Spark任务中的Stage RDD的依赖关系 RDD和它依赖的父RDD（s）的关系有两种不同的类型，即窄依赖（narrow dependency）和宽依赖（wide dependency）。 窄依赖指的是每一个父RDD的Partition最多被子RDD的一个Partition使用 总结：窄依赖我们形象的比喻为独生子女 宽依赖指的是多个子RDD的Partition会依赖同一个父RDD的Partition 总结：窄依赖我们形象的比喻为超生 Spark任务中的Stage DAG(Directed Acyclic Graph)叫做有向无环图，原始的RDD通过一系列的转换就就形成了DAG，根据RDD之间的依赖关系的不同将DAG划分成不同的Stage，对于窄依赖，partition的转换处理在Stage中完成计算。对于宽依赖，由于有Shuffle的存在，只能在parent RDD处理完成后，才能开始接下来的计算，因此宽依赖是划分Stage的依据。 (7) RDD基础练习 练习1： //通过并行化生成rdd val rdd1 = sc.parallelize(List(5, 6, 4, 7, 3, 8, 2, 9, 1, 10)) //对rdd1里的每一个元素乘2然后排序 val rdd2 = rdd1.map(_ * 2).sortBy(x =&gt; x, true) //过滤出大于等于十的元素 val rdd3 = rdd2.filter(_ &gt;= 10) //将元素以数组的方式在客户端显示 rdd3.collect 复制代码 练习2： val rdd1 = sc.parallelize(Array(&quot;a b c&quot;, &quot;d e f&quot;, &quot;h i j&quot;)) //将rdd1里面的每一个元素先切分在压平 val rdd2 = rdd1.flatMap(_.split(&#39; &#39;)) rdd2.collect 复制代码 练习3： val rdd1 = sc.parallelize(List(5, 6, 4, 3)) val rdd2 = sc.parallelize(List(1, 2, 3, 4)) //求并集 val rdd3 = rdd1.union(rdd2) //求交集 val rdd4 = rdd1.intersection(rdd2) //去重 rdd3.distinct.collect rdd4.collect 复制代码 练习4： val rdd1 = sc.parallelize(List((&quot;tom&quot;, 1), (&quot;jerry&quot;, 3), (&quot;kitty&quot;, 2))) val rdd2 = sc.parallelize(List((&quot;jerry&quot;, 2), (&quot;tom&quot;, 1), (&quot;shuke&quot;, 2))) //求jion val rdd3 = rdd1.join(rdd2) rdd3.collect //求并集 val rdd4 = rdd1 union rdd2 //按key进行分组 rdd4.groupByKey rdd4.collect 复制代码 练习5： val rdd1 = sc.parallelize(List((&quot;tom&quot;, 1), (&quot;tom&quot;, 2), (&quot;jerry&quot;, 3), (&quot;kitty&quot;, 2))) val rdd2 = sc.parallelize(List((&quot;jerry&quot;, 2), (&quot;tom&quot;, 1), (&quot;shuke&quot;, 2))) //cogroup val rdd3 = rdd1.cogroup(rdd2) //注意cogroup与groupByKey的区别 rdd3.collect 复制代码 练习6： val rdd1 = sc.parallelize(List(1, 2, 3, 4, 5)) //reduce聚合 val rdd2 = rdd1.reduce(_ + _) rdd2.collect 复制代码 练习7： val rdd1 = sc.parallelize(List((&quot;tom&quot;, 1), (&quot;jerry&quot;, 3), (&quot;kitty&quot;, 2), (&quot;shuke&quot;, 1))) val rdd2 = sc.parallelize(List((&quot;jerry&quot;, 2), (&quot;tom&quot;, 3), (&quot;shuke&quot;, 2), (&quot;kitty&quot;, 5))) val rdd3 = rdd1.union(rdd2) //按key进行聚合 val rdd4 = rdd3.reduceByKey(_ + _) rdd4.collect //按value的降序排序 val rdd5 = rdd4.map(t =&gt; (t._2, t._1)).sortByKey(false).map(t =&gt; (t._2, t._1)) rdd5.collect 复制代码7. Spark RDD的高级算子 (1) mapPartitionsWithIndex 把每个partition中的分区号和对应的值拿出来 def mapPartitionsWithIndex[U](f: (Int, Iterator[T]) ⇒ Iterator[U], preservesPartitioning: Boolean = false)(implicit arg0: ClassTag[U]): RDD[U] f中函数参数： 第一个参数是Int，代表分区号 第二个Iterator[T]代表分区中的元素 e.g.: 将每个分区中的元素和分区号打印出来 val rdd1 = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 2) 创建一个函数返回RDD中的每个分区号和元素： def func1(index:Int, iter:Iterator[Int]):Iterator[String] ={ iter.toList.map( x =&gt; &quot;[PartID:&quot; + index + &quot;, value=&quot; + x + &quot;]&quot; ).iterator } 复制代码 调用：rdd1.mapPartitionsWithIndex(func1).collect (2) aggregate 先对局部聚合，再对全局聚合 e.g.: val rdd1 = sc.parallelize(List(1,2,3,4,5), 2) 查看每个分区中的元素： scala&gt; rdd1.mapPartitionsWithIndex(fun1).collect res4: Array[String] = Array( [partId : 0 , value = 1 ], [partId : 0 , value = 2 ], [partId : 1 , value = 3 ], [partId : 1 , value = 4 ], [partId : 1 , value = 5 ]) 复制代码 将每个分区中的最大值求和，注意初始值是0: scala&gt; rdd2.aggregate(0)(max(_,_),_+_) res6: Int = 7 复制代码 如果初始值时候100，则结果为300: scala&gt; rdd2.aggregate(100)(max(_,_),_+_) res8: Int = 300 ``` 复制代码 如果是求和，注意初始值是0： scala&gt; rdd2.aggregate(0)(_+_,_+_) res9: Int = 15 复制代码 如果初始值是10，则结果是45 scala&gt; rdd2.aggregate(10)(_+_,_+_) res10: Int = 45 复制代码 e.g. —— 字符串： val rdd2 = sc.parallelize(List(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;),2) 修改一下刚才的查看分区元素的函数 def func2(index: Int, iter: Iterator[(String)]) : Iterator[String] = { iter.toList.map(x =&gt; &quot;[partID:&quot; + index + &quot;, val: &quot; + x + &quot;]&quot;).iterator } 复制代码 两个分区中的元素： [partID:0, val: a], [partID:0, val: b], [partID:0, val: c], [partID:1, val: d], [partID:1, val: e], [partID:1, val: f] 复制代码 运行结果： e.g.: val rdd3 = sc.parallelize(List(&quot;12&quot;,&quot;23&quot;,&quot;345&quot;,&quot;4567&quot;),2) rdd3.aggregate(&quot;&quot;)((x,y) =&gt; math.max(x.length, y.length).toString, (x,y) =&gt; x + y) 复制代码 结果可能是24，也可能是42 val rdd4 = sc.parallelize(List(&quot;12&quot;,&quot;23&quot;,&quot;345&quot;,&quot;&quot;),2) rdd4.aggregate(&quot;&quot;)((x,y) =&gt; math.min(x.length, y.length).toString, (x,y) =&gt; x + y) 复制代码 结果是10，也可能是01 原因：注意有个初始值&quot;&quot;，其长度0，然后0.toString变成字符串 val rdd5 = sc.parallelize(List(&quot;12&quot;,&quot;23&quot;,&quot;&quot;,&quot;345&quot;),2) rdd5.aggregate(&quot;&quot;)((x,y) =&gt; math.min(x.length, y.length).toString, (x,y) =&gt; x + y) 复制代码 结果是11，原因同上。 (3) aggregateByKey 准备数据： val pairRDD = sc.parallelize(List( (&quot;cat&quot;,2), (&quot;cat&quot;, 5), (&quot;mouse&quot;, 4),(&quot;cat&quot;, 12), (&quot;dog&quot;, 12), (&quot;mouse&quot;, 2)), 2) def func3(index: Int, iter: Iterator[(String, Int)]) : Iterator[String] = { iter.toList.map(x =&gt; &quot;[partID:&quot; + index + &quot;, val: &quot; + x + &quot;]&quot;).iterator } 复制代码 两个分区中的元素： e.g.: 将每个分区中的动物最多的个数求和 scala&gt; pairRDD.aggregateByKey(0)(math.max(_, _), _ + _).collect res69: Array[(String, Int)] = Array((dog,12), (cat,17), (mouse,6)) 复制代码 将每种动物个数求和 scala&gt; pairRDD.aggregateByKey(0)(_+_, _ + _).collect res71: Array[(String, Int)] = Array((dog,12), (cat,19), (mouse,6)) 复制代码 这个例子也可以使用：reduceByKey scala&gt; pairRDD.reduceByKey(_+_).collect res73: Array[(String, Int)] = Array((dog,12), (cat,19), (mouse,6)) 复制代码 (4) coalesce与repartition 都是将RDD中的分区进行重分区。 区别： coalesce默认不会进行shuffle（false）； repartition会进行shuffle（true），会将数据真正通过网络进行重分区。 e.g.: def func4(index: Int, iter: Iterator[(Int)]) : Iterator[String] = { iter.toList.map(x =&gt; &quot;[partID:&quot; + index + &quot;, val: &quot; + x + &quot;]&quot;).iterator } val rdd1 = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 2) 下面两句话是等价的： val rdd2 = rdd1.repartition(3) val rdd3 = rdd1.coalesce(3,true) -&gt; 如果是false，查看RDD的length依然是2 复制代码 (5) 其他高级算子 参考：homepage.cs.latrobe.edu.au/zhe/ZhenHeS… 8. Spark 基础编程案例 (1) 求网站的访问量 Tomcat的访问日志如下： 需求：找到访问量最高的两个网页，要求显示网页名称和访问量 步骤分析： &lt;1&gt;. 对网页的访问量求和 &lt;2&gt;. 降序排序 代码： import org.apache.spark.SparkConf import org.apache.spark.SparkContext object TomcatLogCount { def main(args: Array[String]): Unit = { val conf = new SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;TomcatLogCount&quot;) val sc = new SparkContext(conf) /* * 读入日志并解析 * * 192.168.88.1 - - [30/Jul/2017:12:54:37 +0800] &quot;GET /MyDemoWeb/oracle.jsp HTTP/1.1&quot; 200 242 * */ val rdd1 = sc.textFile(&quot; &quot;).map( line =&gt; { //解析字符串，得到jsp的名字 //1. 解析两个引号间的字符串 val index1 = line.indexOf(&quot;\&quot;&quot;) val index2 = line.lastIndexOf(&quot;\&quot;&quot;) //line1 = GET /MyDemoWeb/oracle.jsp HTTP/1.1 val line1 = line.substring(index1 + 1, index2) val index3 = line1.indexOf(&quot; &quot;) val index4 = line1.lastIndexOf(&quot; &quot;) //line2 = /MyDemoWeb/oracle.jsp val line2 = line1.substring(index3 + 1, index4) //得到jsp的名字 oracle.jsp val jspName = line2.substring(line2.lastIndexOf(&quot;/&quot;)) (jspName, 1) } ) //统计每个jsp的次数 val rdd2 = rdd1.reduceByKey(_+_) //使用Value排序 val rdd3 = rdd2.sortBy(_._2, false) //得到次数最多的两个jsp rdd3.take(2).foreach(println) sc.stop() } } 复制代码 (2) 创建自定义分区 根据jsp文件的名字，将各自的访问日志放入到不同的分区文件中，如下： 生成的分区文件 如：part-00000文件中的内容：只包含了web.jsp的访问日志 代码： import org.apache.spark.SparkConf import org.apache.spark.SparkContext import scala.collection.mutable.HashMap object TomcatLogPartitioner { def main(args: Array[String]): Unit = { val conf = new SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;TomcatLogPartitioner&quot;) val sc = new SparkContext(conf) /* * 读入日志并解析 * * 192.168.88.1 - - [30/Jul/2017:12:54:37 +0800] &quot;GET /MyDemoWeb/oracle.jsp HTTP/1.1&quot; 200 242 * */ val rdd1 = sc.textFile(&quot; &quot;).map( line =&gt; { //解析字符串，得到jsp的名字 //1. 解析两个引号间的字符串 val index1 = line.indexOf(&quot;\&quot;&quot;) val index2 = line.lastIndexOf(&quot;\&quot;&quot;) //line1 = GET /MyDemoWeb/oracle.jsp HTTP/1.1 val line1 = line.substring(index1 + 1, index2) val index3 = line1.indexOf(&quot; &quot;) val index4 = line1.lastIndexOf(&quot; &quot;) //line2 = /MyDemoWeb/oracle.jsp val line2 = line1.substring(index3 + 1, index4) //得到jsp的名字 oracle.jsp val jspName = line2.substring(line2.lastIndexOf(&quot;/&quot;)) (jspName, line) } ) //得到不重复的jsp名字 val rdd2 = rdd1.map(_._1).distinct().collect() //创建分区规则 val wepPartitioner = new WepPartitioner(rdd2) val rdd3 = rdd1.partitionBy(wepPartitioner) //输出rdd3 rdd3.saveAsTextFile(&quot; &quot;) } //定义分区规则 class WepPartitioner(jspList : Array[String]) extends Partitioner { /* * 定义集合来保存分区条件: * String 代表jsp的名字 * Int 代表序号 * */ val partitionMap = new HashMap[String, Int]() //初始分区号 val partID = 0 //填值 for (jsp &lt;- jspList) { patitionMap.put(jsp, partID) partID += 1 } //返回分区个数 def numPartitioners : Int = partitionMap.size //根据jsp，返回对应的分区 def getPartition(key : Any) : Int = partitionMap.getOrElse(key.toString(), 0) } } 复制代码 (3) 使用JDBCRDD 访问数据库 JdbcRDD参数说明： 从上面的参数说明可以看出，JdbcRDD有以下两个缺点： &lt;1&gt;. 执行的SQL必须有两个参数，并类型都是Long &lt;2&gt;. 得到的结果是ResultSet，即：只支持select操作 代码： import org.apache.spark.SparkConf import org.apache.spark.SparkContext import java.sql.Connection import java.sql.DriverManager import java.sql.PreparedStatement /* * 把Spark结果存放到mysql数据库中 * */ object TomcatLogCountToMysql { def main(args: Array[String]): Unit = { //创建SparkContext val conf = new SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;MyTomcatLogCountToMysql&quot;) val sc = new SparkContext(conf) /* * * 读入日志 解析： * * 192.168.88.1 - - [30/Jul/2017:12:54:37 +0800] &quot;GET /MyDemoWeb/oracle.jsp HTTP/1.1&quot; 200 242 */ val rdd1 = sc.textFile(&quot;H:\\tmp_files\\localhost_access_log.txt&quot;) .map( line =&gt; { //解析字符串，得到jsp的名字 //1、解析两个引号之间的字符串 val index1 = line.indexOf(&quot;\&quot;&quot;) val index2 = line.lastIndexOf(&quot;\&quot;&quot;) val line1 = line.substring(index1 + 1, index2) // GET /MyDemoWeb/oracle.jsp HTTP/1.1 //得到两个空格的位置 val index3 = line1.indexOf(&quot; &quot;) val index4 = line1.lastIndexOf(&quot; &quot;) val line2 = line1.substring(index3 + 1, index4) // /MyDemoWeb/oracle.jsp //得到jsp的名字 val jspName = line2.substring(line2.lastIndexOf(&quot;/&quot;)) // oracle.jsp (jspName, 1) }) // // try { // /* // * create table mydata(jsname varchar(50),countNumber Int) // * // * foreach 没有返回值，在本需求中，只需要写数据库，不需要返回新的RDD，所以用foreach即可 // * // * // * 运行 Task not serializable // */ // conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;123456&quot;) // pst = conn.prepareStatement(&quot;insert into mydata values(?,?)&quot;) // // rdd1.foreach(f =&gt; { // pst.setString(1, f._1) // pst.setInt(2, f._2) // // pst.executeUpdate() // }) // } catch { // case t: Throwable =&gt; t.printStackTrace() // } finally { // if (pst != null) pst.close() // if (conn != null) conn.close() // } // // sc.stop() // //存入数据库 // var conn: Connection = null // var pst: PreparedStatement = null // //第一种修改方法 // /* // * 修改思路： // * conn pst 让每一个节点都是用到，需要在不同的节点上传输，实现sericalizable接口 // */ // try { // rdd1.foreach(f =&gt; { // conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;123456&quot;) // pst = conn.prepareStatement(&quot;insert into mydata values(?,?)&quot;) // // pst.setString(1, f._1) // pst.setInt(2, f._2) // // pst.executeUpdate() // }) // } catch { // case t: Throwable =&gt; t.printStackTrace() // } finally { // if (pst != null) pst.close() // if (conn != null) conn.close() // } // // sc.stop() /* * 第一种修改方式，功能上可以实现，但每条数据都会创建连接，对数据库造成很大压力 * * 针对分区来操作：一个分区，建立一个连接即可 */ rdd1.foreachPartition(saveToMysql) sc.stop() } def saveToMysql(it: Iterator[(String, Int)]) = { var conn: Connection = null var pst: PreparedStatement = null try { conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;123456&quot;) pst = conn.prepareStatement(&quot;insert into mydata values(?,?)&quot;) it.foreach(f =&gt; { pst.setString(1, f._1) pst.setInt(2, f._2) pst.executeUpdate() }) } catch { case t: Throwable =&gt; t.printStackTrace() } finally { if (pst != null) pst.close() if (conn != null) conn.close() } } } 复制代码9. 认识 Spark SQL (1) 什么是Spark SQL Spark SQL is Apache Spark&#39;s module for working with structured data.（Spark SQL 是spark 的一个模块，用来处理 结构化的数据。&lt;不能处理非结构化的数据&gt;） Spark SQL是Spark用来处理结构化数据的一个模块，它提供了一个编程抽象叫做DataFrame并且作为分布式SQL查询引擎的作用。 (2) 为什么要学习Spark SQL Hive是将HQL转换成MapReduce然后提交到集群上执行，大大简化了编写MapReduce的程序的复杂性，但是MapReduce这种计算模型执行效率比较慢。所以Spark SQL的应运而生，它是将Spark SQL转换成RDD，然后提交到集群执行，执行效率非常快，同时Spark SQL也支持从Hive中读取数据，Hive 2.x 执行引擎可以使用Spark。 (3) Spark SQL的特点： &lt;1&gt;. 容易集成 不需要单独安装。 &lt;2&gt;. 统一的数据访问方式 结构化数据（JDBC、JSon、Hive、parquer文件）都可以作为Spark SQL 的数据源。 对接多种数据源，且使用方式类似。 &lt;3&gt;. 兼容Hive 把Hive中的数据，读取到Spark SQL中运行。 &lt;4&gt;. 支持标准的数据连接（JDBC） 10. Spark SQL 基础 (1) 基本概念：Datasets和DataFrames &lt;1&gt;. DataFrame DataFrame是组织成命名列的数据集。它在概念上等同于关系数据库中的表，但在底层具有更丰富的优化。DataFrames可以从各种来源构建， 例如： 结构化数据文件 Hive中的表 外部数据库或现有RDDs DataFrame API支持的语言有Scala，Java，Python和R。 从上图可以看出，DataFrame多了数据的结构信息，即schema。RDD是分布式的 Java对象的集合。DataFrame是分布式的Row对象的集合。DataFrame除了提供了比RDD更丰富的算子以外，更重要的特点是提升执行效率、减少数据读取以及执行计划的优化。 &lt;2&gt;. Datasets Dataset是数据的分布式集合。Dataset是在Spark 1.6中添加的一个新接口，是DataFrame之上更高一级的抽象。它提供了RDD的优点（强类型化，使用强大的lambda函数的能力）以及Spark SQL优化后的执行引擎的优点。一个Dataset 可以从JVM对象构造，然后使用函数转换（map， flatMap，filter等）去操作。Dataset API 支持Scala和Java，Python不支持Dataset API。 (2) DataFrames &lt;1&gt;. 创建 DataFrames a. 通过Case Class创建DataFrames ① 定义case class（相当于表的结构：Schema） case class Emp(empno:Int,ename:String,job:String,mgr:Int,hiredate:String,sal:Int,comm:Int,deptno:Int) 注意：由于mgr和comm列中包含null值，简单起见，将对应的case class类型定义为String ② 将HDFS上的数据读入RDD，并将RDD与case Class关联 val lines = sc.textFile(&quot;/XXXX/emp.csv&quot;).map(_.split(&quot;,&quot;)) ③ 将RDD转换成DataFrames val allEmp = lines.map(x =&gt; Emp(x(0).toInt,x(1),x(2),x(3).toInt,x(4),x(5).toInt,x(6).toInt,x(7).toInt)) ④ 通过DataFrames查询数据 val df1 = allEmp.toDF df1.show b. 使用SparkSession 什么是SparkSession Apache Spark 2.0引入了SparkSession，其为用户提供了一个统一的切入点来使用Spark的各项功能，并且允许用户通过它调用DataFrame和Dataset相关API来编写Spark程序。最重要的是，它减少了用户需要了解的一些概念，使得我们可以很容易地与Spark交互。 在2.0版本之前，与Spark交互之前必须先创建SparkConf和SparkContext。然而在Spark 2.0中，我们可以通过SparkSession来实现同样的功能，而不需要显式地创建SparkConf, SparkContext 以及 SQLContext，因为这些对象已经封装在SparkSession中。   - 创建StructType，来定义Schema结构信息 注意：需要import org.apache.spark.sql.types._，import org.apache.spark.sql.Row import org.apache.spark.sql.types._ val myschema = StructType( List( StructField(&quot;empno&quot;,DataTypes.IntegerType), StructField(&quot;ename&quot;,DataTypes.StringType), StructField(&quot;job&quot;,DataTypes.StringType), StructField(&quot;mgr&quot;,DataTypes.IntegerType), StructField(&quot;hiredate&quot;,DataTypes.StringType), StructField(&quot;sal&quot;,DataTypes.IntegerType), StructField(&quot;comm&quot;,DataTypes.IntegerType), StructField(&quot;deptno&quot;,DataTypes.IntegerType), )) val allEmp = lines.map(x =&gt; Row(x(0).toInt,x(1),x(2),x(3).toInt,x(4),x(5).toInt,x(6).toInt,x(7).toInt)) import org.apache.spark.sql.Row val df2 = spark.createDataFrame(allEmp,myschema) 复制代码 c. 使用JSon文件来创建DataFame val df3 = spark.read 读文件，默认是Parquet文件 val df3 = spark.read.json(&quot;/XXXX/people.json&quot;) 读json文件 df3.show val df4 = spark.read.format(&quot;json&quot;).load(&quot;/XXXX/people.json&quot;) 复制代码 &lt;2&gt;. DataFrame 操作 DataFrame操作也称为无类型的Dataset操作 a. DSL语句 查询所有的员工姓名 查询所有的员工姓名和薪水，并给薪水加100块钱 查询工资大于2000的员工 求每个部门的员工人数 参考：spark.apache.org/docs/2.1.0/… b. SQL语句 **注意：**不能直接执行SQL，需要生成一个视图，再执行sql。 ① 将DataFrame注册成表（视图）：df.createOrReplaceTempView(&quot;emp&quot;) ② 执行查询： spark.sql(&quot;select * from emp&quot;).show spark.sql(&quot;select * from emp where deptno=10&quot;).show spark.sql(&quot;select deptno,sum(sal) from emp group by deptno&quot;).show (3) Spark SQL 中的视图 视图是一个虚表，不存储数据。 两种类型： &lt;1&gt;. 普通视图（本地视图）——createOrReplaceTempView 只在当前Session中有效。 &lt;2&gt;. 全局视图： ——createGlobalTempView 在Spark SQL中，如果想拥有一个临时的view，并想在不同的Session中共享，而且在application的运行周期内可用，那么就需要创建一个全局的临时view。并记得使用的时候加上global_temp作为前缀来引用它，因为全局的临时view是绑定到系统保留的数据库global_temp上。 e.g.: ``` 创建一个新session，读取不到emp视图 spark.newSession.sql(&quot;select * from emp&quot;) 以下两种方式均可读到 全局视图 中的数据: df1.createGlobalTempView(&quot;emp1&quot;) spark.newSession.sql(&quot;select * from global_temp.emp1&quot;).show spark.sql(&quot;select * from global_temp.emp1&quot;).show 复制代码 复制代码 (4) 创建Datasets DataFrame的引入，可以让Spark更好的处理结构数据的计算，但其中一个主要的问题是：缺乏编译时类型安全。为了解决这个问题，Spark采用新的Dataset API (DataFrame API的类型扩展)。 Dataset是一个分布式的数据收集器。这是在Spark1.6之后新加的一个接口，兼顾了RDD的优点（强类型，可以使用功能强大的lambda）以及Spark SQL的执行器高效性的优点。所以可以把DataFrames看成是一种特殊的Datasets，即：Dataset(Row) 创建DataSet： &lt;1&gt;. 使用序列 ① 定义case class: case class MyData(a:Int,b:String) ② 生成序列并创建DataSet: val ds = Seq(MyData(1,&quot;Tom&quot;),MyData(2,&quot;Mary&quot;)).toDS ③ 查看结果 ds.show &lt;2&gt;. 使用JSON数据 ① 定义case class: case class Person(name: String, gender: String) ② 通过JSON数据生成DataFrame: val df = spark.read.json(sc.parallelize(&quot;&quot;&quot;{&quot;gender&quot;: &quot;Male&quot;, &quot;name&quot;: &quot;Tom&quot;}&quot;&quot;&quot; :: Nil)) ③ 将DataFrame转成DataSet: df.as[Person].show df.as[Person].collect &lt;3&gt;. 使用HDFS数据 ① 读取HDFS数据，并创建DataSet: val linesDS = spark.read.text(&quot;hdfs://XXXX:9000/XXXX/data.txt&quot;).as[String] ② 对DataSet进行操作：分词后，查询长度大于3的单词 val words = linesDS.flatMap(_.split(&quot; &quot;)).filter(_.length &gt; 3) words.show words.collect 复制代码 ③ 执行WordCount程序 val result = linesDS.flatMap(_.split(&quot; &quot;)).map((_,1)).groupByKey(x =&gt; x._1).count result.show 排序：result.orderBy($&quot;value&quot;).show 复制代码 (5) Datasets 的操作案例 &lt;1&gt;. 使用emp.json 生成DataFrame: val empDF = spark.read.json(&quot;/XXXX/emp.json&quot;) 查询工资大于3000的员工 empDF.where($&quot;sal&quot; &gt;= 3000).show 复制代码 &lt;2&gt;. 创建case class: case class Emp(empno:Long,ename:String,job:String,hiredate:String,mgr:String,sal:Long,comm:String,deptno:Long) &lt;3&gt;. 生成DataSets并查询数据: val empDS = empDF.as[Emp] 查询工资大于3000的员工 empDS.filter(_.sal &gt; 3000).show 查看10号部门的员工 empDS.filter(_.deptno == 10).show 复制代码 &lt;4&gt;. 多表查询: a. 创建部门表: val deptRDD=sc.textFile(&quot;/XXXX/dept.csv&quot;).map(_.split(&quot;,&quot;)) case class Dept(deptno:Int,dname:String,loc:String) val deptDS = deptRDD.map(x=&gt;Dept(x(0).toInt,x(1),x(2))).toDS 复制代码 复制代码 b. 创建员工表: case class Emp(empno:Int,ename:String,job:String,mgr:String,hiredate:String,sal:Int,comm:String,deptno:Int) val empRDD = sc.textFile(&quot;/XXXX/emp.csv&quot;).map(_.split(&quot;,&quot;)) val empDS = empRDD.map(x =&gt; Emp(x(0).toInt,x(1),x(2),x(3),x(4),x(5).toInt,x(6),x(7).toInt)).toDS 复制代码 c. 执行多表查询：等值链接 val result = deptDS.join(empDS,&quot;deptno&quot;) 另一种写法：注意有三个等号 val result = deptDS.joinWith(empDS,deptDS(&quot;deptno&quot;)=== empDS(&quot;deptno&quot;)) joinWith和join的区别是连接后的新Dataset的schema会不一样 复制代码 &lt;5&gt;. 查看执行计划： result.explain 11. Spark SQL 进阶 (1) 使用数据源 &lt;1&gt;. 什么是parquet文件 Parquet是列式存储格式的一种文件类型，列式存储有以下的核心： 可以跳过不符合条件的数据，只读取需要的数据，降低IO数据量。 压缩编码可以降低磁盘存储空间。由于同一列的数据类型是一样的，可以使用更高效的压缩编码（例如Run Length Encoding和Delta Encoding）进一步节约存储空间。 只读取需要的列，支持向量运算，能够获取更好的扫描性能。 Parquet格式是Spark SQL的默认数据源，可通过spark.sql.sources.default配置 &lt;2&gt;. 使用Load/Save函数 load函数是加载数据，save是存储数据。 e.g.: 读取 users.parquet 文件（Spark自带的示例文件） val userDF = spark.read.load(&quot;/root/users.parquet&quot;) 查看结构： userDF.printSchema 查看内容： userDF.show 读取json文件： val userDF = spark.read.load(&quot;/root/emp.json&quot;) ——&gt;报错 正确方法： val userDF = spark.read.format(&quot;json&quot;).load(&quot;/root/emp.json&quot;) val userDF = spark.read.json(&quot;/root/emp.json&quot;) 保存parquet文件到本地路径： userDF.select($&quot;name&quot;,$&quot;favorite_color&quot;).write.save(&quot;/root/parquet&quot;) 读取刚写入的文件： val userDF1 = spark.read.load(&quot;/root/parquet/part-00000-888d505a-7d51-4a50-aaf5-2bbdb56e67a1.snappy.parquet&quot;) --&gt; 不推荐 生产：（直接读目录） val userDF2 = spark.read.load(&quot;/usr/local/tmp_files/parquet&quot;) 复制代码 关于save函数： 调用save函数的时候，可以指定存储模式，追加、覆盖等等 可以采用SaveMode执行存储操作，SaveMode定义了对数据的处理模式。需要注意的是，这些保存模式不使用任何锁定，不是原子操作。此外，当使用Overwrite方式执行时，在输出新数据之前原数据就已经被删除。SaveMode详细介绍如下表： userDF2.write.save(&quot;/root/parquet&quot;) ——&gt;报错 save的时候覆盖： userDF2.write.mode(&quot;overwrite&quot;).save(&quot;/root/parquet&quot;) 将结果保存成表： userDF2.select($&quot;name&quot;).write.saveAsTable(&quot;table1&quot;) 查看数据： spark.sql(&quot;select * from table2&quot;).show 也可以进行分区、分桶等操作：partitionBy、bucketBy 复制代码 &lt;3&gt;. Parquet文件 Parquet是一个列格式而且用于多个数据处理系统中。Spark SQL提供支持对于Parquet文件的读写，也就是自动保存原始数据的schema。当写Parquet文件时，所有的列被自动转化为nullable，因为兼容性的缘故。 e.g.: 读入json格式的数据，将其转换成parquet格式，并创建相应的表来使用SQL进行查询。（把数据读进来，再写出去，就是Parquet文件） 读入文件： val empDF = spark.read.json(&quot;/root/emp.json&quot;) 写出文件： empDF.write.mode(&quot;overwrite&quot;).save(&quot;/root/parquet&quot;) empDF.write.mode(&quot;overwrite&quot;).parquet(&quot;/root/parquet&quot;) 建表查询： val emp1 = spark.read.parquet(&quot;/root/parquet&quot;) emp1.createOrReplaceTempView(&quot;emp1&quot;) spark.sql(&quot;select * from emp1&quot;).show 复制代码 &lt;4&gt;. Schema的合并： Parquet支持Schema evolution（Schema演变，即：合并）。用户可以先定义一个简单的Schema，然后逐渐的向Schema中增加列描述。通过这种方式，用户可以获取多个有不同Schema但相互兼容的Parquet文件。 e.g.: 通过RDD来创建DataFrame: val df1 = sc.makeRDD(1 to 5).map( i =&gt; (i,i*2)).toDF(&quot;single&quot;,&quot;double&quot;) ——&gt;&quot;single&quot;,&quot;double&quot; 是表结构 df1.show df1.write.mode(&quot;overwrite&quot;).save(&quot;/root/test_table/key=1&quot;) val df2 = sc.makeRDD(6 to 10).map( i =&gt; (i,i*3)).toDF(&quot;single&quot;,&quot;triple&quot;) df2.show df2.write.mode(&quot;overwrite&quot;).save(&quot;/root/test_table/key=2&quot;) 合并两个部分: val df3 = spark.read.parquet(&quot;/root/tmp_files/test_table&quot;) val df3 = spark.read.option(&quot;mergeSchema&quot;,true).parquet(&quot;/root/tmp_files/test_table&quot;) 复制代码 &lt;5&gt;. JSON Datasets Spark SQL能自动解析JSON数据集的Schema，读取JSON数据集为DataFrame格式。读取JSON数据集方法为SQLContext.read().json()。该方法将String格式的RDD或JSON文件转换为DataFrame。 需要注意的是，这里的JSON文件不是常规的JSON格式。JSON文件每一行必须包含一个独立的、自满足有效的JSON对象。如果用多行描述一个JSON对象，会导致读取出错。读取JSON数据集示例如下： 读取Json文件，生成DataFrame: val peopleDF = spark.read.json(&quot;/usr/local/tmp_files/people.json&quot;) 打印Schema结构信息： peopleDF.printSchema 创建临时视图： peopleDF.createOrReplaceTempView(&quot;peopleView&quot;) 执行查询： spark.sql(&quot;select * from peopleView&quot;).show Spark SQL 支持统一的访问接口。对于不同的数据源，读取进来，生成DataFrame后，操作完全一样。 复制代码 &lt;6&gt;. 使用JDBC Spark SQL同样支持通过JDBC读取其他数据库的数据作为数据源。 Spark加载MySQL： spark-shell --master spark://XXXX:7077 --jars /XXXX/.jar --driver-class-path /XXXX/.jar Spark连接MySQL： 方法一： val mysqlDF = spark.read.format(&quot;jdbc&quot;).option(&quot;url&quot;,&quot;jdbc:mysql://XXXX:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;).option(&quot;user&quot;,&quot;root&quot;).option(&quot;password&quot;,&quot;123456&quot;).option(&quot;driver&quot;,&quot;com.mysql.cj.jdbc.Driver&quot;).option(&quot;dbtable&quot;,&quot;emp&quot;).load mysqlDF.show``` 复制代码 方式二：定义一个Properties类 import java.util.Properties val mysqlProps = new Properties() mysqlProps.setProperty(&quot;user&quot;,&quot;root&quot;) mysqlProps.setProperty(&quot;password&quot;,&quot;123456&quot;) val mysqlDF1 = spark.read.jdbc(&quot;jdbc:mysql://XXXX:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;,&quot;emp&quot;,mysqlProps) mysqlDF1.show ``` 复制代码 &lt;7&gt;. 使用Hive Table a. 准备工作： 搭建好Hive的环境（需要Hadoop） 配置Spark SQL支持Hive： 将以下文件拷贝到$SPARK_HOME/conf的目录下，即可 $HIVE_HOME/conf/hive-site.xml $HADOOP_CONF_DIR/core-site.xml $HADOOP_CONF_DIR/hdfs-site.xml 重启Spark b. 使用Spark Shell操作Hive 启动Hadoop、Hive 启动Spark 启动spark-sql的时候，需要使用--jars指定mysql的驱动程序 创建表：spark.sql(&quot;create table spark.emp1(empno Int,ename String,job String,mgr String,hiredate String,sal Int,comm String,deptno Int)row format delimited fields terminated by &#39;,&#39;&quot;) 导入数据：spark.sql(&quot;load data local inpath &#39;/root/emp.csv&#39; overwrite into table spark.emp1&quot;) 查询数据：spark.sql(&quot;select * from spark.emp1&quot;).show (2) 在IDE中开发Spark SQL &lt;1&gt;. 创建DataFrame a. StructType方式 package Demo import org.apache.spark.sql.SparkSession import org.apache.spark.sql.types.StructType import org.apache.spark.sql.types.StructField import org.apache.spark.sql.types.IntegerType import org.apache.spark.sql.types.StringType import org.apache.spark.sql.Row import org.apache.log4j.Logger import org.apache.log4j.Level /*创建DataFrame StructType方式*/ object Demo01 { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) // 创建Spark Session对象 val spark = SparkSession.builder().master(&quot;local&quot;).appName(&quot;Demo1&quot;).getOrCreate() // 从指定的地址创建RDD对象 /*1 Tom 12 *2 Mary 13 *3 Lily 15 * */ val personRDD = spark.sparkContext.textFile(&quot;/Users/apple/Documents/student.txt&quot;).map(_.split(&quot;\t&quot;)) // 通过StructType方式指定Schema val schema = StructType( List( StructField(&quot;id&quot;, IntegerType), StructField(&quot;name&quot;, StringType), StructField(&quot;age&quot;, IntegerType))) // 将RDD映射到rowRDD上，映射到Schema上 val rowRDD = personRDD.map(p =&gt; Row(p(0).toInt, p(1), p(2).toInt)) val personDataFrame = spark.createDataFrame(rowRDD, schema) // 注册视图 personDataFrame.createOrReplaceTempView(&quot;t_person&quot;) //执行SQL语句 val df = spark.sql(&quot;select * from t_person order by age desc&quot;) df.show() spark.stop() } 复制代码 }复制代码 b. case Class方式 package Demo import org.apache.spark.sql.SparkSession import org.apache.spark.sql.types.StructType import org.apache.spark.sql.types.StructField import org.apache.spark.sql.types.IntegerType import org.apache.spark.sql.types.StringType import org.apache.spark.sql.Row import org.apache.log4j.Logger import org.apache.log4j.Level /*使用case Class来创建DataFrame*/ object Demo02 { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建Spark Session对象 val spark = SparkSession.builder().master(&quot;local&quot;).appName(&quot;Demo2&quot;).getOrCreate() //从指定的地址创建RDD对象 val lineRDD = spark.sparkContext.textFile(&quot;&quot;).map(_.split(&quot;\t&quot;)) //把数据与case class做匹配 val studentRDD = lineRDD.map(x =&gt; Student(x(0).toInt, x(1), x(2).toInt)) //生成DataFrame import spark.sqlContext.implicits._ val studentDF = studentRDD.toDF //注册视图 执行SQL studentDF.createOrReplaceTempView(&quot;student&quot;) spark.sql(&quot;select * from student&quot;).show spark.stop() } } //定义case class case class Student(stuId: Int, stuName: String, stuAge: Int) 复制代码 &lt;2&gt;. 写入MySQL package Demo import org.apache.spark.sql.SparkSession import org.apache.spark.sql.types.StructType import org.apache.spark.sql.types.StructField import org.apache.spark.sql.types.IntegerType import org.apache.spark.sql.types.StringType import org.apache.spark.sql.Row import org.apache.log4j.Logger import org.apache.log4j.Level import java.util.Properties /*写入MySQL*/ object Demo03 { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建Spark Session对象 val spark = SparkSession.builder().master(&quot;local&quot;).appName(&quot;Demo3&quot;).getOrCreate() //从指定的地址创建RDD对象 val lineRDD = spark.sparkContext.textFile(&quot;&quot;).map(_.split(&quot;\t&quot;)) //通过StructType方式指定Schema val schema = StructType( List( //字段与MySQL表中字段对应一致 StructField(&quot;personID&quot;, IntegerType), StructField(&quot;personName&quot;, StringType), StructField(&quot;personAge&quot;, IntegerType))) //将RDD映射到rowRDD上，映射到Schema上 val rowRDD = lineRDD.map(p =&gt; Row(p(0).toInt,p(1),p(2).toInt)) val personDataFrame = spark.createDataFrame(rowRDD, schema) personDataFrame.createOrReplaceTempView(&quot;myperson&quot;) val result = spark.sql(&quot;select * from myperson&quot;) result.show() //把结果存入到mysql中 val props = new Properties() props.setProperty(&quot;user&quot;, &quot;root&quot;) props.setProperty(&quot;password&quot;, &quot;123456&quot;) //append追加模式 result.write.mode(&quot;append&quot;).jdbc(&quot;jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;student&quot;, props) spark.stop() } } 复制代码 &lt;3&gt;. 使用Spark SQL 读取Hive中的数据，将计算结果存入mysql package Demo import org.apache.spark.sql.SparkSession import java.util.Properties /*使用Spark SQL 读取Hive中的数据，将计算结果存入mysql*/ //命令：./bin/spark-submit --master spark://node3:7077 --jars /usr/local/tmp_files/mysql-connector-java-8.0.11.jar --driver-class-path /usr/local/tmp_files/mysql-connector-java-8.0.11.jar --class day0410.Demo4 /usr/local/tmp_files/Demo4.jar object Demo4 { def main(args: Array[String]): Unit = { //创建SparkSession val spark = SparkSession.builder().appName(&quot;Demo4&quot;).enableHiveSupport().getOrCreate() //执行SQL val result = spark.sql(&quot;select deptno,count(1) from company.emp group by deptno&quot;) //将结果保存到mysql中 val props = new Properties() props.setProperty(&quot;user&quot;, &quot;root&quot;) props.setProperty(&quot;password&quot;, &quot;123456&quot;) result.write.mode(&quot;append&quot;).jdbc(&quot;jdbc:mysql://192.168.109.1:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;emp_stat&quot;, props) spark.stop() } } 复制代码 (3) Spark SQL 性能优化 &lt;1&gt;. 在内存中缓存数据 直接读取内存的值来提高性能。 通过spark.cacheTable(&quot;tableName&quot;)或者dataFrame.cache()。使用spark.uncacheTable(&quot;tableName&quot;)来从内存中去除table。 e.g.： 操作mysql，启动spark shell 时，需要： ./bin/spark-shell --master spark://node3:7077 --jars /usr/local/tmp_files/mysql-connector-java-8.0.11.jar --driver-class-path /usr/local/tmp_files/mysql-connector-java-8.0.11.jar val mysqlDF = spark.read.format(&quot;jdbc&quot;).option(&quot;driver&quot;,&quot;com.mysql.jdbc.Driver&quot;).option(&quot;url&quot;,&quot;jdbc:mysql://192.168.109.1:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;).option(&quot;user&quot;,&quot;root&quot;).option(&quot;password&quot;,&quot;123456&quot;).option(&quot;dbtable&quot;,&quot;emp&quot;).load mysqlDF.show mysqlDF.createOrReplaceTempView(&quot;emp&quot;) spark.sqlContext.cacheTable(&quot;emp&quot;) ----&gt; 标识这张表可以被缓存，数据还没有真正被缓存 spark.sql(&quot;select * from emp&quot;).show ----&gt; 依然读取mysql spark.sql(&quot;select * from emp&quot;).show ----&gt; 从缓存中读取数据 spark.sqlContext.clearCache 清空缓存后，执行查询，会触发查询mysql数据库。 复制代码 &lt;2&gt;. 性能优化相关参数 a. 将数据缓存到内存中的相关优化参数： spark.sql.inMemoryColumnarStorage.compressed 默认为 true Spark SQL 将会基于统计信息自动地为每一列选择一种压缩编码方式。 spark.sql.inMemoryColumnarStorage.batchSize 默认值：10000 缓存批处理大小。缓存数据时, 较大的批处理大小可以提高内存利用率和压缩率，但同时也会带来 OOM（Out Of Memory）的风险。 b. 其他性能相关的配置选项（不过不推荐手动修改，可能在后续版本自动的自适应修改） spark.sql.files.maxPartitionBytes 默认值：128 MB 读取文件时单个分区可容纳的最大字节数 spark.sql.files.openCostInBytes 默认值：4M 打开文件的估算成本, 按照同一时间能够扫描的字节数来测量。当往一个分区写入多个文件的时候会使用。高估更好, 这样的话小文件分区将比大文件分区更快 (先被调度)。 spark.sql.autoBroadcastJoinThreshold 默认值：10M 用于配置一个表在执行 join 操作时能够广播给所有 worker 节点的最大字节大小。通过将这个值设置为 -1 可以禁用广播。注意，当前数据统计仅支持已经运行了 ANALYZE TABLE COMPUTE STATISTICS noscan 命令的 Hive Metastore 表。 spark.sql.shuffle.partitions 默认值：200 用于配置 join 或聚合操作混洗（shuffle）数据时使用的分区数。 12. 认识 Spark Streaming (1) Spark Streaming 简介 流式计算框架（类似于Storm） 常用的实时计算引擎（流式计算） &lt;1&gt;. Apache Storm：真正的流式计算 &lt;2&gt;. Spark Streaming ：严格上来说不是真正的流式计算（实时计算），把连续的流式数据，当成不连续的RDD，本质是一个离散计算（不连续） &lt;3&gt;. Apache Flink：真正的流式计算，与Spark Streaming相反， 把离散的数据，当成流式数据来处理 &lt;4&gt;. JStorm Spark Streaming makes it easy to build scalable fault-tolerant streaming applications.（易于构建灵活的、高容错的流式系统） Spark Streaming是核心Spark API的扩展，可实现可扩展、高吞吐量、可容错的实时数据流处理。数据可以从诸如Kafka，Flume，Kinesis或TCP套接字等众多来源获取，并且可以使用由高级函数（如map，reduce，join和window）开发的复杂算法进行流数据处理。最后，处理后的数据可以被推送到文件系统，数据库和实时仪表板。而且，还可以在数据流上应用Spark提供的机器学习和图处理算法。 (2) Spark Streaming 的特点 &lt;1&gt;. 易用，已经集成到Spark中 &lt;2&gt;. 容错性：底层RDD，RDD本身具有容错机制 &lt;3&gt;. 支持多种语言：Java Scala Python (3) Spark Streaming的内部结构 在内部，它的工作原理如下。Spark Streaming接收实时输入数据流，并将数据切分成批，然后由Spark引擎对其进行处理，最后生成“批”形式的结果流。 Spark Streaming将连续的数据流抽象为discretizedstream或DStream。在内部DStream 由一个RDD序列表示。 13. Spark Streaming 基础 (1) Spark Streaming 官方示例 &lt;1&gt;. 介绍： 向Spark Streaming中发送字符串，Spark 接收到以后进行计数 &lt;2&gt;. 准备工作： netcat网络工具（yum install nc.x86_64） **注意：**总核数大于等于2，一个核心用于接收数据，另一个用于处理数据 &lt;3&gt;. 操作： 启动同一Linux系统的两个窗口，一个负责输入，一个负责监听 窗口1：nc -l 1234 （-l监听模式；1234端口号） 窗口2：run-example streaming.NetworkWordCount localhost 1234 在窗口1输入文本信息，窗口2监听并进行计数统计 (2) 自写 Spark Streaming 官方示例 MyNetworkWordCount.scala /** * * @ClassName: MyNetworkWordCount * @Description * @Author: YBCarry * @Date2019-05-13 20:49 * @Version: V1.0 * **/ import org.apache.spark.streaming.StreamingContext import org.apache.spark.SparkConf import org.apache.spark.streaming.Seconds import org.apache.spark.storage.StorageLevel import org.apache.log4j.Logger import org.apache.log4j.Level import org.apache.spark.internal.Logging /* * 自写流式计算程序 * * 知识点： * 1、创建一个StreamingContext对象 --&gt; 核心：创建一个DStream * 2、DStream的表现形式：就是一个RDD * 3、使用DStream把连续的数据流变成不连续的RDD * * spark Streaming 最核心的内容 */ object MyNetworkWordCount { def main(args: Array[String]): Unit = { //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyNetworkWordCount&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //创建DStream 从netcat服务器上接收数据 val lines = ssc.socketTextStream(&quot;172.16.194.128&quot;, 1234, StorageLevel.MEMORY_ONLY) //lines中包含了netcat服务器发送过来的数据 //分词操作 val words = lines.flatMap(_.split(&quot; &quot;)) //计数 val wordPair = words.transform(x =&gt; x.map(x =&gt; (x, 1))) //打印结果 wordPair.print() //启动StreamingContext 进行计算 ssc.start() //等待任务结束 ssc.awaitTermination() } } 复制代码 14. Spark Streaming 进阶 (1) StreamingContext对象详解 初始化StreamingContext： 方式一：从SparkConf对象中创建： 方式二：从一个现有的SparkContext实例中创建 程序中的几点说明： appName参数是应用程序在集群UI上显示的名称。 master是Spark，Mesos或YARN集群的URL，或者一个特殊的“local [*]”字符串来让程序以本地模式运行。 当在集群上运行程序时，不需要在程序中硬编码master参数，而是使用spark-submit提交应用程序并将master的URL以脚本参数的形式传入。但是，对于本地测试和单元测试，您可以通过“local[*]”来运行Spark Streaming程序（请确保本地系统中的cpu核心数够用）。 StreamingContext会内在的创建一个SparkContext的实例（所有Spark功能的起始点），你可以通过ssc.sparkContext访问到这个实例。 批处理的时间窗口长度必须根据应用程序的延迟要求和可用的集群资源进行设置。 注意： 一旦一个StreamingContextt开始运作，就不能设置或添加新的流计算。 一旦一个上下文被停止，它将无法重新启动。 同一时刻，一个JVM中只能有一个StreamingContext处于活动状态。 StreamingContext上的stop()方法也会停止SparkContext。 要仅停止StreamingContext（保持SparkContext活跃），请将stop() 方法的可选参数stopSparkContext设置为false。 只要前一个StreamingContext在下一个StreamingContext被创建之前停止（不停止SparkContext），SparkContext就可以被重用来创建多个StreamingContext。 (2) 离散流（DStreams）：Discretized Streams 把连续的数据变成不连续的RDD 因为DStream的特性，导致，Spark Streaming不是真正的流式计算 DiscretizedStream或DStream 是Spark Streaming对流式数据的基本抽象。它表示连续的数据流，这些连续的数据流可以是从数据源接收的输入数据流，也可以是通过对输入数据流执行转换操作而生成的经处理的数据流。在内部，DStream由一系列连续的RDD表示，如下图： 举例分析：在之前的NetworkWordCount的例子中，我们将一行行文本组成的流转换为单词流，具体做法为：将flatMap操作应用于名为lines的DStream中的每个RDD上，以生成words DStream的RDD。如下图所示： 但是DStream和RDD也有区别，下面画图说明： (3) 转换操作（transformation） transform(func) 通过RDD-to-RDD函数作用于源DStream中的各个RDD，可以是任意的RDD操作，从而返回一个新的RDD 举例：在NetworkWordCount中，也可以使用transform来生成元组对 updateStateByKey(func) 操作允许不断用新信息更新它的同时保持任意状态。 定义状态：状态可以是任何的数据类型 定义状态更新函数：怎样利用更新前的状态和从输入流里面获取的新值更新状态 重写NetworkWordCount程序，累计每个单词出现的频率（注意：累计） TotalNetworkWordCount.scala package test.Network import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.storage.StorageLevel import org.apache.spark.streaming.{Seconds, StreamingContext} /** * * @ClassName: TotalNetworkWordCount * @Description: 实现累加操作 * @Author: YBCarry * @Date2019-05-15 16:05 * @Version: V1.0 * **/ object TotalNetworkWordCount { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyNetworkWordCount&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //设置检查点目录，保存之前都的状态信息 ssc.checkpoint(&quot;&quot;) //创建DStream val lines = ssc.socketTextStream(&quot;bigdata01&quot;, 1234, StorageLevel.MEMORY_ONLY) //分割 val words = lines.flatMap(_.split(&quot; &quot;)) //计数 // val wordPair = words.map((_, 1)) val wordPair = words.transform( x =&gt; x.map(x =&gt; (x, 1))) //定义一个值函数 ；累加计数 /* * 接收两个参数 * currentValues —— 当前值 * previousValue ——历史值 * */ val addFunc = (currentValues : Seq[Int], previousValues : Option[Int]) =&gt; { //累加当前的序列 val currrentTotal = currentValues.sum //累加历史值 Some(currrentTotal + previousValues.getOrElse(0)) } //累加运算 val total = wordPair.updateStateByKey(addFunc) total.print() ssc.start() ssc.awaitTermination() } } 复制代码 复制代码 (4) 窗口操作 Spark Streaming还提供了窗口计算功能，允许在数据的滑动窗口上应用转换操作。下图说明了滑动窗口的工作方式： 如图所示，每当窗口滑过originalDStream时，落在窗口内的源RDD被组合并被执行操作以产生windowed DStream的RDD。在上面的例子中，操作应用于最近3个时间单位的数据，并以2个时间单位滑动。这表明任何窗口操作都需要指定两个参数。 窗口长度（windowlength） - 窗口的时间长度（上图的示例中为：3）。 滑动间隔（slidinginterval） - 两次相邻的窗口操作的间隔（即每次滑动的时间长度）（上图示例中为：2）。 这两个参数必须是源DStream的批间隔的倍数（上图示例中为：1）。 e.g.: 假设对之前的单词计数的示例进行扩展，每10秒钟对过去30秒的数据进行wordcount。则在最近30秒的pairs DStream数据中对(word, 1)键值对应用reduceByKey操作。这是通过使用reduceByKeyAndWindow操作完成的。 package test.NetworkByWindow import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.storage.StorageLevel import org.apache.spark.streaming.{Seconds, StreamingContext} /** * * @ClassName: NetworkWordCountByWindow * @Description: 每10秒读取过去30秒的数据 * @Author: YBCarry * @Date2019-05-15 17:00 * @Version: V1.0 * **/ object NetworkWordCountByWindow { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyNetworkWordCount&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //设置检查点目录，保存之前都的状态信息 ssc.checkpoint(&quot;&quot;) //创建DStream val lines = ssc.socketTextStream(&quot;bigdata01&quot;, 1234, StorageLevel.MEMORY_ONLY) //分割 每个单词计数 val words = lines.flatMap(_.split(&quot; &quot;)).map((_, 1)) /* * 窗口操作 * 参数说明：要进行的操作 窗口的大小(30s) 窗口移动距离(12s) ——&gt; 采样时间(3)的整数倍 * */ val result = words.reduceByKeyAndWindow((x : Int, y : Int) =&gt; (x + y), Seconds(30), Seconds(12)) } } 复制代码 15. Spark 数据源 (1) 输入DStreams和接收器 输入DStreams表示从数据源获取输入数据流的DStreams。在NetworkWordCount例子中，lines表示输入DStream，它代表从netcat服务器获取的数据流。每一个输入流DStream和一个Receiver对象相关联，这个Receiver从源中获取数据，并将数据存入内存中用于处理。 输入DStreams表示从数据源获取的原始数据流。Spark Streaming拥有两类数据源： 基本源（Basic sources）：这些源在StreamingContext API中直接可用。例如文件系统、套接字连接、Akka的actor等 高级源（Advanced sources）：这些源包括Kafka,Flume,Kinesis,Twitter等等。 下面通过具体的案例，详细说明： (2) 基本源 &lt;1&gt;. 文件流：通过监控文件系统的变化，若有新文件添加，则将它读入并作为数据流 注意： ① 这些文件具有相同的格式 ② 这些文件通过原子移动或重命名文件的方式在dataDirectory创建 ③ 如果在文件中追加内容，这些追加的新数据也不会被读取。 Spark Streaming监控一个文件夹，如果有变化，则把变化采集过来 import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.streaming.{Seconds, StreamingContext} /** * * @ClassName: FileStreaming * @Description * @Author: YBCarry * @Date2019-05-16 09:24 * @Version: V1.0 * **/ object FileStreaming { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyFileStreaming&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(10)) //监控目录，读取产生的新文件 val lines = ssc.textFileStream(&quot;\\Users\\apple\\学习\\SparkFiles&quot;) lines.print() ssc.start() ssc.awaitTermination() } } 复制代码 注意：需要在原文件中编辑，然后拷贝一份。 &lt;2&gt;. RDD队列流 使用streamingContext.queueStream(queueOfRDD)创建基于RDD队列的DStream，用于调试Spark Streaming应用程序。 package test.RDDQueue import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.rdd.RDD import org.apache.spark.streaming.{Seconds, StreamingContext} import scala.collection.mutable.Queue /** * * @ClassName: RDDQueueStream * @Description: RDD队列流 * @Author: YBCarry * @Date2019-05-16 10:48 * @Version: V1.0 * **/ object RDDQueueStream { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyRDDQueueStream&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //创建队列 RDD[Int] val rddQueue = new Queue[RDD[Int]]() //向队列里添加数据 (创建数据源) for (i &lt;- 1 to 3) { rddQueue += ssc.sparkContext.makeRDD(1 to 10) //便于观察 Thread.sleep(1000) } //从队列中接收数据，创建DStream val inputDStream = ssc.queueStream(rddQueue) //处理数据 val result = inputDStream.map(x =&gt; (x, x * 2)) result.print() ssc.start() ssc.awaitTermination() } } 复制代码 &lt;3&gt;. 套接字流：通过监听Socket端口来接收数据 (3) 高级源 &lt;1&gt;. Spark Streaming接收Flume数据 a. 基于Flume的Push模式: Flume被用于在Flume agents之间推送数据，在这种方式下，Spark Streaming可以很方便的建立一个receiver，起到一个Avro agent的作用。Flume可以将数据推送到改receiver。 以下为配置步骤： **第一步：**Flume的配置文件 MyFlumeStream01.conf #定义agent名， source、channel、sink的名称 a4.sources = r1 a4.channels = c1 a4.sinks = k1 #具体定义source a4.sources.r1.type = spooldir a4.sources.r1.spoolDir = /usr/local/tmp_files/logs #具体定义channel a4.channels.c1.type = memory a4.channels.c1.capacity = 10000 a4.channels.c1.transactionCapacity = 100 #具体定义sink a4.sinks = k1 a4.sinks.k1.type = avro a4.sinks.k1.channel = c1 a4.sinks.k1.hostname = bigdata01 a4.sinks.k1.port = 1234 #组装source、channel、sink a4.sources.r1.channels = c1 a4.sinks.k1.channel = c1 复制代码 **第二步：**Spark Streaming程序 package test.Flume import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.streaming.flume.FlumeUtils import org.apache.spark.streaming.{Seconds, StreamingContext} /** * * @ClassName: MyFlumeStream * @Description: flume将数据推送给Spark Streaming 使用push * @Author: YBCarry * @Date2019-05-16 14:01 * @Version: V1.0 * **/ object MyFlumeStream01 { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyRDDQueueStream&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //对接Flume //创建一个Flumeevent从flume中接收puch来的数据（也是DStream） //flume将数据push到localhost:1234，Spark Stream在这里监听 val flumeEventDStream = FlumeUtils.createStream(ssc, &quot;bigdata01&quot;, 1234) //将Flumeevent中的事件转换成字符串 val lineDStream = flumeEventDStream.map(e =&gt; { new String(e.event.getBody.array) }) //输出结果 lineDStream.print() ssc.start() ssc.awaitTermination() } } 复制代码 **第三步：**测试 启动Flume flume-ng agent -n a4 -f Spark/MyFlumeStream01.conf -c conf -Dflume.root.logger=INFO,console 启动Spark Streaming程序 拷贝日志文件到/root/training/logs目录 观察输出，采集到数据 b. 基于Custom Sink的Pull模式 不同于Flume直接将数据推送到Spark Streaming中，第二种模式通过以下条件运行一个正常的Flume sink。Flume将数据推送到sink中，并且数据保持buffered状态。Spark Streaming使用一个可靠的Flume接收器和转换器从sink拉取数据。只要当数据被接收并且被Spark Streaming备份后，转换器才运行成功。 这样,与第一种模式相比，保证了很好的健壮性和容错能力，这种模式需要为Flume配置一个正常的sink。 以下为配置步骤： **第一步：**Flume的配置文件 FlumeLogPull.conf a1.channels = c1 a1.sinks = k1 a1.sources = r1 a1.sources.r1.type = spooldir a1.sources.r1.spoolDir = /usr/local/tmp_files/logs a1.channels.c1.type = memory a1.channels.c1.capacity = 100000 a1.channels.c1.transactionCapacity = 100000 a1.sinks.k1.type = org.apache.spark.streaming.flume.sink.SparkSink a1.sinks.k1.channel = c1 a1.sinks.k1.hostname = bigdata01 a1.sinks.k1.port = 1234 #组装source、channel、sink a1.sources.r1.channels = c1 a1.sinks.k1.channel = c1 复制代码 **第二步：**Spark Streaming程序 复制代码 package test.Flume import org.apache.spark.streaming.StreamingContext import org.apache.spark.SparkConf import org.apache.spark.streaming.Seconds import org.apache.spark.storage.StorageLevel import org.apache.log4j.Logger import org.apache.log4j.Level import org.apache.spark.streaming.flume.FlumeUtils /** * @ClassName: FlumePutSink @Description: 测试pull方式 使用Spark sink @Author: YBCarry @Date2019-05-16 15:23 @Version: V1.0 **/ object FlumeLogPull { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;FlumeLogPull&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf,Seconds(3)) //创建FlumeEvent的DStream，采用pull的方式 val flumeEvent = FlumeUtils.createPollingStream(ssc, &quot;172.16.194.128&quot;,1234, StorageLevel.MEMORY_ONLY) //将FlumeEvent的事件准换成字符串 val lineDStream = flumeEvent.map( e =&gt; { new String(e.event.getBody.array) }) //输出结果 lineDStream.print() ssc.start() ssc.awaitTermination() } 复制代码 } 复制代码 **第三步：**需要的jar包 将spark-streaming-flume-sink_2.11-2.1.0.jar拷贝到Flume的lib目录下。 **第四步：**测试 启动Flume 启动Spark Streaming程序 将测试数据拷贝到/root/training/logs 观察输出 16. Spark 性能优化 (1) 概述 Spark的计算本质是分布式计算，所以，Spark程序的性能可能因为集群中的任何因素出现瓶颈：CPU、网络带宽、或者内存。如果在持久化RDD的时候，持久化了大量的数据，那么Java虚拟机的垃圾回收就可能成为一个瓶颈。Java虚拟机会定期进行垃圾回收，此时会追踪所有Java对象，并且在垃圾回收时，找到那些已经不再使用的对象。 核心：清理旧对象，给新对象腾出空间。垃圾回收的性能开销，是与内存中的对象数量成正比。 (2) spark内存分配 (3) Spark GC原理 (4) 减少批数据的执行时间 在Spark中有几个优化可以减少批处理的时间： &lt;1&gt;. 减少批数据的执行时间 在Spark中有几个优化可以减少批处理的时间： ① 数据接收的并行水平 通过网络(如kafka，flume，socket等)接收数据需要这些数据反序列化并被保存到Spark中。如果数据接收成为系统的瓶颈，就要考虑并行地接收数据。注意，每个输入DStream创建一个receiver（运行在worker机器上）接收单个数据流。创建多个输入DStream并配置它们可以从源中接收不同分区的数据流，从而实现多数据流接收。例如，接收两个topic数据的单个输入DStream可以被切分为两个kafka输入流，每个接收一个topic。这将在两个worker上运行两个receiver，因此允许数据并行接收，提高整体的吞吐量。多个DStream可以被合并生成单个DStream，这样运用在单个输入DStream的transformation操作可以运用在合并的DStream上。 ② 数据处理的并行水平 如果运行在计算stage上的并发任务数不足够大，就不会充分利用集群的资源。默认的并发任务数通过配置属性来确定spark.default.parallelism。 ③ 数据序列化 可以通过改变序列化格式来减少数据序列化的开销。在流式传输的情况下，有两种类型的数据会被序列化： 输入数据 由流操作生成的持久RDD 在上述两种情况下，使用Kryo序列化格式可以减少CPU和内存开销。 (5) 设置正确的批容量 为了Spark Streaming应用程序能够在集群中稳定运行，系统应该能够以足够的速度处理接收的数据（即处理速度应该大于或等于接收数据的速度）。这可以通过流的网络UI观察得到。批处理时间应该小于批间隔时间。 根据流计算的性质，批间隔时间可能显著的影响数据处理速率，这个速率可以通过应用程序维持。可以考虑WordCountNetwork这个例子，对于一个特定的数据处理速率，系统可能可以每2秒打印一次单词计数（批间隔时间为2秒），但无法每500毫秒打印一次单词计数。所以，为了在生产环境中维持期望的数据处理速率，就应该设置合适的批间隔时间(即批数据的容量)。 找出正确的批容量的一个好的办法是用一个保守的批间隔时间（5-10,秒）和低数据速率来测试你的应用程序。 (6) 内存调优 介绍几个比较推荐的自定义选项，它们可以减少Spark Streaming应用程序垃圾回收的相关暂停，获得更稳定的批处理时间。 **Default persistence level of DStreams：**和RDDs不同的是，默认的持久化级别是序列化数据到内存中（DStream是StorageLevel.MEMORY_ONLY_SER，RDD是StorageLevel.MEMORY_ONLY）。即使保存数据为序列化形态会增加序列化/反序列化的开销，但是可以明显的减少垃圾回收的暂停。 **Clearing persistent RDDs：**默认情况下，通过Spark内置策略（LUR），Spark Streaming生成的持久化RDD将会从内存中清理掉。如果spark.cleaner.ttl已经设置了，比这个时间存在更老的持久化RDD将会被定时的清理掉。正如前面提到的那样，这个值需要根据Spark Streaming应用程序的操作小心设置。然而，可以设置配置选项spark.streaming.unpersist为true来更智能的去持久化（unpersist）RDD。这个配置使系统找出那些不需要经常保有的RDD，然后去持久化它们。这可以减少Spark RDD的内存使用，也可能改善垃圾回收的行为。 **Concurrent garbage collector：**使用并发的标记-清除垃圾回收可以进一步减少垃圾回收的暂停时间。尽管并发的垃圾回收会减少系统的整体吞吐量，但是仍然推荐使用它以获得更稳定的批处理时间。 (7) shuffle原理 &lt;1&gt;. 优化前 &lt;2&gt;. 优化后 17. Spark MLlib库 (1) 概述 MLlib is Apache Spark&#39;s scalable machine learning library.(MLlib 是 Spark 支持 Scala 的可以扩展的机器学习库。) Spark在机器学习方面具有得天独厚的有事，有以下几个原因： &lt;1&gt;. 机器学习算法一般都有多个步骤迭代计算，需要在多次迭代后，获得足够小的误差或者收敛才会停止。 e.g.: double wucha = 1.0 while ( wucha &gt;= 0.00001 ) { 建模 wucha -= 某个值 } 模型计算完毕 复制代码 当迭代使用Hadoop的MapReduce计算框架时，每次都要读写硬盘以及任务启动工作，导致很大的IO开销。而Spark基于内存的计算模型天生擅长迭代计算，只有在必要时，才会读写硬盘，所以Spark是机器学习比较理想的平台。 &lt;2&gt;. 通信角度 Hadoop的MapReduce计算框架通过heartbeat方式来进行通信和传递数据，执行速度慢。 Spark有高效的Akka和Netty通信系统，通信效率高。 SPark MLlib 是Spark 对常用的机器学习算法的实现库，同时包括相关测试和数据生成器。 (2) 什么是机器学习 &lt;1&gt;. 定义 A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E。 机器学习(Machine Learning, ML)是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。（通过算法使计算机能够模拟人类的判别能力） **三个关键词：**算法、经验、模型评价 **应用：**金融反欺诈、语音识别、自然语言处理、翻译、模式识别、智能控制等等。 &lt;2&gt;. 机器学习工作流程 在数据的基础上，通过算法构建出模型，并进行评价 如果达到要求，则用该模型测试其他数据 如果不达到要求，要调整算法来重新建立模型，再次进行评估 循环往复，直到获得满意的经验 &lt;3&gt;. 基于大数据的机器学习 传统的机器学习算法，由于技术和单机存储的限制，依赖于数据抽样，只能在少量数据上使用。所以存在的问题是很难做好随机，从而导致学习的模型不准确。 在大数据上进行机器学习，可以直接处理全量数据并进行大量迭代计算。Spark本身计算优势，适合机器学习。此外spark-shell、pyspark都可以提供及时查询工具。 (3) MLlib MLlib是Spark机器学习库，简化机器学习的工程实践工作，方便扩展到更大规模。集成了通用的学习算法：分类、回归、聚类、协同过滤、降维等等。另外，MLlib本身在Spark中，数据清洗、SQL、建模放在一起。 转载于:https://juejin.im/post/5cd16c00e51d453a51433062" />
<link rel="canonical" href="https://uzzz.org/2019/05/07/790853.html" />
<meta property="og:url" content="https://uzzz.org/2019/05/07/790853.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-07T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"原文链接： https://juejin.im/post/5cd16c00e51d453a51433062 Linux环境Spark安装配置及使用 1. 认识Spark (1) Spark介绍 大数据计算引擎 官网：spark.apache.org/ 官方介绍：Apache Spark™ is a unified analytics engine for large-scale data processing.（Apache Spark™是一个用于大规模数据处理的统一分析引擎。） Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab，2010年开源，2013年6月成为Apache孵化项目，2014年2月成为Apache顶级项目。目前，Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、Spark Streaming、GraphX、MLlib等子项目，Spark是基于内存计算的大数据并行计算框架。Spark基于内存计算，提高了在大数据环境下数据处理的实时性，同时保证了高容错性和高可伸缩性，允许用户将Spark部署在大量廉价硬件之上，形成集群。 Spark生态圈： Spark Core：RDD（弹性分布式数据集） Spark SQL Spark Streaming Spark MLLib：协同过滤，ALS，逻辑回归等等 --&gt; 机器学习 Spark Graphx：图计算 (2) 为什么要学习Spark Hadoop的MapReduce计算模型存在的问题： MapReduce的核心是Shuffle（洗牌）。在整个Shuffle的过程中，至少会产生6次的I/O。 中间结果输出：基于MapReduce的计算引擎通常会将中间结果输出到磁盘上，进行存储和容错。另外，当一些查询（如：Hive）翻译到MapReduce任务时，往往会产生多个Stage（阶段），而这些串联的Stage又依赖于底层文件系统（如HDFS）来存储每一个Stage的输出结果，而I/O的效率往往较低，从而影响了MapReduce的运行速度。 Spark的最大特点：基于内存 Spark是MapReduce的替代方案，而且兼容HDFS、Hive，可融入Hadoop的生态系统，弥补MapReduce的不足。 (3) Spark的特点：快、易用、通用、兼容 快——与Hadoop的MapReduce相比，Spark基于内存的运算速度要快100倍以上，即使，Spark基于硬盘的运算也要快10倍。Spark实现了高效的DAG执行引擎，从而可以通过内存来高效处理数据流。 易用——Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的shell，可以非常方便地在这些shell中使用Spark集群来验证解决问题的方法。 通用——Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。Spark统一的解决方案非常具有吸引力，毕竟任何公司都想用统一的平台去处理遇到的问题，减少开发和维护的人力成本和部署平台的物力成本。另外Spark还可以很好的融入Hadoop的体系结构中可以直接操作HDFS，并提供Hive on Spark、Pig on Spark的框架集成Hadoop。 兼容——Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和ApacheMesos作为它的资源管理和调度器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase和Cassandra等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力。Spark也可以不依赖于第三方的资源管理和调度器，它实现了Standalone作为其内置的资源管理和调度框架，这样进一步降低了Spark的使用门槛，使得所有人都可以非常容易地部署和使用Spark。此外，Spark还提供了在EC2上部署Standalone的Spark集群的工具。 2. Spark体系架构 Spark的运行方式 Yarn Standalone：本机调试（demo） Worker(从节点)：每个服务器上，资源和任务的管理者，只负责管理一个节点。 执行过程： 一个Worker 有多个 Executor。 Executor是任务的执行者，按阶段（stage）划分任务。—&gt; RDD 客户端：Driver Program 提交任务到集群中。 spark-submit spark-shell 3. Spark-2.1.0安装流程 (1) 准备工作 具备java环境 配置主机名 配置免密码登录 防火墙关闭 (2) 解压spark-2.1.0-bin-hadoop2.7.tgz安装包到目标目录下： tar -zxvf .tar.gz -C 目标目录 (3) 为后续方便，重命名Spark文件夹： mv spark-2.1.0-bin-hadoop2.7/ spark-2.1.0 (4) Spark目录介绍 bin —— Spark操作命令 conf —— 配置文件 data —— Spark测试文件 examples —— Spark示例程序 jars LICENSE licenses NOTICE python R README.md RELEASE sbin —— Spark集群命令 yarn —— Spark-yarn配置 (5) 修改配置文件： &lt;1&gt;. 配置spark-env.sh： 进入spark-2.1.0/conf路径，重命名配置文件： mv spark-env.sh.template spark-env.sh 修改spark-env.sh信息： vi spark-env.sh export JAVA_HOME=/opt/module/jdk1.8.0_144 export SPARK_MASTER_HOST=bigdata01 export SPARK_MASTER_PORT=7077 复制代码 &lt;2&gt;. 配置slaves： 进入spark-2.1.0/conf路径，重命名配置文件： mv slaves.template slaves 修改slaves信息： vi slaves bigdata02 bigdata03 复制代码 (6) 配置环境变量： 修改配置文件： vi /etc/profile 增加以下内容： export SPARK_HOME=spark安装路径 export PATH=$PATH:$SPARK_HOME/bin export PATH=$PATH:$SPARK_HOME/sbin 声明环境变量： source /etc/profile (6) 集群配置： 拷贝配置好的spark到其他机器上 scp -r spark-2.1.0/ bigdata02:$PWD scp -r spark-2.1.0/ bigdata03:$PWD (7) 启动： 启动主节点： start-master.sh 启动从节点： start-slaves.sh 启动shell： spark-shell 通过网页端查看： http://bigdata01:8080/ Spark中内置有Tomcat，故端口号默认为8080 (8) 关闭： 关闭主节点： stop-master.sh 关闭从节点： stop-slaves.sh 4. Spark HA的实现 (1) 基于文件系统的单点恢复 主要用于开发或测试环境。 当spark提供目录保存spark Application和worker的注册信息，并将他们的恢复状态写入该目录中，一旦Master发生故障，就可以通过重新启动Master进程（sbin/start-master.sh），恢复已运行的spark Application和worker的注册信息。 基于文件系统的单点恢复，主要是在spark-env.sh里对SPARK_DAEMON_JAVA_OPTS设置 创建存放文件夹：mkdir /opt/module/spark-2.1.0/recovery 修改配置信息： vi spark-env.sh 增加内容：export SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=FILESYSTEM -Dspark.deploy.recoveryDirectory=/opt/module/spark-2.1.0/recovery&quot; (2) 基于Zookeeper的Standby Masters 适用于现实生产。 ZooKeeper提供了一个Leader Election机制，利用这个机制可以保证虽然集群存在多个Master，但是只有一个是Active的，其他的都是Standby。当Active的Master出现故障时，另外的一个Standby Master会被选举出来。由于集群的信息，包括Worker，Driver和Application的信息都已经持久化到ZooKeeper，因此在切换的过程中只会影响新Job的提交，对于正在进行的Job没有任何的影响。加入ZooKeeper的集群整体架构如下图所示： 修改配置信息： vi spark-env.sh 增加内容：export SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=bigdata01:2181,bigdata02:2181,bigdata03:2181 -Dspark.deploy.zookeeper.dir=/spark&quot; 注释掉：export SPARK_MASTER_HOST和export SPARK_MASTER_PORT 发送新的配置文件到集群其余节点： scp spark-env.sh bigdata02:$PWD scp spark-env.sh bigdata03:$PWD 5. 执行Spark的任务 (1) spark-submit 用于提交Spark的任务（任务即相关jar包） e.g.: 蒙特卡洛求PI（圆周率） 原理：如下图所示，随机向正方形内落点，通过统计正方形内所有点数和落入圆内的点数来计算占比，得出正方形与圆的面积近似比值，进而近似出PI值。 命令： spark-submit --master spark://XXXX:7077 （指明master地址） --class org.apache.spark.examples.SparkPi （指明主程序的名字） /XXXX/spark/examples/jars/spark-examples_2.11-2.1.0.jar（指明jar包地址） 100（指明运行次数） (2) spark-shell 相当于REPL，作为一个独立的Application运行 spark-shell是Spark自带的交互式Shell程序，方便用户进行交互式编程，用户可以在该命令行下用scala编写spark程序。 参数说明： --master spark://XXXX:7077 指定Master的地址 --executor-memory 2g 指定每个worker可用内存为2G --total-executor-cores 2 指定整个集群使用的cup核数为2个 Spark Session 是 2.0 以后提供的，利用 SparkSession 可以访问spark所有组件 两种运行模式： &lt;1&gt;. 本地模式 启动：spark-shell（后面不接任何参数） &lt;2&gt;. 集群模式 启动：spark-shell --master spark://XXXX:7077（指明master地址） e.g.: 编写WordCount程序 &lt;1&gt;. 处理本地文件，把结果打印到屏幕上 启动：spark-shell 传入文件：sc.textFile(&quot;/XXXX/WordCount.txt&quot;)（本地文件路径）.flatMap(_.split(&quot; &quot;))（按照空格分割）.map((_,1))（单词遍历）.reduceByKey(_+_)（单词计数）.collect &lt;2&gt;. 处理HDFS文件，结果保存在hdfs上 启动：spark-shell --master spark://XXXX:7077（指 sc.textFile(&quot;hdfs://XXXX:9000/sp_wc.txt&quot;).flatMap(.split(&quot; &quot;)).map((,1)).reduceByKey(+).saveAsTextFile(&quot;hdfs://XXXX:9000/output/spark/WordCount&quot;) (3) 单步运行WordCount -&gt; RDD 启动shell：spark-shell scala&gt; val rdd1 = sc.textFile(&quot;/root/sp_wc.txt&quot;) rdd1: org.apache.spark.rdd.RDD[String] = /root/sp_wc.txt MapPartitionsRDD[1] at textFile at &lt;console&gt;:24 scala&gt; rdd1.collect res0: Array[String] = Array(I love Scala, I love Skark, 2019/5/8) scala&gt; val rdd2 = rdd1.flatMap(_.split(&quot; &quot;)) rdd2: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[2] at flatMap at &lt;console&gt;:26 scala&gt; rdd2.collect res1: Array[String] = Array(I, love, Scala, I, love, Skark, 2019/5/8) scala&gt; val rdd3 = rdd2.map((_,1)) rdd3: org.apache.spark.rdd.RDD[(String, Int)] = MapPartitionsRDD[3] at map at &lt;console&gt;:28 scala&gt; rdd3.collect res2: Array[(String, Int)] = Array((I,1), (love,1), (Scala,1), (I,1), (love,1), (Skark,1), (2019/5/8,1)) scala&gt; val rdd4 = rdd3.reduceByKey(_+_) rdd4: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[4] at reduceByKey at &lt;console&gt;:30 scala&gt; rdd4.collect res3: Array[(String, Int)] = Array((2019/5/8,1), (love,2), (I,2), (Skark,1), (Scala,1)) 复制代码 (4) 在IDE中运行WorkCount &lt;1&gt;. scala版本 import org.apache.spark.SparkConf import org.apache.spark.SparkContext object WordCount { def main(args: Array[String]): Unit = { //创建一个Spark配置文件 val conf = new SparkConf().setAppName(&quot;Scala WordCount&quot;).setMaster(&quot;local&quot;) //创建Spark对象 val sc = new SparkContext(conf) val result = sc.textFile(args(0)) .flatMap(_.split(&quot; &quot;)) .map((_, 1)) .reduceByKey(_ + _) .saveAsTextFile(args(1)) sc.stop() } } 复制代码 &lt;2&gt;. Java版本 import java.util.Arrays; import java.util.Iterator; import java.util.List; import org.apache.spark.SparkConf; import org.apache.spark.api.java.JavaPairRDD; import org.apache.spark.api.java.JavaRDD; import org.apache.spark.api.java.JavaSparkContext; import org.apache.spark.api.java.function.FlatMapFunction; import org.apache.spark.api.java.function.Function2; import org.apache.spark.api.java.function.PairFunction; import parquet.format.PageHeader; import scala.Tuple2; public class WordCount { public static void main(String[] args) { // TODO Auto-generated method stub SparkConf conf = new SparkConf() .setAppName(&quot;JavaWordCount&quot;) .setMaster(&quot;local&quot;) ; //新建SparkContext对象 JavaSparkContext sc = new JavaSparkContext(conf) ; //读入数据 JavaRDD&lt;String&gt; lines = sc.textFile(&quot;hdfs://XXXX:9000/WordCount.txt&quot;) ; //分词 第一个参数表示读进来的话 第二个参数表示 返回值 JavaRDD&lt;String&gt; words = lines.flatMap(new FlatMapFunction&lt;String, String&gt;() { @Override public Iterator&lt;String&gt; call(String input) throws Exception { return Arrays.asList(input.split(&quot; &quot;)).iterator() ; } }) ; //每个单词记一次数 /* * String, String, Integer * input &lt;key value&gt; */ JavaPairRDD&lt;String, Integer&gt; ones = words.mapToPair(new PairFunction&lt;String, String, Integer&gt;() { @Override public Tuple2&lt;String, Integer&gt; call(String input) throws Exception { return new Tuple2&lt;String, Integer&gt;(input, 1) ; } }) ; //执行reduce操作 /* * Integer, Integer, Integer * nteger arg0, Integer arg1 返回值 */ JavaPairRDD&lt;String,Integer&gt; counts = ones.reduceByKey(new Function2&lt;Integer, Integer, Integer&gt;() { @Override public Integer call(Integer arg0, Integer arg1) throws Exception { // TODO Auto-generated method stub return arg0 + arg1 ; } }) ; //打印结果 List&lt;Tuple2&lt;String, Integer&gt;&gt; output = counts.collect() ; for (Tuple2&lt;String, Integer&gt; tuple :output) { System.out.println(tuple._1 + &quot; : &quot; + tuple._2) ; } sc.stop() ; } } 复制代码 (5) WordCount程序处理过程 (6) Spark提交任务的流程 6. Spark的算子 (1) RDD基础 &lt;1&gt;. 什么是RDD RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合。RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度。 &lt;2&gt;. RDD的属性（源码中的一段话） **一组分片（Partition）。**即数据集的基本组成单位。对于RDD来说，每个分片都会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的分片个数，如果没有指定，那么就会采用默认值。默认值就是程序所分配到的CPU Core的数目。 **一个计算每个分区的函数。**Spark中RDD的计算是以分片为单位的，每个RDD都会实现compute函数以达到这个目的。compute函数会对迭代器进行复合，不需要保存每次计算的结果。 **RDD之间的依赖关系。**RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。 **一个Partitioner，即RDD的分片函数。**当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。只有对于于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。 **一个列表。**存储存取每个Partition的优先位置（preferred location）。对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。 &lt;3&gt;. RDD的创建方式 通过外部的数据文件创建，如HDFS： val rdd1 = sc.textFile(“hdfs://XXXX:9000/data.txt”) 通过sc.parallelize进行创建： val rdd1 = sc.parallelize(Array(1,2,3,4,5,6,7,8)) DD的类型：Transformation和Action &lt;4&gt;. RDD的基本原理 (2) Transformation RDD中的所有转换都是延迟加载的，也就是说，它们并不会直接计算结果。相反的，它们只是记住这些应用到基础数据集（例如一个文件）上的转换动作。只有当发生一个要求返回结果给Driver的动作时，这些转换才会真正运行。这种设计让Spark更加有效率地运行。 (3) Action (4) RDD的缓存机制 RDD通过persist方法或cache方法可以将前面的计算结果缓存，但是并不是这两个方法被调用时立即缓存，而是触发后面的action时，该RDD将会被缓存在计算节点的内存中，并供后面重用。 通过查看源码发现cache最终也是调用了persist方法，默认的存储级别都是仅在内存存储一份，Spark的存储级别还有好多种，存储级别在object StorageLevel中定义的。 缓存有可能丢失，或者存储存储于内存的数据由于内存不足而被删除，RDD的缓存容错机制保证了即使缓存丢失也能保证计算的正确执行。通过基于RDD的一系列转换，丢失的数据会被重算，由于RDD的各个Partition是相对独立的，因此只需要计算丢失的部分即可，并不需要重算全部Partition。 Demo示例： 通过UI进行监控： (5) RDD的Checkpoint（检查点）机制：容错机制 检查点（本质是通过将RDD写入Disk做检查点）是为了通过lineage（血统）做容错的辅助，lineage过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果之后有节点出现问题而丢失分区，从做检查点的RDD开始重做Lineage，就会减少开销。 设置checkpoint的目录，可以是本地的文件夹、也可以是HDFS。一般是在具有容错能力，高可靠的文件系统上(比如HDFS, S3等)设置一个检查点路径，用于保存检查点数据。 分别举例说明： &lt;1&gt;. 本地目录 注意：这种模式，需要将spark-shell运行在本地模式上 &lt;2&gt;. HDFS的目录 注意：这种模式，需要将spark-shell运行在集群模式上 (6) RDD的依赖关系和Spark任务中的Stage RDD的依赖关系 RDD和它依赖的父RDD（s）的关系有两种不同的类型，即窄依赖（narrow dependency）和宽依赖（wide dependency）。 窄依赖指的是每一个父RDD的Partition最多被子RDD的一个Partition使用 总结：窄依赖我们形象的比喻为独生子女 宽依赖指的是多个子RDD的Partition会依赖同一个父RDD的Partition 总结：窄依赖我们形象的比喻为超生 Spark任务中的Stage DAG(Directed Acyclic Graph)叫做有向无环图，原始的RDD通过一系列的转换就就形成了DAG，根据RDD之间的依赖关系的不同将DAG划分成不同的Stage，对于窄依赖，partition的转换处理在Stage中完成计算。对于宽依赖，由于有Shuffle的存在，只能在parent RDD处理完成后，才能开始接下来的计算，因此宽依赖是划分Stage的依据。 (7) RDD基础练习 练习1： //通过并行化生成rdd val rdd1 = sc.parallelize(List(5, 6, 4, 7, 3, 8, 2, 9, 1, 10)) //对rdd1里的每一个元素乘2然后排序 val rdd2 = rdd1.map(_ * 2).sortBy(x =&gt; x, true) //过滤出大于等于十的元素 val rdd3 = rdd2.filter(_ &gt;= 10) //将元素以数组的方式在客户端显示 rdd3.collect 复制代码 练习2： val rdd1 = sc.parallelize(Array(&quot;a b c&quot;, &quot;d e f&quot;, &quot;h i j&quot;)) //将rdd1里面的每一个元素先切分在压平 val rdd2 = rdd1.flatMap(_.split(&#39; &#39;)) rdd2.collect 复制代码 练习3： val rdd1 = sc.parallelize(List(5, 6, 4, 3)) val rdd2 = sc.parallelize(List(1, 2, 3, 4)) //求并集 val rdd3 = rdd1.union(rdd2) //求交集 val rdd4 = rdd1.intersection(rdd2) //去重 rdd3.distinct.collect rdd4.collect 复制代码 练习4： val rdd1 = sc.parallelize(List((&quot;tom&quot;, 1), (&quot;jerry&quot;, 3), (&quot;kitty&quot;, 2))) val rdd2 = sc.parallelize(List((&quot;jerry&quot;, 2), (&quot;tom&quot;, 1), (&quot;shuke&quot;, 2))) //求jion val rdd3 = rdd1.join(rdd2) rdd3.collect //求并集 val rdd4 = rdd1 union rdd2 //按key进行分组 rdd4.groupByKey rdd4.collect 复制代码 练习5： val rdd1 = sc.parallelize(List((&quot;tom&quot;, 1), (&quot;tom&quot;, 2), (&quot;jerry&quot;, 3), (&quot;kitty&quot;, 2))) val rdd2 = sc.parallelize(List((&quot;jerry&quot;, 2), (&quot;tom&quot;, 1), (&quot;shuke&quot;, 2))) //cogroup val rdd3 = rdd1.cogroup(rdd2) //注意cogroup与groupByKey的区别 rdd3.collect 复制代码 练习6： val rdd1 = sc.parallelize(List(1, 2, 3, 4, 5)) //reduce聚合 val rdd2 = rdd1.reduce(_ + _) rdd2.collect 复制代码 练习7： val rdd1 = sc.parallelize(List((&quot;tom&quot;, 1), (&quot;jerry&quot;, 3), (&quot;kitty&quot;, 2), (&quot;shuke&quot;, 1))) val rdd2 = sc.parallelize(List((&quot;jerry&quot;, 2), (&quot;tom&quot;, 3), (&quot;shuke&quot;, 2), (&quot;kitty&quot;, 5))) val rdd3 = rdd1.union(rdd2) //按key进行聚合 val rdd4 = rdd3.reduceByKey(_ + _) rdd4.collect //按value的降序排序 val rdd5 = rdd4.map(t =&gt; (t._2, t._1)).sortByKey(false).map(t =&gt; (t._2, t._1)) rdd5.collect 复制代码7. Spark RDD的高级算子 (1) mapPartitionsWithIndex 把每个partition中的分区号和对应的值拿出来 def mapPartitionsWithIndex[U](f: (Int, Iterator[T]) ⇒ Iterator[U], preservesPartitioning: Boolean = false)(implicit arg0: ClassTag[U]): RDD[U] f中函数参数： 第一个参数是Int，代表分区号 第二个Iterator[T]代表分区中的元素 e.g.: 将每个分区中的元素和分区号打印出来 val rdd1 = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 2) 创建一个函数返回RDD中的每个分区号和元素： def func1(index:Int, iter:Iterator[Int]):Iterator[String] ={ iter.toList.map( x =&gt; &quot;[PartID:&quot; + index + &quot;, value=&quot; + x + &quot;]&quot; ).iterator } 复制代码 调用：rdd1.mapPartitionsWithIndex(func1).collect (2) aggregate 先对局部聚合，再对全局聚合 e.g.: val rdd1 = sc.parallelize(List(1,2,3,4,5), 2) 查看每个分区中的元素： scala&gt; rdd1.mapPartitionsWithIndex(fun1).collect res4: Array[String] = Array( [partId : 0 , value = 1 ], [partId : 0 , value = 2 ], [partId : 1 , value = 3 ], [partId : 1 , value = 4 ], [partId : 1 , value = 5 ]) 复制代码 将每个分区中的最大值求和，注意初始值是0: scala&gt; rdd2.aggregate(0)(max(_,_),_+_) res6: Int = 7 复制代码 如果初始值时候100，则结果为300: scala&gt; rdd2.aggregate(100)(max(_,_),_+_) res8: Int = 300 ``` 复制代码 如果是求和，注意初始值是0： scala&gt; rdd2.aggregate(0)(_+_,_+_) res9: Int = 15 复制代码 如果初始值是10，则结果是45 scala&gt; rdd2.aggregate(10)(_+_,_+_) res10: Int = 45 复制代码 e.g. —— 字符串： val rdd2 = sc.parallelize(List(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;),2) 修改一下刚才的查看分区元素的函数 def func2(index: Int, iter: Iterator[(String)]) : Iterator[String] = { iter.toList.map(x =&gt; &quot;[partID:&quot; + index + &quot;, val: &quot; + x + &quot;]&quot;).iterator } 复制代码 两个分区中的元素： [partID:0, val: a], [partID:0, val: b], [partID:0, val: c], [partID:1, val: d], [partID:1, val: e], [partID:1, val: f] 复制代码 运行结果： e.g.: val rdd3 = sc.parallelize(List(&quot;12&quot;,&quot;23&quot;,&quot;345&quot;,&quot;4567&quot;),2) rdd3.aggregate(&quot;&quot;)((x,y) =&gt; math.max(x.length, y.length).toString, (x,y) =&gt; x + y) 复制代码 结果可能是24，也可能是42 val rdd4 = sc.parallelize(List(&quot;12&quot;,&quot;23&quot;,&quot;345&quot;,&quot;&quot;),2) rdd4.aggregate(&quot;&quot;)((x,y) =&gt; math.min(x.length, y.length).toString, (x,y) =&gt; x + y) 复制代码 结果是10，也可能是01 原因：注意有个初始值&quot;&quot;，其长度0，然后0.toString变成字符串 val rdd5 = sc.parallelize(List(&quot;12&quot;,&quot;23&quot;,&quot;&quot;,&quot;345&quot;),2) rdd5.aggregate(&quot;&quot;)((x,y) =&gt; math.min(x.length, y.length).toString, (x,y) =&gt; x + y) 复制代码 结果是11，原因同上。 (3) aggregateByKey 准备数据： val pairRDD = sc.parallelize(List( (&quot;cat&quot;,2), (&quot;cat&quot;, 5), (&quot;mouse&quot;, 4),(&quot;cat&quot;, 12), (&quot;dog&quot;, 12), (&quot;mouse&quot;, 2)), 2) def func3(index: Int, iter: Iterator[(String, Int)]) : Iterator[String] = { iter.toList.map(x =&gt; &quot;[partID:&quot; + index + &quot;, val: &quot; + x + &quot;]&quot;).iterator } 复制代码 两个分区中的元素： e.g.: 将每个分区中的动物最多的个数求和 scala&gt; pairRDD.aggregateByKey(0)(math.max(_, _), _ + _).collect res69: Array[(String, Int)] = Array((dog,12), (cat,17), (mouse,6)) 复制代码 将每种动物个数求和 scala&gt; pairRDD.aggregateByKey(0)(_+_, _ + _).collect res71: Array[(String, Int)] = Array((dog,12), (cat,19), (mouse,6)) 复制代码 这个例子也可以使用：reduceByKey scala&gt; pairRDD.reduceByKey(_+_).collect res73: Array[(String, Int)] = Array((dog,12), (cat,19), (mouse,6)) 复制代码 (4) coalesce与repartition 都是将RDD中的分区进行重分区。 区别： coalesce默认不会进行shuffle（false）； repartition会进行shuffle（true），会将数据真正通过网络进行重分区。 e.g.: def func4(index: Int, iter: Iterator[(Int)]) : Iterator[String] = { iter.toList.map(x =&gt; &quot;[partID:&quot; + index + &quot;, val: &quot; + x + &quot;]&quot;).iterator } val rdd1 = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 2) 下面两句话是等价的： val rdd2 = rdd1.repartition(3) val rdd3 = rdd1.coalesce(3,true) -&gt; 如果是false，查看RDD的length依然是2 复制代码 (5) 其他高级算子 参考：homepage.cs.latrobe.edu.au/zhe/ZhenHeS… 8. Spark 基础编程案例 (1) 求网站的访问量 Tomcat的访问日志如下： 需求：找到访问量最高的两个网页，要求显示网页名称和访问量 步骤分析： &lt;1&gt;. 对网页的访问量求和 &lt;2&gt;. 降序排序 代码： import org.apache.spark.SparkConf import org.apache.spark.SparkContext object TomcatLogCount { def main(args: Array[String]): Unit = { val conf = new SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;TomcatLogCount&quot;) val sc = new SparkContext(conf) /* * 读入日志并解析 * * 192.168.88.1 - - [30/Jul/2017:12:54:37 +0800] &quot;GET /MyDemoWeb/oracle.jsp HTTP/1.1&quot; 200 242 * */ val rdd1 = sc.textFile(&quot; &quot;).map( line =&gt; { //解析字符串，得到jsp的名字 //1. 解析两个引号间的字符串 val index1 = line.indexOf(&quot;\\&quot;&quot;) val index2 = line.lastIndexOf(&quot;\\&quot;&quot;) //line1 = GET /MyDemoWeb/oracle.jsp HTTP/1.1 val line1 = line.substring(index1 + 1, index2) val index3 = line1.indexOf(&quot; &quot;) val index4 = line1.lastIndexOf(&quot; &quot;) //line2 = /MyDemoWeb/oracle.jsp val line2 = line1.substring(index3 + 1, index4) //得到jsp的名字 oracle.jsp val jspName = line2.substring(line2.lastIndexOf(&quot;/&quot;)) (jspName, 1) } ) //统计每个jsp的次数 val rdd2 = rdd1.reduceByKey(_+_) //使用Value排序 val rdd3 = rdd2.sortBy(_._2, false) //得到次数最多的两个jsp rdd3.take(2).foreach(println) sc.stop() } } 复制代码 (2) 创建自定义分区 根据jsp文件的名字，将各自的访问日志放入到不同的分区文件中，如下： 生成的分区文件 如：part-00000文件中的内容：只包含了web.jsp的访问日志 代码： import org.apache.spark.SparkConf import org.apache.spark.SparkContext import scala.collection.mutable.HashMap object TomcatLogPartitioner { def main(args: Array[String]): Unit = { val conf = new SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;TomcatLogPartitioner&quot;) val sc = new SparkContext(conf) /* * 读入日志并解析 * * 192.168.88.1 - - [30/Jul/2017:12:54:37 +0800] &quot;GET /MyDemoWeb/oracle.jsp HTTP/1.1&quot; 200 242 * */ val rdd1 = sc.textFile(&quot; &quot;).map( line =&gt; { //解析字符串，得到jsp的名字 //1. 解析两个引号间的字符串 val index1 = line.indexOf(&quot;\\&quot;&quot;) val index2 = line.lastIndexOf(&quot;\\&quot;&quot;) //line1 = GET /MyDemoWeb/oracle.jsp HTTP/1.1 val line1 = line.substring(index1 + 1, index2) val index3 = line1.indexOf(&quot; &quot;) val index4 = line1.lastIndexOf(&quot; &quot;) //line2 = /MyDemoWeb/oracle.jsp val line2 = line1.substring(index3 + 1, index4) //得到jsp的名字 oracle.jsp val jspName = line2.substring(line2.lastIndexOf(&quot;/&quot;)) (jspName, line) } ) //得到不重复的jsp名字 val rdd2 = rdd1.map(_._1).distinct().collect() //创建分区规则 val wepPartitioner = new WepPartitioner(rdd2) val rdd3 = rdd1.partitionBy(wepPartitioner) //输出rdd3 rdd3.saveAsTextFile(&quot; &quot;) } //定义分区规则 class WepPartitioner(jspList : Array[String]) extends Partitioner { /* * 定义集合来保存分区条件: * String 代表jsp的名字 * Int 代表序号 * */ val partitionMap = new HashMap[String, Int]() //初始分区号 val partID = 0 //填值 for (jsp &lt;- jspList) { patitionMap.put(jsp, partID) partID += 1 } //返回分区个数 def numPartitioners : Int = partitionMap.size //根据jsp，返回对应的分区 def getPartition(key : Any) : Int = partitionMap.getOrElse(key.toString(), 0) } } 复制代码 (3) 使用JDBCRDD 访问数据库 JdbcRDD参数说明： 从上面的参数说明可以看出，JdbcRDD有以下两个缺点： &lt;1&gt;. 执行的SQL必须有两个参数，并类型都是Long &lt;2&gt;. 得到的结果是ResultSet，即：只支持select操作 代码： import org.apache.spark.SparkConf import org.apache.spark.SparkContext import java.sql.Connection import java.sql.DriverManager import java.sql.PreparedStatement /* * 把Spark结果存放到mysql数据库中 * */ object TomcatLogCountToMysql { def main(args: Array[String]): Unit = { //创建SparkContext val conf = new SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;MyTomcatLogCountToMysql&quot;) val sc = new SparkContext(conf) /* * * 读入日志 解析： * * 192.168.88.1 - - [30/Jul/2017:12:54:37 +0800] &quot;GET /MyDemoWeb/oracle.jsp HTTP/1.1&quot; 200 242 */ val rdd1 = sc.textFile(&quot;H:\\\\tmp_files\\\\localhost_access_log.txt&quot;) .map( line =&gt; { //解析字符串，得到jsp的名字 //1、解析两个引号之间的字符串 val index1 = line.indexOf(&quot;\\&quot;&quot;) val index2 = line.lastIndexOf(&quot;\\&quot;&quot;) val line1 = line.substring(index1 + 1, index2) // GET /MyDemoWeb/oracle.jsp HTTP/1.1 //得到两个空格的位置 val index3 = line1.indexOf(&quot; &quot;) val index4 = line1.lastIndexOf(&quot; &quot;) val line2 = line1.substring(index3 + 1, index4) // /MyDemoWeb/oracle.jsp //得到jsp的名字 val jspName = line2.substring(line2.lastIndexOf(&quot;/&quot;)) // oracle.jsp (jspName, 1) }) // // try { // /* // * create table mydata(jsname varchar(50),countNumber Int) // * // * foreach 没有返回值，在本需求中，只需要写数据库，不需要返回新的RDD，所以用foreach即可 // * // * // * 运行 Task not serializable // */ // conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;123456&quot;) // pst = conn.prepareStatement(&quot;insert into mydata values(?,?)&quot;) // // rdd1.foreach(f =&gt; { // pst.setString(1, f._1) // pst.setInt(2, f._2) // // pst.executeUpdate() // }) // } catch { // case t: Throwable =&gt; t.printStackTrace() // } finally { // if (pst != null) pst.close() // if (conn != null) conn.close() // } // // sc.stop() // //存入数据库 // var conn: Connection = null // var pst: PreparedStatement = null // //第一种修改方法 // /* // * 修改思路： // * conn pst 让每一个节点都是用到，需要在不同的节点上传输，实现sericalizable接口 // */ // try { // rdd1.foreach(f =&gt; { // conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;123456&quot;) // pst = conn.prepareStatement(&quot;insert into mydata values(?,?)&quot;) // // pst.setString(1, f._1) // pst.setInt(2, f._2) // // pst.executeUpdate() // }) // } catch { // case t: Throwable =&gt; t.printStackTrace() // } finally { // if (pst != null) pst.close() // if (conn != null) conn.close() // } // // sc.stop() /* * 第一种修改方式，功能上可以实现，但每条数据都会创建连接，对数据库造成很大压力 * * 针对分区来操作：一个分区，建立一个连接即可 */ rdd1.foreachPartition(saveToMysql) sc.stop() } def saveToMysql(it: Iterator[(String, Int)]) = { var conn: Connection = null var pst: PreparedStatement = null try { conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;123456&quot;) pst = conn.prepareStatement(&quot;insert into mydata values(?,?)&quot;) it.foreach(f =&gt; { pst.setString(1, f._1) pst.setInt(2, f._2) pst.executeUpdate() }) } catch { case t: Throwable =&gt; t.printStackTrace() } finally { if (pst != null) pst.close() if (conn != null) conn.close() } } } 复制代码9. 认识 Spark SQL (1) 什么是Spark SQL Spark SQL is Apache Spark&#39;s module for working with structured data.（Spark SQL 是spark 的一个模块，用来处理 结构化的数据。&lt;不能处理非结构化的数据&gt;） Spark SQL是Spark用来处理结构化数据的一个模块，它提供了一个编程抽象叫做DataFrame并且作为分布式SQL查询引擎的作用。 (2) 为什么要学习Spark SQL Hive是将HQL转换成MapReduce然后提交到集群上执行，大大简化了编写MapReduce的程序的复杂性，但是MapReduce这种计算模型执行效率比较慢。所以Spark SQL的应运而生，它是将Spark SQL转换成RDD，然后提交到集群执行，执行效率非常快，同时Spark SQL也支持从Hive中读取数据，Hive 2.x 执行引擎可以使用Spark。 (3) Spark SQL的特点： &lt;1&gt;. 容易集成 不需要单独安装。 &lt;2&gt;. 统一的数据访问方式 结构化数据（JDBC、JSon、Hive、parquer文件）都可以作为Spark SQL 的数据源。 对接多种数据源，且使用方式类似。 &lt;3&gt;. 兼容Hive 把Hive中的数据，读取到Spark SQL中运行。 &lt;4&gt;. 支持标准的数据连接（JDBC） 10. Spark SQL 基础 (1) 基本概念：Datasets和DataFrames &lt;1&gt;. DataFrame DataFrame是组织成命名列的数据集。它在概念上等同于关系数据库中的表，但在底层具有更丰富的优化。DataFrames可以从各种来源构建， 例如： 结构化数据文件 Hive中的表 外部数据库或现有RDDs DataFrame API支持的语言有Scala，Java，Python和R。 从上图可以看出，DataFrame多了数据的结构信息，即schema。RDD是分布式的 Java对象的集合。DataFrame是分布式的Row对象的集合。DataFrame除了提供了比RDD更丰富的算子以外，更重要的特点是提升执行效率、减少数据读取以及执行计划的优化。 &lt;2&gt;. Datasets Dataset是数据的分布式集合。Dataset是在Spark 1.6中添加的一个新接口，是DataFrame之上更高一级的抽象。它提供了RDD的优点（强类型化，使用强大的lambda函数的能力）以及Spark SQL优化后的执行引擎的优点。一个Dataset 可以从JVM对象构造，然后使用函数转换（map， flatMap，filter等）去操作。Dataset API 支持Scala和Java，Python不支持Dataset API。 (2) DataFrames &lt;1&gt;. 创建 DataFrames a. 通过Case Class创建DataFrames ① 定义case class（相当于表的结构：Schema） case class Emp(empno:Int,ename:String,job:String,mgr:Int,hiredate:String,sal:Int,comm:Int,deptno:Int) 注意：由于mgr和comm列中包含null值，简单起见，将对应的case class类型定义为String ② 将HDFS上的数据读入RDD，并将RDD与case Class关联 val lines = sc.textFile(&quot;/XXXX/emp.csv&quot;).map(_.split(&quot;,&quot;)) ③ 将RDD转换成DataFrames val allEmp = lines.map(x =&gt; Emp(x(0).toInt,x(1),x(2),x(3).toInt,x(4),x(5).toInt,x(6).toInt,x(7).toInt)) ④ 通过DataFrames查询数据 val df1 = allEmp.toDF df1.show b. 使用SparkSession 什么是SparkSession Apache Spark 2.0引入了SparkSession，其为用户提供了一个统一的切入点来使用Spark的各项功能，并且允许用户通过它调用DataFrame和Dataset相关API来编写Spark程序。最重要的是，它减少了用户需要了解的一些概念，使得我们可以很容易地与Spark交互。 在2.0版本之前，与Spark交互之前必须先创建SparkConf和SparkContext。然而在Spark 2.0中，我们可以通过SparkSession来实现同样的功能，而不需要显式地创建SparkConf, SparkContext 以及 SQLContext，因为这些对象已经封装在SparkSession中。   - 创建StructType，来定义Schema结构信息 注意：需要import org.apache.spark.sql.types._，import org.apache.spark.sql.Row import org.apache.spark.sql.types._ val myschema = StructType( List( StructField(&quot;empno&quot;,DataTypes.IntegerType), StructField(&quot;ename&quot;,DataTypes.StringType), StructField(&quot;job&quot;,DataTypes.StringType), StructField(&quot;mgr&quot;,DataTypes.IntegerType), StructField(&quot;hiredate&quot;,DataTypes.StringType), StructField(&quot;sal&quot;,DataTypes.IntegerType), StructField(&quot;comm&quot;,DataTypes.IntegerType), StructField(&quot;deptno&quot;,DataTypes.IntegerType), )) val allEmp = lines.map(x =&gt; Row(x(0).toInt,x(1),x(2),x(3).toInt,x(4),x(5).toInt,x(6).toInt,x(7).toInt)) import org.apache.spark.sql.Row val df2 = spark.createDataFrame(allEmp,myschema) 复制代码 c. 使用JSon文件来创建DataFame val df3 = spark.read 读文件，默认是Parquet文件 val df3 = spark.read.json(&quot;/XXXX/people.json&quot;) 读json文件 df3.show val df4 = spark.read.format(&quot;json&quot;).load(&quot;/XXXX/people.json&quot;) 复制代码 &lt;2&gt;. DataFrame 操作 DataFrame操作也称为无类型的Dataset操作 a. DSL语句 查询所有的员工姓名 查询所有的员工姓名和薪水，并给薪水加100块钱 查询工资大于2000的员工 求每个部门的员工人数 参考：spark.apache.org/docs/2.1.0/… b. SQL语句 **注意：**不能直接执行SQL，需要生成一个视图，再执行sql。 ① 将DataFrame注册成表（视图）：df.createOrReplaceTempView(&quot;emp&quot;) ② 执行查询： spark.sql(&quot;select * from emp&quot;).show spark.sql(&quot;select * from emp where deptno=10&quot;).show spark.sql(&quot;select deptno,sum(sal) from emp group by deptno&quot;).show (3) Spark SQL 中的视图 视图是一个虚表，不存储数据。 两种类型： &lt;1&gt;. 普通视图（本地视图）——createOrReplaceTempView 只在当前Session中有效。 &lt;2&gt;. 全局视图： ——createGlobalTempView 在Spark SQL中，如果想拥有一个临时的view，并想在不同的Session中共享，而且在application的运行周期内可用，那么就需要创建一个全局的临时view。并记得使用的时候加上global_temp作为前缀来引用它，因为全局的临时view是绑定到系统保留的数据库global_temp上。 e.g.: ``` 创建一个新session，读取不到emp视图 spark.newSession.sql(&quot;select * from emp&quot;) 以下两种方式均可读到 全局视图 中的数据: df1.createGlobalTempView(&quot;emp1&quot;) spark.newSession.sql(&quot;select * from global_temp.emp1&quot;).show spark.sql(&quot;select * from global_temp.emp1&quot;).show 复制代码 复制代码 (4) 创建Datasets DataFrame的引入，可以让Spark更好的处理结构数据的计算，但其中一个主要的问题是：缺乏编译时类型安全。为了解决这个问题，Spark采用新的Dataset API (DataFrame API的类型扩展)。 Dataset是一个分布式的数据收集器。这是在Spark1.6之后新加的一个接口，兼顾了RDD的优点（强类型，可以使用功能强大的lambda）以及Spark SQL的执行器高效性的优点。所以可以把DataFrames看成是一种特殊的Datasets，即：Dataset(Row) 创建DataSet： &lt;1&gt;. 使用序列 ① 定义case class: case class MyData(a:Int,b:String) ② 生成序列并创建DataSet: val ds = Seq(MyData(1,&quot;Tom&quot;),MyData(2,&quot;Mary&quot;)).toDS ③ 查看结果 ds.show &lt;2&gt;. 使用JSON数据 ① 定义case class: case class Person(name: String, gender: String) ② 通过JSON数据生成DataFrame: val df = spark.read.json(sc.parallelize(&quot;&quot;&quot;{&quot;gender&quot;: &quot;Male&quot;, &quot;name&quot;: &quot;Tom&quot;}&quot;&quot;&quot; :: Nil)) ③ 将DataFrame转成DataSet: df.as[Person].show df.as[Person].collect &lt;3&gt;. 使用HDFS数据 ① 读取HDFS数据，并创建DataSet: val linesDS = spark.read.text(&quot;hdfs://XXXX:9000/XXXX/data.txt&quot;).as[String] ② 对DataSet进行操作：分词后，查询长度大于3的单词 val words = linesDS.flatMap(_.split(&quot; &quot;)).filter(_.length &gt; 3) words.show words.collect 复制代码 ③ 执行WordCount程序 val result = linesDS.flatMap(_.split(&quot; &quot;)).map((_,1)).groupByKey(x =&gt; x._1).count result.show 排序：result.orderBy($&quot;value&quot;).show 复制代码 (5) Datasets 的操作案例 &lt;1&gt;. 使用emp.json 生成DataFrame: val empDF = spark.read.json(&quot;/XXXX/emp.json&quot;) 查询工资大于3000的员工 empDF.where($&quot;sal&quot; &gt;= 3000).show 复制代码 &lt;2&gt;. 创建case class: case class Emp(empno:Long,ename:String,job:String,hiredate:String,mgr:String,sal:Long,comm:String,deptno:Long) &lt;3&gt;. 生成DataSets并查询数据: val empDS = empDF.as[Emp] 查询工资大于3000的员工 empDS.filter(_.sal &gt; 3000).show 查看10号部门的员工 empDS.filter(_.deptno == 10).show 复制代码 &lt;4&gt;. 多表查询: a. 创建部门表: val deptRDD=sc.textFile(&quot;/XXXX/dept.csv&quot;).map(_.split(&quot;,&quot;)) case class Dept(deptno:Int,dname:String,loc:String) val deptDS = deptRDD.map(x=&gt;Dept(x(0).toInt,x(1),x(2))).toDS 复制代码 复制代码 b. 创建员工表: case class Emp(empno:Int,ename:String,job:String,mgr:String,hiredate:String,sal:Int,comm:String,deptno:Int) val empRDD = sc.textFile(&quot;/XXXX/emp.csv&quot;).map(_.split(&quot;,&quot;)) val empDS = empRDD.map(x =&gt; Emp(x(0).toInt,x(1),x(2),x(3),x(4),x(5).toInt,x(6),x(7).toInt)).toDS 复制代码 c. 执行多表查询：等值链接 val result = deptDS.join(empDS,&quot;deptno&quot;) 另一种写法：注意有三个等号 val result = deptDS.joinWith(empDS,deptDS(&quot;deptno&quot;)=== empDS(&quot;deptno&quot;)) joinWith和join的区别是连接后的新Dataset的schema会不一样 复制代码 &lt;5&gt;. 查看执行计划： result.explain 11. Spark SQL 进阶 (1) 使用数据源 &lt;1&gt;. 什么是parquet文件 Parquet是列式存储格式的一种文件类型，列式存储有以下的核心： 可以跳过不符合条件的数据，只读取需要的数据，降低IO数据量。 压缩编码可以降低磁盘存储空间。由于同一列的数据类型是一样的，可以使用更高效的压缩编码（例如Run Length Encoding和Delta Encoding）进一步节约存储空间。 只读取需要的列，支持向量运算，能够获取更好的扫描性能。 Parquet格式是Spark SQL的默认数据源，可通过spark.sql.sources.default配置 &lt;2&gt;. 使用Load/Save函数 load函数是加载数据，save是存储数据。 e.g.: 读取 users.parquet 文件（Spark自带的示例文件） val userDF = spark.read.load(&quot;/root/users.parquet&quot;) 查看结构： userDF.printSchema 查看内容： userDF.show 读取json文件： val userDF = spark.read.load(&quot;/root/emp.json&quot;) ——&gt;报错 正确方法： val userDF = spark.read.format(&quot;json&quot;).load(&quot;/root/emp.json&quot;) val userDF = spark.read.json(&quot;/root/emp.json&quot;) 保存parquet文件到本地路径： userDF.select($&quot;name&quot;,$&quot;favorite_color&quot;).write.save(&quot;/root/parquet&quot;) 读取刚写入的文件： val userDF1 = spark.read.load(&quot;/root/parquet/part-00000-888d505a-7d51-4a50-aaf5-2bbdb56e67a1.snappy.parquet&quot;) --&gt; 不推荐 生产：（直接读目录） val userDF2 = spark.read.load(&quot;/usr/local/tmp_files/parquet&quot;) 复制代码 关于save函数： 调用save函数的时候，可以指定存储模式，追加、覆盖等等 可以采用SaveMode执行存储操作，SaveMode定义了对数据的处理模式。需要注意的是，这些保存模式不使用任何锁定，不是原子操作。此外，当使用Overwrite方式执行时，在输出新数据之前原数据就已经被删除。SaveMode详细介绍如下表： userDF2.write.save(&quot;/root/parquet&quot;) ——&gt;报错 save的时候覆盖： userDF2.write.mode(&quot;overwrite&quot;).save(&quot;/root/parquet&quot;) 将结果保存成表： userDF2.select($&quot;name&quot;).write.saveAsTable(&quot;table1&quot;) 查看数据： spark.sql(&quot;select * from table2&quot;).show 也可以进行分区、分桶等操作：partitionBy、bucketBy 复制代码 &lt;3&gt;. Parquet文件 Parquet是一个列格式而且用于多个数据处理系统中。Spark SQL提供支持对于Parquet文件的读写，也就是自动保存原始数据的schema。当写Parquet文件时，所有的列被自动转化为nullable，因为兼容性的缘故。 e.g.: 读入json格式的数据，将其转换成parquet格式，并创建相应的表来使用SQL进行查询。（把数据读进来，再写出去，就是Parquet文件） 读入文件： val empDF = spark.read.json(&quot;/root/emp.json&quot;) 写出文件： empDF.write.mode(&quot;overwrite&quot;).save(&quot;/root/parquet&quot;) empDF.write.mode(&quot;overwrite&quot;).parquet(&quot;/root/parquet&quot;) 建表查询： val emp1 = spark.read.parquet(&quot;/root/parquet&quot;) emp1.createOrReplaceTempView(&quot;emp1&quot;) spark.sql(&quot;select * from emp1&quot;).show 复制代码 &lt;4&gt;. Schema的合并： Parquet支持Schema evolution（Schema演变，即：合并）。用户可以先定义一个简单的Schema，然后逐渐的向Schema中增加列描述。通过这种方式，用户可以获取多个有不同Schema但相互兼容的Parquet文件。 e.g.: 通过RDD来创建DataFrame: val df1 = sc.makeRDD(1 to 5).map( i =&gt; (i,i*2)).toDF(&quot;single&quot;,&quot;double&quot;) ——&gt;&quot;single&quot;,&quot;double&quot; 是表结构 df1.show df1.write.mode(&quot;overwrite&quot;).save(&quot;/root/test_table/key=1&quot;) val df2 = sc.makeRDD(6 to 10).map( i =&gt; (i,i*3)).toDF(&quot;single&quot;,&quot;triple&quot;) df2.show df2.write.mode(&quot;overwrite&quot;).save(&quot;/root/test_table/key=2&quot;) 合并两个部分: val df3 = spark.read.parquet(&quot;/root/tmp_files/test_table&quot;) val df3 = spark.read.option(&quot;mergeSchema&quot;,true).parquet(&quot;/root/tmp_files/test_table&quot;) 复制代码 &lt;5&gt;. JSON Datasets Spark SQL能自动解析JSON数据集的Schema，读取JSON数据集为DataFrame格式。读取JSON数据集方法为SQLContext.read().json()。该方法将String格式的RDD或JSON文件转换为DataFrame。 需要注意的是，这里的JSON文件不是常规的JSON格式。JSON文件每一行必须包含一个独立的、自满足有效的JSON对象。如果用多行描述一个JSON对象，会导致读取出错。读取JSON数据集示例如下： 读取Json文件，生成DataFrame: val peopleDF = spark.read.json(&quot;/usr/local/tmp_files/people.json&quot;) 打印Schema结构信息： peopleDF.printSchema 创建临时视图： peopleDF.createOrReplaceTempView(&quot;peopleView&quot;) 执行查询： spark.sql(&quot;select * from peopleView&quot;).show Spark SQL 支持统一的访问接口。对于不同的数据源，读取进来，生成DataFrame后，操作完全一样。 复制代码 &lt;6&gt;. 使用JDBC Spark SQL同样支持通过JDBC读取其他数据库的数据作为数据源。 Spark加载MySQL： spark-shell --master spark://XXXX:7077 --jars /XXXX/.jar --driver-class-path /XXXX/.jar Spark连接MySQL： 方法一： val mysqlDF = spark.read.format(&quot;jdbc&quot;).option(&quot;url&quot;,&quot;jdbc:mysql://XXXX:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;).option(&quot;user&quot;,&quot;root&quot;).option(&quot;password&quot;,&quot;123456&quot;).option(&quot;driver&quot;,&quot;com.mysql.cj.jdbc.Driver&quot;).option(&quot;dbtable&quot;,&quot;emp&quot;).load mysqlDF.show``` 复制代码 方式二：定义一个Properties类 import java.util.Properties val mysqlProps = new Properties() mysqlProps.setProperty(&quot;user&quot;,&quot;root&quot;) mysqlProps.setProperty(&quot;password&quot;,&quot;123456&quot;) val mysqlDF1 = spark.read.jdbc(&quot;jdbc:mysql://XXXX:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;,&quot;emp&quot;,mysqlProps) mysqlDF1.show ``` 复制代码 &lt;7&gt;. 使用Hive Table a. 准备工作： 搭建好Hive的环境（需要Hadoop） 配置Spark SQL支持Hive： 将以下文件拷贝到$SPARK_HOME/conf的目录下，即可 $HIVE_HOME/conf/hive-site.xml $HADOOP_CONF_DIR/core-site.xml $HADOOP_CONF_DIR/hdfs-site.xml 重启Spark b. 使用Spark Shell操作Hive 启动Hadoop、Hive 启动Spark 启动spark-sql的时候，需要使用--jars指定mysql的驱动程序 创建表：spark.sql(&quot;create table spark.emp1(empno Int,ename String,job String,mgr String,hiredate String,sal Int,comm String,deptno Int)row format delimited fields terminated by &#39;,&#39;&quot;) 导入数据：spark.sql(&quot;load data local inpath &#39;/root/emp.csv&#39; overwrite into table spark.emp1&quot;) 查询数据：spark.sql(&quot;select * from spark.emp1&quot;).show (2) 在IDE中开发Spark SQL &lt;1&gt;. 创建DataFrame a. StructType方式 package Demo import org.apache.spark.sql.SparkSession import org.apache.spark.sql.types.StructType import org.apache.spark.sql.types.StructField import org.apache.spark.sql.types.IntegerType import org.apache.spark.sql.types.StringType import org.apache.spark.sql.Row import org.apache.log4j.Logger import org.apache.log4j.Level /*创建DataFrame StructType方式*/ object Demo01 { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) // 创建Spark Session对象 val spark = SparkSession.builder().master(&quot;local&quot;).appName(&quot;Demo1&quot;).getOrCreate() // 从指定的地址创建RDD对象 /*1 Tom 12 *2 Mary 13 *3 Lily 15 * */ val personRDD = spark.sparkContext.textFile(&quot;/Users/apple/Documents/student.txt&quot;).map(_.split(&quot;\\t&quot;)) // 通过StructType方式指定Schema val schema = StructType( List( StructField(&quot;id&quot;, IntegerType), StructField(&quot;name&quot;, StringType), StructField(&quot;age&quot;, IntegerType))) // 将RDD映射到rowRDD上，映射到Schema上 val rowRDD = personRDD.map(p =&gt; Row(p(0).toInt, p(1), p(2).toInt)) val personDataFrame = spark.createDataFrame(rowRDD, schema) // 注册视图 personDataFrame.createOrReplaceTempView(&quot;t_person&quot;) //执行SQL语句 val df = spark.sql(&quot;select * from t_person order by age desc&quot;) df.show() spark.stop() } 复制代码 }复制代码 b. case Class方式 package Demo import org.apache.spark.sql.SparkSession import org.apache.spark.sql.types.StructType import org.apache.spark.sql.types.StructField import org.apache.spark.sql.types.IntegerType import org.apache.spark.sql.types.StringType import org.apache.spark.sql.Row import org.apache.log4j.Logger import org.apache.log4j.Level /*使用case Class来创建DataFrame*/ object Demo02 { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建Spark Session对象 val spark = SparkSession.builder().master(&quot;local&quot;).appName(&quot;Demo2&quot;).getOrCreate() //从指定的地址创建RDD对象 val lineRDD = spark.sparkContext.textFile(&quot;&quot;).map(_.split(&quot;\\t&quot;)) //把数据与case class做匹配 val studentRDD = lineRDD.map(x =&gt; Student(x(0).toInt, x(1), x(2).toInt)) //生成DataFrame import spark.sqlContext.implicits._ val studentDF = studentRDD.toDF //注册视图 执行SQL studentDF.createOrReplaceTempView(&quot;student&quot;) spark.sql(&quot;select * from student&quot;).show spark.stop() } } //定义case class case class Student(stuId: Int, stuName: String, stuAge: Int) 复制代码 &lt;2&gt;. 写入MySQL package Demo import org.apache.spark.sql.SparkSession import org.apache.spark.sql.types.StructType import org.apache.spark.sql.types.StructField import org.apache.spark.sql.types.IntegerType import org.apache.spark.sql.types.StringType import org.apache.spark.sql.Row import org.apache.log4j.Logger import org.apache.log4j.Level import java.util.Properties /*写入MySQL*/ object Demo03 { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建Spark Session对象 val spark = SparkSession.builder().master(&quot;local&quot;).appName(&quot;Demo3&quot;).getOrCreate() //从指定的地址创建RDD对象 val lineRDD = spark.sparkContext.textFile(&quot;&quot;).map(_.split(&quot;\\t&quot;)) //通过StructType方式指定Schema val schema = StructType( List( //字段与MySQL表中字段对应一致 StructField(&quot;personID&quot;, IntegerType), StructField(&quot;personName&quot;, StringType), StructField(&quot;personAge&quot;, IntegerType))) //将RDD映射到rowRDD上，映射到Schema上 val rowRDD = lineRDD.map(p =&gt; Row(p(0).toInt,p(1),p(2).toInt)) val personDataFrame = spark.createDataFrame(rowRDD, schema) personDataFrame.createOrReplaceTempView(&quot;myperson&quot;) val result = spark.sql(&quot;select * from myperson&quot;) result.show() //把结果存入到mysql中 val props = new Properties() props.setProperty(&quot;user&quot;, &quot;root&quot;) props.setProperty(&quot;password&quot;, &quot;123456&quot;) //append追加模式 result.write.mode(&quot;append&quot;).jdbc(&quot;jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;student&quot;, props) spark.stop() } } 复制代码 &lt;3&gt;. 使用Spark SQL 读取Hive中的数据，将计算结果存入mysql package Demo import org.apache.spark.sql.SparkSession import java.util.Properties /*使用Spark SQL 读取Hive中的数据，将计算结果存入mysql*/ //命令：./bin/spark-submit --master spark://node3:7077 --jars /usr/local/tmp_files/mysql-connector-java-8.0.11.jar --driver-class-path /usr/local/tmp_files/mysql-connector-java-8.0.11.jar --class day0410.Demo4 /usr/local/tmp_files/Demo4.jar object Demo4 { def main(args: Array[String]): Unit = { //创建SparkSession val spark = SparkSession.builder().appName(&quot;Demo4&quot;).enableHiveSupport().getOrCreate() //执行SQL val result = spark.sql(&quot;select deptno,count(1) from company.emp group by deptno&quot;) //将结果保存到mysql中 val props = new Properties() props.setProperty(&quot;user&quot;, &quot;root&quot;) props.setProperty(&quot;password&quot;, &quot;123456&quot;) result.write.mode(&quot;append&quot;).jdbc(&quot;jdbc:mysql://192.168.109.1:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;, &quot;emp_stat&quot;, props) spark.stop() } } 复制代码 (3) Spark SQL 性能优化 &lt;1&gt;. 在内存中缓存数据 直接读取内存的值来提高性能。 通过spark.cacheTable(&quot;tableName&quot;)或者dataFrame.cache()。使用spark.uncacheTable(&quot;tableName&quot;)来从内存中去除table。 e.g.： 操作mysql，启动spark shell 时，需要： ./bin/spark-shell --master spark://node3:7077 --jars /usr/local/tmp_files/mysql-connector-java-8.0.11.jar --driver-class-path /usr/local/tmp_files/mysql-connector-java-8.0.11.jar val mysqlDF = spark.read.format(&quot;jdbc&quot;).option(&quot;driver&quot;,&quot;com.mysql.jdbc.Driver&quot;).option(&quot;url&quot;,&quot;jdbc:mysql://192.168.109.1:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;).option(&quot;user&quot;,&quot;root&quot;).option(&quot;password&quot;,&quot;123456&quot;).option(&quot;dbtable&quot;,&quot;emp&quot;).load mysqlDF.show mysqlDF.createOrReplaceTempView(&quot;emp&quot;) spark.sqlContext.cacheTable(&quot;emp&quot;) ----&gt; 标识这张表可以被缓存，数据还没有真正被缓存 spark.sql(&quot;select * from emp&quot;).show ----&gt; 依然读取mysql spark.sql(&quot;select * from emp&quot;).show ----&gt; 从缓存中读取数据 spark.sqlContext.clearCache 清空缓存后，执行查询，会触发查询mysql数据库。 复制代码 &lt;2&gt;. 性能优化相关参数 a. 将数据缓存到内存中的相关优化参数： spark.sql.inMemoryColumnarStorage.compressed 默认为 true Spark SQL 将会基于统计信息自动地为每一列选择一种压缩编码方式。 spark.sql.inMemoryColumnarStorage.batchSize 默认值：10000 缓存批处理大小。缓存数据时, 较大的批处理大小可以提高内存利用率和压缩率，但同时也会带来 OOM（Out Of Memory）的风险。 b. 其他性能相关的配置选项（不过不推荐手动修改，可能在后续版本自动的自适应修改） spark.sql.files.maxPartitionBytes 默认值：128 MB 读取文件时单个分区可容纳的最大字节数 spark.sql.files.openCostInBytes 默认值：4M 打开文件的估算成本, 按照同一时间能够扫描的字节数来测量。当往一个分区写入多个文件的时候会使用。高估更好, 这样的话小文件分区将比大文件分区更快 (先被调度)。 spark.sql.autoBroadcastJoinThreshold 默认值：10M 用于配置一个表在执行 join 操作时能够广播给所有 worker 节点的最大字节大小。通过将这个值设置为 -1 可以禁用广播。注意，当前数据统计仅支持已经运行了 ANALYZE TABLE COMPUTE STATISTICS noscan 命令的 Hive Metastore 表。 spark.sql.shuffle.partitions 默认值：200 用于配置 join 或聚合操作混洗（shuffle）数据时使用的分区数。 12. 认识 Spark Streaming (1) Spark Streaming 简介 流式计算框架（类似于Storm） 常用的实时计算引擎（流式计算） &lt;1&gt;. Apache Storm：真正的流式计算 &lt;2&gt;. Spark Streaming ：严格上来说不是真正的流式计算（实时计算），把连续的流式数据，当成不连续的RDD，本质是一个离散计算（不连续） &lt;3&gt;. Apache Flink：真正的流式计算，与Spark Streaming相反， 把离散的数据，当成流式数据来处理 &lt;4&gt;. JStorm Spark Streaming makes it easy to build scalable fault-tolerant streaming applications.（易于构建灵活的、高容错的流式系统） Spark Streaming是核心Spark API的扩展，可实现可扩展、高吞吐量、可容错的实时数据流处理。数据可以从诸如Kafka，Flume，Kinesis或TCP套接字等众多来源获取，并且可以使用由高级函数（如map，reduce，join和window）开发的复杂算法进行流数据处理。最后，处理后的数据可以被推送到文件系统，数据库和实时仪表板。而且，还可以在数据流上应用Spark提供的机器学习和图处理算法。 (2) Spark Streaming 的特点 &lt;1&gt;. 易用，已经集成到Spark中 &lt;2&gt;. 容错性：底层RDD，RDD本身具有容错机制 &lt;3&gt;. 支持多种语言：Java Scala Python (3) Spark Streaming的内部结构 在内部，它的工作原理如下。Spark Streaming接收实时输入数据流，并将数据切分成批，然后由Spark引擎对其进行处理，最后生成“批”形式的结果流。 Spark Streaming将连续的数据流抽象为discretizedstream或DStream。在内部DStream 由一个RDD序列表示。 13. Spark Streaming 基础 (1) Spark Streaming 官方示例 &lt;1&gt;. 介绍： 向Spark Streaming中发送字符串，Spark 接收到以后进行计数 &lt;2&gt;. 准备工作： netcat网络工具（yum install nc.x86_64） **注意：**总核数大于等于2，一个核心用于接收数据，另一个用于处理数据 &lt;3&gt;. 操作： 启动同一Linux系统的两个窗口，一个负责输入，一个负责监听 窗口1：nc -l 1234 （-l监听模式；1234端口号） 窗口2：run-example streaming.NetworkWordCount localhost 1234 在窗口1输入文本信息，窗口2监听并进行计数统计 (2) 自写 Spark Streaming 官方示例 MyNetworkWordCount.scala /** * * @ClassName: MyNetworkWordCount * @Description * @Author: YBCarry * @Date2019-05-13 20:49 * @Version: V1.0 * **/ import org.apache.spark.streaming.StreamingContext import org.apache.spark.SparkConf import org.apache.spark.streaming.Seconds import org.apache.spark.storage.StorageLevel import org.apache.log4j.Logger import org.apache.log4j.Level import org.apache.spark.internal.Logging /* * 自写流式计算程序 * * 知识点： * 1、创建一个StreamingContext对象 --&gt; 核心：创建一个DStream * 2、DStream的表现形式：就是一个RDD * 3、使用DStream把连续的数据流变成不连续的RDD * * spark Streaming 最核心的内容 */ object MyNetworkWordCount { def main(args: Array[String]): Unit = { //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyNetworkWordCount&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //创建DStream 从netcat服务器上接收数据 val lines = ssc.socketTextStream(&quot;172.16.194.128&quot;, 1234, StorageLevel.MEMORY_ONLY) //lines中包含了netcat服务器发送过来的数据 //分词操作 val words = lines.flatMap(_.split(&quot; &quot;)) //计数 val wordPair = words.transform(x =&gt; x.map(x =&gt; (x, 1))) //打印结果 wordPair.print() //启动StreamingContext 进行计算 ssc.start() //等待任务结束 ssc.awaitTermination() } } 复制代码 14. Spark Streaming 进阶 (1) StreamingContext对象详解 初始化StreamingContext： 方式一：从SparkConf对象中创建： 方式二：从一个现有的SparkContext实例中创建 程序中的几点说明： appName参数是应用程序在集群UI上显示的名称。 master是Spark，Mesos或YARN集群的URL，或者一个特殊的“local [*]”字符串来让程序以本地模式运行。 当在集群上运行程序时，不需要在程序中硬编码master参数，而是使用spark-submit提交应用程序并将master的URL以脚本参数的形式传入。但是，对于本地测试和单元测试，您可以通过“local[*]”来运行Spark Streaming程序（请确保本地系统中的cpu核心数够用）。 StreamingContext会内在的创建一个SparkContext的实例（所有Spark功能的起始点），你可以通过ssc.sparkContext访问到这个实例。 批处理的时间窗口长度必须根据应用程序的延迟要求和可用的集群资源进行设置。 注意： 一旦一个StreamingContextt开始运作，就不能设置或添加新的流计算。 一旦一个上下文被停止，它将无法重新启动。 同一时刻，一个JVM中只能有一个StreamingContext处于活动状态。 StreamingContext上的stop()方法也会停止SparkContext。 要仅停止StreamingContext（保持SparkContext活跃），请将stop() 方法的可选参数stopSparkContext设置为false。 只要前一个StreamingContext在下一个StreamingContext被创建之前停止（不停止SparkContext），SparkContext就可以被重用来创建多个StreamingContext。 (2) 离散流（DStreams）：Discretized Streams 把连续的数据变成不连续的RDD 因为DStream的特性，导致，Spark Streaming不是真正的流式计算 DiscretizedStream或DStream 是Spark Streaming对流式数据的基本抽象。它表示连续的数据流，这些连续的数据流可以是从数据源接收的输入数据流，也可以是通过对输入数据流执行转换操作而生成的经处理的数据流。在内部，DStream由一系列连续的RDD表示，如下图： 举例分析：在之前的NetworkWordCount的例子中，我们将一行行文本组成的流转换为单词流，具体做法为：将flatMap操作应用于名为lines的DStream中的每个RDD上，以生成words DStream的RDD。如下图所示： 但是DStream和RDD也有区别，下面画图说明： (3) 转换操作（transformation） transform(func) 通过RDD-to-RDD函数作用于源DStream中的各个RDD，可以是任意的RDD操作，从而返回一个新的RDD 举例：在NetworkWordCount中，也可以使用transform来生成元组对 updateStateByKey(func) 操作允许不断用新信息更新它的同时保持任意状态。 定义状态：状态可以是任何的数据类型 定义状态更新函数：怎样利用更新前的状态和从输入流里面获取的新值更新状态 重写NetworkWordCount程序，累计每个单词出现的频率（注意：累计） TotalNetworkWordCount.scala package test.Network import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.storage.StorageLevel import org.apache.spark.streaming.{Seconds, StreamingContext} /** * * @ClassName: TotalNetworkWordCount * @Description: 实现累加操作 * @Author: YBCarry * @Date2019-05-15 16:05 * @Version: V1.0 * **/ object TotalNetworkWordCount { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyNetworkWordCount&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //设置检查点目录，保存之前都的状态信息 ssc.checkpoint(&quot;&quot;) //创建DStream val lines = ssc.socketTextStream(&quot;bigdata01&quot;, 1234, StorageLevel.MEMORY_ONLY) //分割 val words = lines.flatMap(_.split(&quot; &quot;)) //计数 // val wordPair = words.map((_, 1)) val wordPair = words.transform( x =&gt; x.map(x =&gt; (x, 1))) //定义一个值函数 ；累加计数 /* * 接收两个参数 * currentValues —— 当前值 * previousValue ——历史值 * */ val addFunc = (currentValues : Seq[Int], previousValues : Option[Int]) =&gt; { //累加当前的序列 val currrentTotal = currentValues.sum //累加历史值 Some(currrentTotal + previousValues.getOrElse(0)) } //累加运算 val total = wordPair.updateStateByKey(addFunc) total.print() ssc.start() ssc.awaitTermination() } } 复制代码 复制代码 (4) 窗口操作 Spark Streaming还提供了窗口计算功能，允许在数据的滑动窗口上应用转换操作。下图说明了滑动窗口的工作方式： 如图所示，每当窗口滑过originalDStream时，落在窗口内的源RDD被组合并被执行操作以产生windowed DStream的RDD。在上面的例子中，操作应用于最近3个时间单位的数据，并以2个时间单位滑动。这表明任何窗口操作都需要指定两个参数。 窗口长度（windowlength） - 窗口的时间长度（上图的示例中为：3）。 滑动间隔（slidinginterval） - 两次相邻的窗口操作的间隔（即每次滑动的时间长度）（上图示例中为：2）。 这两个参数必须是源DStream的批间隔的倍数（上图示例中为：1）。 e.g.: 假设对之前的单词计数的示例进行扩展，每10秒钟对过去30秒的数据进行wordcount。则在最近30秒的pairs DStream数据中对(word, 1)键值对应用reduceByKey操作。这是通过使用reduceByKeyAndWindow操作完成的。 package test.NetworkByWindow import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.storage.StorageLevel import org.apache.spark.streaming.{Seconds, StreamingContext} /** * * @ClassName: NetworkWordCountByWindow * @Description: 每10秒读取过去30秒的数据 * @Author: YBCarry * @Date2019-05-15 17:00 * @Version: V1.0 * **/ object NetworkWordCountByWindow { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyNetworkWordCount&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //设置检查点目录，保存之前都的状态信息 ssc.checkpoint(&quot;&quot;) //创建DStream val lines = ssc.socketTextStream(&quot;bigdata01&quot;, 1234, StorageLevel.MEMORY_ONLY) //分割 每个单词计数 val words = lines.flatMap(_.split(&quot; &quot;)).map((_, 1)) /* * 窗口操作 * 参数说明：要进行的操作 窗口的大小(30s) 窗口移动距离(12s) ——&gt; 采样时间(3)的整数倍 * */ val result = words.reduceByKeyAndWindow((x : Int, y : Int) =&gt; (x + y), Seconds(30), Seconds(12)) } } 复制代码 15. Spark 数据源 (1) 输入DStreams和接收器 输入DStreams表示从数据源获取输入数据流的DStreams。在NetworkWordCount例子中，lines表示输入DStream，它代表从netcat服务器获取的数据流。每一个输入流DStream和一个Receiver对象相关联，这个Receiver从源中获取数据，并将数据存入内存中用于处理。 输入DStreams表示从数据源获取的原始数据流。Spark Streaming拥有两类数据源： 基本源（Basic sources）：这些源在StreamingContext API中直接可用。例如文件系统、套接字连接、Akka的actor等 高级源（Advanced sources）：这些源包括Kafka,Flume,Kinesis,Twitter等等。 下面通过具体的案例，详细说明： (2) 基本源 &lt;1&gt;. 文件流：通过监控文件系统的变化，若有新文件添加，则将它读入并作为数据流 注意： ① 这些文件具有相同的格式 ② 这些文件通过原子移动或重命名文件的方式在dataDirectory创建 ③ 如果在文件中追加内容，这些追加的新数据也不会被读取。 Spark Streaming监控一个文件夹，如果有变化，则把变化采集过来 import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.streaming.{Seconds, StreamingContext} /** * * @ClassName: FileStreaming * @Description * @Author: YBCarry * @Date2019-05-16 09:24 * @Version: V1.0 * **/ object FileStreaming { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyFileStreaming&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(10)) //监控目录，读取产生的新文件 val lines = ssc.textFileStream(&quot;\\\\Users\\\\apple\\\\学习\\\\SparkFiles&quot;) lines.print() ssc.start() ssc.awaitTermination() } } 复制代码 注意：需要在原文件中编辑，然后拷贝一份。 &lt;2&gt;. RDD队列流 使用streamingContext.queueStream(queueOfRDD)创建基于RDD队列的DStream，用于调试Spark Streaming应用程序。 package test.RDDQueue import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.rdd.RDD import org.apache.spark.streaming.{Seconds, StreamingContext} import scala.collection.mutable.Queue /** * * @ClassName: RDDQueueStream * @Description: RDD队列流 * @Author: YBCarry * @Date2019-05-16 10:48 * @Version: V1.0 * **/ object RDDQueueStream { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyRDDQueueStream&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //创建队列 RDD[Int] val rddQueue = new Queue[RDD[Int]]() //向队列里添加数据 (创建数据源) for (i &lt;- 1 to 3) { rddQueue += ssc.sparkContext.makeRDD(1 to 10) //便于观察 Thread.sleep(1000) } //从队列中接收数据，创建DStream val inputDStream = ssc.queueStream(rddQueue) //处理数据 val result = inputDStream.map(x =&gt; (x, x * 2)) result.print() ssc.start() ssc.awaitTermination() } } 复制代码 &lt;3&gt;. 套接字流：通过监听Socket端口来接收数据 (3) 高级源 &lt;1&gt;. Spark Streaming接收Flume数据 a. 基于Flume的Push模式: Flume被用于在Flume agents之间推送数据，在这种方式下，Spark Streaming可以很方便的建立一个receiver，起到一个Avro agent的作用。Flume可以将数据推送到改receiver。 以下为配置步骤： **第一步：**Flume的配置文件 MyFlumeStream01.conf #定义agent名， source、channel、sink的名称 a4.sources = r1 a4.channels = c1 a4.sinks = k1 #具体定义source a4.sources.r1.type = spooldir a4.sources.r1.spoolDir = /usr/local/tmp_files/logs #具体定义channel a4.channels.c1.type = memory a4.channels.c1.capacity = 10000 a4.channels.c1.transactionCapacity = 100 #具体定义sink a4.sinks = k1 a4.sinks.k1.type = avro a4.sinks.k1.channel = c1 a4.sinks.k1.hostname = bigdata01 a4.sinks.k1.port = 1234 #组装source、channel、sink a4.sources.r1.channels = c1 a4.sinks.k1.channel = c1 复制代码 **第二步：**Spark Streaming程序 package test.Flume import org.apache.log4j.{Level, Logger} import org.apache.spark.SparkConf import org.apache.spark.streaming.flume.FlumeUtils import org.apache.spark.streaming.{Seconds, StreamingContext} /** * * @ClassName: MyFlumeStream * @Description: flume将数据推送给Spark Streaming 使用push * @Author: YBCarry * @Date2019-05-16 14:01 * @Version: V1.0 * **/ object MyFlumeStream01 { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;MyRDDQueueStream&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf, Seconds(3)) //对接Flume //创建一个Flumeevent从flume中接收puch来的数据（也是DStream） //flume将数据push到localhost:1234，Spark Stream在这里监听 val flumeEventDStream = FlumeUtils.createStream(ssc, &quot;bigdata01&quot;, 1234) //将Flumeevent中的事件转换成字符串 val lineDStream = flumeEventDStream.map(e =&gt; { new String(e.event.getBody.array) }) //输出结果 lineDStream.print() ssc.start() ssc.awaitTermination() } } 复制代码 **第三步：**测试 启动Flume flume-ng agent -n a4 -f Spark/MyFlumeStream01.conf -c conf -Dflume.root.logger=INFO,console 启动Spark Streaming程序 拷贝日志文件到/root/training/logs目录 观察输出，采集到数据 b. 基于Custom Sink的Pull模式 不同于Flume直接将数据推送到Spark Streaming中，第二种模式通过以下条件运行一个正常的Flume sink。Flume将数据推送到sink中，并且数据保持buffered状态。Spark Streaming使用一个可靠的Flume接收器和转换器从sink拉取数据。只要当数据被接收并且被Spark Streaming备份后，转换器才运行成功。 这样,与第一种模式相比，保证了很好的健壮性和容错能力，这种模式需要为Flume配置一个正常的sink。 以下为配置步骤： **第一步：**Flume的配置文件 FlumeLogPull.conf a1.channels = c1 a1.sinks = k1 a1.sources = r1 a1.sources.r1.type = spooldir a1.sources.r1.spoolDir = /usr/local/tmp_files/logs a1.channels.c1.type = memory a1.channels.c1.capacity = 100000 a1.channels.c1.transactionCapacity = 100000 a1.sinks.k1.type = org.apache.spark.streaming.flume.sink.SparkSink a1.sinks.k1.channel = c1 a1.sinks.k1.hostname = bigdata01 a1.sinks.k1.port = 1234 #组装source、channel、sink a1.sources.r1.channels = c1 a1.sinks.k1.channel = c1 复制代码 **第二步：**Spark Streaming程序 复制代码 package test.Flume import org.apache.spark.streaming.StreamingContext import org.apache.spark.SparkConf import org.apache.spark.streaming.Seconds import org.apache.spark.storage.StorageLevel import org.apache.log4j.Logger import org.apache.log4j.Level import org.apache.spark.streaming.flume.FlumeUtils /** * @ClassName: FlumePutSink @Description: 测试pull方式 使用Spark sink @Author: YBCarry @Date2019-05-16 15:23 @Version: V1.0 **/ object FlumeLogPull { def main(args: Array[String]): Unit = { Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.ERROR) Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName(&quot;FlumeLogPull&quot;).setMaster(&quot;local[2]&quot;) //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf,Seconds(3)) //创建FlumeEvent的DStream，采用pull的方式 val flumeEvent = FlumeUtils.createPollingStream(ssc, &quot;172.16.194.128&quot;,1234, StorageLevel.MEMORY_ONLY) //将FlumeEvent的事件准换成字符串 val lineDStream = flumeEvent.map( e =&gt; { new String(e.event.getBody.array) }) //输出结果 lineDStream.print() ssc.start() ssc.awaitTermination() } 复制代码 } 复制代码 **第三步：**需要的jar包 将spark-streaming-flume-sink_2.11-2.1.0.jar拷贝到Flume的lib目录下。 **第四步：**测试 启动Flume 启动Spark Streaming程序 将测试数据拷贝到/root/training/logs 观察输出 16. Spark 性能优化 (1) 概述 Spark的计算本质是分布式计算，所以，Spark程序的性能可能因为集群中的任何因素出现瓶颈：CPU、网络带宽、或者内存。如果在持久化RDD的时候，持久化了大量的数据，那么Java虚拟机的垃圾回收就可能成为一个瓶颈。Java虚拟机会定期进行垃圾回收，此时会追踪所有Java对象，并且在垃圾回收时，找到那些已经不再使用的对象。 核心：清理旧对象，给新对象腾出空间。垃圾回收的性能开销，是与内存中的对象数量成正比。 (2) spark内存分配 (3) Spark GC原理 (4) 减少批数据的执行时间 在Spark中有几个优化可以减少批处理的时间： &lt;1&gt;. 减少批数据的执行时间 在Spark中有几个优化可以减少批处理的时间： ① 数据接收的并行水平 通过网络(如kafka，flume，socket等)接收数据需要这些数据反序列化并被保存到Spark中。如果数据接收成为系统的瓶颈，就要考虑并行地接收数据。注意，每个输入DStream创建一个receiver（运行在worker机器上）接收单个数据流。创建多个输入DStream并配置它们可以从源中接收不同分区的数据流，从而实现多数据流接收。例如，接收两个topic数据的单个输入DStream可以被切分为两个kafka输入流，每个接收一个topic。这将在两个worker上运行两个receiver，因此允许数据并行接收，提高整体的吞吐量。多个DStream可以被合并生成单个DStream，这样运用在单个输入DStream的transformation操作可以运用在合并的DStream上。 ② 数据处理的并行水平 如果运行在计算stage上的并发任务数不足够大，就不会充分利用集群的资源。默认的并发任务数通过配置属性来确定spark.default.parallelism。 ③ 数据序列化 可以通过改变序列化格式来减少数据序列化的开销。在流式传输的情况下，有两种类型的数据会被序列化： 输入数据 由流操作生成的持久RDD 在上述两种情况下，使用Kryo序列化格式可以减少CPU和内存开销。 (5) 设置正确的批容量 为了Spark Streaming应用程序能够在集群中稳定运行，系统应该能够以足够的速度处理接收的数据（即处理速度应该大于或等于接收数据的速度）。这可以通过流的网络UI观察得到。批处理时间应该小于批间隔时间。 根据流计算的性质，批间隔时间可能显著的影响数据处理速率，这个速率可以通过应用程序维持。可以考虑WordCountNetwork这个例子，对于一个特定的数据处理速率，系统可能可以每2秒打印一次单词计数（批间隔时间为2秒），但无法每500毫秒打印一次单词计数。所以，为了在生产环境中维持期望的数据处理速率，就应该设置合适的批间隔时间(即批数据的容量)。 找出正确的批容量的一个好的办法是用一个保守的批间隔时间（5-10,秒）和低数据速率来测试你的应用程序。 (6) 内存调优 介绍几个比较推荐的自定义选项，它们可以减少Spark Streaming应用程序垃圾回收的相关暂停，获得更稳定的批处理时间。 **Default persistence level of DStreams：**和RDDs不同的是，默认的持久化级别是序列化数据到内存中（DStream是StorageLevel.MEMORY_ONLY_SER，RDD是StorageLevel.MEMORY_ONLY）。即使保存数据为序列化形态会增加序列化/反序列化的开销，但是可以明显的减少垃圾回收的暂停。 **Clearing persistent RDDs：**默认情况下，通过Spark内置策略（LUR），Spark Streaming生成的持久化RDD将会从内存中清理掉。如果spark.cleaner.ttl已经设置了，比这个时间存在更老的持久化RDD将会被定时的清理掉。正如前面提到的那样，这个值需要根据Spark Streaming应用程序的操作小心设置。然而，可以设置配置选项spark.streaming.unpersist为true来更智能的去持久化（unpersist）RDD。这个配置使系统找出那些不需要经常保有的RDD，然后去持久化它们。这可以减少Spark RDD的内存使用，也可能改善垃圾回收的行为。 **Concurrent garbage collector：**使用并发的标记-清除垃圾回收可以进一步减少垃圾回收的暂停时间。尽管并发的垃圾回收会减少系统的整体吞吐量，但是仍然推荐使用它以获得更稳定的批处理时间。 (7) shuffle原理 &lt;1&gt;. 优化前 &lt;2&gt;. 优化后 17. Spark MLlib库 (1) 概述 MLlib is Apache Spark&#39;s scalable machine learning library.(MLlib 是 Spark 支持 Scala 的可以扩展的机器学习库。) Spark在机器学习方面具有得天独厚的有事，有以下几个原因： &lt;1&gt;. 机器学习算法一般都有多个步骤迭代计算，需要在多次迭代后，获得足够小的误差或者收敛才会停止。 e.g.: double wucha = 1.0 while ( wucha &gt;= 0.00001 ) { 建模 wucha -= 某个值 } 模型计算完毕 复制代码 当迭代使用Hadoop的MapReduce计算框架时，每次都要读写硬盘以及任务启动工作，导致很大的IO开销。而Spark基于内存的计算模型天生擅长迭代计算，只有在必要时，才会读写硬盘，所以Spark是机器学习比较理想的平台。 &lt;2&gt;. 通信角度 Hadoop的MapReduce计算框架通过heartbeat方式来进行通信和传递数据，执行速度慢。 Spark有高效的Akka和Netty通信系统，通信效率高。 SPark MLlib 是Spark 对常用的机器学习算法的实现库，同时包括相关测试和数据生成器。 (2) 什么是机器学习 &lt;1&gt;. 定义 A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E。 机器学习(Machine Learning, ML)是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。（通过算法使计算机能够模拟人类的判别能力） **三个关键词：**算法、经验、模型评价 **应用：**金融反欺诈、语音识别、自然语言处理、翻译、模式识别、智能控制等等。 &lt;2&gt;. 机器学习工作流程 在数据的基础上，通过算法构建出模型，并进行评价 如果达到要求，则用该模型测试其他数据 如果不达到要求，要调整算法来重新建立模型，再次进行评估 循环往复，直到获得满意的经验 &lt;3&gt;. 基于大数据的机器学习 传统的机器学习算法，由于技术和单机存储的限制，依赖于数据抽样，只能在少量数据上使用。所以存在的问题是很难做好随机，从而导致学习的模型不准确。 在大数据上进行机器学习，可以直接处理全量数据并进行大量迭代计算。Spark本身计算优势，适合机器学习。此外spark-shell、pyspark都可以提供及时查询工具。 (3) MLlib MLlib是Spark机器学习库，简化机器学习的工程实践工作，方便扩展到更大规模。集成了通用的学习算法：分类、回归、聚类、协同过滤、降维等等。另外，MLlib本身在Spark中，数据清洗、SQL、建模放在一起。 转载于:https://juejin.im/post/5cd16c00e51d453a51433062","@type":"BlogPosting","url":"https://uzzz.org/2019/05/07/790853.html","headline":"Linux环境Spark安装配置及使用","dateModified":"2019-05-07T00:00:00+08:00","datePublished":"2019-05-07T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/05/07/790853.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Linux环境Spark安装配置及使用</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix" data-track-view="{&quot;mod&quot;:&quot;popu_307&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/weixin_33754065/article/details/91464979,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_307&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/weixin_33754065/article/details/91464979&quot;}"> 
 <div class="article-source-link">
   原文链接：
  <a href="" target="_blank">https://juejin.im/post/5cd16c00e51d453a51433062</a> 
 </div> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-cd6c485e8b.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-cd6c485e8b.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="article-content">
   <h1 class="heading">Linux环境Spark安装配置及使用</h1> 
   <h2 class="heading">1. 认识Spark</h2> 
   <h3 class="heading">(1) Spark介绍</h3> 
   <ul>
    <li>大数据计算引擎</li> 
    <li>官网：<a href="https://link.juejin.im?target=https%3A%2F%2Fspark.apache.org%2F" rel="nofollow">spark.apache.org/</a></li> 
    <li>官方介绍：Apache Spark™ is a unified analytics engine for large-scale data processing.（Apache Spark™是一个用于大规模数据处理的统一分析引擎。）</li> 
    <li>Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab，2010年开源，2013年6月成为Apache孵化项目，2014年2月成为Apache顶级项目。目前，Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、Spark Streaming、GraphX、MLlib等子项目，Spark是基于内存计算的大数据并行计算框架。Spark基于内存计算，提高了在大数据环境下数据处理的实时性，同时保证了高容错性和高可伸缩性，允许用户将Spark部署在大量廉价硬件之上，形成集群。</li> 
    <li>Spark生态圈： 
     <ul>
      <li>Spark Core：RDD（弹性分布式数据集）</li> 
      <li>Spark SQL</li> 
      <li>Spark Streaming</li> 
      <li>Spark MLLib：协同过滤，ALS，逻辑回归等等 --&gt; 机器学习</li> 
      <li>Spark Graphx：图计算</li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(2) 为什么要学习Spark</h3> 
   <ul>
    <li>Hadoop的MapReduce计算模型存在的问题： 
     <ul>
      <li> <p>MapReduce的核心是Shuffle（洗牌）。在整个Shuffle的过程中，至少会产生6次的I/O。 </p>
       <figure>
        <figcaption></figcaption>
       </figure><p></p> </li> 
      <li> <p>中间结果输出：基于MapReduce的计算引擎通常会将中间结果输出到磁盘上，进行存储和容错。另外，当一些查询（如：Hive）翻译到MapReduce任务时，往往会产生多个Stage（阶段），而这些串联的Stage又依赖于底层文件系统（如HDFS）来存储每一个Stage的输出结果，而I/O的效率往往较低，从而影响了MapReduce的运行速度。</p> </li> 
     </ul></li> 
    <li><strong>Spark的最大特点：基于内存</strong></li> 
    <li>Spark是MapReduce的替代方案，而且兼容HDFS、Hive，可融入Hadoop的生态系统，弥补MapReduce的不足。</li> 
   </ul>
   <h3 class="heading">(3) Spark的特点：快、易用、通用、兼容</h3> 
   <ul>
    <li><strong>快</strong>——与Hadoop的MapReduce相比，Spark基于内存的运算速度要快100倍以上，即使，Spark基于硬盘的运算也要快10倍。Spark实现了高效的DAG执行引擎，从而可以通过内存来高效处理数据流。</li> 
    <li><strong>易用</strong>——Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的shell，可以非常方便地在这些shell中使用Spark集群来验证解决问题的方法。</li> 
    <li><strong>通用</strong>——Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。Spark统一的解决方案非常具有吸引力，毕竟任何公司都想用统一的平台去处理遇到的问题，减少开发和维护的人力成本和部署平台的物力成本。另外Spark还可以很好的融入Hadoop的体系结构中可以直接操作HDFS，并提供Hive on Spark、Pig on Spark的框架集成Hadoop。</li> 
    <li><strong>兼容</strong>——Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和ApacheMesos作为它的资源管理和调度器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase和Cassandra等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力。Spark也可以不依赖于第三方的资源管理和调度器，它实现了Standalone作为其内置的资源管理和调度框架，这样进一步降低了Spark的使用门槛，使得所有人都可以非常容易地部署和使用Spark。此外，Spark还提供了在EC2上部署Standalone的Spark集群的工具。</li> 
   </ul>
   <h2 class="heading">2. Spark体系架构</h2> 
   <p></p>
   <figure>
    <figcaption></figcaption>
   </figure>
   <p></p> 
   <p></p>
   <figure>
    <figcaption></figcaption>
   </figure>
   <p></p> 
   <ul>
    <li>Spark的运行方式 
     <ul>
      <li>Yarn</li> 
      <li>Standalone：本机调试（demo）</li> 
     </ul></li> 
    <li>Worker(从节点)：每个服务器上，资源和任务的管理者，只负责管理一个节点。</li> 
    <li>执行过程： 
     <ul>
      <li>一个Worker 有多个 Executor。 Executor是任务的执行者，按阶段（stage）划分任务。—&gt; RDD</li> 
     </ul></li> 
    <li>客户端：Driver Program 提交任务到集群中。 
     <ul>
      <li>spark-submit</li> 
      <li>spark-shell</li> 
     </ul></li> 
   </ul>
   <h2 class="heading">3. Spark-2.1.0安装流程</h2> 
   <h3 class="heading">(1) 准备工作</h3> 
   <ul>
    <li>具备java环境</li> 
    <li>配置主机名</li> 
    <li>配置免密码登录</li> 
    <li>防火墙关闭</li> 
   </ul>
   <h3 class="heading">(2) 解压spark-2.1.0-bin-hadoop2.7.tgz安装包到目标目录下：</h3> 
   <ul>
    <li><code>tar -zxvf .tar.gz -C 目标目录</code></li> 
   </ul>
   <h3 class="heading">(3) 为后续方便，重命名Spark文件夹：</h3> 
   <ul>
    <li><code>mv spark-2.1.0-bin-hadoop2.7/ spark-2.1.0</code></li> 
   </ul>
   <h3 class="heading">(4) Spark目录介绍</h3> 
   <ul>
    <li>bin —— Spark操作命令</li> 
    <li>conf —— 配置文件</li> 
    <li>data —— Spark测试文件</li> 
    <li>examples —— Spark示例程序</li> 
    <li>jars</li> 
    <li>LICENSE</li> 
    <li>licenses</li> 
    <li>NOTICE</li> 
    <li>python</li> 
    <li>R</li> 
    <li>README.md</li> 
    <li>RELEASE</li> 
    <li>sbin —— Spark集群命令</li> 
    <li>yarn —— Spark-yarn配置</li> 
   </ul>
   <h3 class="heading">(5) 修改配置文件：</h3> 
   <ul>
    <li>&lt;1&gt;. 配置spark-env.sh： 
     <ul>
      <li>进入spark-2.1.0/conf路径，重命名配置文件： 
       <ul>
        <li><code>mv spark-env.sh.template spark-env.sh</code></li> 
       </ul></li> 
      <li>修改spark-env.sh信息： 
       <ul>
        <li><code>vi spark-env.sh</code></li> 
        <li> <pre><code class="hljs bash copyable"><span class="hljs-built_in">export</span> JAVA_HOME=/opt/module/jdk1.8.0_144
<span class="hljs-built_in">export</span> SPARK_MASTER_HOST=bigdata01
<span class="hljs-built_in">export</span> SPARK_MASTER_PORT=7077
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
     </ul></li> 
    <li>&lt;2&gt;. 配置slaves： 
     <ul>
      <li>进入spark-2.1.0/conf路径，重命名配置文件： 
       <ul>
        <li><code>mv slaves.template slaves</code></li> 
       </ul></li> 
      <li>修改slaves信息： 
       <ul>
        <li><code>vi slaves</code></li> 
        <li> <pre><code class="hljs bash copyable">bigdata02
bigdata03
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(6) 配置环境变量：</h3> 
   <ul>
    <li>修改配置文件： 
     <ul>
      <li><code>vi /etc/profile</code></li> 
     </ul></li> 
    <li>增加以下内容： 
     <ul>
      <li><code>export SPARK_HOME=spark安装路径</code></li> 
      <li><code>export PATH=$PATH:$SPARK_HOME/bin</code></li> 
      <li><code>export PATH=$PATH:$SPARK_HOME/sbin</code></li> 
     </ul></li> 
    <li>声明环境变量： 
     <ul>
      <li><code>source /etc/profile</code></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(6) 集群配置：</h3> 
   <ul>
    <li>拷贝配置好的spark到其他机器上 
     <ul>
      <li><code>scp -r spark-2.1.0/ bigdata02:$PWD</code></li> 
      <li><code>scp -r spark-2.1.0/ bigdata03:$PWD</code></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(7) 启动：</h3> 
   <ul>
    <li>启动主节点： 
     <ul>
      <li><code>start-master.sh</code></li> 
     </ul></li> 
    <li>启动从节点： 
     <ul>
      <li><code>start-slaves.sh</code></li> 
     </ul></li> 
    <li>启动shell： 
     <ul>
      <li><code>spark-shell</code></li> 
     </ul></li> 
    <li>通过网页端查看： 
     <ul>
      <li><a href="https://link.juejin.im?target=http%3A%2F%2Fbigdata01%3A8080%2F" rel="nofollow">http://bigdata01:8080/</a></li> 
      <li>Spark中内置有Tomcat，故端口号默认为8080</li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(8) 关闭：</h3> 
   <ul>
    <li>关闭主节点： 
     <ul>
      <li><code>stop-master.sh</code></li> 
     </ul></li> 
    <li>关闭从节点： 
     <ul>
      <li><code>stop-slaves.sh</code></li> 
     </ul></li> 
   </ul>
   <h2 class="heading">4. Spark HA的实现</h2> 
   <h3 class="heading">(1) 基于文件系统的单点恢复</h3> 
   <ul>
    <li> <p>主要用于开发或测试环境。</p> </li> 
    <li> <p>当spark提供目录保存spark Application和worker的注册信息，并将他们的恢复状态写入该目录中，一旦Master发生故障，就可以通过重新启动Master进程（sbin/start-master.sh），恢复已运行的spark Application和worker的注册信息。</p> </li> 
    <li> <p>基于文件系统的单点恢复，主要是在spark-env.sh里对SPARK_DAEMON_JAVA_OPTS设置 </p>
     <figure>
      <figcaption></figcaption>
     </figure><p></p> 
     <ul>
      <li>创建存放文件夹：<code>mkdir /opt/module/spark-2.1.0/recovery</code></li> 
      <li>修改配置信息： 
       <ul>
        <li><code>vi spark-env.sh</code></li> 
        <li>增加内容：<code>export SPARK_DAEMON_JAVA_OPTS="-Dspark.deploy.recoveryMode=FILESYSTEM -Dspark.deploy.recoveryDirectory=/opt/module/spark-2.1.0/recovery"</code></li> 
       </ul></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(2) 基于Zookeeper的Standby Masters</h3> 
   <ul>
    <li> <p>适用于现实生产。</p> </li> 
    <li> <p>ZooKeeper提供了一个Leader Election机制，利用这个机制可以保证虽然集群存在多个Master，但是只有一个是Active的，其他的都是Standby。当Active的Master出现故障时，另外的一个Standby Master会被选举出来。由于集群的信息，包括Worker，Driver和Application的信息都已经持久化到ZooKeeper，因此在切换的过程中只会影响新Job的提交，对于正在进行的Job没有任何的影响。加入ZooKeeper的集群整体架构如下图所示： </p>
     <figure>
      <figcaption></figcaption>
     </figure>
     <figure>
      <figcaption></figcaption>
     </figure><p></p> </li> 
    <li> <p>修改配置信息：</p> 
     <ul>
      <li><code>vi spark-env.sh</code></li> 
      <li>增加内容：<code>export SPARK_DAEMON_JAVA_OPTS="-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=bigdata01:2181,bigdata02:2181,bigdata03:2181 -Dspark.deploy.zookeeper.dir=/spark"</code></li> 
      <li>注释掉：<code>export SPARK_MASTER_HOST</code>和<code>export SPARK_MASTER_PORT</code></li> 
     </ul></li> 
    <li> <p>发送新的配置文件到集群其余节点：</p> 
     <ul>
      <li><code>scp spark-env.sh bigdata02:$PWD</code></li> 
      <li><code>scp spark-env.sh bigdata03:$PWD</code></li> 
     </ul></li> 
   </ul>
   <h2 class="heading">5. 执行Spark的任务</h2> 
   <h3 class="heading">(1) spark-submit</h3> 
   <ul>
    <li>用于提交Spark的任务（任务即相关jar包）</li> 
    <li>e.g.: 蒙特卡洛求PI（圆周率） 
     <ul>
      <li>原理：如下图所示，随机向正方形内落点，通过统计正方形内所有点数和落入圆内的点数来计算占比，得出正方形与圆的面积近似比值，进而近似出PI值。 
       <figure>
        <figcaption></figcaption>
       </figure></li> 
      <li>命令： 
       <ul>
        <li><code>spark-submit --master spark://XXXX:7077</code> （指明master地址） <code>--class org.apache.spark.examples.SparkPi</code> （指明主程序的名字） <code>/XXXX/spark/examples/jars/spark-examples_2.11-2.1.0.jar</code>（指明jar包地址） <code>100</code>（指明运行次数）</li> 
       </ul></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(2) spark-shell</h3> 
   <ul>
    <li>相当于REPL，作为一个独立的Application运行</li> 
    <li>spark-shell是Spark自带的交互式Shell程序，方便用户进行交互式编程，用户可以在该命令行下用scala编写spark程序。</li> 
    <li>参数说明： 
     <ul>
      <li><code>--master spark://XXXX:7077</code> 指定Master的地址</li> 
      <li><code>--executor-memory 2g</code> 指定每个worker可用内存为2G</li> 
      <li><code>--total-executor-cores 2</code> 指定整个集群使用的cup核数为2个</li> 
     </ul></li> 
    <li>Spark Session 是 2.0 以后提供的，利用 SparkSession 可以访问spark所有组件</li> 
    <li>两种运行模式： 
     <ul>
      <li>&lt;1&gt;. 本地模式 
       <ul>
        <li>启动：<code>spark-shell</code>（后面不接任何参数）</li> 
       </ul></li> 
      <li>&lt;2&gt;. 集群模式 
       <ul>
        <li>启动：<code>spark-shell --master spark://XXXX:7077</code>（指明master地址）</li> 
       </ul></li> 
     </ul></li> 
    <li>e.g.: 编写WordCount程序 
     <ul>
      <li>&lt;1&gt;. 处理本地文件，把结果打印到屏幕上 
       <ul>
        <li>启动：<code>spark-shell</code></li> 
        <li>传入文件：<code>sc.textFile("/XXXX/WordCount.txt")</code>（本地文件路径）<code>.flatMap(_.split(" "))</code>（按照空格分割）<code>.map((_,1))</code>（单词遍历）<code>.reduceByKey(_+_)</code>（单词计数）<code>.collect</code></li> 
       </ul></li> 
      <li>&lt;2&gt;. 处理HDFS文件，结果保存在hdfs上 
       <ul>
        <li>启动：<code>spark-shell --master spark://XXXX:7077</code>（指</li> 
        <li>sc.textFile("hdfs://XXXX:9000/sp_wc.txt").flatMap(<em>.split(" ")).map((</em>,1)).reduceByKey(<em>+</em>).saveAsTextFile("hdfs://XXXX:9000/output/spark/WordCount")</li> 
       </ul></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(3) 单步运行WordCount -&gt; RDD</h3> 
   <ul>
    <li>启动shell：<code>spark-shell</code></li> 
    <li> <pre><code class="hljs bash copyable">  scala&gt; val rdd1 = sc.textFile(<span class="hljs-string">"/root/sp_wc.txt"</span>)
  rdd1: org.apache.spark.rdd.RDD[String] = /root/sp_wc.txt MapPartitionsRDD[1] at textFile at &lt;console&gt;:24
  
  scala&gt; rdd1.collect
  res0: Array[String] = Array(I love Scala, I love Skark, 2019/5/8)
  
  scala&gt; val rdd2 = rdd1.flatMap(_.split(<span class="hljs-string">" "</span>))
  rdd2: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[2] at flatMap at &lt;console&gt;:26
  
  scala&gt; rdd2.collect
  res1: Array[String] = Array(I, love, Scala, I, love, Skark, 2019/5/8)
  
  scala&gt; val rdd3 = rdd2.map((_,1))
  rdd3: org.apache.spark.rdd.RDD[(String, Int)] = MapPartitionsRDD[3] at map at &lt;console&gt;:28
  
  scala&gt; rdd3.collect
  res2: Array[(String, Int)] = Array((I,1), (love,1), (Scala,1), (I,1), (love,1), (Skark,1), (2019/5/8,1))
  
  scala&gt; val rdd4 = rdd3.reduceByKey(_+_)
  rdd4: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[4] at reduceByKey at &lt;console&gt;:30
  
  scala&gt; rdd4.collect
  res3: Array[(String, Int)] = Array((2019/5/8,1), (love,2), (I,2), (Skark,1), (Scala,1))
<span class="copy-code-btn">复制代码</span></code></pre></li> 
   </ul>
   <h3 class="heading">(4) 在IDE中运行WorkCount</h3> 
   <ul>
    <li>&lt;1&gt;. scala版本 
     <ul>
      <li> <pre><code class="hljs bash copyable">import org.apache.spark.SparkConf
import org.apache.spark.SparkContext

object WordCount {
  
  def main(args: Array[String]): Unit = {
    
    //创建一个Spark配置文件
    val conf = new SparkConf().setAppName(<span class="hljs-string">"Scala WordCount"</span>).setMaster(<span class="hljs-string">"local"</span>)
    
    //创建Spark对象
    val sc = new SparkContext(conf)
    
    val result = sc.textFile(args(0))
      .flatMap(_.split(<span class="hljs-string">" "</span>))
      .map((_, 1))
      .reduceByKey(_ + _)
      .saveAsTextFile(args(1))

    sc.stop()
  }
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
    <li>&lt;2&gt;. Java版本 
     <ul>
      <li> <pre><code class="hljs bash copyable">import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.api.java.function.FlatMapFunction;
import org.apache.spark.api.java.function.Function2;
import org.apache.spark.api.java.function.PairFunction;

import parquet.format.PageHeader;
import scala.Tuple2;

public class WordCount {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		SparkConf conf = new SparkConf()
				.setAppName(<span class="hljs-string">"JavaWordCount"</span>)
				.setMaster(<span class="hljs-string">"local"</span>) ;

		//新建SparkContext对象
		JavaSparkContext sc = new JavaSparkContext(conf) ;
		
		//读入数据
		JavaRDD&lt;String&gt; lines = sc.textFile(<span class="hljs-string">"hdfs://XXXX:9000/WordCount.txt"</span>) ;
		
		//分词 第一个参数表示读进来的话 第二个参数表示 返回值
		JavaRDD&lt;String&gt; words = lines.flatMap(new FlatMapFunction&lt;String, String&gt;() {
		
		@Override
		public Iterator&lt;String&gt; call(String input) throws Exception {
			
			<span class="hljs-built_in">return</span> Arrays.asList(input.split(<span class="hljs-string">" "</span>)).iterator() ;
		    }
		}) ;
		
		//每个单词记一次数 
		/*
		* String, String, Integer
		* input   &lt;key      value&gt;
		*/
		JavaPairRDD&lt;String, Integer&gt; ones = words.mapToPair(new PairFunction&lt;String, String, Integer&gt;() {
		
		@Override
		public Tuple2&lt;String, Integer&gt; call(String input) throws Exception {
			
			<span class="hljs-built_in">return</span> new Tuple2&lt;String, Integer&gt;(input, 1) ;
		}
		}) ;
		
		//执行reduce操作
		/*
		* Integer, Integer, Integer
		* nteger arg0, Integer arg1 返回值
		*/
		JavaPairRDD&lt;String,Integer&gt; counts = ones.reduceByKey(new Function2&lt;Integer, Integer, Integer&gt;() {
		
			@Override
			public Integer call(Integer arg0, Integer arg1) throws Exception {
				// TODO Auto-generated method stub
				<span class="hljs-built_in">return</span> arg0 + arg1 ;
			}
		}) ;
		
		//打印结果
		List&lt;Tuple2&lt;String, Integer&gt;&gt; output = counts.collect() ;
		
		<span class="hljs-keyword">for</span> (Tuple2&lt;String, Integer&gt; tuple :output) {
			System.out.println(tuple._1 + <span class="hljs-string">" : "</span> + tuple._2) ;
		}
		
		sc.stop() ;
		
		}
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(5) WordCount程序处理过程</h3> 
   <p></p>
   <figure>
    <figcaption></figcaption>
   </figure>
   <p></p> 
   <h3 class="heading">(6) Spark提交任务的流程</h3> 
   <p></p>
   <figure>
    <figcaption></figcaption>
   </figure>
   <p></p> 
   <h2 class="heading">6. Spark的算子</h2> 
   <h3 class="heading">(1) RDD基础</h3> 
   <ul>
    <li>&lt;1&gt;. 什么是RDD 
     <ul>
      <li>RDD（Resilient Distributed Dataset）叫做<strong>弹性分布式数据集</strong>，是<strong>Spark中最基本的数据抽象</strong>，它代表一个不可变、可分区、里面的元素可并行计算的集合。RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度。</li> 
     </ul></li> 
    <li>&lt;2&gt;. RDD的属性（源码中的一段话） 
     <ul>
      <li>**一组分片（Partition）。**即数据集的基本组成单位。对于RDD来说，每个分片都会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的分片个数，如果没有指定，那么就会采用默认值。默认值就是程序所分配到的CPU Core的数目。</li> 
      <li>**一个计算每个分区的函数。**Spark中RDD的计算是以分片为单位的，每个RDD都会实现compute函数以达到这个目的。compute函数会对迭代器进行复合，不需要保存每次计算的结果。</li> 
      <li>**RDD之间的依赖关系。**RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。</li> 
      <li>**一个Partitioner，即RDD的分片函数。**当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。只有对于于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。</li> 
      <li>**一个列表。**存储存取每个Partition的优先位置（preferred location）。对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。</li> 
     </ul></li> 
    <li>&lt;3&gt;. RDD的创建方式 
     <ul>
      <li>通过外部的数据文件创建，如HDFS： 
       <ul>
        <li><code>val rdd1 = sc.textFile(“hdfs://XXXX:9000/data.txt”)</code></li> 
       </ul></li> 
      <li>通过sc.parallelize进行创建： 
       <ul>
        <li><code>val rdd1 = sc.parallelize(Array(1,2,3,4,5,6,7,8))</code></li> 
       </ul></li> 
      <li>DD的类型：Transformation和Action</li> 
     </ul></li> 
    <li>&lt;4&gt;. RDD的基本原理 
     <figure>
      <figcaption></figcaption>
     </figure></li> 
   </ul>
   <h3 class="heading">(2) Transformation</h3> 
   <ul>
    <li>RDD中的所有转换都是<strong>延迟加载</strong>的，也就是说，它们并不会直接计算结果。相反的，它们只是记住这些应用到基础数据集（例如一个文件）上的转换动作。只有当发生一个要求返回结果给Driver的动作时，这些转换才会真正运行。这种设计让Spark更加有效率地运行。 
     <figure>
      <figcaption></figcaption>
     </figure>
     <figure>
      <figcaption></figcaption>
     </figure></li> 
   </ul>
   <h3 class="heading">(3) Action</h3> 
   <p></p>
   <figure>
    <figcaption></figcaption>
   </figure>
   <p></p> 
   <h3 class="heading">(4) RDD的缓存机制</h3> 
   <ul>
    <li>RDD通过persist方法或cache方法可以将前面的计算结果缓存，但是并不是这两个方法被调用时立即缓存，而是触发后面的action时，该RDD将会被缓存在计算节点的内存中，并供后面重用。 
     <figure>
      <figcaption></figcaption>
     </figure></li> 
    <li>通过查看源码发现cache最终也是调用了persist方法，默认的存储级别都是仅在内存存储一份，Spark的存储级别还有好多种，存储级别在object StorageLevel中定义的。 
     <figure>
      <figcaption></figcaption>
     </figure></li> 
    <li>缓存有可能丢失，或者存储存储于内存的数据由于内存不足而被删除，RDD的缓存容错机制保证了即使缓存丢失也能保证计算的正确执行。通过基于RDD的一系列转换，丢失的数据会被重算，由于RDD的各个Partition是相对独立的，因此只需要计算丢失的部分即可，并不需要重算全部Partition。 
     <ul>
      <li>Demo示例： 
       <figure>
        <figcaption></figcaption>
       </figure></li> 
      <li>通过UI进行监控： 
       <figure>
        <figcaption></figcaption>
       </figure></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(5) RDD的Checkpoint（检查点）机制：容错机制</h3> 
   <ul>
    <li>检查点（本质是通过将RDD写入Disk做检查点）是为了通过lineage（血统）做容错的辅助，lineage过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果之后有节点出现问题而丢失分区，从做检查点的RDD开始重做Lineage，就会减少开销。</li> 
    <li>设置checkpoint的目录，可以是本地的文件夹、也可以是HDFS。一般是在具有容错能力，高可靠的文件系统上(比如HDFS, S3等)设置一个检查点路径，用于保存检查点数据。</li> 
    <li>分别举例说明： 
     <ul>
      <li>&lt;1&gt;. 本地目录</li> 
      <li><strong>注意：这种模式，需要将spark-shell运行在本地模式上</strong> 
       <figure>
        <figcaption></figcaption>
       </figure></li> 
      <li>&lt;2&gt;. HDFS的目录</li> 
      <li><strong>注意：这种模式，需要将spark-shell运行在集群模式上</strong> 
       <figure>
        <figcaption></figcaption>
       </figure></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(6) RDD的依赖关系和Spark任务中的Stage</h3> 
   <ul>
    <li> <p>RDD的依赖关系</p> 
     <ul>
      <li> <p>RDD和它依赖的父RDD（s）的关系有两种不同的类型，即窄依赖（narrow dependency）和宽依赖（wide dependency）。 </p>
       <figure>
        <figcaption></figcaption>
       </figure><p></p> </li> 
      <li> <p><strong>窄依赖</strong>指的是每一个父RDD的Partition最多被子RDD的一个Partition使用</p> 
       <ul>
        <li>总结：窄依赖我们形象的比喻为独生子女</li> 
       </ul></li> 
      <li> <p><strong>宽依赖</strong>指的是多个子RDD的Partition会依赖同一个父RDD的Partition</p> 
       <ul>
        <li>总结：窄依赖我们形象的比喻为超生</li> 
       </ul></li> 
     </ul></li> 
    <li> <p>Spark任务中的Stage</p> 
     <ul>
      <li>DAG(Directed Acyclic Graph)叫做有向无环图，原始的RDD通过一系列的转换就就形成了DAG，根据RDD之间的依赖关系的不同将DAG划分成不同的Stage，对于窄依赖，partition的转换处理在Stage中完成计算。对于宽依赖，由于有Shuffle的存在，只能在parent RDD处理完成后，才能开始接下来的计算，因此<strong>宽依赖是划分Stage的依据</strong>。 
       <figure>
        <figcaption></figcaption>
       </figure></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(7) RDD基础练习</h3> 
   <ul>
    <li> <p>练习1：</p> </li> 
    <li> <pre><code class="hljs bash copyable">  //通过并行化生成rdd
  val rdd1 = sc.parallelize(List(5, 6, 4, 7, 3, 8, 2, 9, 1, 10))
  //对rdd1里的每一个元素乘2然后排序
  val rdd2 = rdd1.map(_ * 2).sortBy(x =&gt; x, <span class="hljs-literal">true</span>)
  //过滤出大于等于十的元素
  val rdd3 = rdd2.filter(_ &gt;= 10)
  //将元素以数组的方式在客户端显示
  rdd3.collect
<span class="copy-code-btn">复制代码</span></code></pre></li> 
    <li> <p>练习2：</p> </li> 
    <li> <pre><code class="hljs bash copyable">  val rdd1 = sc.parallelize(Array(<span class="hljs-string">"a b c"</span>, <span class="hljs-string">"d e f"</span>, <span class="hljs-string">"h i j"</span>))
  //将rdd1里面的每一个元素先切分在压平
  val rdd2 = rdd1.flatMap(_.split(<span class="hljs-string">' '</span>))
  rdd2.collect
<span class="copy-code-btn">复制代码</span></code></pre></li> 
    <li> <p>练习3：</p> </li> 
    <li> <pre><code class="hljs bash copyable">  val rdd1 = sc.parallelize(List(5, 6, 4, 3))
  val rdd2 = sc.parallelize(List(1, 2, 3, 4))
  //求并集
  val rdd3 = rdd1.union(rdd2)
  //求交集
  val rdd4 = rdd1.intersection(rdd2)
  //去重
  rdd3.distinct.collect
  rdd4.collect
<span class="copy-code-btn">复制代码</span></code></pre></li> 
    <li> <p>练习4：</p> </li> 
    <li> <pre><code class="hljs bash copyable">  val rdd1 = sc.parallelize(List((<span class="hljs-string">"tom"</span>, 1), (<span class="hljs-string">"jerry"</span>, 3), (<span class="hljs-string">"kitty"</span>, 2)))
  val rdd2 = sc.parallelize(List((<span class="hljs-string">"jerry"</span>, 2), (<span class="hljs-string">"tom"</span>, 1), (<span class="hljs-string">"shuke"</span>, 2)))
  //求jion
  val rdd3 = rdd1.join(rdd2)
  rdd3.collect
  //求并集
  val rdd4 = rdd1 union rdd2
  //按key进行分组
  rdd4.groupByKey
  rdd4.collect
<span class="copy-code-btn">复制代码</span></code></pre></li> 
    <li> <p>练习5：</p> </li> 
    <li> <pre><code class="hljs bash copyable">  val rdd1 = sc.parallelize(List((<span class="hljs-string">"tom"</span>, 1), (<span class="hljs-string">"tom"</span>, 2), (<span class="hljs-string">"jerry"</span>, 3), (<span class="hljs-string">"kitty"</span>, 2)))
  val rdd2 = sc.parallelize(List((<span class="hljs-string">"jerry"</span>, 2), (<span class="hljs-string">"tom"</span>, 1), (<span class="hljs-string">"shuke"</span>, 2)))
  //cogroup
  val rdd3 = rdd1.cogroup(rdd2)
  //注意cogroup与groupByKey的区别
  rdd3.collect
<span class="copy-code-btn">复制代码</span></code></pre></li> 
    <li> <p>练习6：</p> </li> 
    <li> <pre><code class="hljs bash copyable">  val rdd1 = sc.parallelize(List(1, 2, 3, 4, 5))
  //reduce聚合
  val rdd2 = rdd1.reduce(_ + _)
  rdd2.collect
<span class="copy-code-btn">复制代码</span></code></pre></li> 
    <li> <p>练习7：</p> </li> 
    <li> <pre><code class="hljs bash copyable"> val rdd1 = sc.parallelize(List((<span class="hljs-string">"tom"</span>, 1), (<span class="hljs-string">"jerry"</span>, 3), (<span class="hljs-string">"kitty"</span>, 2),  (<span class="hljs-string">"shuke"</span>, 1)))
  val rdd2 = sc.parallelize(List((<span class="hljs-string">"jerry"</span>, 2), (<span class="hljs-string">"tom"</span>, 3), (<span class="hljs-string">"shuke"</span>, 2), (<span class="hljs-string">"kitty"</span>, 5)))
  val rdd3 = rdd1.union(rdd2)
  //按key进行聚合
  val rdd4 = rdd3.reduceByKey(_ + _)
  rdd4.collect
  //按value的降序排序
  val rdd5 = rdd4.map(t =&gt; (t._2, t._1)).sortByKey(<span class="hljs-literal">false</span>).map(t =&gt; (t._2, t._1))
  rdd5.collect 
<span class="copy-code-btn">复制代码</span></code></pre><h2 class="heading">7. Spark RDD的高级算子</h2> </li> 
   </ul>
   <h3 class="heading">(1) mapPartitionsWithIndex</h3> 
   <ul>
    <li>把每个partition中的分区号和对应的值拿出来 
     <ul>
      <li><code>def mapPartitionsWithIndex[U](f: (Int, Iterator[T]) ⇒ Iterator[U], preservesPartitioning: Boolean = false)(implicit arg0: ClassTag[U]): RDD[U]</code></li> 
     </ul></li> 
    <li>f中函数参数： 
     <ul>
      <li>第一个参数是Int，代表分区号</li> 
      <li>第二个Iterator[T]代表分区中的元素</li> 
     </ul></li> 
    <li>e.g.: 将每个分区中的元素和分区号打印出来 
     <ul>
      <li><code>val rdd1 = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 2)</code></li> 
      <li>创建一个函数返回RDD中的每个分区号和元素： 
       <ul>
        <li> <pre><code class="hljs bash copyable">def func1(index:Int, iter:Iterator[Int]):Iterator[String] ={
    iter.toList.map( x =&gt; <span class="hljs-string">"[PartID:"</span> + index + <span class="hljs-string">", value="</span> + x + <span class="hljs-string">"]"</span> ).iterator
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
      <li>调用：<code>rdd1.mapPartitionsWithIndex(func1).collect</code></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(2) aggregate</h3> 
   <ul>
    <li>先对局部聚合，再对全局聚合 
     <figure>
      <figcaption></figcaption>
     </figure></li> 
    <li>e.g.: <code>val rdd1 = sc.parallelize(List(1,2,3,4,5), 2)</code> 
     <ul>
      <li> <p>查看每个分区中的元素：</p> 
       <ul>
        <li> <pre><code class="hljs bash copyable">scala&gt; rdd1.mapPartitionsWithIndex(fun1).collect
  	res4: Array[String] = Array(
  	[partId : 0 , value = 1 ], [partId : 0 , value = 2 ], 
  	[partId : 1 , value = 3 ], [partId : 1 , value = 4 ], [partId : 1 , value = 5 ])
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
      <li> <p>将每个分区中的最大值求和，注意初始值是0:</p> 
       <ul>
        <li> <pre><code class="hljs bash copyable">scala&gt; rdd2.aggregate(0)(max(_,_),_+_)
  	res6: Int = 7
<span class="copy-code-btn">复制代码</span></code></pre></li> 
        <li>如果初始值时候100，则结果为300:</li> 
        <li> <pre><code class="hljs bash copyable">scala&gt; rdd2.aggregate(100)(max(_,_),_+_)
  	res8: Int = 300
    ```
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
      <li> <p>如果是求和，注意初始值是0：</p> 
       <ul>
        <li> <pre><code class="hljs bash copyable">scala&gt; rdd2.aggregate(0)(_+_,_+_)
  	res9: Int = 15
<span class="copy-code-btn">复制代码</span></code></pre></li> 
        <li>如果初始值是10，则结果是45</li> 
        <li> <pre><code class="hljs bash copyable">scala&gt; rdd2.aggregate(10)(_+_,_+_)
  	res10: Int = 45  
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
      <li> <p>e.g. —— 字符串：</p> 
       <ul>
        <li><code>val rdd2 = sc.parallelize(List("a","b","c","d","e","f"),2)</code></li> 
        <li>修改一下刚才的查看分区元素的函数 
         <ul>
          <li> <pre><code class="hljs bash copyable">def func2(index: Int, iter: Iterator[(String)]) : Iterator[String] = {
    iter.toList.map(x =&gt; <span class="hljs-string">"[partID:"</span> +  index + <span class="hljs-string">", val: "</span> + x + <span class="hljs-string">"]"</span>).iterator
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
          <li>两个分区中的元素： 
           <ul>
            <li> <pre><code class="hljs bash copyable">[partID:0, val: a], [partID:0, val: b], [partID:0, val: c],
[partID:1, val: d], [partID:1, val: e], [partID:1, val: f]
<span class="copy-code-btn">复制代码</span></code></pre></li> 
           </ul></li> 
          <li>运行结果：</li> 
         </ul></li> 
       </ul></li> 
      <li> <p>e.g.:</p> 
       <ul>
        <li> <pre><code class="hljs bash copyable">val rdd3 = sc.parallelize(List(<span class="hljs-string">"12"</span>,<span class="hljs-string">"23"</span>,<span class="hljs-string">"345"</span>,<span class="hljs-string">"4567"</span>),2)
rdd3.aggregate(<span class="hljs-string">""</span>)((x,y) =&gt; math.max(x.length, y.length).toString, (x,y) =&gt; x + y)
<span class="copy-code-btn">复制代码</span></code></pre></li> 
        <li> <p>结果可能是<code>24</code>，也可能是<code>42</code></p> </li> 
        <li> <pre><code class="hljs bash copyable">val rdd4 = sc.parallelize(List(<span class="hljs-string">"12"</span>,<span class="hljs-string">"23"</span>,<span class="hljs-string">"345"</span>,<span class="hljs-string">""</span>),2)
rdd4.aggregate(<span class="hljs-string">""</span>)((x,y) =&gt; math.min(x.length, y.length).toString, (x,y) =&gt; x + y)
<span class="copy-code-btn">复制代码</span></code></pre></li> 
        <li> <p>结果是<code>10</code>，也可能是<code>01</code></p> </li> 
        <li> <p>原因：注意有个初始值<code>""</code>，其长度0，然后0.toString变成字符串</p> </li> 
        <li> <pre><code class="hljs bash copyable">val rdd5 = sc.parallelize(List(<span class="hljs-string">"12"</span>,<span class="hljs-string">"23"</span>,<span class="hljs-string">""</span>,<span class="hljs-string">"345"</span>),2)
rdd5.aggregate(<span class="hljs-string">""</span>)((x,y) =&gt; math.min(x.length, y.length).toString, (x,y) =&gt; x + y)
<span class="copy-code-btn">复制代码</span></code></pre></li> 
        <li> <p>结果是<code>11</code>，原因同上。</p> </li> 
       </ul></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(3) aggregateByKey</h3> 
   <ul>
    <li> <p>准备数据：</p> 
     <ul>
      <li> <pre><code class="hljs bash copyable">val pairRDD = sc.parallelize(List( (<span class="hljs-string">"cat"</span>,2), (<span class="hljs-string">"cat"</span>, 5), (<span class="hljs-string">"mouse"</span>, 4),(<span class="hljs-string">"cat"</span>, 12), (<span class="hljs-string">"dog"</span>, 12), (<span class="hljs-string">"mouse"</span>, 2)), 2)
def func3(index: Int, iter: Iterator[(String, Int)]) : Iterator[String] = {
  iter.toList.map(x =&gt; <span class="hljs-string">"[partID:"</span> +  index + <span class="hljs-string">", val: "</span> + x + <span class="hljs-string">"]"</span>).iterator
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
    <li> <p>两个分区中的元素： </p>
     <figure>
      <figcaption></figcaption>
     </figure><p></p> </li> 
    <li> <p>e.g.:</p> 
     <ul>
      <li>将每个分区中的动物最多的个数求和</li> 
      <li> <pre><code class="hljs bash copyable">scala&gt; pairRDD.aggregateByKey(0)(math.max(_, _), _ + _).collect
res69: Array[(String, Int)] = Array((dog,12), (cat,17), (mouse,6))
<span class="copy-code-btn">复制代码</span></code></pre></li> 
      <li>将每种动物个数求和</li> 
      <li> <pre><code class="hljs bash copyable">scala&gt; pairRDD.aggregateByKey(0)(_+_, _ + _).collect
res71: Array[(String, Int)] = Array((dog,12), (cat,19), (mouse,6))
<span class="copy-code-btn">复制代码</span></code></pre></li> 
      <li>这个例子也可以使用：reduceByKey</li> 
      <li> <pre><code class="hljs bash copyable">scala&gt; pairRDD.reduceByKey(_+_).collect
res73: Array[(String, Int)] = Array((dog,12), (cat,19), (mouse,6))
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(4) coalesce与repartition</h3> 
   <ul>
    <li>都是将RDD中的分区进行重分区。</li> 
    <li>区别： 
     <ul>
      <li><strong>coalesce</strong>默认不会进行shuffle（false）；</li> 
      <li><strong>repartition</strong>会进行shuffle（true），会将数据真正通过网络进行重分区。</li> 
     </ul></li> 
    <li>e.g.: 
     <ul>
      <li> <pre><code class="hljs bash copyable">def func4(index: Int, iter: Iterator[(Int)]) : Iterator[String] = {
   iter.toList.map(x =&gt; <span class="hljs-string">"[partID:"</span> +  index + <span class="hljs-string">", val: "</span> + x + <span class="hljs-string">"]"</span>).iterator
}
 
val rdd1 = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 2)
 
下面两句话是等价的：
val rdd2 = rdd1.repartition(3)
val rdd3 = rdd1.coalesce(3,<span class="hljs-literal">true</span>) -&gt; 如果是<span class="hljs-literal">false</span>，查看RDD的length依然是2
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(5) 其他高级算子</h3> 
   <ul>
    <li>参考：<a href="https://link.juejin.im?target=http%3A%2F%2Fhomepage.cs.latrobe.edu.au%2Fzhe%2FZhenHeSparkRDDAPIExamples.html" rel="nofollow">homepage.cs.latrobe.edu.au/zhe/ZhenHeS…</a></li> 
   </ul>
   <h2 class="heading">8. Spark 基础编程案例</h2> 
   <h3 class="heading">(1) 求网站的访问量</h3> 
   <ul>
    <li> <p>Tomcat的访问日志如下： </p>
     <figure>
      <figcaption></figcaption>
     </figure><p></p> </li> 
    <li> <p>需求：找到访问量最高的两个网页，要求显示网页名称和访问量</p> </li> 
    <li> <p>步骤分析：</p> 
     <ul>
      <li>&lt;1&gt;. 对网页的访问量求和</li> 
      <li>&lt;2&gt;. 降序排序</li> 
     </ul></li> 
    <li> <p>代码：</p> 
     <ul>
      <li> <pre><code class="hljs bash copyable">import org.apache.spark.SparkConf
import org.apache.spark.SparkContext

object TomcatLogCount {
  
  def main(args: Array[String]): Unit = {
    
    val conf = new SparkConf().setMaster(<span class="hljs-string">"local"</span>).setAppName(<span class="hljs-string">"TomcatLogCount"</span>)
    val sc = new SparkContext(conf)
    
    /*
     * 读入日志并解析
     * 
     * 192.168.88.1 - - [30/Jul/2017:12:54:37 +0800] <span class="hljs-string">"GET /MyDemoWeb/oracle.jsp HTTP/1.1"</span> 200 242
     * */
    
    val rdd1 = sc.textFile(<span class="hljs-string">" "</span>).map(
        line =&gt; {
          //解析字符串，得到jsp的名字
          //1. 解析两个引号间的字符串
          val index1 = line.indexOf(<span class="hljs-string">"\""</span>)
          val index2 = line.lastIndexOf(<span class="hljs-string">"\""</span>)
          //line1 = GET /MyDemoWeb/oracle.jsp HTTP/1.1
          val line1 = line.substring(index1 + 1, index2)
          
          val index3 = line1.indexOf(<span class="hljs-string">" "</span>)
          val index4 = line1.lastIndexOf(<span class="hljs-string">" "</span>)
          //line2 = /MyDemoWeb/oracle.jsp
          val line2 = line1.substring(index3 + 1, index4)
          
          //得到jsp的名字  oracle.jsp
          val jspName = line2.substring(line2.lastIndexOf(<span class="hljs-string">"/"</span>))
          
          (jspName, 1)
        }
        )
    //统计每个jsp的次数
    val rdd2 = rdd1.reduceByKey(_+_)
    
    //使用Value排序
    val rdd3 = rdd2.sortBy(_._2, <span class="hljs-literal">false</span>)
    
    //得到次数最多的两个jsp
    rdd3.take(2).foreach(println)
  
    sc.stop()
  }
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(2) 创建自定义分区</h3> 
   <ul>
    <li>根据jsp文件的名字，将各自的访问日志放入到不同的分区文件中，如下： 
     <ul>
      <li> <p>生成的分区文件 </p>
       <figure>
        <figcaption></figcaption>
       </figure><p></p> </li> 
      <li> <p>如：part-00000文件中的内容：只包含了web.jsp的访问日志 </p>
       <figure>
        <figcaption></figcaption>
       </figure><p></p> </li> 
     </ul></li> 
    <li>代码： 
     <ul>
      <li> <pre><code class="hljs bash copyable">import org.apache.spark.SparkConf
import org.apache.spark.SparkContext
import scala.collection.mutable.HashMap


object TomcatLogPartitioner {
  
  def main(args: Array[String]): Unit = {
    
    val conf = new SparkConf().setMaster(<span class="hljs-string">"local"</span>).setAppName(<span class="hljs-string">"TomcatLogPartitioner"</span>)
    val sc = new SparkContext(conf)
    
    /*
     * 读入日志并解析
     * 
     * 192.168.88.1 - - [30/Jul/2017:12:54:37 +0800] <span class="hljs-string">"GET /MyDemoWeb/oracle.jsp HTTP/1.1"</span> 200 242
     * */
    
    val rdd1 = sc.textFile(<span class="hljs-string">" "</span>).map(
        line =&gt; {
          //解析字符串，得到jsp的名字
          //1. 解析两个引号间的字符串
          val index1 = line.indexOf(<span class="hljs-string">"\""</span>)
          val index2 = line.lastIndexOf(<span class="hljs-string">"\""</span>)
          //line1 = GET /MyDemoWeb/oracle.jsp HTTP/1.1
          val line1 = line.substring(index1 + 1, index2)
          
          val index3 = line1.indexOf(<span class="hljs-string">" "</span>)
          val index4 = line1.lastIndexOf(<span class="hljs-string">" "</span>)
          //line2 = /MyDemoWeb/oracle.jsp
          val line2 = line1.substring(index3 + 1, index4)
          
          //得到jsp的名字  oracle.jsp
          val jspName = line2.substring(line2.lastIndexOf(<span class="hljs-string">"/"</span>))
          
          (jspName, line)
        }
        )
        
        //得到不重复的jsp名字
        val rdd2 = rdd1.map(_._1).distinct().collect()
        
        //创建分区规则
        val wepPartitioner = new WepPartitioner(rdd2)
        val rdd3 = rdd1.partitionBy(wepPartitioner)
        
        //输出rdd3
        rdd3.saveAsTextFile(<span class="hljs-string">" "</span>)
    
  }
  
  //定义分区规则
  class WepPartitioner(jspList : Array[String]) extends Partitioner {
    
    /*
     * 定义集合来保存分区条件:
     * String 代表jsp的名字
     * Int 代表序号
     * */ 
     
    val partitionMap = new HashMap[String, Int]()
    //初始分区号
    val partID = 0
    //填值
    <span class="hljs-keyword">for</span> (jsp &lt;- jspList) {
      patitionMap.put(jsp, partID)
      partID += 1
    }
    
    //返回分区个数
    def numPartitioners : Int = partitionMap.size
    
    //根据jsp，返回对应的分区
      def getPartition(key : Any) : Int = partitionMap.getOrElse(key.toString(), 0)
      
  }
  
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(3) 使用JDBCRDD 访问数据库</h3> 
   <ul>
    <li> <p>JdbcRDD参数说明： </p>
     <figure>
      <figcaption></figcaption>
     </figure><p></p> </li> 
    <li> <p>从上面的参数说明可以看出，JdbcRDD有以下两个缺点：</p> 
     <ul>
      <li>&lt;1&gt;. 执行的SQL必须有两个参数，并类型都是Long</li> 
      <li>&lt;2&gt;. 得到的结果是ResultSet，即：只支持select操作</li> 
     </ul></li> 
    <li> <p>代码：</p> 
     <ul>
      <li> <pre><code class="hljs bash copyable">import org.apache.spark.SparkConf
import org.apache.spark.SparkContext
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement

/*
 * 把Spark结果存放到mysql数据库中
 *
 */

object TomcatLogCountToMysql {
  def main(args: Array[String]): Unit = {
    //创建SparkContext
    val conf = new SparkConf().setMaster(<span class="hljs-string">"local"</span>).setAppName(<span class="hljs-string">"MyTomcatLogCountToMysql"</span>)

    val sc = new SparkContext(conf)

    /*
     *
     * 读入日志 解析：
     *
     * 192.168.88.1 - - [30/Jul/2017:12:54:37 +0800] <span class="hljs-string">"GET /MyDemoWeb/oracle.jsp HTTP/1.1"</span> 200 242
     */

    val rdd1 = sc.textFile(<span class="hljs-string">"H:\\tmp_files\\localhost_access_log.txt"</span>)
      .map(
        line =&gt; {
          //解析字符串，得到jsp的名字
          //1、解析两个引号之间的字符串
          val index1 = line.indexOf(<span class="hljs-string">"\""</span>)
          val index2 = line.lastIndexOf(<span class="hljs-string">"\""</span>)
          val line1 = line.substring(index1 + 1, index2) // GET /MyDemoWeb/oracle.jsp HTTP/1.1

          //得到两个空格的位置
          val index3 = line1.indexOf(<span class="hljs-string">" "</span>)
          val index4 = line1.lastIndexOf(<span class="hljs-string">" "</span>)
          val line2 = line1.substring(index3 + 1, index4) // /MyDemoWeb/oracle.jsp

          //得到jsp的名字
          val jspName = line2.substring(line2.lastIndexOf(<span class="hljs-string">"/"</span>)) // oracle.jsp

          (jspName, 1)
        })

    //
    //    try {
    //      /*
    //       * create table mydata(jsname varchar(50),countNumber Int)
    //       *
    //       * foreach  没有返回值，在本需求中，只需要写数据库，不需要返回新的RDD，所以用foreach即可
    //       *
    //       *
    //       * 运行 Task not serializable
    //       */
    //      conn = DriverManager.getConnection(<span class="hljs-string">"jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>)
    //      pst = conn.prepareStatement(<span class="hljs-string">"insert into mydata values(?,?)"</span>)
    //
    //      rdd1.foreach(f =&gt; {
    //        pst.setString(1, f._1)
    //        pst.setInt(2, f._2)
    //
    //        pst.executeUpdate()
    //      })
    //    } catch {
    //      <span class="hljs-keyword">case</span> t: Throwable =&gt; t.printStackTrace()
    //    } finally {
    //      <span class="hljs-keyword">if</span> (pst != null) pst.close()
    //      <span class="hljs-keyword">if</span> (conn != null) conn.close()
    //    }
    //
    //    sc.stop()
    //    //存入数据库
    //    var conn: Connection = null
    //    var pst: PreparedStatement = null

    //    //第一种修改方法
    //    /*
    //     * 修改思路：
    //     * conn pst 让每一个节点都是用到，需要在不同的节点上传输，实现sericalizable接口
    //     */
    //    try {
    //      rdd1.foreach(f =&gt; {
    //        conn = DriverManager.getConnection(<span class="hljs-string">"jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>)
    //        pst = conn.prepareStatement(<span class="hljs-string">"insert into mydata values(?,?)"</span>)
    //
    //        pst.setString(1, f._1)
    //        pst.setInt(2, f._2)
    //
    //        pst.executeUpdate()
    //      })
    //    } catch {
    //      <span class="hljs-keyword">case</span> t: Throwable =&gt; t.printStackTrace()
    //    } finally {
    //      <span class="hljs-keyword">if</span> (pst != null) pst.close()
    //      <span class="hljs-keyword">if</span> (conn != null) conn.close()
    //    }
    //
    //    sc.stop()

    /*
     * 第一种修改方式，功能上可以实现，但每条数据都会创建连接，对数据库造成很大压力
     *
     * 针对分区来操作：一个分区，建立一个连接即可
     */
    rdd1.foreachPartition(saveToMysql)
    sc.stop()

  }

  def saveToMysql(it: Iterator[(String, Int)]) = {
    var conn: Connection = null
    var pst: PreparedStatement = null

    try {
      conn = DriverManager.getConnection(<span class="hljs-string">"jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>)
      pst = conn.prepareStatement(<span class="hljs-string">"insert into mydata values(?,?)"</span>)

      it.foreach(f =&gt; {

        pst.setString(1, f._1)
        pst.setInt(2, f._2)

        pst.executeUpdate()
      })
    } catch {
      <span class="hljs-keyword">case</span> t: Throwable =&gt; t.printStackTrace()
    } finally {
      <span class="hljs-keyword">if</span> (pst != null) pst.close()
      <span class="hljs-keyword">if</span> (conn != null) conn.close()
    }
  }

}
<span class="copy-code-btn">复制代码</span></code></pre><h2 class="heading">9. 认识 Spark SQL</h2> </li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(1) 什么是Spark SQL</h3> 
   <ul>
    <li>Spark SQL is Apache Spark's module for working with structured data.（Spark SQL 是spark 的一个模块，用来处理 结构化的数据。&lt;不能处理非结构化的数据&gt;）</li> 
    <li>Spark SQL是Spark用来处理结构化数据的一个模块，它提供了一个编程抽象叫做DataFrame并且作为分布式SQL查询引擎的作用。</li> 
   </ul>
   <h3 class="heading">(2) 为什么要学习Spark SQL</h3> 
   <ul>
    <li>Hive是将HQL转换成MapReduce然后提交到集群上执行，大大简化了编写MapReduce的程序的复杂性，但是MapReduce这种计算模型执行效率比较慢。所以Spark SQL的应运而生，它是将Spark SQL转换成RDD，然后提交到集群执行，执行效率非常快，同时Spark SQL也支持从Hive中读取数据，Hive 2.x 执行引擎可以使用Spark。</li> 
   </ul>
   <h3 class="heading">(3) Spark SQL的特点：</h3> 
   <ul>
    <li>&lt;1&gt;. 容易集成 
     <ul>
      <li>不需要单独安装。</li> 
     </ul></li> 
    <li>&lt;2&gt;. 统一的数据访问方式 
     <ul>
      <li>结构化数据（JDBC、JSon、Hive、parquer文件）都可以作为Spark SQL 的数据源。 
       <ul>
        <li>对接多种数据源，且使用方式类似。</li> 
       </ul></li> 
     </ul></li> 
    <li>&lt;3&gt;. 兼容Hive 
     <ul>
      <li>把Hive中的数据，读取到Spark SQL中运行。</li> 
     </ul></li> 
    <li>&lt;4&gt;. 支持标准的数据连接（JDBC）</li> 
   </ul>
   <h2 class="heading">10. Spark SQL 基础</h2> 
   <h3 class="heading">(1) 基本概念：Datasets和DataFrames</h3> 
   <ul>
    <li> <p>&lt;1&gt;. DataFrame</p> 
     <ul>
      <li> <p>DataFrame是组织成命名列的数据集。它在概念上等同于关系数据库中的表，但在底层具有更丰富的优化。DataFrames可以从各种来源构建，</p> </li> 
      <li> <p>例如：</p> 
       <ul>
        <li>结构化数据文件</li> 
        <li>Hive中的表</li> 
        <li>外部数据库或现有RDDs</li> 
       </ul></li> 
      <li> <p>DataFrame API支持的语言有Scala，Java，Python和R。</p> </li> 
      <li> <p>从上图可以看出，DataFrame多了数据的结构信息，即schema。RDD是分布式的 Java对象的集合。DataFrame是分布式的Row对象的集合。DataFrame除了提供了比RDD更丰富的算子以外，更重要的特点是提升执行效率、减少数据读取以及执行计划的优化。</p> </li> 
     </ul></li> 
    <li> <p>&lt;2&gt;. Datasets</p> 
     <ul>
      <li>Dataset是数据的分布式集合。Dataset是在Spark 1.6中添加的一个新接口，是DataFrame之上更高一级的抽象。它提供了RDD的优点（强类型化，使用强大的lambda函数的能力）以及Spark SQL优化后的执行引擎的优点。一个Dataset 可以从JVM对象构造，然后使用函数转换（map， flatMap，filter等）去操作。Dataset API 支持Scala和Java，Python不支持Dataset API。</li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(2) DataFrames</h3> 
   <ul>
    <li> <p>&lt;1&gt;. 创建 DataFrames</p> 
     <ul>
      <li>a. 通过Case Class创建DataFrames 
       <ul>
        <li>① 定义case class（相当于表的结构：Schema） 
         <ul>
          <li><code>case class Emp(empno:Int,ename:String,job:String,mgr:Int,hiredate:String,sal:Int,comm:Int,deptno:Int)</code></li> 
          <li>注意：由于mgr和comm列中包含null值，简单起见，将对应的case class类型定义为String</li> 
         </ul></li> 
        <li>② 将HDFS上的数据读入RDD，并将RDD与case Class关联 
         <ul>
          <li><code>val lines = sc.textFile("/XXXX/emp.csv").map(_.split(","))</code></li> 
         </ul></li> 
        <li>③ 将RDD转换成DataFrames 
         <ul>
          <li><code>val allEmp = lines.map(x =&gt; Emp(x(0).toInt,x(1),x(2),x(3).toInt,x(4),x(5).toInt,x(6).toInt,x(7).toInt))</code></li> 
         </ul></li> 
        <li>④ 通过DataFrames查询数据 
         <ul>
          <li><code>val df1 = allEmp.toDF</code></li> 
          <li><code>df1.show</code></li> 
         </ul></li> 
       </ul></li> 
      <li>b. 使用SparkSession 
       <ul>
        <li>什么是SparkSession 
         <ul>
          <li>Apache Spark 2.0引入了SparkSession，其为用户提供了一个统一的切入点来使用Spark的各项功能，并且允许用户通过它调用DataFrame和Dataset相关API来编写Spark程序。最重要的是，它减少了用户需要了解的一些概念，使得我们可以很容易地与Spark交互。</li> 
          <li>在2.0版本之前，与Spark交互之前必须先创建SparkConf和SparkContext。然而在Spark 2.0中，我们可以通过SparkSession来实现同样的功能，而不需要显式地创建SparkConf, SparkContext 以及 SQLContext，因为这些对象已经封装在SparkSession中。   - 创建StructType，来定义Schema结构信息</li> 
          <li>注意：需要<code>import org.apache.spark.sql.types._</code>，<code>import org.apache.spark.sql.Row</code></li> 
          <li> <pre><code class="hljs bash copyable"> import org.apache.spark.sql.types._
    
		val myschema = StructType(
		List(
		StructField(<span class="hljs-string">"empno"</span>,DataTypes.IntegerType),
		StructField(<span class="hljs-string">"ename"</span>,DataTypes.StringType),
		StructField(<span class="hljs-string">"job"</span>,DataTypes.StringType),
		StructField(<span class="hljs-string">"mgr"</span>,DataTypes.IntegerType),
		StructField(<span class="hljs-string">"hiredate"</span>,DataTypes.StringType),
		StructField(<span class="hljs-string">"sal"</span>,DataTypes.IntegerType),
		StructField(<span class="hljs-string">"comm"</span>,DataTypes.IntegerType),
		StructField(<span class="hljs-string">"deptno"</span>,DataTypes.IntegerType),
		))
		
		val allEmp = lines.map(x =&gt; Row(x(0).toInt,x(1),x(2),x(3).toInt,x(4),x(5).toInt,x(6).toInt,x(7).toInt))
	
		import org.apache.spark.sql.Row
		
		val df2 = spark.createDataFrame(allEmp,myschema)
<span class="copy-code-btn">复制代码</span></code></pre></li> 
         </ul></li> 
       </ul></li> 
      <li>c. 使用JSon文件来创建DataFame 
       <ul>
        <li> <pre><code class="hljs bash copyable">val df3 = spark.read    读文件，默认是Parquet文件
  	val df3 = spark.read.json(<span class="hljs-string">"/XXXX/people.json"</span>)    读json文件
  	
  	df3.show
  	
  	val df4 = spark.read.format(<span class="hljs-string">"json"</span>).load(<span class="hljs-string">"/XXXX/people.json"</span>)
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
     </ul></li> 
    <li> <p>&lt;2&gt;. DataFrame 操作</p> 
     <ul>
      <li> <p>DataFrame操作也称为无类型的Dataset操作</p> </li> 
      <li> <p>a. DSL语句</p> 
       <ul>
        <li>查询所有的员工姓名 
         <figure>
          <figcaption></figcaption>
         </figure></li> 
        <li>查询所有的员工姓名和薪水，并给薪水加100块钱 
         <figure>
          <figcaption></figcaption>
         </figure></li> 
        <li>查询工资大于2000的员工 
         <figure>
          <figcaption></figcaption>
         </figure></li> 
        <li>求每个部门的员工人数 
         <figure>
          <figcaption></figcaption>
         </figure></li> 
        <li>参考：<a href="https://link.juejin.im?target=http%3A%2F%2Fspark.apache.org%2Fdocs%2F2.1.0%2Fapi%2Fscala%2Findex.html%23org.apache.spark.sql.Dataset" rel="nofollow">spark.apache.org/docs/2.1.0/…</a></li> 
       </ul></li> 
      <li> <p>b. SQL语句</p> 
       <ul>
        <li>**注意：**不能直接执行SQL，需要生成一个视图，再执行sql。</li> 
        <li>① 将DataFrame注册成表（视图）：<code>df.createOrReplaceTempView("emp")</code></li> 
        <li>② 执行查询： 
         <ul>
          <li><code>spark.sql("select * from emp").show</code></li> 
          <li><code>spark.sql("select * from emp where deptno=10").show</code></li> 
          <li><code>spark.sql("select deptno,sum(sal) from emp group by deptno").show</code></li> 
         </ul></li> 
       </ul></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(3) Spark SQL 中的视图</h3> 
   <ul>
    <li>视图是一个虚表，不存储数据。</li> 
    <li>两种类型： 
     <ul>
      <li> <p>&lt;1&gt;. <strong>普通视图（本地视图）</strong>——createOrReplaceTempView</p> 
       <ul>
        <li>只在当前Session中有效。</li> 
       </ul></li> 
      <li> <p>&lt;2&gt;. <strong>全局视图：</strong> ——createGlobalTempView</p> 
       <ul>
        <li>在Spark SQL中，如果想拥有一个临时的view，并想在不同的Session中共享，而且在application的运行周期内可用，那么就需要创建一个全局的临时view。并记得使用的时候加上global_temp作为前缀来引用它，因为全局的临时view是绑定到系统保留的数据库global_temp上。</li> 
       </ul></li> 
      <li> <p>e.g.: ``` 创建一个新session，读取不到emp视图 spark.newSession.sql("select * from emp")</p> <pre><code class="copyable">以下两种方式均可读到 全局视图 中的数据:
df1.createGlobalTempView("emp1")
spark.newSession.sql("select * from global_temp.emp1").show

spark.sql("select * from global_temp.emp1").show
<span class="copy-code-btn">复制代码</span></code></pre> <pre><code class="hljs bash copyable">
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(4) 创建Datasets</h3> 
   <ul>
    <li>DataFrame的引入，可以让Spark更好的处理结构数据的计算，但其中一个主要的问题是：缺乏编译时类型安全。为了解决这个问题，Spark采用新的Dataset API (DataFrame API的类型扩展)。 
     <figure>
      <figcaption></figcaption>
     </figure></li> 
    <li>Dataset是一个分布式的数据收集器。这是在Spark1.6之后新加的一个接口，兼顾了RDD的优点（强类型，可以使用功能强大的lambda）以及Spark SQL的执行器高效性的优点。所以可以把DataFrames看成是一种特殊的Datasets，即：Dataset(Row)</li> 
    <li>创建DataSet： 
     <ul>
      <li>&lt;1&gt;. 使用序列 
       <ul>
        <li>① 定义case class: 
         <ul>
          <li><code>case class MyData(a:Int,b:String)</code></li> 
         </ul></li> 
        <li>② 生成序列并创建DataSet: 
         <ul>
          <li><code>val ds = Seq(MyData(1,"Tom"),MyData(2,"Mary")).toDS</code></li> 
         </ul></li> 
        <li>③ 查看结果 
         <ul>
          <li><code>ds.show</code></li> 
         </ul></li> 
       </ul></li> 
      <li>&lt;2&gt;. 使用JSON数据 
       <ul>
        <li>① 定义case class: 
         <ul>
          <li><code>case class Person(name: String, gender: String)</code></li> 
         </ul></li> 
        <li>② 通过JSON数据生成DataFrame: 
         <ul>
          <li><code>val df = spark.read.json(sc.parallelize("""{"gender": "Male", "name": "Tom"}""" :: Nil))</code></li> 
         </ul></li> 
        <li>③ 将DataFrame转成DataSet: 
         <ul>
          <li><code>df.as[Person].show</code></li> 
          <li><code>df.as[Person].collect</code></li> 
         </ul></li> 
       </ul></li> 
      <li>&lt;3&gt;. 使用HDFS数据 
       <ul>
        <li>① 读取HDFS数据，并创建DataSet: 
         <ul>
          <li><code>val linesDS = spark.read.text("hdfs://XXXX:9000/XXXX/data.txt").as[String]</code></li> 
         </ul></li> 
        <li>② 对DataSet进行操作：分词后，查询长度大于3的单词 
         <ul>
          <li> <pre><code class="hljs bash copyable">val words = linesDS.flatMap(_.split(<span class="hljs-string">" "</span>)).filter(_.length &gt; 3)
words.show
words.collect
<span class="copy-code-btn">复制代码</span></code></pre></li> 
         </ul></li> 
        <li>③ 执行WordCount程序 
         <ul>
          <li> <pre><code class="hljs bash copyable">val result = linesDS.flatMap(_.split(<span class="hljs-string">" "</span>)).map((_,1)).groupByKey(x =&gt; x._1).count
result.show
排序：result.orderBy($<span class="hljs-string">"value"</span>).show
<span class="copy-code-btn">复制代码</span></code></pre></li> 
         </ul></li> 
       </ul></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(5) Datasets 的操作案例</h3> 
   <ul>
    <li>&lt;1&gt;. 使用emp.json 生成DataFrame: 
     <ul>
      <li> <pre><code class="hljs bash copyable">val empDF = spark.read.json(<span class="hljs-string">"/XXXX/emp.json"</span>)
查询工资大于3000的员工
empDF.where($<span class="hljs-string">"sal"</span> &gt;= 3000).show
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
    <li>&lt;2&gt;. 创建case class: 
     <ul>
      <li><code>case class Emp(empno:Long,ename:String,job:String,hiredate:String,mgr:String,sal:Long,comm:String,deptno:Long)</code></li> 
     </ul></li> 
    <li>&lt;3&gt;. 生成DataSets并查询数据: 
     <ul>
      <li> <pre><code class="hljs bash copyable"> val empDS = empDF.as[Emp]

 查询工资大于3000的员工
 empDS.filter(_.sal &gt; 3000).show

 查看10号部门的员工
 empDS.filter(_.deptno == 10).show
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
    <li>&lt;4&gt;. 多表查询: 
     <ul>
      <li>a. 创建部门表: 
       <ul>
        <li> <pre><code class="hljs bash copyable">  val deptRDD=sc.textFile(<span class="hljs-string">"/XXXX/dept.csv"</span>).map(_.split(<span class="hljs-string">","</span>))
  <span class="hljs-keyword">case</span> class Dept(deptno:Int,dname:String,loc:String)
  val deptDS = deptRDD.map(x=&gt;Dept(x(0).toInt,x(1),x(2))).toDS
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul><pre><code class="hljs bash copyable"><span class="copy-code-btn">复制代码</span></code></pre></li> 
      <li>b. 创建员工表: 
       <ul>
        <li> <pre><code class="hljs bash copyable"><span class="hljs-keyword">case</span> class Emp(empno:Int,ename:String,job:String,mgr:String,hiredate:String,sal:Int,comm:String,deptno:Int)
val empRDD = sc.textFile(<span class="hljs-string">"/XXXX/emp.csv"</span>).map(_.split(<span class="hljs-string">","</span>))
val empDS = empRDD.map(x =&gt; Emp(x(0).toInt,x(1),x(2),x(3),x(4),x(5).toInt,x(6),x(7).toInt)).toDS
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
      <li>c. 执行多表查询：等值链接 
       <ul>
        <li> <pre><code class="hljs bash copyable">val result = deptDS.join(empDS,<span class="hljs-string">"deptno"</span>)

另一种写法：注意有三个等号
val result = deptDS.joinWith(empDS,deptDS(<span class="hljs-string">"deptno"</span>)=== empDS(<span class="hljs-string">"deptno"</span>))
joinWith和join的区别是连接后的新Dataset的schema会不一样
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
     </ul></li> 
    <li>&lt;5&gt;. 查看执行计划： 
     <ul>
      <li><code>result.explain</code></li> 
     </ul></li> 
   </ul>
   <h2 class="heading">11. Spark SQL 进阶</h2> 
   <h3 class="heading">(1) 使用数据源</h3> 
   <ul>
    <li>&lt;1&gt;. 什么是parquet文件 
     <ul>
      <li>Parquet是列式存储格式的一种文件类型，列式存储有以下的核心： 
       <ul>
        <li>可以跳过不符合条件的数据，只读取需要的数据，降低IO数据量。</li> 
        <li>压缩编码可以降低磁盘存储空间。由于同一列的数据类型是一样的，可以使用更高效的压缩编码（例如Run Length Encoding和Delta Encoding）进一步节约存储空间。</li> 
        <li>只读取需要的列，支持向量运算，能够获取更好的扫描性能。</li> 
        <li><strong>Parquet格式是Spark SQL的默认数据源，可通过spark.sql.sources.default配置</strong></li> 
       </ul></li> 
     </ul></li> 
    <li>&lt;2&gt;. 使用Load/Save函数 
     <ul>
      <li>load函数是加载数据，save是存储数据。</li> 
      <li>e.g.: 
       <ul>
        <li> <pre><code class="hljs bash copyable">  读取 users.parquet 文件（Spark自带的示例文件）
  val userDF = spark.read.load(<span class="hljs-string">"/root/users.parquet"</span>)
  查看结构：
  userDF.printSchema
  查看内容：
  userDF.show
  
  读取json文件：
  val userDF = spark.read.load(<span class="hljs-string">"/root/emp.json"</span>) ——&gt;报错
  正确方法：
  val userDF = spark.read.format(<span class="hljs-string">"json"</span>).load(<span class="hljs-string">"/root/emp.json"</span>)
  val userDF = spark.read.json(<span class="hljs-string">"/root/emp.json"</span>)

  保存parquet文件到本地路径：
  userDF.select($<span class="hljs-string">"name"</span>,$<span class="hljs-string">"favorite_color"</span>).write.save(<span class="hljs-string">"/root/parquet"</span>)
  
  读取刚写入的文件：
  val userDF1 = spark.read.load(<span class="hljs-string">"/root/parquet/part-00000-888d505a-7d51-4a50-aaf5-2bbdb56e67a1.snappy.parquet"</span>) --&gt; 不推荐
  
  生产：（直接读目录）
  val userDF2 = spark.read.load(<span class="hljs-string">"/usr/local/tmp_files/parquet"</span>)
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
      <li>关于save函数： 
       <ul>
        <li> <p>调用save函数的时候，可以指定存储模式，追加、覆盖等等</p> </li> 
        <li> <p>可以采用SaveMode执行存储操作，SaveMode定义了对数据的处理模式。需要注意的是，这些保存模式不使用任何锁定，不是原子操作。此外，当使用Overwrite方式执行时，在输出新数据之前原数据就已经被删除。SaveMode详细介绍如下表：</p> </li> 
        <li> <pre><code class="hljs bash copyable">userDF2.write.save(<span class="hljs-string">"/root/parquet"</span>) ——&gt;报错
  	
save的时候覆盖：
userDF2.write.mode(<span class="hljs-string">"overwrite"</span>).save(<span class="hljs-string">"/root/parquet"</span>)
将结果保存成表：
userDF2.select($<span class="hljs-string">"name"</span>).write.saveAsTable(<span class="hljs-string">"table1"</span>)
查看数据：
spark.sql(<span class="hljs-string">"select * from table2"</span>).show

也可以进行分区、分桶等操作：partitionBy、bucketBy
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
     </ul></li> 
    <li>&lt;3&gt;. Parquet文件 
     <ul>
      <li>Parquet是一个列格式而且用于多个数据处理系统中。Spark SQL提供支持对于Parquet文件的读写，也就是自动保存原始数据的schema。当写Parquet文件时，所有的列被自动转化为nullable，因为兼容性的缘故。</li> 
      <li>e.g.: 
       <ul>
        <li> <pre><code class="hljs bash copyable">读入json格式的数据，将其转换成parquet格式，并创建相应的表来使用SQL进行查询。（把数据读进来，再写出去，就是Parquet文件）

读入文件：
val empDF = spark.read.json(<span class="hljs-string">"/root/emp.json"</span>)

写出文件：
empDF.write.mode(<span class="hljs-string">"overwrite"</span>).save(<span class="hljs-string">"/root/parquet"</span>)
empDF.write.mode(<span class="hljs-string">"overwrite"</span>).parquet(<span class="hljs-string">"/root/parquet"</span>)
  	
建表查询：
val emp1 = spark.read.parquet(<span class="hljs-string">"/root/parquet"</span>)
emp1.createOrReplaceTempView(<span class="hljs-string">"emp1"</span>)
spark.sql(<span class="hljs-string">"select * from emp1"</span>).show
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
     </ul></li> 
    <li>&lt;4&gt;. Schema的合并： 
     <ul>
      <li>Parquet支持Schema evolution（Schema演变，即：合并）。用户可以先定义一个简单的Schema，然后逐渐的向Schema中增加列描述。通过这种方式，用户可以获取多个有不同Schema但相互兼容的Parquet文件。</li> 
      <li>e.g.: 
       <ul>
        <li> <pre><code class="hljs bash copyable">通过RDD来创建DataFrame:
val df1 = sc.makeRDD(1 to 5).map( i =&gt; (i,i*2)).toDF(<span class="hljs-string">"single"</span>,<span class="hljs-string">"double"</span>) ——&gt;<span class="hljs-string">"single"</span>,<span class="hljs-string">"double"</span>  是表结构
df1.show
df1.write.mode(<span class="hljs-string">"overwrite"</span>).save(<span class="hljs-string">"/root/test_table/key=1"</span>)
val df2 = sc.makeRDD(6 to 10).map( i =&gt; (i,i*3)).toDF(<span class="hljs-string">"single"</span>,<span class="hljs-string">"triple"</span>)
df2.show
df2.write.mode(<span class="hljs-string">"overwrite"</span>).save(<span class="hljs-string">"/root/test_table/key=2"</span>)
  	
合并两个部分:
val df3 = spark.read.parquet(<span class="hljs-string">"/root/tmp_files/test_table"</span>)
val df3 = spark.read.option(<span class="hljs-string">"mergeSchema"</span>,<span class="hljs-literal">true</span>).parquet(<span class="hljs-string">"/root/tmp_files/test_table"</span>)
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
     </ul></li> 
    <li>&lt;5&gt;. JSON Datasets 
     <ul>
      <li>Spark SQL能自动解析JSON数据集的Schema，读取JSON数据集为DataFrame格式。读取JSON数据集方法为SQLContext.read().json()。该方法将String格式的RDD或JSON文件转换为DataFrame。</li> 
      <li>需要注意的是，这里的JSON文件不是常规的JSON格式。JSON文件每一行必须包含一个独立的、自满足有效的JSON对象。如果用多行描述一个JSON对象，会导致读取出错。读取JSON数据集示例如下：</li> 
      <li> <pre><code class="hljs bash copyable">读取Json文件，生成DataFrame:
val peopleDF = spark.read.json(<span class="hljs-string">"/usr/local/tmp_files/people.json"</span>)
打印Schema结构信息：
peopleDF.printSchema
创建临时视图：
peopleDF.createOrReplaceTempView(<span class="hljs-string">"peopleView"</span>)
执行查询：
spark.sql(<span class="hljs-string">"select * from peopleView"</span>).show
Spark SQL 支持统一的访问接口。对于不同的数据源，读取进来，生成DataFrame后，操作完全一样。
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
    <li>&lt;6&gt;. 使用JDBC 
     <ul>
      <li>Spark SQL同样支持通过JDBC读取其他数据库的数据作为数据源。</li> 
      <li>Spark加载MySQL： 
       <ul>
        <li><code>spark-shell --master spark://XXXX:7077 --jars /XXXX/.jar --driver-class-path /XXXX/.jar</code></li> 
       </ul></li> 
      <li>Spark连接MySQL： 
       <ul>
        <li>方法一： 
         <ul>
          <li> <pre><code class="hljs bash copyable">  val mysqlDF = spark.read.format(<span class="hljs-string">"jdbc"</span>).option(<span class="hljs-string">"url"</span>,<span class="hljs-string">"jdbc:mysql://XXXX:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8"</span>).option(<span class="hljs-string">"user"</span>,<span class="hljs-string">"root"</span>).option(<span class="hljs-string">"password"</span>,<span class="hljs-string">"123456"</span>).option(<span class="hljs-string">"driver"</span>,<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>).option(<span class="hljs-string">"dbtable"</span>,<span class="hljs-string">"emp"</span>).load

  mysqlDF.show```
<span class="copy-code-btn">复制代码</span></code></pre></li> 
         </ul></li> 
        <li>方式二：定义一个Properties类 
         <ul>
          <li> <pre><code class="hljs bash copyable">  import java.util.Properties
  val mysqlProps = new Properties()
  mysqlProps.setProperty(<span class="hljs-string">"user"</span>,<span class="hljs-string">"root"</span>)
  mysqlProps.setProperty(<span class="hljs-string">"password"</span>,<span class="hljs-string">"123456"</span>)
  
  val mysqlDF1 = spark.read.jdbc(<span class="hljs-string">"jdbc:mysql://XXXX:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8"</span>,<span class="hljs-string">"emp"</span>,mysqlProps)
  
  mysqlDF1.show	```
<span class="copy-code-btn">复制代码</span></code></pre></li> 
         </ul></li> 
       </ul></li> 
     </ul></li> 
    <li>&lt;7&gt;. 使用Hive Table 
     <ul>
      <li>a. 准备工作： 
       <ul>
        <li>搭建好Hive的环境（需要Hadoop）</li> 
        <li>配置Spark SQL支持Hive： 
         <ul>
          <li>将以下文件拷贝到$SPARK_HOME/conf的目录下，即可 
           <ul>
            <li>$HIVE_HOME/conf/hive-site.xml</li> 
            <li>$HADOOP_CONF_DIR/core-site.xml</li> 
            <li>$HADOOP_CONF_DIR/hdfs-site.xml</li> 
           </ul></li> 
          <li>重启Spark</li> 
         </ul></li> 
       </ul></li> 
      <li>b. 使用Spark Shell操作Hive 
       <ul>
        <li>启动Hadoop、Hive</li> 
        <li>启动Spark 
         <ul>
          <li>启动spark-sql的时候，需要使用--jars指定mysql的驱动程序</li> 
         </ul></li> 
        <li>创建表：<code>spark.sql("create table spark.emp1(empno Int,ename String,job String,mgr String,hiredate String,sal Int,comm String,deptno Int)row format delimited fields terminated by ','")</code></li> 
        <li>导入数据：<code>spark.sql("load data local inpath '/root/emp.csv' overwrite into table spark.emp1")</code></li> 
        <li>查询数据：<code>spark.sql("select * from spark.emp1").show</code></li> 
       </ul></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(2) 在IDE中开发Spark SQL</h3> 
   <ul>
    <li>&lt;1&gt;. 创建DataFrame 
     <ul>
      <li>a. StructType方式 
       <ul>
        <li> <pre><code class="hljs bash copyable">  package Demo

  import org.apache.spark.sql.SparkSession
  import org.apache.spark.sql.types.StructType
  import org.apache.spark.sql.types.StructField
  import org.apache.spark.sql.types.IntegerType
  import org.apache.spark.sql.types.StringType
  import org.apache.spark.sql.Row
  import org.apache.log4j.Logger
  import org.apache.log4j.Level
  
  /*创建DataFrame StructType方式*/
  object Demo01 {
  
    def main(args: Array[String]): Unit = {
  
      Logger.getLogger(<span class="hljs-string">"org.apache.spark"</span>).setLevel(Level.ERROR)
  		Logger.getLogger(<span class="hljs-string">"org.eclipse.jetty.server"</span>).setLevel(Level.OFF)
      
      // 创建Spark Session对象
      val spark = SparkSession.builder().master(<span class="hljs-string">"local"</span>).appName(<span class="hljs-string">"Demo1"</span>).getOrCreate()
  
      // 从指定的地址创建RDD对象
      /*1    Tom    12
  		 *2    Mary	  13
  		 *3    Lily	  15
       * */
      val personRDD = spark.sparkContext.textFile(<span class="hljs-string">"/Users/apple/Documents/student.txt"</span>).map(_.split(<span class="hljs-string">"\t"</span>))
  
      // 通过StructType方式指定Schema
      val schema = StructType(
        List(
          StructField(<span class="hljs-string">"id"</span>, IntegerType),
          StructField(<span class="hljs-string">"name"</span>, StringType),
          StructField(<span class="hljs-string">"age"</span>, IntegerType)))
  
      // 将RDD映射到rowRDD上，映射到Schema上
      val rowRDD = personRDD.map(p =&gt; Row(p(0).toInt, p(1), p(2).toInt))
      val personDataFrame = spark.createDataFrame(rowRDD, schema)
  
      // 注册视图
      personDataFrame.createOrReplaceTempView(<span class="hljs-string">"t_person"</span>)
  
      //执行SQL语句
      val df = spark.sql(<span class="hljs-string">"select * from t_person order by age desc"</span>)
  
      df.show()

  spark.stop()
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul> }<pre><code class="hljs bash copyable"><span class="copy-code-btn">复制代码</span></code></pre></li> 
      <li>b. case Class方式 
       <ul>
        <li> <pre><code class="hljs bash copyable">  package Demo

  import org.apache.spark.sql.SparkSession
  import org.apache.spark.sql.types.StructType
  import org.apache.spark.sql.types.StructField
  import org.apache.spark.sql.types.IntegerType
  import org.apache.spark.sql.types.StringType
  import org.apache.spark.sql.Row
  import org.apache.log4j.Logger
  import org.apache.log4j.Level
  
  /*使用<span class="hljs-keyword">case</span> Class来创建DataFrame*/
  object Demo02 {
  
    def main(args: Array[String]): Unit = {
      Logger.getLogger(<span class="hljs-string">"org.apache.spark"</span>).setLevel(Level.ERROR)
      Logger.getLogger(<span class="hljs-string">"org.eclipse.jetty.server"</span>).setLevel(Level.OFF)
  
      //创建Spark Session对象
      val spark = SparkSession.builder().master(<span class="hljs-string">"local"</span>).appName(<span class="hljs-string">"Demo2"</span>).getOrCreate()
  
      //从指定的地址创建RDD对象
      val lineRDD = spark.sparkContext.textFile(<span class="hljs-string">""</span>).map(_.split(<span class="hljs-string">"\t"</span>))
  
      //把数据与<span class="hljs-keyword">case</span> class做匹配
      val studentRDD = lineRDD.map(x =&gt; Student(x(0).toInt, x(1), x(2).toInt))
  
      //生成DataFrame
      import spark.sqlContext.implicits._
      val studentDF = studentRDD.toDF
  
      //注册视图 执行SQL
      studentDF.createOrReplaceTempView(<span class="hljs-string">"student"</span>)
  
      spark.sql(<span class="hljs-string">"select * from student"</span>).show
  
      spark.stop()
    }
  }
  
  //定义<span class="hljs-keyword">case</span> class
  <span class="hljs-keyword">case</span> class Student(stuId: Int, stuName: String, stuAge: Int)
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
     </ul></li> 
    <li>&lt;2&gt;. 写入MySQL 
     <ul>
      <li> <pre><code class="hljs bash copyable">package Demo


import org.apache.spark.sql.SparkSession
import org.apache.spark.sql.types.StructType
import org.apache.spark.sql.types.StructField
import org.apache.spark.sql.types.IntegerType
import org.apache.spark.sql.types.StringType
import org.apache.spark.sql.Row
import org.apache.log4j.Logger
import org.apache.log4j.Level
import java.util.Properties

/*写入MySQL*/
object Demo03 {
  
  def main(args: Array[String]): Unit = {
    Logger.getLogger(<span class="hljs-string">"org.apache.spark"</span>).setLevel(Level.ERROR)
		Logger.getLogger(<span class="hljs-string">"org.eclipse.jetty.server"</span>).setLevel(Level.OFF)

    //创建Spark Session对象
    val spark = SparkSession.builder().master(<span class="hljs-string">"local"</span>).appName(<span class="hljs-string">"Demo3"</span>).getOrCreate()

    //从指定的地址创建RDD对象
    val lineRDD = spark.sparkContext.textFile(<span class="hljs-string">""</span>).map(_.split(<span class="hljs-string">"\t"</span>))
    
    //通过StructType方式指定Schema
    val schema = StructType(
      List(
        //字段与MySQL表中字段对应一致  
        StructField(<span class="hljs-string">"personID"</span>, IntegerType),
        StructField(<span class="hljs-string">"personName"</span>, StringType),
        StructField(<span class="hljs-string">"personAge"</span>, IntegerType)))
        
   //将RDD映射到rowRDD上，映射到Schema上
   val rowRDD = lineRDD.map(p =&gt; Row(p(0).toInt,p(1),p(2).toInt))
   val personDataFrame = spark.createDataFrame(rowRDD, schema)
   
   personDataFrame.createOrReplaceTempView(<span class="hljs-string">"myperson"</span>)
   
   val result = spark.sql(<span class="hljs-string">"select * from myperson"</span>)
   
   result.show()
   
   //把结果存入到mysql中
   val props = new Properties()
   props.setProperty(<span class="hljs-string">"user"</span>, <span class="hljs-string">"root"</span>)
   props.setProperty(<span class="hljs-string">"password"</span>, <span class="hljs-string">"123456"</span>)
   //append追加模式
   result.write.mode(<span class="hljs-string">"append"</span>).jdbc(<span class="hljs-string">"jdbc:mysql://localhost:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8"</span>, <span class="hljs-string">"student"</span>, props)
   
   spark.stop()
  
  }
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
    <li>&lt;3&gt;. 使用Spark SQL 读取Hive中的数据，将计算结果存入mysql 
     <ul>
      <li> <pre><code class="hljs bash copyable">package Demo

import org.apache.spark.sql.SparkSession
import java.util.Properties

/*使用Spark SQL 读取Hive中的数据，将计算结果存入mysql*/
//命令：./bin/spark-submit --master spark://node3:7077 --jars /usr/<span class="hljs-built_in">local</span>/tmp_files/mysql-connector-java-8.0.11.jar --driver-class-path /usr/<span class="hljs-built_in">local</span>/tmp_files/mysql-connector-java-8.0.11.jar --class day0410.Demo4 /usr/<span class="hljs-built_in">local</span>/tmp_files/Demo4.jar 
object Demo4 {
  def main(args: Array[String]): Unit = {

    //创建SparkSession
    val spark = SparkSession.builder().appName(<span class="hljs-string">"Demo4"</span>).enableHiveSupport().getOrCreate()

    //执行SQL
    val result = spark.sql(<span class="hljs-string">"select deptno,count(1) from company.emp group by deptno"</span>)

    //将结果保存到mysql中
    val props = new Properties()
    props.setProperty(<span class="hljs-string">"user"</span>, <span class="hljs-string">"root"</span>)
    props.setProperty(<span class="hljs-string">"password"</span>, <span class="hljs-string">"123456"</span>)

    result.write.mode(<span class="hljs-string">"append"</span>).jdbc(<span class="hljs-string">"jdbc:mysql://192.168.109.1:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8"</span>, <span class="hljs-string">"emp_stat"</span>, props)

    spark.stop()
  }
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(3) Spark SQL 性能优化</h3> 
   <ul>
    <li> <p>&lt;1&gt;. 在内存中缓存数据</p> 
     <ul>
      <li>直接读取内存的值来提高性能。</li> 
      <li>通过spark.cacheTable("tableName")或者dataFrame.cache()。使用spark.uncacheTable("tableName")来从内存中去除table。</li> 
      <li>e.g.： 
       <ul>
        <li> <pre><code class="hljs bash copyable">  操作mysql，启动spark shell 时，需要：
  ./bin/spark-shell --master spark://node3:7077 --jars /usr/<span class="hljs-built_in">local</span>/tmp_files/mysql-connector-java-8.0.11.jar --driver-class-path /usr/<span class="hljs-built_in">local</span>/tmp_files/mysql-connector-java-8.0.11.jar
  
  val mysqlDF = spark.read.format(<span class="hljs-string">"jdbc"</span>).option(<span class="hljs-string">"driver"</span>,<span class="hljs-string">"com.mysql.jdbc.Driver"</span>).option(<span class="hljs-string">"url"</span>,<span class="hljs-string">"jdbc:mysql://192.168.109.1:3306/company?serverTimezone=UTC&amp;characterEncoding=utf-8"</span>).option(<span class="hljs-string">"user"</span>,<span class="hljs-string">"root"</span>).option(<span class="hljs-string">"password"</span>,<span class="hljs-string">"123456"</span>).option(<span class="hljs-string">"dbtable"</span>,<span class="hljs-string">"emp"</span>).load
  
  mysqlDF.show
  mysqlDF.createOrReplaceTempView(<span class="hljs-string">"emp"</span>)
  
  spark.sqlContext.cacheTable(<span class="hljs-string">"emp"</span>)   ----&gt; 标识这张表可以被缓存，数据还没有真正被缓存
  spark.sql(<span class="hljs-string">"select * from emp"</span>).show  ----&gt; 依然读取mysql
  spark.sql(<span class="hljs-string">"select * from emp"</span>).show  ----&gt; 从缓存中读取数据
  
  spark.sqlContext.clearCache
  
  清空缓存后，执行查询，会触发查询mysql数据库。
<span class="copy-code-btn">复制代码</span></code></pre></li> 
       </ul></li> 
     </ul></li> 
    <li> <p>&lt;2&gt;. 性能优化相关参数</p> 
     <ul>
      <li> <p>a. 将数据缓存到内存中的相关优化参数：</p> 
       <ul>
        <li> <p>spark.sql.inMemoryColumnarStorage.compressed</p> 
         <ul>
          <li>默认为 true</li> 
          <li>Spark SQL 将会基于统计信息自动地为每一列选择一种压缩编码方式。</li> 
         </ul></li> 
        <li> <p>spark.sql.inMemoryColumnarStorage.batchSize</p> 
         <ul>
          <li>默认值：10000</li> 
          <li>缓存批处理大小。缓存数据时, 较大的批处理大小可以提高内存利用率和压缩率，但同时也会带来 OOM（Out Of Memory）的风险。</li> 
         </ul></li> 
       </ul></li> 
      <li> <p>b. 其他性能相关的配置选项（不过不推荐手动修改，可能在后续版本自动的自适应修改）</p> 
       <ul>
        <li>spark.sql.files.maxPartitionBytes 
         <ul>
          <li>默认值：128 MB</li> 
          <li>读取文件时单个分区可容纳的最大字节数</li> 
         </ul></li> 
        <li>spark.sql.files.openCostInBytes 
         <ul>
          <li>默认值：4M</li> 
          <li>打开文件的估算成本, 按照同一时间能够扫描的字节数来测量。当往一个分区写入多个文件的时候会使用。高估更好, 这样的话小文件分区将比大文件分区更快 (先被调度)。</li> 
         </ul></li> 
        <li>spark.sql.autoBroadcastJoinThreshold 
         <ul>
          <li>默认值：10M</li> 
          <li>用于配置一个表在执行 join 操作时能够广播给所有 worker 节点的最大字节大小。通过将这个值设置为 -1 可以禁用广播。注意，当前数据统计仅支持已经运行了 ANALYZE TABLE COMPUTE STATISTICS noscan 命令的 Hive Metastore 表。</li> 
         </ul></li> 
        <li>spark.sql.shuffle.partitions 
         <ul>
          <li>默认值：200</li> 
          <li>用于配置 join 或聚合操作混洗（shuffle）数据时使用的分区数。</li> 
         </ul></li> 
       </ul></li> 
     </ul></li> 
   </ul>
   <h2 class="heading">12. 认识 Spark Streaming</h2> 
   <h3 class="heading">(1) Spark Streaming 简介</h3> 
   <ul>
    <li>流式计算框架（类似于Storm）</li> 
    <li>常用的实时计算引擎（流式计算） 
     <ul>
      <li>&lt;1&gt;. Apache Storm：真正的流式计算</li> 
      <li>&lt;2&gt;. Spark Streaming ：严格上来说不是真正的流式计算（实时计算），把连续的流式数据，当成不连续的RDD，本质是一个离散计算（不连续）</li> 
      <li>&lt;3&gt;. Apache Flink：真正的流式计算，与Spark Streaming相反， 把离散的数据，当成流式数据来处理</li> 
      <li>&lt;4&gt;. JStorm</li> 
     </ul></li> 
    <li>Spark Streaming makes it easy to build scalable fault-tolerant streaming applications.（易于构建灵活的、高容错的流式系统）</li> 
    <li>Spark Streaming是核心Spark API的扩展，可实现可扩展、高吞吐量、可容错的实时数据流处理。数据可以从诸如Kafka，Flume，Kinesis或TCP套接字等众多来源获取，并且可以使用由高级函数（如map，reduce，join和window）开发的复杂算法进行流数据处理。最后，处理后的数据可以被推送到文件系统，数据库和实时仪表板。而且，还可以在数据流上应用Spark提供的机器学习和图处理算法。 
     <figure>
      <figcaption></figcaption>
     </figure></li> 
   </ul>
   <h3 class="heading">(2) Spark Streaming 的特点</h3> 
   <ul>
    <li>&lt;1&gt;. 易用，已经集成到Spark中</li> 
    <li>&lt;2&gt;. 容错性：底层RDD，RDD本身具有容错机制</li> 
    <li>&lt;3&gt;. 支持多种语言：Java Scala Python</li> 
   </ul>
   <h3 class="heading">(3) Spark Streaming的内部结构</h3> 
   <ul>
    <li>在内部，它的工作原理如下。Spark Streaming接收实时输入数据流，并将数据切分成批，然后由Spark引擎对其进行处理，最后生成“批”形式的结果流。 
     <figure>
      <figcaption></figcaption>
     </figure></li> 
    <li>Spark Streaming将连续的数据流抽象为discretizedstream或DStream。在内部DStream 由一个RDD序列表示。</li> 
   </ul>
   <h2 class="heading">13. Spark Streaming 基础</h2> 
   <h3 class="heading">(1) Spark Streaming 官方示例</h3> 
   <ul>
    <li>&lt;1&gt;. 介绍： 
     <ul>
      <li>向Spark Streaming中发送字符串，Spark 接收到以后进行计数</li> 
     </ul></li> 
    <li>&lt;2&gt;. 准备工作： 
     <ul>
      <li>netcat网络工具（<code>yum install nc.x86_64</code>）</li> 
      <li>**注意：**总核数大于等于2，一个核心用于接收数据，另一个用于处理数据</li> 
     </ul></li> 
    <li>&lt;3&gt;. 操作： 
     <ul>
      <li>启动同一Linux系统的两个窗口，一个负责输入，一个负责监听</li> 
      <li>窗口1：<code>nc -l 1234</code> （<code>-l</code>监听模式；<code>1234</code>端口号）</li> 
      <li>窗口2：<code>run-example streaming.NetworkWordCount localhost 1234</code></li> 
      <li>在窗口1输入文本信息，窗口2监听并进行计数统计</li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(2) 自写 Spark Streaming 官方示例</h3> 
   <ul>
    <li>MyNetworkWordCount.scala 
     <ul>
      <li> <pre><code class="hljs bash copyable">/**
  *
  * @ClassName: MyNetworkWordCount
  * @Description
  * @Author: YBCarry
  * @Date2019-05-13 20:49
  * @Version: V1.0
  *
  **/
import org.apache.spark.streaming.StreamingContext
import org.apache.spark.SparkConf
import org.apache.spark.streaming.Seconds
import org.apache.spark.storage.StorageLevel
import org.apache.log4j.Logger
import org.apache.log4j.Level
import org.apache.spark.internal.Logging
/*
 * 自写流式计算程序
 *
 * 知识点：
 * 1、创建一个StreamingContext对象  --&gt;  核心：创建一个DStream
 * 2、DStream的表现形式：就是一个RDD
 * 3、使用DStream把连续的数据流变成不连续的RDD
 *
 * spark Streaming 最核心的内容
 */
object MyNetworkWordCount {
  def main(args: Array[String]): Unit = {


    //创建一个Streaming Context对象
    //<span class="hljs-built_in">local</span>[2] 表示开启了两个线程
    val conf = new SparkConf().setAppName(<span class="hljs-string">"MyNetworkWordCount"</span>).setMaster(<span class="hljs-string">"local[2]"</span>)
    //Seconds(3) 表示采样时间间隔
    val ssc = new StreamingContext(conf, Seconds(3))

    //创建DStream 从netcat服务器上接收数据
    val lines = ssc.socketTextStream(<span class="hljs-string">"172.16.194.128"</span>, 1234, StorageLevel.MEMORY_ONLY)

    //lines中包含了netcat服务器发送过来的数据
    //分词操作
    val words = lines.flatMap(_.split(<span class="hljs-string">" "</span>))

    //计数
    val wordPair = words.transform(x =&gt; x.map(x =&gt; (x, 1)))

    //打印结果
    wordPair.print()

    //启动StreamingContext 进行计算
    ssc.start()

    //等待任务结束
    ssc.awaitTermination()

  }
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
   </ul>
   <h2 class="heading">14. Spark Streaming 进阶</h2> 
   <h3 class="heading">(1) StreamingContext对象详解</h3> 
   <ul>
    <li>初始化StreamingContext： 
     <ul>
      <li>方式一：从SparkConf对象中创建： 
       <figure>
        <figcaption></figcaption>
       </figure></li> 
      <li>方式二：从一个现有的SparkContext实例中创建 
       <figure>
        <figcaption></figcaption>
       </figure></li> 
     </ul></li> 
    <li>程序中的几点说明： 
     <ul>
      <li>appName参数是应用程序在集群UI上显示的名称。</li> 
      <li>master是Spark，Mesos或YARN集群的URL，或者一个特殊的“local [*]”字符串来让程序以本地模式运行。</li> 
      <li>当在集群上运行程序时，不需要在程序中硬编码master参数，而是使用spark-submit提交应用程序并将master的URL以脚本参数的形式传入。但是，对于本地测试和单元测试，您可以通过“local[*]”来运行Spark Streaming程序（请确保本地系统中的cpu核心数够用）。</li> 
      <li>StreamingContext会内在的创建一个SparkContext的实例（所有Spark功能的起始点），你可以通过ssc.sparkContext访问到这个实例。</li> 
      <li>批处理的时间窗口长度必须根据应用程序的延迟要求和可用的集群资源进行设置。</li> 
     </ul></li> 
    <li>注意： 
     <ul>
      <li>一旦一个StreamingContextt开始运作，就不能设置或添加新的流计算。</li> 
      <li>一旦一个上下文被停止，它将无法重新启动。</li> 
      <li>同一时刻，一个JVM中只能有一个StreamingContext处于活动状态。</li> 
      <li>StreamingContext上的stop()方法也会停止SparkContext。 要仅停止StreamingContext（保持SparkContext活跃），请将stop() 方法的可选参数stopSparkContext设置为false。</li> 
      <li>只要前一个StreamingContext在下一个StreamingContext被创建之前停止（不停止SparkContext），SparkContext就可以被重用来创建多个StreamingContext。</li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(2) 离散流（DStreams）：Discretized Streams</h3> 
   <ul>
    <li>把连续的数据变成不连续的RDD</li> 
    <li>因为DStream的特性，导致，Spark Streaming不是真正的流式计算</li> 
    <li>DiscretizedStream或DStream 是Spark Streaming对流式数据的基本抽象。它表示连续的数据流，这些连续的数据流可以是从数据源接收的输入数据流，也可以是通过对输入数据流执行转换操作而生成的经处理的数据流。在内部，DStream由一系列连续的RDD表示，如下图： 
     <figure>
      <figcaption></figcaption>
     </figure></li> 
    <li>举例分析：在之前的NetworkWordCount的例子中，我们将一行行文本组成的流转换为单词流，具体做法为：将flatMap操作应用于名为lines的DStream中的每个RDD上，以生成words DStream的RDD。如下图所示： 
     <figure>
      <figcaption></figcaption>
     </figure></li> 
    <li>但是DStream和RDD也有区别，下面画图说明： 
     <figure>
      <figcaption></figcaption>
     </figure>
     <figure>
      <figcaption></figcaption>
     </figure></li> 
   </ul>
   <h3 class="heading">(3) 转换操作（transformation）</h3> 
   <p></p>
   <figure>
    <figcaption></figcaption>
   </figure>
   <p></p> 
   <ul>
    <li> <p>transform(func)</p> 
     <ul>
      <li>通过RDD-to-RDD函数作用于源DStream中的各个RDD，可以是任意的RDD操作，从而返回一个新的RDD</li> 
      <li>举例：在NetworkWordCount中，也可以使用transform来生成元组对</li> 
     </ul></li> 
    <li> <p>updateStateByKey(func)</p> 
     <ul>
      <li>操作允许不断用新信息更新它的同时保持任意状态。</li> 
      <li>定义状态：状态可以是任何的数据类型</li> 
      <li>定义状态更新函数：怎样利用更新前的状态和从输入流里面获取的新值更新状态</li> 
     </ul></li> 
    <li> <p>重写NetworkWordCount程序，累计每个单词出现的频率（注意：累计）</p> 
     <ul>
      <li>TotalNetworkWordCount.scala</li> 
      <li> <pre><code class="hljs bash copyable">    package test.Network

    import org.apache.log4j.{Level, Logger}
    import org.apache.spark.SparkConf
    import org.apache.spark.storage.StorageLevel
    import org.apache.spark.streaming.{Seconds, StreamingContext}
    
    /**
      *
      * @ClassName: TotalNetworkWordCount
      * @Description: 实现累加操作
      * @Author: YBCarry
      * @Date2019-05-15 16:05
      * @Version: V1.0
      *
      **/
    object TotalNetworkWordCount {
    
      def main(args: Array[String]): Unit = {
    
        Logger.getLogger(<span class="hljs-string">"org.apache.spark"</span>).setLevel(Level.ERROR)
        Logger.getLogger(<span class="hljs-string">"org.eclipse.jetty.server"</span>).setLevel(Level.OFF)
    
        //创建一个Streaming Context对象
        //<span class="hljs-built_in">local</span>[2] 表示开启了两个线程
        val conf = new SparkConf().setAppName(<span class="hljs-string">"MyNetworkWordCount"</span>).setMaster(<span class="hljs-string">"local[2]"</span>)
        //Seconds(3) 表示采样时间间隔
        val ssc = new StreamingContext(conf, Seconds(3))
    
        //设置检查点目录，保存之前都的状态信息
        ssc.checkpoint(<span class="hljs-string">""</span>)
    
        //创建DStream
        val lines = ssc.socketTextStream(<span class="hljs-string">"bigdata01"</span>, 1234, StorageLevel.MEMORY_ONLY)
    
        //分割
        val words = lines.flatMap(_.split(<span class="hljs-string">" "</span>))
    
        //计数
  //    val wordPair = words.map((_, 1))
        val wordPair = words.transform( x =&gt; x.map(x =&gt; (x, 1)))
    
        //定义一个值函数 ；累加计数
        /*
        * 接收两个参数
        * currentValues —— 当前值
        * previousValue ——历史值
        * */
        val addFunc = (currentValues : Seq[Int], previousValues : Option[Int]) =&gt; {
    
          //累加当前的序列
          val currrentTotal = currentValues.sum
          //累加历史值
          Some(currrentTotal + previousValues.getOrElse(0))
        }
    
        //累加运算
        val total = wordPair.updateStateByKey(addFunc)
    
        total.print()
    
        ssc.start()

    ssc.awaitTermination()
  }
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul><pre><code class="hljs bash copyable">
<span class="copy-code-btn">复制代码</span></code></pre></li> 
   </ul>
   <h3 class="heading">(4) 窗口操作</h3> 
   <ul>
    <li> <p>Spark Streaming还提供了窗口计算功能，允许在数据的滑动窗口上应用转换操作。下图说明了滑动窗口的工作方式： </p>
     <figure>
      <figcaption></figcaption>
     </figure><p></p> </li> 
    <li> <p>如图所示，每当窗口滑过originalDStream时，落在窗口内的源RDD被组合并被执行操作以产生windowed DStream的RDD。在上面的例子中，操作应用于最近3个时间单位的数据，并以2个时间单位滑动。这表明任何窗口操作都需要指定两个参数。</p> 
     <ul>
      <li>窗口长度（windowlength） - 窗口的时间长度（上图的示例中为：3）。</li> 
      <li>滑动间隔（slidinginterval） - 两次相邻的窗口操作的间隔（即每次滑动的时间长度）（上图示例中为：2）。</li> 
      <li>这两个参数必须是源DStream的批间隔的倍数（上图示例中为：1）。</li> 
     </ul></li> 
    <li> <p>e.g.: 假设对之前的单词计数的示例进行扩展，每10秒钟对过去30秒的数据进行wordcount。则在最近30秒的pairs DStream数据中对(word, 1)键值对应用reduceByKey操作。这是通过使用reduceByKeyAndWindow操作完成的。</p> </li> 
    <li> <pre><code class="hljs bash copyable">  package test.NetworkByWindow

  import org.apache.log4j.{Level, Logger}
  import org.apache.spark.SparkConf
  import org.apache.spark.storage.StorageLevel
  import org.apache.spark.streaming.{Seconds, StreamingContext}
  
  /**
    *
    * @ClassName: NetworkWordCountByWindow
    * @Description: 每10秒读取过去30秒的数据
    * @Author: YBCarry
    * @Date2019-05-15 17:00
    * @Version: V1.0
    *
    **/
  object NetworkWordCountByWindow {
  
    def main(args: Array[String]): Unit = {
  
      Logger.getLogger(<span class="hljs-string">"org.apache.spark"</span>).setLevel(Level.ERROR)
      Logger.getLogger(<span class="hljs-string">"org.eclipse.jetty.server"</span>).setLevel(Level.OFF)
  
      //创建一个Streaming Context对象
      //<span class="hljs-built_in">local</span>[2] 表示开启了两个线程
      val conf = new SparkConf().setAppName(<span class="hljs-string">"MyNetworkWordCount"</span>).setMaster(<span class="hljs-string">"local[2]"</span>)
      //Seconds(3) 表示采样时间间隔
      val ssc = new StreamingContext(conf, Seconds(3))
  
      //设置检查点目录，保存之前都的状态信息
      ssc.checkpoint(<span class="hljs-string">""</span>)
  
      //创建DStream
      val lines = ssc.socketTextStream(<span class="hljs-string">"bigdata01"</span>, 1234, StorageLevel.MEMORY_ONLY)
  
      //分割 每个单词计数
      val words = lines.flatMap(_.split(<span class="hljs-string">" "</span>)).map((_, 1))
  
      /*
      * 窗口操作
      * 参数说明：要进行的操作  窗口的大小(30s)  窗口移动距离(12s) ——&gt; 采样时间(3)的整数倍 
      * */
      val result = words.reduceByKeyAndWindow((x : Int, y : Int) =&gt; (x + y), Seconds(30), Seconds(12))
    }
  
  }
<span class="copy-code-btn">复制代码</span></code></pre></li> 
   </ul>
   <h2 class="heading">15. Spark 数据源</h2> 
   <h3 class="heading">(1) 输入DStreams和接收器</h3> 
   <ul>
    <li>输入DStreams表示从数据源获取输入数据流的DStreams。在NetworkWordCount例子中，lines表示输入DStream，它代表从netcat服务器获取的数据流。每一个输入流DStream和一个Receiver对象相关联，这个Receiver从源中获取数据，并将数据存入内存中用于处理。</li> 
    <li>输入DStreams表示从数据源获取的原始数据流。Spark Streaming拥有两类数据源： 
     <ul>
      <li>基本源（Basic sources）：这些源在StreamingContext API中直接可用。例如文件系统、套接字连接、Akka的actor等</li> 
      <li>高级源（Advanced sources）：这些源包括Kafka,Flume,Kinesis,Twitter等等。</li> 
     </ul></li> 
    <li>下面通过具体的案例，详细说明：</li> 
   </ul>
   <h3 class="heading">(2) 基本源</h3> 
   <ul>
    <li> <p>&lt;1&gt;. 文件流：通过监控文件系统的变化，若有新文件添加，则将它读入并作为数据流</p> 
     <ul>
      <li>注意： 
       <ul>
        <li>① 这些文件具有相同的格式</li> 
        <li>② 这些文件通过原子移动或重命名文件的方式在dataDirectory创建</li> 
        <li>③ 如果在文件中追加内容，这些追加的新数据也不会被读取。</li> 
       </ul></li> 
      <li>Spark Streaming监控一个文件夹，如果有变化，则把变化采集过来</li> 
      <li> <pre><code class="hljs bash copyable">import org.apache.log4j.{Level, Logger}
import org.apache.spark.SparkConf
import org.apache.spark.streaming.{Seconds, StreamingContext}

/**
  *
  * @ClassName: FileStreaming
  * @Description
  * @Author: YBCarry
  * @Date2019-05-16 09:24
  * @Version: V1.0
  *
  **/
object FileStreaming {

  def main(args: Array[String]): Unit = {

    Logger.getLogger(<span class="hljs-string">"org.apache.spark"</span>).setLevel(Level.ERROR)
    Logger.getLogger(<span class="hljs-string">"org.eclipse.jetty.server"</span>).setLevel(Level.OFF)

    //创建一个Streaming Context对象
    //<span class="hljs-built_in">local</span>[2] 表示开启了两个线程
    val conf = new SparkConf().setAppName(<span class="hljs-string">"MyFileStreaming"</span>).setMaster(<span class="hljs-string">"local[2]"</span>)
    //Seconds(3) 表示采样时间间隔
    val ssc = new StreamingContext(conf, Seconds(10))

    //监控目录，读取产生的新文件
    val lines = ssc.textFileStream(<span class="hljs-string">"\\Users\\apple\\学习\\SparkFiles"</span>)

    lines.print()

    ssc.start()
    ssc.awaitTermination()

  }

}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
      <li>注意：需要在原文件中编辑，然后拷贝一份。</li> 
     </ul></li> 
    <li> <p>&lt;2&gt;. RDD队列流</p> 
     <ul>
      <li>使用streamingContext.queueStream(queueOfRDD)创建基于RDD队列的DStream，用于调试Spark Streaming应用程序。</li> 
      <li> <pre><code class="hljs bash copyable">package test.RDDQueue


import org.apache.log4j.{Level, Logger}
import org.apache.spark.SparkConf
import org.apache.spark.rdd.RDD
import org.apache.spark.streaming.{Seconds, StreamingContext}

import scala.collection.mutable.Queue

/**
  *
  * @ClassName: RDDQueueStream
  * @Description: RDD队列流
  * @Author: YBCarry
  * @Date2019-05-16 10:48
  * @Version: V1.0
  *
  **/
object RDDQueueStream {

  def main(args: Array[String]): Unit = {

    Logger.getLogger(<span class="hljs-string">"org.apache.spark"</span>).setLevel(Level.ERROR)
    Logger.getLogger(<span class="hljs-string">"org.eclipse.jetty.server"</span>).setLevel(Level.OFF)

    //创建一个Streaming Context对象
    //<span class="hljs-built_in">local</span>[2] 表示开启了两个线程
    val conf = new SparkConf().setAppName(<span class="hljs-string">"MyRDDQueueStream"</span>).setMaster(<span class="hljs-string">"local[2]"</span>)
    //Seconds(3) 表示采样时间间隔
    val ssc = new StreamingContext(conf, Seconds(3))

    //创建队列 RDD[Int]
    val rddQueue = new Queue[RDD[Int]]()

    //向队列里添加数据 (创建数据源)
    <span class="hljs-keyword">for</span> (i &lt;- 1 to 3) {

      rddQueue += ssc.sparkContext.makeRDD(1 to 10)

      //便于观察
      Thread.sleep(1000)
    }

    //从队列中接收数据，创建DStream
    val inputDStream = ssc.queueStream(rddQueue)

    //处理数据
    val result = inputDStream.map(x =&gt; (x, x * 2))
    result.print()

    ssc.start()
    ssc.awaitTermination()

  }

}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
     </ul></li> 
    <li> <p>&lt;3&gt;. 套接字流：通过监听Socket端口来接收数据</p> </li> 
   </ul>
   <h3 class="heading">(3) 高级源</h3> 
   <ul>
    <li>&lt;1&gt;. Spark Streaming接收Flume数据 
     <ul>
      <li>a. 基于Flume的Push模式: 
       <ul>
        <li>Flume被用于在Flume agents之间推送数据，在这种方式下，Spark Streaming可以很方便的建立一个receiver，起到一个Avro agent的作用。Flume可以将数据推送到改receiver。</li> 
       </ul></li> 
      <li>以下为配置步骤： 
       <ul>
        <li>**第一步：**Flume的配置文件 
         <ul>
          <li>MyFlumeStream01.conf</li> 
          <li> <pre><code class="hljs bash copyable"><span class="hljs-comment">#定义agent名， source、channel、sink的名称</span>
a4.sources = r1
a4.channels = c1
a4.sinks = k1

<span class="hljs-comment">#具体定义source</span>
a4.sources.r1.type = spooldir
a4.sources.r1.spoolDir = /usr/<span class="hljs-built_in">local</span>/tmp_files/logs

<span class="hljs-comment">#具体定义channel</span>
a4.channels.c1.type = memory
a4.channels.c1.capacity = 10000
a4.channels.c1.transactionCapacity = 100

<span class="hljs-comment">#具体定义sink</span>
a4.sinks = k1
a4.sinks.k1.type = avro
a4.sinks.k1.channel = c1
a4.sinks.k1.hostname = bigdata01
a4.sinks.k1.port = 1234

<span class="hljs-comment">#组装source、channel、sink</span>
a4.sources.r1.channels = c1
a4.sinks.k1.channel = c1
<span class="copy-code-btn">复制代码</span></code></pre></li> 
         </ul></li> 
        <li>**第二步：**Spark Streaming程序 
         <ul>
          <li> <pre><code class="hljs bash copyable">package test.Flume

import org.apache.log4j.{Level, Logger}
import org.apache.spark.SparkConf
import org.apache.spark.streaming.flume.FlumeUtils
import org.apache.spark.streaming.{Seconds, StreamingContext}

/**
  *
  * @ClassName: MyFlumeStream
  * @Description: flume将数据推送给Spark Streaming 使用push
  * @Author: YBCarry
  * @Date2019-05-16 14:01
  * @Version: V1.0
  *
  **/
object MyFlumeStream01 {

  def main(args: Array[String]): Unit = {

    Logger.getLogger(<span class="hljs-string">"org.apache.spark"</span>).setLevel(Level.ERROR)
    Logger.getLogger(<span class="hljs-string">"org.eclipse.jetty.server"</span>).setLevel(Level.OFF)

    //创建一个Streaming Context对象
    //<span class="hljs-built_in">local</span>[2] 表示开启了两个线程
    val conf = new SparkConf().setAppName(<span class="hljs-string">"MyRDDQueueStream"</span>).setMaster(<span class="hljs-string">"local[2]"</span>)
    //Seconds(3) 表示采样时间间隔
    val ssc = new StreamingContext(conf, Seconds(3))

    //对接Flume
    //创建一个Flumeevent从flume中接收puch来的数据（也是DStream）
    //flume将数据push到localhost:1234，Spark Stream在这里监听
    val flumeEventDStream = FlumeUtils.createStream(ssc, <span class="hljs-string">"bigdata01"</span>, 1234)

    //将Flumeevent中的事件转换成字符串
    val lineDStream = flumeEventDStream.map(e =&gt; {
      new String(e.event.getBody.array)
    })

    //输出结果
    lineDStream.print()

    ssc.start()
    ssc.awaitTermination()

   }
}
<span class="copy-code-btn">复制代码</span></code></pre></li> 
         </ul></li> 
        <li>**第三步：**测试 
         <ul>
          <li>启动Flume 
           <ul>
            <li><code>flume-ng agent -n a4 -f Spark/MyFlumeStream01.conf -c conf -Dflume.root.logger=INFO,console</code></li> 
           </ul></li> 
          <li>启动Spark Streaming程序</li> 
          <li>拷贝日志文件到/root/training/logs目录</li> 
          <li>观察输出，采集到数据</li> 
         </ul></li> 
       </ul></li> 
      <li>b. 基于Custom Sink的Pull模式 
       <ul>
        <li>不同于Flume直接将数据推送到Spark Streaming中，第二种模式通过以下条件运行一个正常的Flume sink。Flume将数据推送到sink中，并且数据保持buffered状态。Spark Streaming使用一个可靠的Flume接收器和转换器从sink拉取数据。只要当数据被接收并且被Spark Streaming备份后，转换器才运行成功。</li> 
        <li>这样,与第一种模式相比，保证了很好的健壮性和容错能力，这种模式需要为Flume配置一个正常的sink。</li> 
        <li>以下为配置步骤： 
         <ul>
          <li> <p>**第一步：**Flume的配置文件</p> 
           <ul>
            <li>FlumeLogPull.conf</li> 
            <li> <pre><code class="hljs bash copyable">  a1.channels = c1
  a1.sinks = k1
  a1.sources = r1
  
  a1.sources.r1.type = spooldir
  a1.sources.r1.spoolDir = /usr/<span class="hljs-built_in">local</span>/tmp_files/logs
  
  a1.channels.c1.type = memory
  a1.channels.c1.capacity = 100000
  a1.channels.c1.transactionCapacity = 100000
  
  a1.sinks.k1.type = org.apache.spark.streaming.flume.sink.SparkSink
  a1.sinks.k1.channel = c1
  a1.sinks.k1.hostname = bigdata01
  a1.sinks.k1.port = 1234
  
  <span class="hljs-comment">#组装source、channel、sink</span>
  a1.sources.r1.channels = c1
  a1.sinks.k1.channel = c1

<span class="copy-code-btn">复制代码</span></code></pre></li> 
           </ul></li> 
          <li> <p>**第二步：**Spark Streaming程序</p> 
           <ul>
            <li> <pre><code class="hljs bash copyable"><span class="copy-code-btn">复制代码</span></code></pre></li> 
           </ul><p>package test.Flume</p> <p>import org.apache.spark.streaming.StreamingContext import org.apache.spark.SparkConf import org.apache.spark.streaming.Seconds import org.apache.spark.storage.StorageLevel import org.apache.log4j.Logger import org.apache.log4j.Level import org.apache.spark.streaming.flume.FlumeUtils</p> <p>/** *</p> 
           <ul>
            <li>@ClassName: FlumePutSink</li> 
            <li>@Description: 测试pull方式 使用Spark sink</li> 
            <li>@Author: YBCarry</li> 
            <li>@Date2019-05-16 15:23</li> 
            <li>@Version: V1.0</li> 
            <li> </li>
           </ul><p>**/ object FlumeLogPull {</p> <p>def main(args: Array[String]): Unit = { Logger.getLogger("org.apache.spark").setLevel(Level.ERROR) Logger.getLogger("org.eclipse.jetty.server").setLevel(Level.OFF) //创建一个Streaming Context对象 //local[2] 表示开启了两个线程 val conf = new SparkConf().setAppName("FlumeLogPull").setMaster("local[2]") //Seconds(3) 表示采样时间间隔 val ssc = new StreamingContext(conf,Seconds(3))</p> <pre><code class="copyable">//创建FlumeEvent的DStream，采用pull的方式
val flumeEvent = FlumeUtils.createPollingStream(ssc, "172.16.194.128",1234, StorageLevel.MEMORY_ONLY)

//将FlumeEvent的事件准换成字符串
val lineDStream = flumeEvent.map( e =&gt; {
  new String(e.event.getBody.array)
})

//输出结果
lineDStream.print()

ssc.start()
ssc.awaitTermination()
}
<span class="copy-code-btn">复制代码</span></code></pre> <p>}</p> <pre><code class="hljs bash copyable"><span class="copy-code-btn">复制代码</span></code></pre></li> 
          <li> <p>**第三步：**需要的jar包</p> 
           <ul>
            <li>将<code>spark-streaming-flume-sink_2.11-2.1.0.jar</code>拷贝到Flume的lib目录下。</li> 
           </ul></li> 
          <li> <p>**第四步：**测试</p> 
           <ul>
            <li>启动Flume</li> 
            <li>启动Spark Streaming程序</li> 
            <li>将测试数据拷贝到/root/training/logs</li> 
            <li>观察输出</li> 
           </ul></li> 
         </ul></li> 
       </ul></li> 
     </ul></li> 
   </ul>
   <h2 class="heading">16. Spark 性能优化</h2> 
   <h3 class="heading">(1) 概述</h3> 
   <ul>
    <li>Spark的计算本质是分布式计算，所以，Spark程序的性能可能因为集群中的任何因素出现瓶颈：CPU、网络带宽、或者内存。如果在持久化RDD的时候，持久化了大量的数据，那么Java虚拟机的垃圾回收就可能成为一个瓶颈。Java虚拟机会定期进行垃圾回收，此时会追踪所有Java对象，并且在垃圾回收时，找到那些已经不再使用的对象。</li> 
    <li>核心：清理旧对象，给新对象腾出空间。垃圾回收的性能开销，是与内存中的对象数量成正比。</li> 
   </ul>
   <h3 class="heading">(2) spark内存分配</h3> 
   <p></p>
   <figure>
    <figcaption></figcaption>
   </figure>
   <p></p> 
   <h3 class="heading">(3) Spark GC原理</h3> 
   <p></p>
   <figure>
    <figcaption></figcaption>
   </figure>
   <p></p> 
   <h3 class="heading">(4) 减少批数据的执行时间</h3> 
   <ul>
    <li>在Spark中有几个优化可以减少批处理的时间： 
     <ul>
      <li>&lt;1&gt;. 减少批数据的执行时间 
       <ul>
        <li>在Spark中有几个优化可以减少批处理的时间： 
         <ul>
          <li>① 数据接收的并行水平 
           <ul>
            <li>通过网络(如kafka，flume，socket等)接收数据需要这些数据反序列化并被保存到Spark中。如果数据接收成为系统的瓶颈，就要考虑并行地接收数据。注意，每个输入DStream创建一个receiver（运行在worker机器上）接收单个数据流。创建多个输入DStream并配置它们可以从源中接收不同分区的数据流，从而实现多数据流接收。例如，接收两个topic数据的单个输入DStream可以被切分为两个kafka输入流，每个接收一个topic。这将在两个worker上运行两个receiver，因此允许数据并行接收，提高整体的吞吐量。多个DStream可以被合并生成单个DStream，这样运用在单个输入DStream的transformation操作可以运用在合并的DStream上。</li> 
           </ul></li> 
          <li>② 数据处理的并行水平 
           <ul>
            <li>如果运行在计算stage上的并发任务数不足够大，就不会充分利用集群的资源。默认的并发任务数通过配置属性来确定spark.default.parallelism。</li> 
           </ul></li> 
          <li>③ 数据序列化 
           <ul>
            <li>可以通过改变序列化格式来减少数据序列化的开销。在流式传输的情况下，有两种类型的数据会被序列化： 
             <ul>
              <li>输入数据</li> 
              <li>由流操作生成的持久RDD</li> 
             </ul></li> 
            <li>在上述两种情况下，使用Kryo序列化格式可以减少CPU和内存开销。</li> 
           </ul></li> 
         </ul></li> 
       </ul></li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(5) 设置正确的批容量</h3> 
   <ul>
    <li>为了Spark Streaming应用程序能够在集群中稳定运行，系统应该能够以足够的速度处理接收的数据（即处理速度应该大于或等于接收数据的速度）。这可以通过流的网络UI观察得到。批处理时间应该小于批间隔时间。</li> 
    <li>根据流计算的性质，批间隔时间可能显著的影响数据处理速率，这个速率可以通过应用程序维持。可以考虑WordCountNetwork这个例子，对于一个特定的数据处理速率，系统可能可以每2秒打印一次单词计数（批间隔时间为2秒），但无法每500毫秒打印一次单词计数。所以，为了在生产环境中维持期望的数据处理速率，就应该设置合适的批间隔时间(即批数据的容量)。</li> 
    <li>找出正确的批容量的一个好的办法是用一个保守的批间隔时间（5-10,秒）和低数据速率来测试你的应用程序。</li> 
   </ul>
   <h3 class="heading">(6) 内存调优</h3> 
   <ul>
    <li>介绍几个比较推荐的自定义选项，它们可以减少Spark Streaming应用程序垃圾回收的相关暂停，获得更稳定的批处理时间。 
     <ul>
      <li>**Default persistence level of DStreams：**和RDDs不同的是，默认的持久化级别是序列化数据到内存中（DStream是StorageLevel.MEMORY_ONLY_SER，RDD是StorageLevel.MEMORY_ONLY）。即使保存数据为序列化形态会增加序列化/反序列化的开销，但是可以明显的减少垃圾回收的暂停。</li> 
      <li>**Clearing persistent RDDs：**默认情况下，通过Spark内置策略（LUR），Spark Streaming生成的持久化RDD将会从内存中清理掉。如果spark.cleaner.ttl已经设置了，比这个时间存在更老的持久化RDD将会被定时的清理掉。正如前面提到的那样，这个值需要根据Spark Streaming应用程序的操作小心设置。然而，可以设置配置选项spark.streaming.unpersist为true来更智能的去持久化（unpersist）RDD。这个配置使系统找出那些不需要经常保有的RDD，然后去持久化它们。这可以减少Spark RDD的内存使用，也可能改善垃圾回收的行为。</li> 
      <li>**Concurrent garbage collector：**使用并发的标记-清除垃圾回收可以进一步减少垃圾回收的暂停时间。尽管并发的垃圾回收会减少系统的整体吞吐量，但是仍然推荐使用它以获得更稳定的批处理时间。</li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(7) shuffle原理</h3> 
   <ul>
    <li>&lt;1&gt;. 优化前 
     <figure>
      <figcaption></figcaption>
     </figure></li> 
    <li>&lt;2&gt;. 优化后 
     <figure>
      <figcaption></figcaption>
     </figure></li> 
   </ul>
   <h2 class="heading">17. Spark MLlib库</h2> 
   <h3 class="heading">(1) 概述</h3> 
   <ul>
    <li>MLlib is Apache Spark's scalable machine learning library.(MLlib 是 Spark 支持 Scala 的可以扩展的机器学习库。)</li> 
    <li>Spark在机器学习方面具有得天独厚的有事，有以下几个原因： 
     <ul>
      <li>&lt;1&gt;. 机器学习算法一般都有多个步骤迭代计算，需要在多次迭代后，获得足够小的误差或者收敛才会停止。 
       <ul>
        <li>e.g.:</li> 
        <li> <pre><code class="hljs bash copyable">  double wucha = 1.0
  <span class="hljs-keyword">while</span> ( wucha &gt;= 0.00001 ) {
	  建模  wucha -= 某个值
  }
  
  模型计算完毕
<span class="copy-code-btn">复制代码</span></code></pre></li> 
        <li>当迭代使用Hadoop的MapReduce计算框架时，每次都要读写硬盘以及任务启动工作，导致很大的IO开销。而Spark基于内存的计算模型天生擅长迭代计算，只有在必要时，才会读写硬盘，所以Spark是机器学习比较理想的平台。</li> 
       </ul></li> 
      <li>&lt;2&gt;. 通信角度 
       <ul>
        <li>Hadoop的MapReduce计算框架通过heartbeat方式来进行通信和传递数据，执行速度慢。 
         <ul>
          <li>Spark有高效的Akka和Netty通信系统，通信效率高。</li> 
         </ul></li> 
       </ul></li> 
     </ul></li> 
    <li>SPark MLlib 是Spark 对常用的机器学习算法的实现库，同时包括相关测试和数据生成器。</li> 
   </ul>
   <h3 class="heading">(2) 什么是机器学习</h3> 
   <ul>
    <li>&lt;1&gt;. 定义 
     <ul>
      <li>A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E。</li> 
      <li>机器学习(Machine Learning, ML)是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。（通过算法使计算机能够模拟人类的判别能力）</li> 
      <li>**三个关键词：**算法、经验、模型评价</li> 
      <li>**应用：**金融反欺诈、语音识别、自然语言处理、翻译、模式识别、智能控制等等。</li> 
     </ul></li> 
    <li>&lt;2&gt;. 机器学习工作流程 
     <ul>
      <li>在数据的基础上，通过算法构建出模型，并进行评价 
       <ul>
        <li>如果达到要求，则用该模型测试其他数据</li> 
        <li>如果不达到要求，要调整算法来重新建立模型，再次进行评估</li> 
        <li>循环往复，直到获得满意的经验</li> 
       </ul></li> 
     </ul></li> 
    <li>&lt;3&gt;. 基于大数据的机器学习 
     <ul>
      <li>传统的机器学习算法，由于技术和单机存储的限制，依赖于数据抽样，只能在少量数据上使用。所以存在的问题是很难做好随机，从而导致学习的模型不准确。</li> 
      <li>在大数据上进行机器学习，可以直接处理全量数据并进行大量迭代计算。Spark本身计算优势，适合机器学习。此外spark-shell、pyspark都可以提供及时查询工具。</li> 
     </ul></li> 
   </ul>
   <h3 class="heading">(3) MLlib</h3> 
   <ul>
    <li>MLlib是Spark机器学习库，简化机器学习的工程实践工作，方便扩展到更大规模。集成了通用的学习算法：分类、回归、聚类、协同过滤、降维等等。另外，MLlib本身在Spark中，数据清洗、SQL、建模放在一起。</li> 
   </ul>
  </div> 
  <p>转载于:https://juejin.im/post/5cd16c00e51d453a51433062</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
