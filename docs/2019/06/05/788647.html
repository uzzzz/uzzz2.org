<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>高能！8段代码演示Numpy数据运算的神操作 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="高能！8段代码演示Numpy数据运算的神操作" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="导读：本文介绍一下在Python科学计算中非常重要的一个库——Numpy。 作者：王天庆 如需转载请联系大数据（ID：hzdashuju） Numpy是Numerical Python extensions 的缩写，字面意思是Python数值计算扩展。Numpy是Python中众多机器学习库的依赖，这些库通过Numpy实现基本的矩阵计算，Python的OpenCV库自然也不例外。 Numpy支持高阶、大量计算的矩阵、向量计算，与此同时提供了较为丰富的函数。Numpy采用友好的BSD许可协议开放源代码。它是一个跨平台的科学计算库，提供了与Matlab相似的功能和操作方法。 虽然科学计算领域一直是Matlab的天下，但是Numpy基于更加现代化的编程语言——Python。而且Python凭借着开源、免费、灵活性、简单易学、工程特性好等特点风靡技术圈，已经成为机器学习、数据分析等领域的主流编程语言。 虽然Matlab提供的包非常多，但是Python因其简单灵活、扩展性强等特点，也诞生了一系列优秀的库。例如Scipy具有大多数Matlab所具备的功能，Matplotlib能够简便地进行数据可视化。虽然当前Matlab的地位仍然难以撼动，但是，随着时间的推移，Python在科学计算上的生态系统也会越来越丰富。 安装Numpy的方法也很简单，使用Python的包管理工具pip或者anaconda便可以实现。例如在shell中输入下列命令行便可以通过pip安装Numpy： pip&nbsp;install&nbsp;numpy 另外，Numpy是OpenCV的一个依赖库，所以，我们使用pip工具安装好OpenCV库之后，Numpy一般也都已经安装好了。 01 array类型 Numpy的array类型是该库的一个基本数据类型，这个数据类型从字面上看是数组的意思，也就意味着它最关键的属性是元素与维度，我们可以这个数据类型来实现多维数组。 因此，通过这个数据类型，我们可以使用一维数组用来表示向量，二维数组来表示矩阵，以此类推用以表示更高维度的张量。 我们通过下面的例子来简单体会一下在Numpy中array类型的使用。 1. Numpy中array类型的基本使用 import&nbsp;numpy&nbsp;as&nbsp;np#&nbsp;引入numpy库，并将其别名为nparray&nbsp;=&nbsp;np.array([1,2,3,4])#&nbsp;通过np.array()方法创建一个名为array的array类型，参数是一个listarray#&nbsp;在shell中输入，返回的结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4])array.max()#&nbsp;获取该array类型中最大的元素值，结果为:#&nbsp;4array.mean()#&nbsp;求该array中元素的平均值，结果为:#&nbsp;2.5array.min()#&nbsp;获取该array中元素的最小值：#&nbsp;1array&nbsp;*&nbsp;2#&nbsp;直接将该array乘以2，Python将该运算符重载，将每一个元素都乘以了2，其输出结果为：#&nbsp;array([2,&nbsp;4,&nbsp;6,&nbsp;8])array&nbsp;+&nbsp;1#&nbsp;将每一个元素都加上1，输出结果为：#&nbsp;array([2,&nbsp;3,&nbsp;4,&nbsp;5])array&nbsp;/&nbsp;2&nbsp;#&nbsp;将每一个元素都除以2，得到浮点数表示的结果为：#&nbsp;array([&nbsp;0.5,&nbsp;&nbsp;1.&nbsp;,&nbsp;&nbsp;1.5,&nbsp;&nbsp;2.&nbsp;])array&nbsp;%&nbsp;2#&nbsp;Numpy库除了可以对array实现除法运算，还可以实现取模运算，结果为：#&nbsp;array([1,&nbsp;0,&nbsp;1,&nbsp;0],&nbsp;dtype=int32)array.argmax()#&nbsp;获取该组数据中元素值最大的一个数据的索引，下标从0开始，其结果为：#&nbsp;3as&nbsp;np#&nbsp;引入numpy库，并将其别名为nparray&nbsp;=&nbsp;np.array([1,2,3,4])#&nbsp;通过np.array()方法创建一个名为array的array类型，参数是一个listarray#&nbsp;在shell中输入，返回的结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4])array.max()#&nbsp;获取该array类型中最大的元素值，结果为:#&nbsp;4array.mean()#&nbsp;求该array中元素的平均值，结果为:#&nbsp;2.5array.min()#&nbsp;获取该array中元素的最小值：#&nbsp;1array&nbsp;*&nbsp;2#&nbsp;直接将该array乘以2，Python将该运算符重载，将每一个元素都乘以了2，其输出结果为：#&nbsp;array([2,&nbsp;4,&nbsp;6,&nbsp;8])array&nbsp;+&nbsp;1#&nbsp;将每一个元素都加上1，输出结果为：#&nbsp;array([2,&nbsp;3,&nbsp;4,&nbsp;5])array&nbsp;/&nbsp;2&nbsp;#&nbsp;将每一个元素都除以2，得到浮点数表示的结果为：#&nbsp;array([&nbsp;0.5,&nbsp;&nbsp;1.&nbsp;,&nbsp;&nbsp;1.5,&nbsp;&nbsp;2.&nbsp;])array&nbsp;%&nbsp;2#&nbsp;Numpy库除了可以对array实现除法运算，还可以实现取模运算，结果为：#&nbsp;array([1,&nbsp;0,&nbsp;1,&nbsp;0],&nbsp;dtype=int32)array.argmax()#&nbsp;获取该组数据中元素值最大的一个数据的索引，下标从0开始，其结果为：#&nbsp;3 通过上面的代码片段，我们可以了解Numpy中array类型的基本使用方法。我们可以看到，array其实是一个类，通过传入一个list参数来实例化为一个对象，也就实现了对数据的封装。这个对象中包含对各个元素进行计算的基本方法，例如求平均值、求最大值等。除此之外，我们再看一下关于更高维度数据的处理。 2. Numpy对更高维度数据的处理 import&nbsp;numpy&nbsp;as&nbsp;nparray&nbsp;=&nbsp;np.array([[1,2],[3,4],[5,6]])#&nbsp;创建一个二维数组，用以表示一个3行2列的矩阵，名为arrayarray#在交互式编程界面中输入array，返回结果为：#&nbsp;array([[1,&nbsp;2],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;4],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5,&nbsp;6]])array.shape#&nbsp;查看数据的维度属性，下面的输出结果元组，代表的是3行2列#&nbsp;(3,&nbsp;2)array.size#&nbsp;查看array中的元素数量，输出结果为：#&nbsp;6array.argmax()#&nbsp;查看元素值最大的元素索引，结果为：#&nbsp;5array.flatten()#&nbsp;将shape为(3,2)的array转换为一行表示，输出结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6])#&nbsp;我们可以看到，flatten()方法是将多维数据“压平”为一维数组的过程array.reshape(2,3)#&nbsp;将array数据从shape为(3,2)的形式转换为(2,3)的形式：#&nbsp;array([[1,&nbsp;2,&nbsp;3],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,&nbsp;5,&nbsp;6]])as&nbsp;nparray&nbsp;=&nbsp;np.array([[1,2],[3,4],[5,6]])#&nbsp;创建一个二维数组，用以表示一个3行2列的矩阵，名为arrayarray#在交互式编程界面中输入array，返回结果为：#&nbsp;array([[1,&nbsp;2],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;4],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5,&nbsp;6]])array.shape#&nbsp;查看数据的维度属性，下面的输出结果元组，代表的是3行2列#&nbsp;(3,&nbsp;2)array.size#&nbsp;查看array中的元素数量，输出结果为：#&nbsp;6array.argmax()#&nbsp;查看元素值最大的元素索引，结果为：#&nbsp;5array.flatten()#&nbsp;将shape为(3,2)的array转换为一行表示，输出结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6])#&nbsp;我们可以看到，flatten()方法是将多维数据“压平”为一维数组的过程array.reshape(2,3)#&nbsp;将array数据从shape为(3,2)的形式转换为(2,3)的形式：#&nbsp;array([[1,&nbsp;2,&nbsp;3],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,&nbsp;5,&nbsp;6]]) 除此之外，Numpy还包含了创建特殊类别的array类型的方法，例如。 3. Numpy创建特殊类别的array类型 import&nbsp;numpy&nbsp;as&nbsp;nparray_zeros&nbsp;=&nbsp;np.zeros((2,3,3))#生成结果为：#&nbsp;array([[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]],##&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]]])array_ones&nbsp;=&nbsp;np.ones((2,3,3))#&nbsp;生成所有元素都为1的array，其shape是(2,3,3)array_ones.shape#&nbsp;(2,&nbsp;3,&nbsp;3)array_arange&nbsp;=&nbsp;np.arange(10)#&nbsp;生成一个array，从0递增到10，步长为1，结果为：#&nbsp;array([0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9])array_linespace&nbsp;=&nbsp;np.linspace(0,10,5)#&nbsp;生成一个array从0到10递增，步长为5，结果为：#&nbsp;array([&nbsp;&nbsp;0.&nbsp;,&nbsp;&nbsp;&nbsp;2.5,&nbsp;&nbsp;&nbsp;5.&nbsp;,&nbsp;&nbsp;&nbsp;7.5,&nbsp;&nbsp;10.&nbsp;])as&nbsp;nparray_zeros&nbsp;=&nbsp;np.zeros((2,3,3))#生成结果为：#&nbsp;array([[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]],##&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]]])array_ones&nbsp;=&nbsp;np.ones((2,3,3))#&nbsp;生成所有元素都为1的array，其shape是(2,3,3)array_ones.shape#&nbsp;(2,&nbsp;3,&nbsp;3)array_arange&nbsp;=&nbsp;np.arange(10)#&nbsp;生成一个array，从0递增到10，步长为1，结果为：#&nbsp;array([0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9])array_linespace&nbsp;=&nbsp;np.linspace(0,10,5)#&nbsp;生成一个array从0到10递增，步长为5，结果为：#&nbsp;array([&nbsp;&nbsp;0.&nbsp;,&nbsp;&nbsp;&nbsp;2.5,&nbsp;&nbsp;&nbsp;5.&nbsp;,&nbsp;&nbsp;&nbsp;7.5,&nbsp;&nbsp;10.&nbsp;]) Numpy作为Python的一款著名数值计算库，其在基础计算上的功能也是非常完备的，代码如下。 4. Numpy基础计算演示 import&nbsp;numpy&nbsp;as&nbsp;npnp.abs([1,-2,-3,4])#&nbsp;取绝对值，结果为：array([1,&nbsp;2,&nbsp;3,&nbsp;4])np.sin(np.pi&nbsp;/&nbsp;2)#&nbsp;求余弦值，结果为：1.0np.arctan(1)#&nbsp;求反正切值，结果为：0.78539816339744828np.exp(2)#&nbsp;求自然常数e的2次方，结果为：7.3890560989306504np.power(2,3)#&nbsp;求2的3次方，结果为：8np.dot([1,2],[3,4])#&nbsp;将向量[1,2]与[3,4]求点积，结果为：11np.sqrt(4)#&nbsp;将4开平方，结果为：2.0np.sum([1,2,3,4])#&nbsp;求和，结果为：10np.mean([1,2,3,4])#&nbsp;求平均值，结果为：2.5np.std([1,2,3,4])#&nbsp;求标准差，结果为：1.1180339887498949as&nbsp;npnp.abs([1,-2,-3,4])#&nbsp;取绝对值，结果为：array([1,&nbsp;2,&nbsp;3,&nbsp;4])np.sin(np.pi&nbsp;/&nbsp;2)#&nbsp;求余弦值，结果为：1.0np.arctan(1)#&nbsp;求反正切值，结果为：0.78539816339744828np.exp(2)#&nbsp;求自然常数e的2次方，结果为：7.3890560989306504np.power(2,3)#&nbsp;求2的3次方，结果为：8np.dot([1,2],[3,4])#&nbsp;将向量[1,2]与[3,4]求点积，结果为：11np.sqrt(4)#&nbsp;将4开平方，结果为：2.0np.sum([1,2,3,4])#&nbsp;求和，结果为：10np.mean([1,2,3,4])#&nbsp;求平均值，结果为：2.5np.std([1,2,3,4])#&nbsp;求标准差，结果为：1.1180339887498949 除此之外，Numpy所包含的基本计算功能还有很多，例如将array切分、拼接、倒序等。 02 线性代数相关 我们在前面介绍了array类型及其基本操作方法，了解到使用array类型可以表示向量、矩阵和多维张量。线性代数计算在科学计算领域非常重要，在机器学习和数据挖掘领域，线性代数相关函数的使用也是非常频繁的。下面，我们介绍一下Numpy为我们提供的线性代数操作。 5. Numpy提供的线性代数操作 import&nbsp;numpy&nbsp;as&nbsp;npvector_a&nbsp;=&nbsp;np.array([1,2,3])vector_b&nbsp;=&nbsp;np.array([2,3,4])#&nbsp;定义两个向量vector_a与vector_bnp.dot(vector_a,vector_b)#&nbsp;将两个向量相乘，在这里也就是点乘，结果为20vector_a.dot(vector_b)#&nbsp;将vector_a与vector_b相乘，结果为20np.dot(vector_a,vector_b.T)&#39;&#39;&#39;将一个行向量与一个列向量叉乘的结果相当于将两个行向量求点积，在这里我们测试了dot()方法。其中array类型的T()方法表示转置。测试结果表明：dot()方法对于两个向量默认求其点积。对于符合叉乘格式的矩阵，自动进行叉乘。我们看一下下面这个例子：&#39;&#39;&#39;matrix_a&nbsp;=&nbsp;np.array([[1,2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])#&nbsp;定义一个2行2列的方阵matrix_b&nbsp;=&nbsp;np.dot(matrix_a,matrix_a.T)#&nbsp;这里将该方阵与其转置叉乘，将结果赋予matrix_b变量matrix_b&#39;&#39;&#39;结果为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])&#39;&#39;&#39;np.linalg.norm([1,2])#&nbsp;求一个向量的范数的值，结果为2.2360679774997898#&nbsp;如果norm()方法没有指定第二个参数，则默认为求2范数。np.linalg.norm([1,-2],1)#&nbsp;指定第二个参数值为1，即求1范数，我们在前面介绍过，1范数的结果即为向量中各元素绝对值之和，结果为3.0np.linalg.norm([1,2,3,4],np.inf)#&nbsp;求向量的无穷范数，其中np.inf表示正无穷，也就是向量中元素值最大的那个，其结果为4.0np.linalg.norm([1,2,3,4],-np.inf)#&nbsp;同理，求负无穷范数的结果为1，也就是向量中元素的最小值np.linalg.norm(matrix_b)#&nbsp;除了向量可以求范数，矩阵也可以有类似的运算，即为F范数，结果为29.866369046136157np.linalg.det(matrix_a)#&nbsp;求矩阵matrix_a的行列式，结果为-2.0000000000000004np.trace(matrix_a)#&nbsp;求矩阵matrix_a的迹，结果为5np.linalg.matrix_rank(matrix_a)#&nbsp;求矩阵的秩，结果为2vector_a&nbsp;*&nbsp;vector_b#&nbsp;使用*符号将两个向量相乘，是将两个向量中的元素分别相乘，也就是前面我们所讲到的哈达马乘积，结果为array([&nbsp;2,&nbsp;&nbsp;6,&nbsp;12])vector_a&nbsp;**&nbsp;vector_b#&nbsp;使用二元运算符**对两个向量进行操作，结果为array([&nbsp;1,&nbsp;&nbsp;8,&nbsp;81],&nbsp;dtype=int32)#&nbsp;表示将向量vector_a中元素对应vector_b中的元素值求幂运算。例如最终结果[1,8,81]可以表示为：#&nbsp;[1*1,2*2*2,3*3*3*3]np.linalg.pinv(matrix_a)&#39;&#39;&#39;求矩阵的逆矩阵，方法pinv()求的是伪逆矩阵，结果为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])不使用伪逆矩阵的算法，直接使用逆矩阵的方法是inv()，即np.linalg.inv(matrix_a)结果相同，也为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])&#39;&#39;&#39;as&nbsp;npvector_a&nbsp;=&nbsp;np.array([1,2,3])vector_b&nbsp;=&nbsp;np.array([2,3,4])#&nbsp;定义两个向量vector_a与vector_bnp.dot(vector_a,vector_b)#&nbsp;将两个向量相乘，在这里也就是点乘，结果为20vector_a.dot(vector_b)#&nbsp;将vector_a与vector_b相乘，结果为20np.dot(vector_a,vector_b.T)&#39;&#39;&#39;将一个行向量与一个列向量叉乘的结果相当于将两个行向量求点积，在这里我们测试了dot()方法。其中array类型的T()方法表示转置。测试结果表明：dot()方法对于两个向量默认求其点积。对于符合叉乘格式的矩阵，自动进行叉乘。我们看一下下面这个例子：&#39;&#39;&#39;matrix_a&nbsp;=&nbsp;np.array([[1,2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])#&nbsp;定义一个2行2列的方阵matrix_b&nbsp;=&nbsp;np.dot(matrix_a,matrix_a.T)#&nbsp;这里将该方阵与其转置叉乘，将结果赋予matrix_b变量matrix_b&#39;&#39;&#39;结果为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])&#39;&#39;&#39;np.linalg.norm([1,2])#&nbsp;求一个向量的范数的值，结果为2.2360679774997898#&nbsp;如果norm()方法没有指定第二个参数，则默认为求2范数。np.linalg.norm([1,-2],1)#&nbsp;指定第二个参数值为1，即求1范数，我们在前面介绍过，1范数的结果即为向量中各元素绝对值之和，结果为3.0np.linalg.norm([1,2,3,4],np.inf)#&nbsp;求向量的无穷范数，其中np.inf表示正无穷，也就是向量中元素值最大的那个，其结果为4.0np.linalg.norm([1,2,3,4],-np.inf)#&nbsp;同理，求负无穷范数的结果为1，也就是向量中元素的最小值np.linalg.norm(matrix_b)#&nbsp;除了向量可以求范数，矩阵也可以有类似的运算，即为F范数，结果为29.866369046136157np.linalg.det(matrix_a)#&nbsp;求矩阵matrix_a的行列式，结果为-2.0000000000000004np.trace(matrix_a)#&nbsp;求矩阵matrix_a的迹，结果为5np.linalg.matrix_rank(matrix_a)#&nbsp;求矩阵的秩，结果为2vector_a&nbsp;*&nbsp;vector_b#&nbsp;使用*符号将两个向量相乘，是将两个向量中的元素分别相乘，也就是前面我们所讲到的哈达马乘积，结果为array([&nbsp;2,&nbsp;&nbsp;6,&nbsp;12])vector_a&nbsp;**&nbsp;vector_b#&nbsp;使用二元运算符**对两个向量进行操作，结果为array([&nbsp;1,&nbsp;&nbsp;8,&nbsp;81],&nbsp;dtype=int32)#&nbsp;表示将向量vector_a中元素对应vector_b中的元素值求幂运算。例如最终结果[1,8,81]可以表示为：#&nbsp;[1*1,2*2*2,3*3*3*3]np.linalg.pinv(matrix_a)&#39;&#39;&#39;求矩阵的逆矩阵，方法pinv()求的是伪逆矩阵，结果为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])不使用伪逆矩阵的算法，直接使用逆矩阵的方法是inv()，即np.linalg.inv(matrix_a)结果相同，也为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])&#39;&#39;&#39; 03 矩阵的高级函数 我们在前面学习了Numpy的基本数据类型array，同时了解了一些基本的数学运算方法。其实除了前面我们所提到的对矩阵求逆、求秩、求转置等基本运算之外，Numpy还为我们提供了矩阵的分解等更高级的函数。 矩阵分解(decomposition, factorization)是将矩阵拆解为若干个矩阵的相乘的过程。在数值分析，常常被用来实现一些矩阵运算的快速算法，在机器学习领域有非常重要的作用。 例如我们在前面介绍过线性降维的PCA算法，其中就涉及矩阵分解的步骤。今日头条、亚马逊网上商城这类互联网产品，总会根据我们的个人喜好给我们推送一些它认为我们会感兴趣的资讯或商品，这类用于推送消息的系统称为推荐系统(Recommendation System)。 在推荐系统的实现过程中，就用到了矩阵分解算法。例如主流的开源大数据计算引擎Spark在ml机器学习库中通过ALS算法实现了推荐系统，也有的推荐系统采用SVD算法来实现整套系统中的矩阵分解过程。 在Numpy中，为我们提供了基于SVD算法的矩阵分解，SVD算法即为奇异值分解法，相对于矩阵的特征值分解法，它可以对非方阵形式的矩阵进行分解，将一个矩阵A分解为如下形式： A = U∑VT 式中，A代表需要被分解的矩阵，设其维度是m×n。U矩阵是被分解为的三个矩阵之一，它是一个m×m的方阵，构成这个矩阵的向量是正交的，被称为左奇异向量；∑是一个m×n的向量，它的特点是除了对角线中的元素外，其余元素都为0。V是一个n×n的方阵，它的转置也是一个方阵，与U矩阵类似，构成这个矩阵的向量也是正交的，被称为右奇异向量。整个奇异值分解算法矩阵的形式如图4-1所示，具体算法实现在此不再赘述。 ▲图4-1 SVD算法的矩阵形式 我们使用Numpy演示一下SVD算法的使用。 6. SVD算法演示 import&nbsp;numpy&nbsp;as&nbsp;npmatrix&nbsp;=&nbsp;np.array([&nbsp;&nbsp;&nbsp;&nbsp;[1,2],&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])another_matrix&nbsp;=&nbsp;np.dot(matrix,matrix.T)#&nbsp;生成一个矩阵&nbsp;another_matrixprint(another_matrix)&#39;&#39;&#39;该矩阵为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])&#39;&#39;&#39;U,s,V&nbsp;=&nbsp;np.linalg.svd(another_matrix,2)#&nbsp;使用奇异值分解法将该矩阵进行分解，分解得到三个子矩阵U,s,V#&nbsp;在s矩阵的基础上，生成S矩阵为：S&nbsp;=&nbsp;np.array([[s[0],0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,s[1]]])#&nbsp;我们在下面看一下生成的几个矩阵的样子print(U)&#39;&#39;&#39;[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]&#39;&#39;&#39;print(s)&#39;&#39;&#39;[&nbsp;29.86606875&nbsp;&nbsp;&nbsp;0.13393125]&#39;&#39;&#39;print(V)&#39;&#39;&#39;[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]&#39;&#39;&#39;#&nbsp;利用生成的U,S,V三个矩阵，我们可以重建回原来的矩阵another_matrixnp.dot(U,np.dot(S,V))#&nbsp;输出结果为:&#39;&#39;&#39;array([[&nbsp;&nbsp;5.,&nbsp;&nbsp;11.],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;11.,&nbsp;&nbsp;25.]])&#39;&#39;&#39;as&nbsp;npmatrix&nbsp;=&nbsp;np.array([&nbsp;&nbsp;&nbsp;&nbsp;[1,2],&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])another_matrix&nbsp;=&nbsp;np.dot(matrix,matrix.T)#&nbsp;生成一个矩阵&nbsp;another_matrixprint(another_matrix)&#39;&#39;&#39;该矩阵为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])&#39;&#39;&#39;U,s,V&nbsp;=&nbsp;np.linalg.svd(another_matrix,2)#&nbsp;使用奇异值分解法将该矩阵进行分解，分解得到三个子矩阵U,s,V#&nbsp;在s矩阵的基础上，生成S矩阵为：S&nbsp;=&nbsp;np.array([[s[0],0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,s[1]]])#&nbsp;我们在下面看一下生成的几个矩阵的样子print(U)&#39;&#39;&#39;[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]&#39;&#39;&#39;print(s)&#39;&#39;&#39;[&nbsp;29.86606875&nbsp;&nbsp;&nbsp;0.13393125]&#39;&#39;&#39;print(V)&#39;&#39;&#39;[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]&#39;&#39;&#39;#&nbsp;利用生成的U,S,V三个矩阵，我们可以重建回原来的矩阵another_matrixnp.dot(U,np.dot(S,V))#&nbsp;输出结果为:&#39;&#39;&#39;array([[&nbsp;&nbsp;5.,&nbsp;&nbsp;11.],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;11.,&nbsp;&nbsp;25.]])&#39;&#39;&#39; 在上面的代码片段中，s向量表示的是分解后的∑矩阵中对角线上的元素，所以我们在这里面引入了一个S矩阵，将s向量中的元素放置在这个矩阵中，用以验证分解后的矩阵重建回原先的矩阵A的过程。 仔细的读者可能会注意到，为什么这里使用SVD算法生成的矩阵U与VT是相同的。大家可能会注意到在上面的代码片段中，为何多了一个生成矩阵another_matrix的过程。这是因为一个矩阵与其转置相乘之后的矩阵是对称矩阵（矩阵中的元素沿着对角线对称），将对称矩阵进行分解后的结果可以表示为： A = V∑VT 通过观察上式，我们不难发现U与V矩阵是相同的，因为这个例子中，U与V矩阵本身也是对称矩阵，不论它的转置与否形式都是一样的。 我们在第2章介绍过用于线性降维的PCA算法，该算法中有一个步骤是将协方差矩阵分解然后重建，下面我们演示一下使用Numpy的SVD算法来实现PCA算法的例子： 7. 基于SVD实现PCA算法 import&nbsp;numpy&nbsp;as&nbsp;np#&nbsp;零均值化，即中心化，是数据的预处理方法def&nbsp;zero_centered(data):&nbsp;&nbsp;&nbsp;&nbsp;matrix_mean&nbsp;=&nbsp;np.mean(data,&nbsp;axis=0)&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data&nbsp;-&nbsp;matrix_meandef&nbsp;pca_eig(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;#&nbsp;也可以用&nbsp;np.cov()&nbsp;方法&nbsp;&nbsp;&nbsp;&nbsp;eig_values,&nbsp;eig_vectors&nbsp;=&nbsp;np.linalg.eig(np.mat(cov_mat))&nbsp;&nbsp;#&nbsp;求特征值和特征向量，特征向量是列向量&nbsp;&nbsp;&nbsp;&nbsp;value_indices&nbsp;=&nbsp;np.argsort(eig_values)&nbsp;&nbsp;#&nbsp;将特征值从小到大排序&nbsp;&nbsp;&nbsp;&nbsp;n_vectors&nbsp;=&nbsp;eig_vectors[:,&nbsp;value_indices[-1:-(n&nbsp;+&nbsp;1):-1]]&nbsp;&nbsp;#&nbsp;最大的n个特征值对应的特征向量&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new_data&nbsp;*&nbsp;n_vectors&nbsp;&nbsp;#&nbsp;返回低维特征空间的数据def&nbsp;pca_svd(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;&nbsp;&nbsp;U,&nbsp;s,&nbsp;V&nbsp;=&nbsp;np.linalg.svd(cov_mat)&nbsp;&nbsp;#&nbsp;将协方差矩阵奇异值分解&nbsp;&nbsp;&nbsp;&nbsp;pc&nbsp;=&nbsp;np.dot(new_data,&nbsp;U)&nbsp;&nbsp;#&nbsp;返回矩阵的第一个列向量即是降维后的结果&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;pc[:,&nbsp;0]def&nbsp;unit_test():&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;np.array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[2.5,&nbsp;2.4],&nbsp;[0.5,&nbsp;0.7],&nbsp;[2.2,&nbsp;2.9],&nbsp;[1.9,&nbsp;2.2],&nbsp;[3.1,&nbsp;3.0],&nbsp;[2.3,&nbsp;2.7],&nbsp;[2,&nbsp;1.6],&nbsp;[1,&nbsp;1.1],&nbsp;[1.5,&nbsp;1.6],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1.1,&nbsp;0.9]])&nbsp;&nbsp;&nbsp;&nbsp;result_eig&nbsp;=&nbsp;pca_eig(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用常规的特征值分解法，将2维数据降到1维&nbsp;&nbsp;&nbsp;&nbsp;print(result_eig)&nbsp;&nbsp;&nbsp;&nbsp;result_svd&nbsp;=&nbsp;pca_svd(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用奇异值分解法将协方差矩阵分解，得到降维结果&nbsp;&nbsp;&nbsp;&nbsp;print(result_svd)if&nbsp;__name__&nbsp;==&nbsp;&#39;__main__&#39;:&nbsp;&nbsp;&nbsp;&nbsp;unit_test()as&nbsp;np#&nbsp;零均值化，即中心化，是数据的预处理方法def&nbsp;zero_centered(data):&nbsp;&nbsp;&nbsp;&nbsp;matrix_mean&nbsp;=&nbsp;np.mean(data,&nbsp;axis=0)&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data&nbsp;-&nbsp;matrix_meandef&nbsp;pca_eig(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;#&nbsp;也可以用&nbsp;np.cov()&nbsp;方法&nbsp;&nbsp;&nbsp;&nbsp;eig_values,&nbsp;eig_vectors&nbsp;=&nbsp;np.linalg.eig(np.mat(cov_mat))&nbsp;&nbsp;#&nbsp;求特征值和特征向量，特征向量是列向量&nbsp;&nbsp;&nbsp;&nbsp;value_indices&nbsp;=&nbsp;np.argsort(eig_values)&nbsp;&nbsp;#&nbsp;将特征值从小到大排序&nbsp;&nbsp;&nbsp;&nbsp;n_vectors&nbsp;=&nbsp;eig_vectors[:,&nbsp;value_indices[-1:-(n&nbsp;+&nbsp;1):-1]]&nbsp;&nbsp;#&nbsp;最大的n个特征值对应的特征向量&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new_data&nbsp;*&nbsp;n_vectors&nbsp;&nbsp;#&nbsp;返回低维特征空间的数据def&nbsp;pca_svd(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;&nbsp;&nbsp;U,&nbsp;s,&nbsp;V&nbsp;=&nbsp;np.linalg.svd(cov_mat)&nbsp;&nbsp;#&nbsp;将协方差矩阵奇异值分解&nbsp;&nbsp;&nbsp;&nbsp;pc&nbsp;=&nbsp;np.dot(new_data,&nbsp;U)&nbsp;&nbsp;#&nbsp;返回矩阵的第一个列向量即是降维后的结果&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;pc[:,&nbsp;0]def&nbsp;unit_test():&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;np.array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[2.5,&nbsp;2.4],&nbsp;[0.5,&nbsp;0.7],&nbsp;[2.2,&nbsp;2.9],&nbsp;[1.9,&nbsp;2.2],&nbsp;[3.1,&nbsp;3.0],&nbsp;[2.3,&nbsp;2.7],&nbsp;[2,&nbsp;1.6],&nbsp;[1,&nbsp;1.1],&nbsp;[1.5,&nbsp;1.6],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1.1,&nbsp;0.9]])&nbsp;&nbsp;&nbsp;&nbsp;result_eig&nbsp;=&nbsp;pca_eig(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用常规的特征值分解法，将2维数据降到1维&nbsp;&nbsp;&nbsp;&nbsp;print(result_eig)&nbsp;&nbsp;&nbsp;&nbsp;result_svd&nbsp;=&nbsp;pca_svd(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用奇异值分解法将协方差矩阵分解，得到降维结果&nbsp;&nbsp;&nbsp;&nbsp;print(result_svd)if&nbsp;__name__&nbsp;==&nbsp;&#39;__main__&#39;:&nbsp;&nbsp;&nbsp;&nbsp;unit_test() 经过降维的数据为： [-0.82797019&nbsp;&nbsp;1.77758033&nbsp;-0.99219749&nbsp;-0.27421042&nbsp;-1.67580142&nbsp;-0.9129491&nbsp;&nbsp;0.09910944&nbsp;&nbsp;1.14457216&nbsp;&nbsp;0.43804614&nbsp;&nbsp;1.22382056]1.77758033&nbsp;-0.99219749&nbsp;-0.27421042&nbsp;-1.67580142&nbsp;-0.9129491&nbsp;&nbsp;0.09910944&nbsp;&nbsp;1.14457216&nbsp;&nbsp;0.43804614&nbsp;&nbsp;1.22382056] 我们可以看到，数据已经从2维的变为1维的了，这两个PCA算法的计算结果是相同的。其中pca_eig() 函数是使用常规的特征值分解方法来求解的，读者可以参照前面讲述的PCA算法过程来理解这段代码。pca_svd() 函数使用奇异值分解法来求解的。这段代码虽然相对精简，但是背后是经过复杂的数学推导的，下面简要阐述一下PCA算法中奇异值分解的步骤。 1) PCA算法中得到样本的协方差矩阵是经过零均值化处理的，将其去掉常数部分，则也可表示为： C = XTX 其中，X是经过中心化处理后的样本矩阵X. 前面我们介绍过，一个矩阵与其转置矩阵相乘的结果是一个对称矩阵。观察到协方差矩阵C便是一个对称矩阵，那么将其进行奇异值分解后则可以表示为： C = V∑VT 2) 将经过中心化的样本矩阵X进行奇异值分解，可以得到： X = U∑VT 因此，我们可以得到： XTX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = (U∑VT)T(U∑VT) =&nbsp;V∑TUTU∑VT&nbsp; &nbsp; &nbsp;&nbsp; =&nbsp;V∑2VT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 奇异矩阵V中的列对应着PCA算法主成分中的主方向，因此可以得到主成分为： XV&nbsp;= U∑VTV =&nbsp;U∑ 关于更详细的数学推倒过程，读者可参考该网址： https://stats.stackexchange.com/questions/134282/relationship-between-svd-and-pca-how-to-use-svd-to-perform-pca Numpy除了为我们提供常规的数学计算函数和矩阵相关操作之外，还提供了很多功能丰富的模块，随机数模块就是其中一部分。利用随机数模块可以生成随机数矩阵，比Python自带的随机数模块功能要强大，我们看一下下面这个例子。 8. Numpy的随机数功能演示 import&nbsp;numpy&nbsp;as&nbsp;np#&nbsp;置随机数种子：np.random.seed()#&nbsp;从[1,3)中生成一个整数的随机数，连续生成10个np.random.randint(1,3,10)#&nbsp;返回：array([2,&nbsp;2,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;2,&nbsp;1,&nbsp;2,&nbsp;2])#&nbsp;若要连续产生[1,3)之间的浮点数，可以使用下述方法：2*np.random.random(10)&nbsp;+&nbsp;1&#39;&#39;&#39;返回：array([&nbsp;1.25705585,&nbsp;&nbsp;2.38059578,&nbsp;&nbsp;1.73232769,&nbsp;&nbsp;2.12303283,&nbsp;&nbsp;2.33946996,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.28020734,&nbsp;&nbsp;2.15724069,&nbsp;&nbsp;1.32845829,&nbsp;&nbsp;2.91361293,&nbsp;&nbsp;1.78637408])&#39;&#39;&#39;np.random.uniform(1,3,10)&#39;&#39;&#39;返回：array([&nbsp;1.37993226,&nbsp;&nbsp;1.38412227,&nbsp;&nbsp;1.18063785,&nbsp;&nbsp;1.75985962,&nbsp;&nbsp;1.42775752,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.62100074,&nbsp;&nbsp;1.71768721,&nbsp;&nbsp;1.50131522,&nbsp;&nbsp;2.20297121,&nbsp;&nbsp;1.08585819])&#39;&#39;&#39;#&nbsp;生成一个满足正太分布(高斯分布)的矩阵，其维度是4*4np.random.normal(size=(4,4))&#39;&#39;&#39;返回：array([[-1.81525915,&nbsp;-2.02236963,&nbsp;&nbsp;0.90969106,&nbsp;&nbsp;0.25448426],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1.04177298,&nbsp;-0.35408201,&nbsp;&nbsp;1.67850233,&nbsp;-0.70361323],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.30710761,&nbsp;&nbsp;0.57461312,&nbsp;-0.37867596,&nbsp;-0.74010685],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.94046747,&nbsp;&nbsp;2.37124816,&nbsp;-0.78503777,&nbsp;-0.33485225]])&#39;&#39;&#39;#&nbsp;随机产生10个，n=5,p=0.5的二项分布数据:np.random.binomial(n=5,p=0.5,size=10)#&nbsp;返回：array([2,&nbsp;0,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;4,&nbsp;2])data&nbsp;=&nbsp;np.arange(10)&nbsp;#&nbsp;产生一个0到9的序列np.random.choice(data,5)&nbsp;#&nbsp;从data数据中随机采集5个样本，采集过程是有放回的#&nbsp;返回：array([0,&nbsp;0,&nbsp;1,&nbsp;6,&nbsp;2])np.random.choice(data,5,replace=False)&nbsp;#从data数据中随机采集5个样本，采集过程是没有放回的#&nbsp;返回：array([0,&nbsp;4,&nbsp;3,&nbsp;9,&nbsp;7])np.random.permutation(data)&nbsp;#&nbsp;对data进行乱序，返回乱序结果#&nbsp;返回：array([2,&nbsp;8,&nbsp;6,&nbsp;4,&nbsp;9,&nbsp;1,&nbsp;3,&nbsp;5,&nbsp;7,&nbsp;0])np.random.shuffle(data)&nbsp;#&nbsp;对data进行乱序，并替换为新的dataprint(data)#&nbsp;输出：[1&nbsp;2&nbsp;8&nbsp;4&nbsp;3&nbsp;6&nbsp;9&nbsp;0&nbsp;5&nbsp;7]as&nbsp;np#&nbsp;置随机数种子：np.random.seed()#&nbsp;从[1,3)中生成一个整数的随机数，连续生成10个np.random.randint(1,3,10)#&nbsp;返回：array([2,&nbsp;2,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;2,&nbsp;1,&nbsp;2,&nbsp;2])#&nbsp;若要连续产生[1,3)之间的浮点数，可以使用下述方法：2*np.random.random(10)&nbsp;+&nbsp;1&#39;&#39;&#39;返回：array([&nbsp;1.25705585,&nbsp;&nbsp;2.38059578,&nbsp;&nbsp;1.73232769,&nbsp;&nbsp;2.12303283,&nbsp;&nbsp;2.33946996,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.28020734,&nbsp;&nbsp;2.15724069,&nbsp;&nbsp;1.32845829,&nbsp;&nbsp;2.91361293,&nbsp;&nbsp;1.78637408])&#39;&#39;&#39;np.random.uniform(1,3,10)&#39;&#39;&#39;返回：array([&nbsp;1.37993226,&nbsp;&nbsp;1.38412227,&nbsp;&nbsp;1.18063785,&nbsp;&nbsp;1.75985962,&nbsp;&nbsp;1.42775752,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.62100074,&nbsp;&nbsp;1.71768721,&nbsp;&nbsp;1.50131522,&nbsp;&nbsp;2.20297121,&nbsp;&nbsp;1.08585819])&#39;&#39;&#39;#&nbsp;生成一个满足正太分布(高斯分布)的矩阵，其维度是4*4np.random.normal(size=(4,4))&#39;&#39;&#39;返回：array([[-1.81525915,&nbsp;-2.02236963,&nbsp;&nbsp;0.90969106,&nbsp;&nbsp;0.25448426],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1.04177298,&nbsp;-0.35408201,&nbsp;&nbsp;1.67850233,&nbsp;-0.70361323],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.30710761,&nbsp;&nbsp;0.57461312,&nbsp;-0.37867596,&nbsp;-0.74010685],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.94046747,&nbsp;&nbsp;2.37124816,&nbsp;-0.78503777,&nbsp;-0.33485225]])&#39;&#39;&#39;#&nbsp;随机产生10个，n=5,p=0.5的二项分布数据:np.random.binomial(n=5,p=0.5,size=10)#&nbsp;返回：array([2,&nbsp;0,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;4,&nbsp;2])data&nbsp;=&nbsp;np.arange(10)&nbsp;#&nbsp;产生一个0到9的序列np.random.choice(data,5)&nbsp;#&nbsp;从data数据中随机采集5个样本，采集过程是有放回的#&nbsp;返回：array([0,&nbsp;0,&nbsp;1,&nbsp;6,&nbsp;2])np.random.choice(data,5,replace=False)&nbsp;#从data数据中随机采集5个样本，采集过程是没有放回的#&nbsp;返回：array([0,&nbsp;4,&nbsp;3,&nbsp;9,&nbsp;7])np.random.permutation(data)&nbsp;#&nbsp;对data进行乱序，返回乱序结果#&nbsp;返回：array([2,&nbsp;8,&nbsp;6,&nbsp;4,&nbsp;9,&nbsp;1,&nbsp;3,&nbsp;5,&nbsp;7,&nbsp;0])np.random.shuffle(data)&nbsp;#&nbsp;对data进行乱序，并替换为新的dataprint(data)#&nbsp;输出：[1&nbsp;2&nbsp;8&nbsp;4&nbsp;3&nbsp;6&nbsp;9&nbsp;0&nbsp;5&nbsp;7] 关于作者：王天庆，长期从事分布式系统、数据科学与工程、人工智能等方面的研究与开发，在人脸识别方面有丰富的实践经验。现就职某世界100强企业的数据实验室，从事数据科学相关技术领域的预研工作。 本文摘编自《Python人脸识别：从入门到工程实践》，经出版方授权发布。 延伸阅读《Python人脸识别》 点击上图了解及购买 转载请联系微信：DoctorData 推荐语：华为资深AI工程师撰写，全面讲解人脸识别各项基础技术、原理和算法，从零实现工程级人脸识别引擎。 据统计，99%的大咖都完成了这个神操作 ▼ 更多精彩 在公众号后台对话框输入以下关键词 查看更多优质内容！ PPT&nbsp;|&nbsp;报告&nbsp;|&nbsp;读书&nbsp;|&nbsp;书单&nbsp;|&nbsp;干货&nbsp; 大数据&nbsp;|&nbsp;揭秘&nbsp;|&nbsp;Python&nbsp;|&nbsp;可视化 AI&nbsp;|&nbsp;人工智能&nbsp;|&nbsp;5G&nbsp;|&nbsp;区块链 机器学习&nbsp;|&nbsp;深度学习&nbsp;|&nbsp;神经网络 1024&nbsp;|&nbsp;段子&nbsp;|&nbsp;数学&nbsp;|&nbsp;高考 猜你想看 真正零基础Python入门：手把手教你从变量和赋值语句学起 Python实操：手把手教你用Matplotlib把数据画出来 有关华为、5G、芯片和操作系统，这些书你读过几本？ 什么是数据？数据科学家需要掌握哪些技能？终于有人讲明白了 Q:&nbsp;你在用哪些工具做数学运算？ 欢迎留言与大家分享 觉得不错，请把这篇文章分享给你的朋友 转载 / 投稿请联系：baiyu@hzbook.com 更多精彩，请在后台点击“历史文章”查看 点击阅读原文，了解更多" />
<meta property="og:description" content="导读：本文介绍一下在Python科学计算中非常重要的一个库——Numpy。 作者：王天庆 如需转载请联系大数据（ID：hzdashuju） Numpy是Numerical Python extensions 的缩写，字面意思是Python数值计算扩展。Numpy是Python中众多机器学习库的依赖，这些库通过Numpy实现基本的矩阵计算，Python的OpenCV库自然也不例外。 Numpy支持高阶、大量计算的矩阵、向量计算，与此同时提供了较为丰富的函数。Numpy采用友好的BSD许可协议开放源代码。它是一个跨平台的科学计算库，提供了与Matlab相似的功能和操作方法。 虽然科学计算领域一直是Matlab的天下，但是Numpy基于更加现代化的编程语言——Python。而且Python凭借着开源、免费、灵活性、简单易学、工程特性好等特点风靡技术圈，已经成为机器学习、数据分析等领域的主流编程语言。 虽然Matlab提供的包非常多，但是Python因其简单灵活、扩展性强等特点，也诞生了一系列优秀的库。例如Scipy具有大多数Matlab所具备的功能，Matplotlib能够简便地进行数据可视化。虽然当前Matlab的地位仍然难以撼动，但是，随着时间的推移，Python在科学计算上的生态系统也会越来越丰富。 安装Numpy的方法也很简单，使用Python的包管理工具pip或者anaconda便可以实现。例如在shell中输入下列命令行便可以通过pip安装Numpy： pip&nbsp;install&nbsp;numpy 另外，Numpy是OpenCV的一个依赖库，所以，我们使用pip工具安装好OpenCV库之后，Numpy一般也都已经安装好了。 01 array类型 Numpy的array类型是该库的一个基本数据类型，这个数据类型从字面上看是数组的意思，也就意味着它最关键的属性是元素与维度，我们可以这个数据类型来实现多维数组。 因此，通过这个数据类型，我们可以使用一维数组用来表示向量，二维数组来表示矩阵，以此类推用以表示更高维度的张量。 我们通过下面的例子来简单体会一下在Numpy中array类型的使用。 1. Numpy中array类型的基本使用 import&nbsp;numpy&nbsp;as&nbsp;np#&nbsp;引入numpy库，并将其别名为nparray&nbsp;=&nbsp;np.array([1,2,3,4])#&nbsp;通过np.array()方法创建一个名为array的array类型，参数是一个listarray#&nbsp;在shell中输入，返回的结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4])array.max()#&nbsp;获取该array类型中最大的元素值，结果为:#&nbsp;4array.mean()#&nbsp;求该array中元素的平均值，结果为:#&nbsp;2.5array.min()#&nbsp;获取该array中元素的最小值：#&nbsp;1array&nbsp;*&nbsp;2#&nbsp;直接将该array乘以2，Python将该运算符重载，将每一个元素都乘以了2，其输出结果为：#&nbsp;array([2,&nbsp;4,&nbsp;6,&nbsp;8])array&nbsp;+&nbsp;1#&nbsp;将每一个元素都加上1，输出结果为：#&nbsp;array([2,&nbsp;3,&nbsp;4,&nbsp;5])array&nbsp;/&nbsp;2&nbsp;#&nbsp;将每一个元素都除以2，得到浮点数表示的结果为：#&nbsp;array([&nbsp;0.5,&nbsp;&nbsp;1.&nbsp;,&nbsp;&nbsp;1.5,&nbsp;&nbsp;2.&nbsp;])array&nbsp;%&nbsp;2#&nbsp;Numpy库除了可以对array实现除法运算，还可以实现取模运算，结果为：#&nbsp;array([1,&nbsp;0,&nbsp;1,&nbsp;0],&nbsp;dtype=int32)array.argmax()#&nbsp;获取该组数据中元素值最大的一个数据的索引，下标从0开始，其结果为：#&nbsp;3as&nbsp;np#&nbsp;引入numpy库，并将其别名为nparray&nbsp;=&nbsp;np.array([1,2,3,4])#&nbsp;通过np.array()方法创建一个名为array的array类型，参数是一个listarray#&nbsp;在shell中输入，返回的结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4])array.max()#&nbsp;获取该array类型中最大的元素值，结果为:#&nbsp;4array.mean()#&nbsp;求该array中元素的平均值，结果为:#&nbsp;2.5array.min()#&nbsp;获取该array中元素的最小值：#&nbsp;1array&nbsp;*&nbsp;2#&nbsp;直接将该array乘以2，Python将该运算符重载，将每一个元素都乘以了2，其输出结果为：#&nbsp;array([2,&nbsp;4,&nbsp;6,&nbsp;8])array&nbsp;+&nbsp;1#&nbsp;将每一个元素都加上1，输出结果为：#&nbsp;array([2,&nbsp;3,&nbsp;4,&nbsp;5])array&nbsp;/&nbsp;2&nbsp;#&nbsp;将每一个元素都除以2，得到浮点数表示的结果为：#&nbsp;array([&nbsp;0.5,&nbsp;&nbsp;1.&nbsp;,&nbsp;&nbsp;1.5,&nbsp;&nbsp;2.&nbsp;])array&nbsp;%&nbsp;2#&nbsp;Numpy库除了可以对array实现除法运算，还可以实现取模运算，结果为：#&nbsp;array([1,&nbsp;0,&nbsp;1,&nbsp;0],&nbsp;dtype=int32)array.argmax()#&nbsp;获取该组数据中元素值最大的一个数据的索引，下标从0开始，其结果为：#&nbsp;3 通过上面的代码片段，我们可以了解Numpy中array类型的基本使用方法。我们可以看到，array其实是一个类，通过传入一个list参数来实例化为一个对象，也就实现了对数据的封装。这个对象中包含对各个元素进行计算的基本方法，例如求平均值、求最大值等。除此之外，我们再看一下关于更高维度数据的处理。 2. Numpy对更高维度数据的处理 import&nbsp;numpy&nbsp;as&nbsp;nparray&nbsp;=&nbsp;np.array([[1,2],[3,4],[5,6]])#&nbsp;创建一个二维数组，用以表示一个3行2列的矩阵，名为arrayarray#在交互式编程界面中输入array，返回结果为：#&nbsp;array([[1,&nbsp;2],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;4],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5,&nbsp;6]])array.shape#&nbsp;查看数据的维度属性，下面的输出结果元组，代表的是3行2列#&nbsp;(3,&nbsp;2)array.size#&nbsp;查看array中的元素数量，输出结果为：#&nbsp;6array.argmax()#&nbsp;查看元素值最大的元素索引，结果为：#&nbsp;5array.flatten()#&nbsp;将shape为(3,2)的array转换为一行表示，输出结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6])#&nbsp;我们可以看到，flatten()方法是将多维数据“压平”为一维数组的过程array.reshape(2,3)#&nbsp;将array数据从shape为(3,2)的形式转换为(2,3)的形式：#&nbsp;array([[1,&nbsp;2,&nbsp;3],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,&nbsp;5,&nbsp;6]])as&nbsp;nparray&nbsp;=&nbsp;np.array([[1,2],[3,4],[5,6]])#&nbsp;创建一个二维数组，用以表示一个3行2列的矩阵，名为arrayarray#在交互式编程界面中输入array，返回结果为：#&nbsp;array([[1,&nbsp;2],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;4],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5,&nbsp;6]])array.shape#&nbsp;查看数据的维度属性，下面的输出结果元组，代表的是3行2列#&nbsp;(3,&nbsp;2)array.size#&nbsp;查看array中的元素数量，输出结果为：#&nbsp;6array.argmax()#&nbsp;查看元素值最大的元素索引，结果为：#&nbsp;5array.flatten()#&nbsp;将shape为(3,2)的array转换为一行表示，输出结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6])#&nbsp;我们可以看到，flatten()方法是将多维数据“压平”为一维数组的过程array.reshape(2,3)#&nbsp;将array数据从shape为(3,2)的形式转换为(2,3)的形式：#&nbsp;array([[1,&nbsp;2,&nbsp;3],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,&nbsp;5,&nbsp;6]]) 除此之外，Numpy还包含了创建特殊类别的array类型的方法，例如。 3. Numpy创建特殊类别的array类型 import&nbsp;numpy&nbsp;as&nbsp;nparray_zeros&nbsp;=&nbsp;np.zeros((2,3,3))#生成结果为：#&nbsp;array([[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]],##&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]]])array_ones&nbsp;=&nbsp;np.ones((2,3,3))#&nbsp;生成所有元素都为1的array，其shape是(2,3,3)array_ones.shape#&nbsp;(2,&nbsp;3,&nbsp;3)array_arange&nbsp;=&nbsp;np.arange(10)#&nbsp;生成一个array，从0递增到10，步长为1，结果为：#&nbsp;array([0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9])array_linespace&nbsp;=&nbsp;np.linspace(0,10,5)#&nbsp;生成一个array从0到10递增，步长为5，结果为：#&nbsp;array([&nbsp;&nbsp;0.&nbsp;,&nbsp;&nbsp;&nbsp;2.5,&nbsp;&nbsp;&nbsp;5.&nbsp;,&nbsp;&nbsp;&nbsp;7.5,&nbsp;&nbsp;10.&nbsp;])as&nbsp;nparray_zeros&nbsp;=&nbsp;np.zeros((2,3,3))#生成结果为：#&nbsp;array([[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]],##&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]]])array_ones&nbsp;=&nbsp;np.ones((2,3,3))#&nbsp;生成所有元素都为1的array，其shape是(2,3,3)array_ones.shape#&nbsp;(2,&nbsp;3,&nbsp;3)array_arange&nbsp;=&nbsp;np.arange(10)#&nbsp;生成一个array，从0递增到10，步长为1，结果为：#&nbsp;array([0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9])array_linespace&nbsp;=&nbsp;np.linspace(0,10,5)#&nbsp;生成一个array从0到10递增，步长为5，结果为：#&nbsp;array([&nbsp;&nbsp;0.&nbsp;,&nbsp;&nbsp;&nbsp;2.5,&nbsp;&nbsp;&nbsp;5.&nbsp;,&nbsp;&nbsp;&nbsp;7.5,&nbsp;&nbsp;10.&nbsp;]) Numpy作为Python的一款著名数值计算库，其在基础计算上的功能也是非常完备的，代码如下。 4. Numpy基础计算演示 import&nbsp;numpy&nbsp;as&nbsp;npnp.abs([1,-2,-3,4])#&nbsp;取绝对值，结果为：array([1,&nbsp;2,&nbsp;3,&nbsp;4])np.sin(np.pi&nbsp;/&nbsp;2)#&nbsp;求余弦值，结果为：1.0np.arctan(1)#&nbsp;求反正切值，结果为：0.78539816339744828np.exp(2)#&nbsp;求自然常数e的2次方，结果为：7.3890560989306504np.power(2,3)#&nbsp;求2的3次方，结果为：8np.dot([1,2],[3,4])#&nbsp;将向量[1,2]与[3,4]求点积，结果为：11np.sqrt(4)#&nbsp;将4开平方，结果为：2.0np.sum([1,2,3,4])#&nbsp;求和，结果为：10np.mean([1,2,3,4])#&nbsp;求平均值，结果为：2.5np.std([1,2,3,4])#&nbsp;求标准差，结果为：1.1180339887498949as&nbsp;npnp.abs([1,-2,-3,4])#&nbsp;取绝对值，结果为：array([1,&nbsp;2,&nbsp;3,&nbsp;4])np.sin(np.pi&nbsp;/&nbsp;2)#&nbsp;求余弦值，结果为：1.0np.arctan(1)#&nbsp;求反正切值，结果为：0.78539816339744828np.exp(2)#&nbsp;求自然常数e的2次方，结果为：7.3890560989306504np.power(2,3)#&nbsp;求2的3次方，结果为：8np.dot([1,2],[3,4])#&nbsp;将向量[1,2]与[3,4]求点积，结果为：11np.sqrt(4)#&nbsp;将4开平方，结果为：2.0np.sum([1,2,3,4])#&nbsp;求和，结果为：10np.mean([1,2,3,4])#&nbsp;求平均值，结果为：2.5np.std([1,2,3,4])#&nbsp;求标准差，结果为：1.1180339887498949 除此之外，Numpy所包含的基本计算功能还有很多，例如将array切分、拼接、倒序等。 02 线性代数相关 我们在前面介绍了array类型及其基本操作方法，了解到使用array类型可以表示向量、矩阵和多维张量。线性代数计算在科学计算领域非常重要，在机器学习和数据挖掘领域，线性代数相关函数的使用也是非常频繁的。下面，我们介绍一下Numpy为我们提供的线性代数操作。 5. Numpy提供的线性代数操作 import&nbsp;numpy&nbsp;as&nbsp;npvector_a&nbsp;=&nbsp;np.array([1,2,3])vector_b&nbsp;=&nbsp;np.array([2,3,4])#&nbsp;定义两个向量vector_a与vector_bnp.dot(vector_a,vector_b)#&nbsp;将两个向量相乘，在这里也就是点乘，结果为20vector_a.dot(vector_b)#&nbsp;将vector_a与vector_b相乘，结果为20np.dot(vector_a,vector_b.T)&#39;&#39;&#39;将一个行向量与一个列向量叉乘的结果相当于将两个行向量求点积，在这里我们测试了dot()方法。其中array类型的T()方法表示转置。测试结果表明：dot()方法对于两个向量默认求其点积。对于符合叉乘格式的矩阵，自动进行叉乘。我们看一下下面这个例子：&#39;&#39;&#39;matrix_a&nbsp;=&nbsp;np.array([[1,2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])#&nbsp;定义一个2行2列的方阵matrix_b&nbsp;=&nbsp;np.dot(matrix_a,matrix_a.T)#&nbsp;这里将该方阵与其转置叉乘，将结果赋予matrix_b变量matrix_b&#39;&#39;&#39;结果为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])&#39;&#39;&#39;np.linalg.norm([1,2])#&nbsp;求一个向量的范数的值，结果为2.2360679774997898#&nbsp;如果norm()方法没有指定第二个参数，则默认为求2范数。np.linalg.norm([1,-2],1)#&nbsp;指定第二个参数值为1，即求1范数，我们在前面介绍过，1范数的结果即为向量中各元素绝对值之和，结果为3.0np.linalg.norm([1,2,3,4],np.inf)#&nbsp;求向量的无穷范数，其中np.inf表示正无穷，也就是向量中元素值最大的那个，其结果为4.0np.linalg.norm([1,2,3,4],-np.inf)#&nbsp;同理，求负无穷范数的结果为1，也就是向量中元素的最小值np.linalg.norm(matrix_b)#&nbsp;除了向量可以求范数，矩阵也可以有类似的运算，即为F范数，结果为29.866369046136157np.linalg.det(matrix_a)#&nbsp;求矩阵matrix_a的行列式，结果为-2.0000000000000004np.trace(matrix_a)#&nbsp;求矩阵matrix_a的迹，结果为5np.linalg.matrix_rank(matrix_a)#&nbsp;求矩阵的秩，结果为2vector_a&nbsp;*&nbsp;vector_b#&nbsp;使用*符号将两个向量相乘，是将两个向量中的元素分别相乘，也就是前面我们所讲到的哈达马乘积，结果为array([&nbsp;2,&nbsp;&nbsp;6,&nbsp;12])vector_a&nbsp;**&nbsp;vector_b#&nbsp;使用二元运算符**对两个向量进行操作，结果为array([&nbsp;1,&nbsp;&nbsp;8,&nbsp;81],&nbsp;dtype=int32)#&nbsp;表示将向量vector_a中元素对应vector_b中的元素值求幂运算。例如最终结果[1,8,81]可以表示为：#&nbsp;[1*1,2*2*2,3*3*3*3]np.linalg.pinv(matrix_a)&#39;&#39;&#39;求矩阵的逆矩阵，方法pinv()求的是伪逆矩阵，结果为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])不使用伪逆矩阵的算法，直接使用逆矩阵的方法是inv()，即np.linalg.inv(matrix_a)结果相同，也为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])&#39;&#39;&#39;as&nbsp;npvector_a&nbsp;=&nbsp;np.array([1,2,3])vector_b&nbsp;=&nbsp;np.array([2,3,4])#&nbsp;定义两个向量vector_a与vector_bnp.dot(vector_a,vector_b)#&nbsp;将两个向量相乘，在这里也就是点乘，结果为20vector_a.dot(vector_b)#&nbsp;将vector_a与vector_b相乘，结果为20np.dot(vector_a,vector_b.T)&#39;&#39;&#39;将一个行向量与一个列向量叉乘的结果相当于将两个行向量求点积，在这里我们测试了dot()方法。其中array类型的T()方法表示转置。测试结果表明：dot()方法对于两个向量默认求其点积。对于符合叉乘格式的矩阵，自动进行叉乘。我们看一下下面这个例子：&#39;&#39;&#39;matrix_a&nbsp;=&nbsp;np.array([[1,2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])#&nbsp;定义一个2行2列的方阵matrix_b&nbsp;=&nbsp;np.dot(matrix_a,matrix_a.T)#&nbsp;这里将该方阵与其转置叉乘，将结果赋予matrix_b变量matrix_b&#39;&#39;&#39;结果为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])&#39;&#39;&#39;np.linalg.norm([1,2])#&nbsp;求一个向量的范数的值，结果为2.2360679774997898#&nbsp;如果norm()方法没有指定第二个参数，则默认为求2范数。np.linalg.norm([1,-2],1)#&nbsp;指定第二个参数值为1，即求1范数，我们在前面介绍过，1范数的结果即为向量中各元素绝对值之和，结果为3.0np.linalg.norm([1,2,3,4],np.inf)#&nbsp;求向量的无穷范数，其中np.inf表示正无穷，也就是向量中元素值最大的那个，其结果为4.0np.linalg.norm([1,2,3,4],-np.inf)#&nbsp;同理，求负无穷范数的结果为1，也就是向量中元素的最小值np.linalg.norm(matrix_b)#&nbsp;除了向量可以求范数，矩阵也可以有类似的运算，即为F范数，结果为29.866369046136157np.linalg.det(matrix_a)#&nbsp;求矩阵matrix_a的行列式，结果为-2.0000000000000004np.trace(matrix_a)#&nbsp;求矩阵matrix_a的迹，结果为5np.linalg.matrix_rank(matrix_a)#&nbsp;求矩阵的秩，结果为2vector_a&nbsp;*&nbsp;vector_b#&nbsp;使用*符号将两个向量相乘，是将两个向量中的元素分别相乘，也就是前面我们所讲到的哈达马乘积，结果为array([&nbsp;2,&nbsp;&nbsp;6,&nbsp;12])vector_a&nbsp;**&nbsp;vector_b#&nbsp;使用二元运算符**对两个向量进行操作，结果为array([&nbsp;1,&nbsp;&nbsp;8,&nbsp;81],&nbsp;dtype=int32)#&nbsp;表示将向量vector_a中元素对应vector_b中的元素值求幂运算。例如最终结果[1,8,81]可以表示为：#&nbsp;[1*1,2*2*2,3*3*3*3]np.linalg.pinv(matrix_a)&#39;&#39;&#39;求矩阵的逆矩阵，方法pinv()求的是伪逆矩阵，结果为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])不使用伪逆矩阵的算法，直接使用逆矩阵的方法是inv()，即np.linalg.inv(matrix_a)结果相同，也为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])&#39;&#39;&#39; 03 矩阵的高级函数 我们在前面学习了Numpy的基本数据类型array，同时了解了一些基本的数学运算方法。其实除了前面我们所提到的对矩阵求逆、求秩、求转置等基本运算之外，Numpy还为我们提供了矩阵的分解等更高级的函数。 矩阵分解(decomposition, factorization)是将矩阵拆解为若干个矩阵的相乘的过程。在数值分析，常常被用来实现一些矩阵运算的快速算法，在机器学习领域有非常重要的作用。 例如我们在前面介绍过线性降维的PCA算法，其中就涉及矩阵分解的步骤。今日头条、亚马逊网上商城这类互联网产品，总会根据我们的个人喜好给我们推送一些它认为我们会感兴趣的资讯或商品，这类用于推送消息的系统称为推荐系统(Recommendation System)。 在推荐系统的实现过程中，就用到了矩阵分解算法。例如主流的开源大数据计算引擎Spark在ml机器学习库中通过ALS算法实现了推荐系统，也有的推荐系统采用SVD算法来实现整套系统中的矩阵分解过程。 在Numpy中，为我们提供了基于SVD算法的矩阵分解，SVD算法即为奇异值分解法，相对于矩阵的特征值分解法，它可以对非方阵形式的矩阵进行分解，将一个矩阵A分解为如下形式： A = U∑VT 式中，A代表需要被分解的矩阵，设其维度是m×n。U矩阵是被分解为的三个矩阵之一，它是一个m×m的方阵，构成这个矩阵的向量是正交的，被称为左奇异向量；∑是一个m×n的向量，它的特点是除了对角线中的元素外，其余元素都为0。V是一个n×n的方阵，它的转置也是一个方阵，与U矩阵类似，构成这个矩阵的向量也是正交的，被称为右奇异向量。整个奇异值分解算法矩阵的形式如图4-1所示，具体算法实现在此不再赘述。 ▲图4-1 SVD算法的矩阵形式 我们使用Numpy演示一下SVD算法的使用。 6. SVD算法演示 import&nbsp;numpy&nbsp;as&nbsp;npmatrix&nbsp;=&nbsp;np.array([&nbsp;&nbsp;&nbsp;&nbsp;[1,2],&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])another_matrix&nbsp;=&nbsp;np.dot(matrix,matrix.T)#&nbsp;生成一个矩阵&nbsp;another_matrixprint(another_matrix)&#39;&#39;&#39;该矩阵为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])&#39;&#39;&#39;U,s,V&nbsp;=&nbsp;np.linalg.svd(another_matrix,2)#&nbsp;使用奇异值分解法将该矩阵进行分解，分解得到三个子矩阵U,s,V#&nbsp;在s矩阵的基础上，生成S矩阵为：S&nbsp;=&nbsp;np.array([[s[0],0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,s[1]]])#&nbsp;我们在下面看一下生成的几个矩阵的样子print(U)&#39;&#39;&#39;[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]&#39;&#39;&#39;print(s)&#39;&#39;&#39;[&nbsp;29.86606875&nbsp;&nbsp;&nbsp;0.13393125]&#39;&#39;&#39;print(V)&#39;&#39;&#39;[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]&#39;&#39;&#39;#&nbsp;利用生成的U,S,V三个矩阵，我们可以重建回原来的矩阵another_matrixnp.dot(U,np.dot(S,V))#&nbsp;输出结果为:&#39;&#39;&#39;array([[&nbsp;&nbsp;5.,&nbsp;&nbsp;11.],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;11.,&nbsp;&nbsp;25.]])&#39;&#39;&#39;as&nbsp;npmatrix&nbsp;=&nbsp;np.array([&nbsp;&nbsp;&nbsp;&nbsp;[1,2],&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])another_matrix&nbsp;=&nbsp;np.dot(matrix,matrix.T)#&nbsp;生成一个矩阵&nbsp;another_matrixprint(another_matrix)&#39;&#39;&#39;该矩阵为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])&#39;&#39;&#39;U,s,V&nbsp;=&nbsp;np.linalg.svd(another_matrix,2)#&nbsp;使用奇异值分解法将该矩阵进行分解，分解得到三个子矩阵U,s,V#&nbsp;在s矩阵的基础上，生成S矩阵为：S&nbsp;=&nbsp;np.array([[s[0],0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,s[1]]])#&nbsp;我们在下面看一下生成的几个矩阵的样子print(U)&#39;&#39;&#39;[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]&#39;&#39;&#39;print(s)&#39;&#39;&#39;[&nbsp;29.86606875&nbsp;&nbsp;&nbsp;0.13393125]&#39;&#39;&#39;print(V)&#39;&#39;&#39;[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]&#39;&#39;&#39;#&nbsp;利用生成的U,S,V三个矩阵，我们可以重建回原来的矩阵another_matrixnp.dot(U,np.dot(S,V))#&nbsp;输出结果为:&#39;&#39;&#39;array([[&nbsp;&nbsp;5.,&nbsp;&nbsp;11.],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;11.,&nbsp;&nbsp;25.]])&#39;&#39;&#39; 在上面的代码片段中，s向量表示的是分解后的∑矩阵中对角线上的元素，所以我们在这里面引入了一个S矩阵，将s向量中的元素放置在这个矩阵中，用以验证分解后的矩阵重建回原先的矩阵A的过程。 仔细的读者可能会注意到，为什么这里使用SVD算法生成的矩阵U与VT是相同的。大家可能会注意到在上面的代码片段中，为何多了一个生成矩阵another_matrix的过程。这是因为一个矩阵与其转置相乘之后的矩阵是对称矩阵（矩阵中的元素沿着对角线对称），将对称矩阵进行分解后的结果可以表示为： A = V∑VT 通过观察上式，我们不难发现U与V矩阵是相同的，因为这个例子中，U与V矩阵本身也是对称矩阵，不论它的转置与否形式都是一样的。 我们在第2章介绍过用于线性降维的PCA算法，该算法中有一个步骤是将协方差矩阵分解然后重建，下面我们演示一下使用Numpy的SVD算法来实现PCA算法的例子： 7. 基于SVD实现PCA算法 import&nbsp;numpy&nbsp;as&nbsp;np#&nbsp;零均值化，即中心化，是数据的预处理方法def&nbsp;zero_centered(data):&nbsp;&nbsp;&nbsp;&nbsp;matrix_mean&nbsp;=&nbsp;np.mean(data,&nbsp;axis=0)&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data&nbsp;-&nbsp;matrix_meandef&nbsp;pca_eig(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;#&nbsp;也可以用&nbsp;np.cov()&nbsp;方法&nbsp;&nbsp;&nbsp;&nbsp;eig_values,&nbsp;eig_vectors&nbsp;=&nbsp;np.linalg.eig(np.mat(cov_mat))&nbsp;&nbsp;#&nbsp;求特征值和特征向量，特征向量是列向量&nbsp;&nbsp;&nbsp;&nbsp;value_indices&nbsp;=&nbsp;np.argsort(eig_values)&nbsp;&nbsp;#&nbsp;将特征值从小到大排序&nbsp;&nbsp;&nbsp;&nbsp;n_vectors&nbsp;=&nbsp;eig_vectors[:,&nbsp;value_indices[-1:-(n&nbsp;+&nbsp;1):-1]]&nbsp;&nbsp;#&nbsp;最大的n个特征值对应的特征向量&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new_data&nbsp;*&nbsp;n_vectors&nbsp;&nbsp;#&nbsp;返回低维特征空间的数据def&nbsp;pca_svd(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;&nbsp;&nbsp;U,&nbsp;s,&nbsp;V&nbsp;=&nbsp;np.linalg.svd(cov_mat)&nbsp;&nbsp;#&nbsp;将协方差矩阵奇异值分解&nbsp;&nbsp;&nbsp;&nbsp;pc&nbsp;=&nbsp;np.dot(new_data,&nbsp;U)&nbsp;&nbsp;#&nbsp;返回矩阵的第一个列向量即是降维后的结果&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;pc[:,&nbsp;0]def&nbsp;unit_test():&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;np.array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[2.5,&nbsp;2.4],&nbsp;[0.5,&nbsp;0.7],&nbsp;[2.2,&nbsp;2.9],&nbsp;[1.9,&nbsp;2.2],&nbsp;[3.1,&nbsp;3.0],&nbsp;[2.3,&nbsp;2.7],&nbsp;[2,&nbsp;1.6],&nbsp;[1,&nbsp;1.1],&nbsp;[1.5,&nbsp;1.6],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1.1,&nbsp;0.9]])&nbsp;&nbsp;&nbsp;&nbsp;result_eig&nbsp;=&nbsp;pca_eig(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用常规的特征值分解法，将2维数据降到1维&nbsp;&nbsp;&nbsp;&nbsp;print(result_eig)&nbsp;&nbsp;&nbsp;&nbsp;result_svd&nbsp;=&nbsp;pca_svd(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用奇异值分解法将协方差矩阵分解，得到降维结果&nbsp;&nbsp;&nbsp;&nbsp;print(result_svd)if&nbsp;__name__&nbsp;==&nbsp;&#39;__main__&#39;:&nbsp;&nbsp;&nbsp;&nbsp;unit_test()as&nbsp;np#&nbsp;零均值化，即中心化，是数据的预处理方法def&nbsp;zero_centered(data):&nbsp;&nbsp;&nbsp;&nbsp;matrix_mean&nbsp;=&nbsp;np.mean(data,&nbsp;axis=0)&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data&nbsp;-&nbsp;matrix_meandef&nbsp;pca_eig(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;#&nbsp;也可以用&nbsp;np.cov()&nbsp;方法&nbsp;&nbsp;&nbsp;&nbsp;eig_values,&nbsp;eig_vectors&nbsp;=&nbsp;np.linalg.eig(np.mat(cov_mat))&nbsp;&nbsp;#&nbsp;求特征值和特征向量，特征向量是列向量&nbsp;&nbsp;&nbsp;&nbsp;value_indices&nbsp;=&nbsp;np.argsort(eig_values)&nbsp;&nbsp;#&nbsp;将特征值从小到大排序&nbsp;&nbsp;&nbsp;&nbsp;n_vectors&nbsp;=&nbsp;eig_vectors[:,&nbsp;value_indices[-1:-(n&nbsp;+&nbsp;1):-1]]&nbsp;&nbsp;#&nbsp;最大的n个特征值对应的特征向量&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new_data&nbsp;*&nbsp;n_vectors&nbsp;&nbsp;#&nbsp;返回低维特征空间的数据def&nbsp;pca_svd(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;&nbsp;&nbsp;U,&nbsp;s,&nbsp;V&nbsp;=&nbsp;np.linalg.svd(cov_mat)&nbsp;&nbsp;#&nbsp;将协方差矩阵奇异值分解&nbsp;&nbsp;&nbsp;&nbsp;pc&nbsp;=&nbsp;np.dot(new_data,&nbsp;U)&nbsp;&nbsp;#&nbsp;返回矩阵的第一个列向量即是降维后的结果&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;pc[:,&nbsp;0]def&nbsp;unit_test():&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;np.array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[2.5,&nbsp;2.4],&nbsp;[0.5,&nbsp;0.7],&nbsp;[2.2,&nbsp;2.9],&nbsp;[1.9,&nbsp;2.2],&nbsp;[3.1,&nbsp;3.0],&nbsp;[2.3,&nbsp;2.7],&nbsp;[2,&nbsp;1.6],&nbsp;[1,&nbsp;1.1],&nbsp;[1.5,&nbsp;1.6],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1.1,&nbsp;0.9]])&nbsp;&nbsp;&nbsp;&nbsp;result_eig&nbsp;=&nbsp;pca_eig(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用常规的特征值分解法，将2维数据降到1维&nbsp;&nbsp;&nbsp;&nbsp;print(result_eig)&nbsp;&nbsp;&nbsp;&nbsp;result_svd&nbsp;=&nbsp;pca_svd(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用奇异值分解法将协方差矩阵分解，得到降维结果&nbsp;&nbsp;&nbsp;&nbsp;print(result_svd)if&nbsp;__name__&nbsp;==&nbsp;&#39;__main__&#39;:&nbsp;&nbsp;&nbsp;&nbsp;unit_test() 经过降维的数据为： [-0.82797019&nbsp;&nbsp;1.77758033&nbsp;-0.99219749&nbsp;-0.27421042&nbsp;-1.67580142&nbsp;-0.9129491&nbsp;&nbsp;0.09910944&nbsp;&nbsp;1.14457216&nbsp;&nbsp;0.43804614&nbsp;&nbsp;1.22382056]1.77758033&nbsp;-0.99219749&nbsp;-0.27421042&nbsp;-1.67580142&nbsp;-0.9129491&nbsp;&nbsp;0.09910944&nbsp;&nbsp;1.14457216&nbsp;&nbsp;0.43804614&nbsp;&nbsp;1.22382056] 我们可以看到，数据已经从2维的变为1维的了，这两个PCA算法的计算结果是相同的。其中pca_eig() 函数是使用常规的特征值分解方法来求解的，读者可以参照前面讲述的PCA算法过程来理解这段代码。pca_svd() 函数使用奇异值分解法来求解的。这段代码虽然相对精简，但是背后是经过复杂的数学推导的，下面简要阐述一下PCA算法中奇异值分解的步骤。 1) PCA算法中得到样本的协方差矩阵是经过零均值化处理的，将其去掉常数部分，则也可表示为： C = XTX 其中，X是经过中心化处理后的样本矩阵X. 前面我们介绍过，一个矩阵与其转置矩阵相乘的结果是一个对称矩阵。观察到协方差矩阵C便是一个对称矩阵，那么将其进行奇异值分解后则可以表示为： C = V∑VT 2) 将经过中心化的样本矩阵X进行奇异值分解，可以得到： X = U∑VT 因此，我们可以得到： XTX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = (U∑VT)T(U∑VT) =&nbsp;V∑TUTU∑VT&nbsp; &nbsp; &nbsp;&nbsp; =&nbsp;V∑2VT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 奇异矩阵V中的列对应着PCA算法主成分中的主方向，因此可以得到主成分为： XV&nbsp;= U∑VTV =&nbsp;U∑ 关于更详细的数学推倒过程，读者可参考该网址： https://stats.stackexchange.com/questions/134282/relationship-between-svd-and-pca-how-to-use-svd-to-perform-pca Numpy除了为我们提供常规的数学计算函数和矩阵相关操作之外，还提供了很多功能丰富的模块，随机数模块就是其中一部分。利用随机数模块可以生成随机数矩阵，比Python自带的随机数模块功能要强大，我们看一下下面这个例子。 8. Numpy的随机数功能演示 import&nbsp;numpy&nbsp;as&nbsp;np#&nbsp;置随机数种子：np.random.seed()#&nbsp;从[1,3)中生成一个整数的随机数，连续生成10个np.random.randint(1,3,10)#&nbsp;返回：array([2,&nbsp;2,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;2,&nbsp;1,&nbsp;2,&nbsp;2])#&nbsp;若要连续产生[1,3)之间的浮点数，可以使用下述方法：2*np.random.random(10)&nbsp;+&nbsp;1&#39;&#39;&#39;返回：array([&nbsp;1.25705585,&nbsp;&nbsp;2.38059578,&nbsp;&nbsp;1.73232769,&nbsp;&nbsp;2.12303283,&nbsp;&nbsp;2.33946996,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.28020734,&nbsp;&nbsp;2.15724069,&nbsp;&nbsp;1.32845829,&nbsp;&nbsp;2.91361293,&nbsp;&nbsp;1.78637408])&#39;&#39;&#39;np.random.uniform(1,3,10)&#39;&#39;&#39;返回：array([&nbsp;1.37993226,&nbsp;&nbsp;1.38412227,&nbsp;&nbsp;1.18063785,&nbsp;&nbsp;1.75985962,&nbsp;&nbsp;1.42775752,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.62100074,&nbsp;&nbsp;1.71768721,&nbsp;&nbsp;1.50131522,&nbsp;&nbsp;2.20297121,&nbsp;&nbsp;1.08585819])&#39;&#39;&#39;#&nbsp;生成一个满足正太分布(高斯分布)的矩阵，其维度是4*4np.random.normal(size=(4,4))&#39;&#39;&#39;返回：array([[-1.81525915,&nbsp;-2.02236963,&nbsp;&nbsp;0.90969106,&nbsp;&nbsp;0.25448426],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1.04177298,&nbsp;-0.35408201,&nbsp;&nbsp;1.67850233,&nbsp;-0.70361323],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.30710761,&nbsp;&nbsp;0.57461312,&nbsp;-0.37867596,&nbsp;-0.74010685],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.94046747,&nbsp;&nbsp;2.37124816,&nbsp;-0.78503777,&nbsp;-0.33485225]])&#39;&#39;&#39;#&nbsp;随机产生10个，n=5,p=0.5的二项分布数据:np.random.binomial(n=5,p=0.5,size=10)#&nbsp;返回：array([2,&nbsp;0,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;4,&nbsp;2])data&nbsp;=&nbsp;np.arange(10)&nbsp;#&nbsp;产生一个0到9的序列np.random.choice(data,5)&nbsp;#&nbsp;从data数据中随机采集5个样本，采集过程是有放回的#&nbsp;返回：array([0,&nbsp;0,&nbsp;1,&nbsp;6,&nbsp;2])np.random.choice(data,5,replace=False)&nbsp;#从data数据中随机采集5个样本，采集过程是没有放回的#&nbsp;返回：array([0,&nbsp;4,&nbsp;3,&nbsp;9,&nbsp;7])np.random.permutation(data)&nbsp;#&nbsp;对data进行乱序，返回乱序结果#&nbsp;返回：array([2,&nbsp;8,&nbsp;6,&nbsp;4,&nbsp;9,&nbsp;1,&nbsp;3,&nbsp;5,&nbsp;7,&nbsp;0])np.random.shuffle(data)&nbsp;#&nbsp;对data进行乱序，并替换为新的dataprint(data)#&nbsp;输出：[1&nbsp;2&nbsp;8&nbsp;4&nbsp;3&nbsp;6&nbsp;9&nbsp;0&nbsp;5&nbsp;7]as&nbsp;np#&nbsp;置随机数种子：np.random.seed()#&nbsp;从[1,3)中生成一个整数的随机数，连续生成10个np.random.randint(1,3,10)#&nbsp;返回：array([2,&nbsp;2,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;2,&nbsp;1,&nbsp;2,&nbsp;2])#&nbsp;若要连续产生[1,3)之间的浮点数，可以使用下述方法：2*np.random.random(10)&nbsp;+&nbsp;1&#39;&#39;&#39;返回：array([&nbsp;1.25705585,&nbsp;&nbsp;2.38059578,&nbsp;&nbsp;1.73232769,&nbsp;&nbsp;2.12303283,&nbsp;&nbsp;2.33946996,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.28020734,&nbsp;&nbsp;2.15724069,&nbsp;&nbsp;1.32845829,&nbsp;&nbsp;2.91361293,&nbsp;&nbsp;1.78637408])&#39;&#39;&#39;np.random.uniform(1,3,10)&#39;&#39;&#39;返回：array([&nbsp;1.37993226,&nbsp;&nbsp;1.38412227,&nbsp;&nbsp;1.18063785,&nbsp;&nbsp;1.75985962,&nbsp;&nbsp;1.42775752,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.62100074,&nbsp;&nbsp;1.71768721,&nbsp;&nbsp;1.50131522,&nbsp;&nbsp;2.20297121,&nbsp;&nbsp;1.08585819])&#39;&#39;&#39;#&nbsp;生成一个满足正太分布(高斯分布)的矩阵，其维度是4*4np.random.normal(size=(4,4))&#39;&#39;&#39;返回：array([[-1.81525915,&nbsp;-2.02236963,&nbsp;&nbsp;0.90969106,&nbsp;&nbsp;0.25448426],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1.04177298,&nbsp;-0.35408201,&nbsp;&nbsp;1.67850233,&nbsp;-0.70361323],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.30710761,&nbsp;&nbsp;0.57461312,&nbsp;-0.37867596,&nbsp;-0.74010685],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.94046747,&nbsp;&nbsp;2.37124816,&nbsp;-0.78503777,&nbsp;-0.33485225]])&#39;&#39;&#39;#&nbsp;随机产生10个，n=5,p=0.5的二项分布数据:np.random.binomial(n=5,p=0.5,size=10)#&nbsp;返回：array([2,&nbsp;0,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;4,&nbsp;2])data&nbsp;=&nbsp;np.arange(10)&nbsp;#&nbsp;产生一个0到9的序列np.random.choice(data,5)&nbsp;#&nbsp;从data数据中随机采集5个样本，采集过程是有放回的#&nbsp;返回：array([0,&nbsp;0,&nbsp;1,&nbsp;6,&nbsp;2])np.random.choice(data,5,replace=False)&nbsp;#从data数据中随机采集5个样本，采集过程是没有放回的#&nbsp;返回：array([0,&nbsp;4,&nbsp;3,&nbsp;9,&nbsp;7])np.random.permutation(data)&nbsp;#&nbsp;对data进行乱序，返回乱序结果#&nbsp;返回：array([2,&nbsp;8,&nbsp;6,&nbsp;4,&nbsp;9,&nbsp;1,&nbsp;3,&nbsp;5,&nbsp;7,&nbsp;0])np.random.shuffle(data)&nbsp;#&nbsp;对data进行乱序，并替换为新的dataprint(data)#&nbsp;输出：[1&nbsp;2&nbsp;8&nbsp;4&nbsp;3&nbsp;6&nbsp;9&nbsp;0&nbsp;5&nbsp;7] 关于作者：王天庆，长期从事分布式系统、数据科学与工程、人工智能等方面的研究与开发，在人脸识别方面有丰富的实践经验。现就职某世界100强企业的数据实验室，从事数据科学相关技术领域的预研工作。 本文摘编自《Python人脸识别：从入门到工程实践》，经出版方授权发布。 延伸阅读《Python人脸识别》 点击上图了解及购买 转载请联系微信：DoctorData 推荐语：华为资深AI工程师撰写，全面讲解人脸识别各项基础技术、原理和算法，从零实现工程级人脸识别引擎。 据统计，99%的大咖都完成了这个神操作 ▼ 更多精彩 在公众号后台对话框输入以下关键词 查看更多优质内容！ PPT&nbsp;|&nbsp;报告&nbsp;|&nbsp;读书&nbsp;|&nbsp;书单&nbsp;|&nbsp;干货&nbsp; 大数据&nbsp;|&nbsp;揭秘&nbsp;|&nbsp;Python&nbsp;|&nbsp;可视化 AI&nbsp;|&nbsp;人工智能&nbsp;|&nbsp;5G&nbsp;|&nbsp;区块链 机器学习&nbsp;|&nbsp;深度学习&nbsp;|&nbsp;神经网络 1024&nbsp;|&nbsp;段子&nbsp;|&nbsp;数学&nbsp;|&nbsp;高考 猜你想看 真正零基础Python入门：手把手教你从变量和赋值语句学起 Python实操：手把手教你用Matplotlib把数据画出来 有关华为、5G、芯片和操作系统，这些书你读过几本？ 什么是数据？数据科学家需要掌握哪些技能？终于有人讲明白了 Q:&nbsp;你在用哪些工具做数学运算？ 欢迎留言与大家分享 觉得不错，请把这篇文章分享给你的朋友 转载 / 投稿请联系：baiyu@hzbook.com 更多精彩，请在后台点击“历史文章”查看 点击阅读原文，了解更多" />
<link rel="canonical" href="https://uzzz.org/2019/06/05/788647.html" />
<meta property="og:url" content="https://uzzz.org/2019/06/05/788647.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-05T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"导读：本文介绍一下在Python科学计算中非常重要的一个库——Numpy。 作者：王天庆 如需转载请联系大数据（ID：hzdashuju） Numpy是Numerical Python extensions 的缩写，字面意思是Python数值计算扩展。Numpy是Python中众多机器学习库的依赖，这些库通过Numpy实现基本的矩阵计算，Python的OpenCV库自然也不例外。 Numpy支持高阶、大量计算的矩阵、向量计算，与此同时提供了较为丰富的函数。Numpy采用友好的BSD许可协议开放源代码。它是一个跨平台的科学计算库，提供了与Matlab相似的功能和操作方法。 虽然科学计算领域一直是Matlab的天下，但是Numpy基于更加现代化的编程语言——Python。而且Python凭借着开源、免费、灵活性、简单易学、工程特性好等特点风靡技术圈，已经成为机器学习、数据分析等领域的主流编程语言。 虽然Matlab提供的包非常多，但是Python因其简单灵活、扩展性强等特点，也诞生了一系列优秀的库。例如Scipy具有大多数Matlab所具备的功能，Matplotlib能够简便地进行数据可视化。虽然当前Matlab的地位仍然难以撼动，但是，随着时间的推移，Python在科学计算上的生态系统也会越来越丰富。 安装Numpy的方法也很简单，使用Python的包管理工具pip或者anaconda便可以实现。例如在shell中输入下列命令行便可以通过pip安装Numpy： pip&nbsp;install&nbsp;numpy 另外，Numpy是OpenCV的一个依赖库，所以，我们使用pip工具安装好OpenCV库之后，Numpy一般也都已经安装好了。 01 array类型 Numpy的array类型是该库的一个基本数据类型，这个数据类型从字面上看是数组的意思，也就意味着它最关键的属性是元素与维度，我们可以这个数据类型来实现多维数组。 因此，通过这个数据类型，我们可以使用一维数组用来表示向量，二维数组来表示矩阵，以此类推用以表示更高维度的张量。 我们通过下面的例子来简单体会一下在Numpy中array类型的使用。 1. Numpy中array类型的基本使用 import&nbsp;numpy&nbsp;as&nbsp;np#&nbsp;引入numpy库，并将其别名为nparray&nbsp;=&nbsp;np.array([1,2,3,4])#&nbsp;通过np.array()方法创建一个名为array的array类型，参数是一个listarray#&nbsp;在shell中输入，返回的结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4])array.max()#&nbsp;获取该array类型中最大的元素值，结果为:#&nbsp;4array.mean()#&nbsp;求该array中元素的平均值，结果为:#&nbsp;2.5array.min()#&nbsp;获取该array中元素的最小值：#&nbsp;1array&nbsp;*&nbsp;2#&nbsp;直接将该array乘以2，Python将该运算符重载，将每一个元素都乘以了2，其输出结果为：#&nbsp;array([2,&nbsp;4,&nbsp;6,&nbsp;8])array&nbsp;+&nbsp;1#&nbsp;将每一个元素都加上1，输出结果为：#&nbsp;array([2,&nbsp;3,&nbsp;4,&nbsp;5])array&nbsp;/&nbsp;2&nbsp;#&nbsp;将每一个元素都除以2，得到浮点数表示的结果为：#&nbsp;array([&nbsp;0.5,&nbsp;&nbsp;1.&nbsp;,&nbsp;&nbsp;1.5,&nbsp;&nbsp;2.&nbsp;])array&nbsp;%&nbsp;2#&nbsp;Numpy库除了可以对array实现除法运算，还可以实现取模运算，结果为：#&nbsp;array([1,&nbsp;0,&nbsp;1,&nbsp;0],&nbsp;dtype=int32)array.argmax()#&nbsp;获取该组数据中元素值最大的一个数据的索引，下标从0开始，其结果为：#&nbsp;3as&nbsp;np#&nbsp;引入numpy库，并将其别名为nparray&nbsp;=&nbsp;np.array([1,2,3,4])#&nbsp;通过np.array()方法创建一个名为array的array类型，参数是一个listarray#&nbsp;在shell中输入，返回的结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4])array.max()#&nbsp;获取该array类型中最大的元素值，结果为:#&nbsp;4array.mean()#&nbsp;求该array中元素的平均值，结果为:#&nbsp;2.5array.min()#&nbsp;获取该array中元素的最小值：#&nbsp;1array&nbsp;*&nbsp;2#&nbsp;直接将该array乘以2，Python将该运算符重载，将每一个元素都乘以了2，其输出结果为：#&nbsp;array([2,&nbsp;4,&nbsp;6,&nbsp;8])array&nbsp;+&nbsp;1#&nbsp;将每一个元素都加上1，输出结果为：#&nbsp;array([2,&nbsp;3,&nbsp;4,&nbsp;5])array&nbsp;/&nbsp;2&nbsp;#&nbsp;将每一个元素都除以2，得到浮点数表示的结果为：#&nbsp;array([&nbsp;0.5,&nbsp;&nbsp;1.&nbsp;,&nbsp;&nbsp;1.5,&nbsp;&nbsp;2.&nbsp;])array&nbsp;%&nbsp;2#&nbsp;Numpy库除了可以对array实现除法运算，还可以实现取模运算，结果为：#&nbsp;array([1,&nbsp;0,&nbsp;1,&nbsp;0],&nbsp;dtype=int32)array.argmax()#&nbsp;获取该组数据中元素值最大的一个数据的索引，下标从0开始，其结果为：#&nbsp;3 通过上面的代码片段，我们可以了解Numpy中array类型的基本使用方法。我们可以看到，array其实是一个类，通过传入一个list参数来实例化为一个对象，也就实现了对数据的封装。这个对象中包含对各个元素进行计算的基本方法，例如求平均值、求最大值等。除此之外，我们再看一下关于更高维度数据的处理。 2. Numpy对更高维度数据的处理 import&nbsp;numpy&nbsp;as&nbsp;nparray&nbsp;=&nbsp;np.array([[1,2],[3,4],[5,6]])#&nbsp;创建一个二维数组，用以表示一个3行2列的矩阵，名为arrayarray#在交互式编程界面中输入array，返回结果为：#&nbsp;array([[1,&nbsp;2],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;4],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5,&nbsp;6]])array.shape#&nbsp;查看数据的维度属性，下面的输出结果元组，代表的是3行2列#&nbsp;(3,&nbsp;2)array.size#&nbsp;查看array中的元素数量，输出结果为：#&nbsp;6array.argmax()#&nbsp;查看元素值最大的元素索引，结果为：#&nbsp;5array.flatten()#&nbsp;将shape为(3,2)的array转换为一行表示，输出结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6])#&nbsp;我们可以看到，flatten()方法是将多维数据“压平”为一维数组的过程array.reshape(2,3)#&nbsp;将array数据从shape为(3,2)的形式转换为(2,3)的形式：#&nbsp;array([[1,&nbsp;2,&nbsp;3],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,&nbsp;5,&nbsp;6]])as&nbsp;nparray&nbsp;=&nbsp;np.array([[1,2],[3,4],[5,6]])#&nbsp;创建一个二维数组，用以表示一个3行2列的矩阵，名为arrayarray#在交互式编程界面中输入array，返回结果为：#&nbsp;array([[1,&nbsp;2],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;4],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5,&nbsp;6]])array.shape#&nbsp;查看数据的维度属性，下面的输出结果元组，代表的是3行2列#&nbsp;(3,&nbsp;2)array.size#&nbsp;查看array中的元素数量，输出结果为：#&nbsp;6array.argmax()#&nbsp;查看元素值最大的元素索引，结果为：#&nbsp;5array.flatten()#&nbsp;将shape为(3,2)的array转换为一行表示，输出结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6])#&nbsp;我们可以看到，flatten()方法是将多维数据“压平”为一维数组的过程array.reshape(2,3)#&nbsp;将array数据从shape为(3,2)的形式转换为(2,3)的形式：#&nbsp;array([[1,&nbsp;2,&nbsp;3],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,&nbsp;5,&nbsp;6]]) 除此之外，Numpy还包含了创建特殊类别的array类型的方法，例如。 3. Numpy创建特殊类别的array类型 import&nbsp;numpy&nbsp;as&nbsp;nparray_zeros&nbsp;=&nbsp;np.zeros((2,3,3))#生成结果为：#&nbsp;array([[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]],##&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]]])array_ones&nbsp;=&nbsp;np.ones((2,3,3))#&nbsp;生成所有元素都为1的array，其shape是(2,3,3)array_ones.shape#&nbsp;(2,&nbsp;3,&nbsp;3)array_arange&nbsp;=&nbsp;np.arange(10)#&nbsp;生成一个array，从0递增到10，步长为1，结果为：#&nbsp;array([0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9])array_linespace&nbsp;=&nbsp;np.linspace(0,10,5)#&nbsp;生成一个array从0到10递增，步长为5，结果为：#&nbsp;array([&nbsp;&nbsp;0.&nbsp;,&nbsp;&nbsp;&nbsp;2.5,&nbsp;&nbsp;&nbsp;5.&nbsp;,&nbsp;&nbsp;&nbsp;7.5,&nbsp;&nbsp;10.&nbsp;])as&nbsp;nparray_zeros&nbsp;=&nbsp;np.zeros((2,3,3))#生成结果为：#&nbsp;array([[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]],##&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]]])array_ones&nbsp;=&nbsp;np.ones((2,3,3))#&nbsp;生成所有元素都为1的array，其shape是(2,3,3)array_ones.shape#&nbsp;(2,&nbsp;3,&nbsp;3)array_arange&nbsp;=&nbsp;np.arange(10)#&nbsp;生成一个array，从0递增到10，步长为1，结果为：#&nbsp;array([0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9])array_linespace&nbsp;=&nbsp;np.linspace(0,10,5)#&nbsp;生成一个array从0到10递增，步长为5，结果为：#&nbsp;array([&nbsp;&nbsp;0.&nbsp;,&nbsp;&nbsp;&nbsp;2.5,&nbsp;&nbsp;&nbsp;5.&nbsp;,&nbsp;&nbsp;&nbsp;7.5,&nbsp;&nbsp;10.&nbsp;]) Numpy作为Python的一款著名数值计算库，其在基础计算上的功能也是非常完备的，代码如下。 4. Numpy基础计算演示 import&nbsp;numpy&nbsp;as&nbsp;npnp.abs([1,-2,-3,4])#&nbsp;取绝对值，结果为：array([1,&nbsp;2,&nbsp;3,&nbsp;4])np.sin(np.pi&nbsp;/&nbsp;2)#&nbsp;求余弦值，结果为：1.0np.arctan(1)#&nbsp;求反正切值，结果为：0.78539816339744828np.exp(2)#&nbsp;求自然常数e的2次方，结果为：7.3890560989306504np.power(2,3)#&nbsp;求2的3次方，结果为：8np.dot([1,2],[3,4])#&nbsp;将向量[1,2]与[3,4]求点积，结果为：11np.sqrt(4)#&nbsp;将4开平方，结果为：2.0np.sum([1,2,3,4])#&nbsp;求和，结果为：10np.mean([1,2,3,4])#&nbsp;求平均值，结果为：2.5np.std([1,2,3,4])#&nbsp;求标准差，结果为：1.1180339887498949as&nbsp;npnp.abs([1,-2,-3,4])#&nbsp;取绝对值，结果为：array([1,&nbsp;2,&nbsp;3,&nbsp;4])np.sin(np.pi&nbsp;/&nbsp;2)#&nbsp;求余弦值，结果为：1.0np.arctan(1)#&nbsp;求反正切值，结果为：0.78539816339744828np.exp(2)#&nbsp;求自然常数e的2次方，结果为：7.3890560989306504np.power(2,3)#&nbsp;求2的3次方，结果为：8np.dot([1,2],[3,4])#&nbsp;将向量[1,2]与[3,4]求点积，结果为：11np.sqrt(4)#&nbsp;将4开平方，结果为：2.0np.sum([1,2,3,4])#&nbsp;求和，结果为：10np.mean([1,2,3,4])#&nbsp;求平均值，结果为：2.5np.std([1,2,3,4])#&nbsp;求标准差，结果为：1.1180339887498949 除此之外，Numpy所包含的基本计算功能还有很多，例如将array切分、拼接、倒序等。 02 线性代数相关 我们在前面介绍了array类型及其基本操作方法，了解到使用array类型可以表示向量、矩阵和多维张量。线性代数计算在科学计算领域非常重要，在机器学习和数据挖掘领域，线性代数相关函数的使用也是非常频繁的。下面，我们介绍一下Numpy为我们提供的线性代数操作。 5. Numpy提供的线性代数操作 import&nbsp;numpy&nbsp;as&nbsp;npvector_a&nbsp;=&nbsp;np.array([1,2,3])vector_b&nbsp;=&nbsp;np.array([2,3,4])#&nbsp;定义两个向量vector_a与vector_bnp.dot(vector_a,vector_b)#&nbsp;将两个向量相乘，在这里也就是点乘，结果为20vector_a.dot(vector_b)#&nbsp;将vector_a与vector_b相乘，结果为20np.dot(vector_a,vector_b.T)&#39;&#39;&#39;将一个行向量与一个列向量叉乘的结果相当于将两个行向量求点积，在这里我们测试了dot()方法。其中array类型的T()方法表示转置。测试结果表明：dot()方法对于两个向量默认求其点积。对于符合叉乘格式的矩阵，自动进行叉乘。我们看一下下面这个例子：&#39;&#39;&#39;matrix_a&nbsp;=&nbsp;np.array([[1,2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])#&nbsp;定义一个2行2列的方阵matrix_b&nbsp;=&nbsp;np.dot(matrix_a,matrix_a.T)#&nbsp;这里将该方阵与其转置叉乘，将结果赋予matrix_b变量matrix_b&#39;&#39;&#39;结果为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])&#39;&#39;&#39;np.linalg.norm([1,2])#&nbsp;求一个向量的范数的值，结果为2.2360679774997898#&nbsp;如果norm()方法没有指定第二个参数，则默认为求2范数。np.linalg.norm([1,-2],1)#&nbsp;指定第二个参数值为1，即求1范数，我们在前面介绍过，1范数的结果即为向量中各元素绝对值之和，结果为3.0np.linalg.norm([1,2,3,4],np.inf)#&nbsp;求向量的无穷范数，其中np.inf表示正无穷，也就是向量中元素值最大的那个，其结果为4.0np.linalg.norm([1,2,3,4],-np.inf)#&nbsp;同理，求负无穷范数的结果为1，也就是向量中元素的最小值np.linalg.norm(matrix_b)#&nbsp;除了向量可以求范数，矩阵也可以有类似的运算，即为F范数，结果为29.866369046136157np.linalg.det(matrix_a)#&nbsp;求矩阵matrix_a的行列式，结果为-2.0000000000000004np.trace(matrix_a)#&nbsp;求矩阵matrix_a的迹，结果为5np.linalg.matrix_rank(matrix_a)#&nbsp;求矩阵的秩，结果为2vector_a&nbsp;*&nbsp;vector_b#&nbsp;使用*符号将两个向量相乘，是将两个向量中的元素分别相乘，也就是前面我们所讲到的哈达马乘积，结果为array([&nbsp;2,&nbsp;&nbsp;6,&nbsp;12])vector_a&nbsp;**&nbsp;vector_b#&nbsp;使用二元运算符**对两个向量进行操作，结果为array([&nbsp;1,&nbsp;&nbsp;8,&nbsp;81],&nbsp;dtype=int32)#&nbsp;表示将向量vector_a中元素对应vector_b中的元素值求幂运算。例如最终结果[1,8,81]可以表示为：#&nbsp;[1*1,2*2*2,3*3*3*3]np.linalg.pinv(matrix_a)&#39;&#39;&#39;求矩阵的逆矩阵，方法pinv()求的是伪逆矩阵，结果为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])不使用伪逆矩阵的算法，直接使用逆矩阵的方法是inv()，即np.linalg.inv(matrix_a)结果相同，也为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])&#39;&#39;&#39;as&nbsp;npvector_a&nbsp;=&nbsp;np.array([1,2,3])vector_b&nbsp;=&nbsp;np.array([2,3,4])#&nbsp;定义两个向量vector_a与vector_bnp.dot(vector_a,vector_b)#&nbsp;将两个向量相乘，在这里也就是点乘，结果为20vector_a.dot(vector_b)#&nbsp;将vector_a与vector_b相乘，结果为20np.dot(vector_a,vector_b.T)&#39;&#39;&#39;将一个行向量与一个列向量叉乘的结果相当于将两个行向量求点积，在这里我们测试了dot()方法。其中array类型的T()方法表示转置。测试结果表明：dot()方法对于两个向量默认求其点积。对于符合叉乘格式的矩阵，自动进行叉乘。我们看一下下面这个例子：&#39;&#39;&#39;matrix_a&nbsp;=&nbsp;np.array([[1,2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])#&nbsp;定义一个2行2列的方阵matrix_b&nbsp;=&nbsp;np.dot(matrix_a,matrix_a.T)#&nbsp;这里将该方阵与其转置叉乘，将结果赋予matrix_b变量matrix_b&#39;&#39;&#39;结果为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])&#39;&#39;&#39;np.linalg.norm([1,2])#&nbsp;求一个向量的范数的值，结果为2.2360679774997898#&nbsp;如果norm()方法没有指定第二个参数，则默认为求2范数。np.linalg.norm([1,-2],1)#&nbsp;指定第二个参数值为1，即求1范数，我们在前面介绍过，1范数的结果即为向量中各元素绝对值之和，结果为3.0np.linalg.norm([1,2,3,4],np.inf)#&nbsp;求向量的无穷范数，其中np.inf表示正无穷，也就是向量中元素值最大的那个，其结果为4.0np.linalg.norm([1,2,3,4],-np.inf)#&nbsp;同理，求负无穷范数的结果为1，也就是向量中元素的最小值np.linalg.norm(matrix_b)#&nbsp;除了向量可以求范数，矩阵也可以有类似的运算，即为F范数，结果为29.866369046136157np.linalg.det(matrix_a)#&nbsp;求矩阵matrix_a的行列式，结果为-2.0000000000000004np.trace(matrix_a)#&nbsp;求矩阵matrix_a的迹，结果为5np.linalg.matrix_rank(matrix_a)#&nbsp;求矩阵的秩，结果为2vector_a&nbsp;*&nbsp;vector_b#&nbsp;使用*符号将两个向量相乘，是将两个向量中的元素分别相乘，也就是前面我们所讲到的哈达马乘积，结果为array([&nbsp;2,&nbsp;&nbsp;6,&nbsp;12])vector_a&nbsp;**&nbsp;vector_b#&nbsp;使用二元运算符**对两个向量进行操作，结果为array([&nbsp;1,&nbsp;&nbsp;8,&nbsp;81],&nbsp;dtype=int32)#&nbsp;表示将向量vector_a中元素对应vector_b中的元素值求幂运算。例如最终结果[1,8,81]可以表示为：#&nbsp;[1*1,2*2*2,3*3*3*3]np.linalg.pinv(matrix_a)&#39;&#39;&#39;求矩阵的逆矩阵，方法pinv()求的是伪逆矩阵，结果为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])不使用伪逆矩阵的算法，直接使用逆矩阵的方法是inv()，即np.linalg.inv(matrix_a)结果相同，也为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])&#39;&#39;&#39; 03 矩阵的高级函数 我们在前面学习了Numpy的基本数据类型array，同时了解了一些基本的数学运算方法。其实除了前面我们所提到的对矩阵求逆、求秩、求转置等基本运算之外，Numpy还为我们提供了矩阵的分解等更高级的函数。 矩阵分解(decomposition, factorization)是将矩阵拆解为若干个矩阵的相乘的过程。在数值分析，常常被用来实现一些矩阵运算的快速算法，在机器学习领域有非常重要的作用。 例如我们在前面介绍过线性降维的PCA算法，其中就涉及矩阵分解的步骤。今日头条、亚马逊网上商城这类互联网产品，总会根据我们的个人喜好给我们推送一些它认为我们会感兴趣的资讯或商品，这类用于推送消息的系统称为推荐系统(Recommendation System)。 在推荐系统的实现过程中，就用到了矩阵分解算法。例如主流的开源大数据计算引擎Spark在ml机器学习库中通过ALS算法实现了推荐系统，也有的推荐系统采用SVD算法来实现整套系统中的矩阵分解过程。 在Numpy中，为我们提供了基于SVD算法的矩阵分解，SVD算法即为奇异值分解法，相对于矩阵的特征值分解法，它可以对非方阵形式的矩阵进行分解，将一个矩阵A分解为如下形式： A = U∑VT 式中，A代表需要被分解的矩阵，设其维度是m×n。U矩阵是被分解为的三个矩阵之一，它是一个m×m的方阵，构成这个矩阵的向量是正交的，被称为左奇异向量；∑是一个m×n的向量，它的特点是除了对角线中的元素外，其余元素都为0。V是一个n×n的方阵，它的转置也是一个方阵，与U矩阵类似，构成这个矩阵的向量也是正交的，被称为右奇异向量。整个奇异值分解算法矩阵的形式如图4-1所示，具体算法实现在此不再赘述。 ▲图4-1 SVD算法的矩阵形式 我们使用Numpy演示一下SVD算法的使用。 6. SVD算法演示 import&nbsp;numpy&nbsp;as&nbsp;npmatrix&nbsp;=&nbsp;np.array([&nbsp;&nbsp;&nbsp;&nbsp;[1,2],&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])another_matrix&nbsp;=&nbsp;np.dot(matrix,matrix.T)#&nbsp;生成一个矩阵&nbsp;another_matrixprint(another_matrix)&#39;&#39;&#39;该矩阵为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])&#39;&#39;&#39;U,s,V&nbsp;=&nbsp;np.linalg.svd(another_matrix,2)#&nbsp;使用奇异值分解法将该矩阵进行分解，分解得到三个子矩阵U,s,V#&nbsp;在s矩阵的基础上，生成S矩阵为：S&nbsp;=&nbsp;np.array([[s[0],0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,s[1]]])#&nbsp;我们在下面看一下生成的几个矩阵的样子print(U)&#39;&#39;&#39;[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]&#39;&#39;&#39;print(s)&#39;&#39;&#39;[&nbsp;29.86606875&nbsp;&nbsp;&nbsp;0.13393125]&#39;&#39;&#39;print(V)&#39;&#39;&#39;[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]&#39;&#39;&#39;#&nbsp;利用生成的U,S,V三个矩阵，我们可以重建回原来的矩阵another_matrixnp.dot(U,np.dot(S,V))#&nbsp;输出结果为:&#39;&#39;&#39;array([[&nbsp;&nbsp;5.,&nbsp;&nbsp;11.],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;11.,&nbsp;&nbsp;25.]])&#39;&#39;&#39;as&nbsp;npmatrix&nbsp;=&nbsp;np.array([&nbsp;&nbsp;&nbsp;&nbsp;[1,2],&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])another_matrix&nbsp;=&nbsp;np.dot(matrix,matrix.T)#&nbsp;生成一个矩阵&nbsp;another_matrixprint(another_matrix)&#39;&#39;&#39;该矩阵为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])&#39;&#39;&#39;U,s,V&nbsp;=&nbsp;np.linalg.svd(another_matrix,2)#&nbsp;使用奇异值分解法将该矩阵进行分解，分解得到三个子矩阵U,s,V#&nbsp;在s矩阵的基础上，生成S矩阵为：S&nbsp;=&nbsp;np.array([[s[0],0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,s[1]]])#&nbsp;我们在下面看一下生成的几个矩阵的样子print(U)&#39;&#39;&#39;[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]&#39;&#39;&#39;print(s)&#39;&#39;&#39;[&nbsp;29.86606875&nbsp;&nbsp;&nbsp;0.13393125]&#39;&#39;&#39;print(V)&#39;&#39;&#39;[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]&#39;&#39;&#39;#&nbsp;利用生成的U,S,V三个矩阵，我们可以重建回原来的矩阵another_matrixnp.dot(U,np.dot(S,V))#&nbsp;输出结果为:&#39;&#39;&#39;array([[&nbsp;&nbsp;5.,&nbsp;&nbsp;11.],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;11.,&nbsp;&nbsp;25.]])&#39;&#39;&#39; 在上面的代码片段中，s向量表示的是分解后的∑矩阵中对角线上的元素，所以我们在这里面引入了一个S矩阵，将s向量中的元素放置在这个矩阵中，用以验证分解后的矩阵重建回原先的矩阵A的过程。 仔细的读者可能会注意到，为什么这里使用SVD算法生成的矩阵U与VT是相同的。大家可能会注意到在上面的代码片段中，为何多了一个生成矩阵another_matrix的过程。这是因为一个矩阵与其转置相乘之后的矩阵是对称矩阵（矩阵中的元素沿着对角线对称），将对称矩阵进行分解后的结果可以表示为： A = V∑VT 通过观察上式，我们不难发现U与V矩阵是相同的，因为这个例子中，U与V矩阵本身也是对称矩阵，不论它的转置与否形式都是一样的。 我们在第2章介绍过用于线性降维的PCA算法，该算法中有一个步骤是将协方差矩阵分解然后重建，下面我们演示一下使用Numpy的SVD算法来实现PCA算法的例子： 7. 基于SVD实现PCA算法 import&nbsp;numpy&nbsp;as&nbsp;np#&nbsp;零均值化，即中心化，是数据的预处理方法def&nbsp;zero_centered(data):&nbsp;&nbsp;&nbsp;&nbsp;matrix_mean&nbsp;=&nbsp;np.mean(data,&nbsp;axis=0)&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data&nbsp;-&nbsp;matrix_meandef&nbsp;pca_eig(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;#&nbsp;也可以用&nbsp;np.cov()&nbsp;方法&nbsp;&nbsp;&nbsp;&nbsp;eig_values,&nbsp;eig_vectors&nbsp;=&nbsp;np.linalg.eig(np.mat(cov_mat))&nbsp;&nbsp;#&nbsp;求特征值和特征向量，特征向量是列向量&nbsp;&nbsp;&nbsp;&nbsp;value_indices&nbsp;=&nbsp;np.argsort(eig_values)&nbsp;&nbsp;#&nbsp;将特征值从小到大排序&nbsp;&nbsp;&nbsp;&nbsp;n_vectors&nbsp;=&nbsp;eig_vectors[:,&nbsp;value_indices[-1:-(n&nbsp;+&nbsp;1):-1]]&nbsp;&nbsp;#&nbsp;最大的n个特征值对应的特征向量&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new_data&nbsp;*&nbsp;n_vectors&nbsp;&nbsp;#&nbsp;返回低维特征空间的数据def&nbsp;pca_svd(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;&nbsp;&nbsp;U,&nbsp;s,&nbsp;V&nbsp;=&nbsp;np.linalg.svd(cov_mat)&nbsp;&nbsp;#&nbsp;将协方差矩阵奇异值分解&nbsp;&nbsp;&nbsp;&nbsp;pc&nbsp;=&nbsp;np.dot(new_data,&nbsp;U)&nbsp;&nbsp;#&nbsp;返回矩阵的第一个列向量即是降维后的结果&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;pc[:,&nbsp;0]def&nbsp;unit_test():&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;np.array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[2.5,&nbsp;2.4],&nbsp;[0.5,&nbsp;0.7],&nbsp;[2.2,&nbsp;2.9],&nbsp;[1.9,&nbsp;2.2],&nbsp;[3.1,&nbsp;3.0],&nbsp;[2.3,&nbsp;2.7],&nbsp;[2,&nbsp;1.6],&nbsp;[1,&nbsp;1.1],&nbsp;[1.5,&nbsp;1.6],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1.1,&nbsp;0.9]])&nbsp;&nbsp;&nbsp;&nbsp;result_eig&nbsp;=&nbsp;pca_eig(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用常规的特征值分解法，将2维数据降到1维&nbsp;&nbsp;&nbsp;&nbsp;print(result_eig)&nbsp;&nbsp;&nbsp;&nbsp;result_svd&nbsp;=&nbsp;pca_svd(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用奇异值分解法将协方差矩阵分解，得到降维结果&nbsp;&nbsp;&nbsp;&nbsp;print(result_svd)if&nbsp;__name__&nbsp;==&nbsp;&#39;__main__&#39;:&nbsp;&nbsp;&nbsp;&nbsp;unit_test()as&nbsp;np#&nbsp;零均值化，即中心化，是数据的预处理方法def&nbsp;zero_centered(data):&nbsp;&nbsp;&nbsp;&nbsp;matrix_mean&nbsp;=&nbsp;np.mean(data,&nbsp;axis=0)&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data&nbsp;-&nbsp;matrix_meandef&nbsp;pca_eig(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;#&nbsp;也可以用&nbsp;np.cov()&nbsp;方法&nbsp;&nbsp;&nbsp;&nbsp;eig_values,&nbsp;eig_vectors&nbsp;=&nbsp;np.linalg.eig(np.mat(cov_mat))&nbsp;&nbsp;#&nbsp;求特征值和特征向量，特征向量是列向量&nbsp;&nbsp;&nbsp;&nbsp;value_indices&nbsp;=&nbsp;np.argsort(eig_values)&nbsp;&nbsp;#&nbsp;将特征值从小到大排序&nbsp;&nbsp;&nbsp;&nbsp;n_vectors&nbsp;=&nbsp;eig_vectors[:,&nbsp;value_indices[-1:-(n&nbsp;+&nbsp;1):-1]]&nbsp;&nbsp;#&nbsp;最大的n个特征值对应的特征向量&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new_data&nbsp;*&nbsp;n_vectors&nbsp;&nbsp;#&nbsp;返回低维特征空间的数据def&nbsp;pca_svd(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;&nbsp;&nbsp;U,&nbsp;s,&nbsp;V&nbsp;=&nbsp;np.linalg.svd(cov_mat)&nbsp;&nbsp;#&nbsp;将协方差矩阵奇异值分解&nbsp;&nbsp;&nbsp;&nbsp;pc&nbsp;=&nbsp;np.dot(new_data,&nbsp;U)&nbsp;&nbsp;#&nbsp;返回矩阵的第一个列向量即是降维后的结果&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;pc[:,&nbsp;0]def&nbsp;unit_test():&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;np.array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[2.5,&nbsp;2.4],&nbsp;[0.5,&nbsp;0.7],&nbsp;[2.2,&nbsp;2.9],&nbsp;[1.9,&nbsp;2.2],&nbsp;[3.1,&nbsp;3.0],&nbsp;[2.3,&nbsp;2.7],&nbsp;[2,&nbsp;1.6],&nbsp;[1,&nbsp;1.1],&nbsp;[1.5,&nbsp;1.6],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1.1,&nbsp;0.9]])&nbsp;&nbsp;&nbsp;&nbsp;result_eig&nbsp;=&nbsp;pca_eig(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用常规的特征值分解法，将2维数据降到1维&nbsp;&nbsp;&nbsp;&nbsp;print(result_eig)&nbsp;&nbsp;&nbsp;&nbsp;result_svd&nbsp;=&nbsp;pca_svd(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用奇异值分解法将协方差矩阵分解，得到降维结果&nbsp;&nbsp;&nbsp;&nbsp;print(result_svd)if&nbsp;__name__&nbsp;==&nbsp;&#39;__main__&#39;:&nbsp;&nbsp;&nbsp;&nbsp;unit_test() 经过降维的数据为： [-0.82797019&nbsp;&nbsp;1.77758033&nbsp;-0.99219749&nbsp;-0.27421042&nbsp;-1.67580142&nbsp;-0.9129491&nbsp;&nbsp;0.09910944&nbsp;&nbsp;1.14457216&nbsp;&nbsp;0.43804614&nbsp;&nbsp;1.22382056]1.77758033&nbsp;-0.99219749&nbsp;-0.27421042&nbsp;-1.67580142&nbsp;-0.9129491&nbsp;&nbsp;0.09910944&nbsp;&nbsp;1.14457216&nbsp;&nbsp;0.43804614&nbsp;&nbsp;1.22382056] 我们可以看到，数据已经从2维的变为1维的了，这两个PCA算法的计算结果是相同的。其中pca_eig() 函数是使用常规的特征值分解方法来求解的，读者可以参照前面讲述的PCA算法过程来理解这段代码。pca_svd() 函数使用奇异值分解法来求解的。这段代码虽然相对精简，但是背后是经过复杂的数学推导的，下面简要阐述一下PCA算法中奇异值分解的步骤。 1) PCA算法中得到样本的协方差矩阵是经过零均值化处理的，将其去掉常数部分，则也可表示为： C = XTX 其中，X是经过中心化处理后的样本矩阵X. 前面我们介绍过，一个矩阵与其转置矩阵相乘的结果是一个对称矩阵。观察到协方差矩阵C便是一个对称矩阵，那么将其进行奇异值分解后则可以表示为： C = V∑VT 2) 将经过中心化的样本矩阵X进行奇异值分解，可以得到： X = U∑VT 因此，我们可以得到： XTX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = (U∑VT)T(U∑VT) =&nbsp;V∑TUTU∑VT&nbsp; &nbsp; &nbsp;&nbsp; =&nbsp;V∑2VT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 奇异矩阵V中的列对应着PCA算法主成分中的主方向，因此可以得到主成分为： XV&nbsp;= U∑VTV =&nbsp;U∑ 关于更详细的数学推倒过程，读者可参考该网址： https://stats.stackexchange.com/questions/134282/relationship-between-svd-and-pca-how-to-use-svd-to-perform-pca Numpy除了为我们提供常规的数学计算函数和矩阵相关操作之外，还提供了很多功能丰富的模块，随机数模块就是其中一部分。利用随机数模块可以生成随机数矩阵，比Python自带的随机数模块功能要强大，我们看一下下面这个例子。 8. Numpy的随机数功能演示 import&nbsp;numpy&nbsp;as&nbsp;np#&nbsp;置随机数种子：np.random.seed()#&nbsp;从[1,3)中生成一个整数的随机数，连续生成10个np.random.randint(1,3,10)#&nbsp;返回：array([2,&nbsp;2,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;2,&nbsp;1,&nbsp;2,&nbsp;2])#&nbsp;若要连续产生[1,3)之间的浮点数，可以使用下述方法：2*np.random.random(10)&nbsp;+&nbsp;1&#39;&#39;&#39;返回：array([&nbsp;1.25705585,&nbsp;&nbsp;2.38059578,&nbsp;&nbsp;1.73232769,&nbsp;&nbsp;2.12303283,&nbsp;&nbsp;2.33946996,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.28020734,&nbsp;&nbsp;2.15724069,&nbsp;&nbsp;1.32845829,&nbsp;&nbsp;2.91361293,&nbsp;&nbsp;1.78637408])&#39;&#39;&#39;np.random.uniform(1,3,10)&#39;&#39;&#39;返回：array([&nbsp;1.37993226,&nbsp;&nbsp;1.38412227,&nbsp;&nbsp;1.18063785,&nbsp;&nbsp;1.75985962,&nbsp;&nbsp;1.42775752,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.62100074,&nbsp;&nbsp;1.71768721,&nbsp;&nbsp;1.50131522,&nbsp;&nbsp;2.20297121,&nbsp;&nbsp;1.08585819])&#39;&#39;&#39;#&nbsp;生成一个满足正太分布(高斯分布)的矩阵，其维度是4*4np.random.normal(size=(4,4))&#39;&#39;&#39;返回：array([[-1.81525915,&nbsp;-2.02236963,&nbsp;&nbsp;0.90969106,&nbsp;&nbsp;0.25448426],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1.04177298,&nbsp;-0.35408201,&nbsp;&nbsp;1.67850233,&nbsp;-0.70361323],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.30710761,&nbsp;&nbsp;0.57461312,&nbsp;-0.37867596,&nbsp;-0.74010685],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.94046747,&nbsp;&nbsp;2.37124816,&nbsp;-0.78503777,&nbsp;-0.33485225]])&#39;&#39;&#39;#&nbsp;随机产生10个，n=5,p=0.5的二项分布数据:np.random.binomial(n=5,p=0.5,size=10)#&nbsp;返回：array([2,&nbsp;0,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;4,&nbsp;2])data&nbsp;=&nbsp;np.arange(10)&nbsp;#&nbsp;产生一个0到9的序列np.random.choice(data,5)&nbsp;#&nbsp;从data数据中随机采集5个样本，采集过程是有放回的#&nbsp;返回：array([0,&nbsp;0,&nbsp;1,&nbsp;6,&nbsp;2])np.random.choice(data,5,replace=False)&nbsp;#从data数据中随机采集5个样本，采集过程是没有放回的#&nbsp;返回：array([0,&nbsp;4,&nbsp;3,&nbsp;9,&nbsp;7])np.random.permutation(data)&nbsp;#&nbsp;对data进行乱序，返回乱序结果#&nbsp;返回：array([2,&nbsp;8,&nbsp;6,&nbsp;4,&nbsp;9,&nbsp;1,&nbsp;3,&nbsp;5,&nbsp;7,&nbsp;0])np.random.shuffle(data)&nbsp;#&nbsp;对data进行乱序，并替换为新的dataprint(data)#&nbsp;输出：[1&nbsp;2&nbsp;8&nbsp;4&nbsp;3&nbsp;6&nbsp;9&nbsp;0&nbsp;5&nbsp;7]as&nbsp;np#&nbsp;置随机数种子：np.random.seed()#&nbsp;从[1,3)中生成一个整数的随机数，连续生成10个np.random.randint(1,3,10)#&nbsp;返回：array([2,&nbsp;2,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;2,&nbsp;1,&nbsp;2,&nbsp;2])#&nbsp;若要连续产生[1,3)之间的浮点数，可以使用下述方法：2*np.random.random(10)&nbsp;+&nbsp;1&#39;&#39;&#39;返回：array([&nbsp;1.25705585,&nbsp;&nbsp;2.38059578,&nbsp;&nbsp;1.73232769,&nbsp;&nbsp;2.12303283,&nbsp;&nbsp;2.33946996,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.28020734,&nbsp;&nbsp;2.15724069,&nbsp;&nbsp;1.32845829,&nbsp;&nbsp;2.91361293,&nbsp;&nbsp;1.78637408])&#39;&#39;&#39;np.random.uniform(1,3,10)&#39;&#39;&#39;返回：array([&nbsp;1.37993226,&nbsp;&nbsp;1.38412227,&nbsp;&nbsp;1.18063785,&nbsp;&nbsp;1.75985962,&nbsp;&nbsp;1.42775752,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.62100074,&nbsp;&nbsp;1.71768721,&nbsp;&nbsp;1.50131522,&nbsp;&nbsp;2.20297121,&nbsp;&nbsp;1.08585819])&#39;&#39;&#39;#&nbsp;生成一个满足正太分布(高斯分布)的矩阵，其维度是4*4np.random.normal(size=(4,4))&#39;&#39;&#39;返回：array([[-1.81525915,&nbsp;-2.02236963,&nbsp;&nbsp;0.90969106,&nbsp;&nbsp;0.25448426],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1.04177298,&nbsp;-0.35408201,&nbsp;&nbsp;1.67850233,&nbsp;-0.70361323],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.30710761,&nbsp;&nbsp;0.57461312,&nbsp;-0.37867596,&nbsp;-0.74010685],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.94046747,&nbsp;&nbsp;2.37124816,&nbsp;-0.78503777,&nbsp;-0.33485225]])&#39;&#39;&#39;#&nbsp;随机产生10个，n=5,p=0.5的二项分布数据:np.random.binomial(n=5,p=0.5,size=10)#&nbsp;返回：array([2,&nbsp;0,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;4,&nbsp;2])data&nbsp;=&nbsp;np.arange(10)&nbsp;#&nbsp;产生一个0到9的序列np.random.choice(data,5)&nbsp;#&nbsp;从data数据中随机采集5个样本，采集过程是有放回的#&nbsp;返回：array([0,&nbsp;0,&nbsp;1,&nbsp;6,&nbsp;2])np.random.choice(data,5,replace=False)&nbsp;#从data数据中随机采集5个样本，采集过程是没有放回的#&nbsp;返回：array([0,&nbsp;4,&nbsp;3,&nbsp;9,&nbsp;7])np.random.permutation(data)&nbsp;#&nbsp;对data进行乱序，返回乱序结果#&nbsp;返回：array([2,&nbsp;8,&nbsp;6,&nbsp;4,&nbsp;9,&nbsp;1,&nbsp;3,&nbsp;5,&nbsp;7,&nbsp;0])np.random.shuffle(data)&nbsp;#&nbsp;对data进行乱序，并替换为新的dataprint(data)#&nbsp;输出：[1&nbsp;2&nbsp;8&nbsp;4&nbsp;3&nbsp;6&nbsp;9&nbsp;0&nbsp;5&nbsp;7] 关于作者：王天庆，长期从事分布式系统、数据科学与工程、人工智能等方面的研究与开发，在人脸识别方面有丰富的实践经验。现就职某世界100强企业的数据实验室，从事数据科学相关技术领域的预研工作。 本文摘编自《Python人脸识别：从入门到工程实践》，经出版方授权发布。 延伸阅读《Python人脸识别》 点击上图了解及购买 转载请联系微信：DoctorData 推荐语：华为资深AI工程师撰写，全面讲解人脸识别各项基础技术、原理和算法，从零实现工程级人脸识别引擎。 据统计，99%的大咖都完成了这个神操作 ▼ 更多精彩 在公众号后台对话框输入以下关键词 查看更多优质内容！ PPT&nbsp;|&nbsp;报告&nbsp;|&nbsp;读书&nbsp;|&nbsp;书单&nbsp;|&nbsp;干货&nbsp; 大数据&nbsp;|&nbsp;揭秘&nbsp;|&nbsp;Python&nbsp;|&nbsp;可视化 AI&nbsp;|&nbsp;人工智能&nbsp;|&nbsp;5G&nbsp;|&nbsp;区块链 机器学习&nbsp;|&nbsp;深度学习&nbsp;|&nbsp;神经网络 1024&nbsp;|&nbsp;段子&nbsp;|&nbsp;数学&nbsp;|&nbsp;高考 猜你想看 真正零基础Python入门：手把手教你从变量和赋值语句学起 Python实操：手把手教你用Matplotlib把数据画出来 有关华为、5G、芯片和操作系统，这些书你读过几本？ 什么是数据？数据科学家需要掌握哪些技能？终于有人讲明白了 Q:&nbsp;你在用哪些工具做数学运算？ 欢迎留言与大家分享 觉得不错，请把这篇文章分享给你的朋友 转载 / 投稿请联系：baiyu@hzbook.com 更多精彩，请在后台点击“历史文章”查看 点击阅读原文，了解更多","@type":"BlogPosting","url":"https://uzzz.org/2019/06/05/788647.html","headline":"高能！8段代码演示Numpy数据运算的神操作","dateModified":"2019-06-05T00:00:00+08:00","datePublished":"2019-06-05T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/06/05/788647.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>高能！8段代码演示Numpy数据运算的神操作</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="rich_media_content" id="js_content"> 
   <p style="letter-spacing:0px;line-height:1.75em;"><img style="font-family:Helvetica, Arial, sans-serif;color:rgb(73,59,59);font-size:15px;letter-spacing:.544px;line-height:25.6px;width:558px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/KfLGF0ibu6cLJiaicLnPCqYROg1Y8spzCyZGKg6ra9H53HCaejCGGjuXl9x9VZ0iaQQCSCzibMkS0iciaQpAntVMQibPgQ/640?wx_fmt=gif" alt="640?wx_fmt=gif"><br></p>
   <span style="line-height:26.25px;color:rgb(73,59,59);font-size:15px;font-family:'微软雅黑';"></span>
   <p><strong><span style="line-height:26.25px;letter-spacing:0px;">导读：</span></strong><span style="letter-spacing:0px;">本文介绍一下在Python科学计算中非常重要的一个库——Numpy。</span></p>
   <pre></pre>
   <p><br></p>
   <p style="font-size:16px;line-height:1.75em;"><span style="color:rgb(127,127,127);font-family:'微软雅黑';font-size:14px;">作者：</span><span style="color:rgb(127,127,127);font-family:'微软雅黑';font-size:14px;">王天庆</span></p>
   <p style="font-size:16px;line-height:1.75em;"><span style="color:rgb(127,127,127);font-family:'微软雅黑';font-size:14px;letter-spacing:.544px;">如需转载请联系大数据（ID：</span><span style="color:rgb(127,127,127);font-family:'微软雅黑';font-size:14px;letter-spacing:.544px;">hzdashuju）</span></p>
   <p><br></p>
   <p style="text-align:center;"><img class="rich_pages" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/KfLGF0ibu6cKs9BX1CeQvQdoiaicS6lfYtWKBlkql64cnibIgIsrHYwxMjFU7bkLVwicRY3RIhh2CNCOUDYR2ibEluLg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:rgb(73,59,59);">Numpy是Numerical Python extensions 的缩写，字面意思是Python数值计算扩展。Numpy是Python中众多机器学习库的依赖，这些库通过Numpy实现基本的矩阵计算，Python的OpenCV库自然也不例外。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;"><strong><span style="font-size:15px;color:rgb(0,122,170);">Numpy支持高阶、大量计算的矩阵、向量计算，与此同时提供了较为丰富的函数。</span></strong></span><span style="font-size:15px;color:rgb(73,59,59);">Numpy采用友好的BSD许可协议开放源代码。它是一个跨平台的科学计算库，提供了与Matlab相似的功能和操作方法。</span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:rgb(73,59,59);">虽然科学计算领域一直是Matlab的天下，但是Numpy基于更加现代化的编程语言——Python。而且Python凭借着开源、免费、灵活性、简单易学、工程特性好等特点风靡技术圈，已经成为机器学习、数据分析等领域的主流编程语言。</span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">虽然Matlab提供的包非常多，但是Python因其简单灵活、扩展性强等特点，也诞生了一系列优秀的库。例如Scipy具有大多数Matlab所具备的功能，Matplotlib能够简便地进行数据可视化。虽然当前Matlab的地位仍然难以撼动，但是，随着时间的推移，<strong><span style="color:rgb(0,122,170);">Python在科学计算上的生态系统也会越来越丰富。</span></strong></span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">安装Numpy的方法也很简单，使用Python的包管理工具pip或者anaconda便可以实现。例如在shell中输入下列命令行便可以通过pip安装Numpy：</span></p>
   <p><br></p>
   <pre><code class="python language-python hljs" style="margin-left:2px;line-height:18px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">pip&nbsp;install&nbsp;numpy</code></pre>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">另外，Numpy是OpenCV的一个依赖库，所以，我们使用pip工具安装好OpenCV库之后，Numpy一般也都已经安装好了。</span></p>
   <p><br></p>
   <p style="text-align:center;"><img class="rich_pages" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/KfLGF0ibu6cKs9BX1CeQvQdoiaicS6lfYtWTEHM5q8JKe6x9GjmX2p0jhYDE6wGb6GDPAKexZNrFibHbSb1Uibsmuow/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p><br></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><strong><span style="color:#007AAA;font-size:18px;">01 array类型</span></strong></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">Numpy的array类型是该库的一个基本数据类型，这个数据类型从字面上看是数组的意思，也就意味着它最关键的属性是元素与维度，我们可以这个数据类型来实现多维数组。</span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">因此，通过这个数据类型，我们可以使用一维数组用来表示向量，二维数组来表示矩阵，以此类推用以表示更高维度的张量。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">我们通过下面的例子来简单体会一下在Numpy中array类型的使用。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><strong><span style="font-size:15px;color:#007AAA;">1. Numpy中array类型的基本使用</span></strong></p>
   <p><br></p>
   <pre class="output_wrapper" style="font-size:14px;color:rgb(79,79,79);line-height:1.8;letter-spacing:0px;font-family:'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;"></pre>
   <pre><code class="python language-python hljs" style="margin-left:2px;line-height:18px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">import&nbsp;numpy&nbsp;as&nbsp;np#&nbsp;引入numpy库，并将其别名为nparray&nbsp;=&nbsp;np.array([1,2,3,4])#&nbsp;通过np.array()方法创建一个名为array的array类型，参数是一个listarray#&nbsp;在shell中输入，返回的结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4])array.max()#&nbsp;获取该array类型中最大的元素值，结果为:#&nbsp;4array.mean()#&nbsp;求该array中元素的平均值，结果为:#&nbsp;2.5array.min()#&nbsp;获取该array中元素的最小值：#&nbsp;1array&nbsp;*&nbsp;2#&nbsp;直接将该array乘以2，Python将该运算符重载，将每一个元素都乘以了2，其输出结果为：#&nbsp;array([2,&nbsp;4,&nbsp;6,&nbsp;8])array&nbsp;+&nbsp;1#&nbsp;将每一个元素都加上1，输出结果为：#&nbsp;array([2,&nbsp;3,&nbsp;4,&nbsp;5])array&nbsp;/&nbsp;2&nbsp;#&nbsp;将每一个元素都除以2，得到浮点数表示的结果为：#&nbsp;array([&nbsp;0.5,&nbsp;&nbsp;1.&nbsp;,&nbsp;&nbsp;1.5,&nbsp;&nbsp;2.&nbsp;])array&nbsp;%&nbsp;2#&nbsp;Numpy库除了可以对array实现除法运算，还可以实现取模运算，结果为：#&nbsp;array([1,&nbsp;0,&nbsp;1,&nbsp;0],&nbsp;dtype=int32)array.argmax()#&nbsp;获取该组数据中元素值最大的一个数据的索引，下标从0开始，其结果为：#&nbsp;3<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">as</span>&nbsp;np<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;引入numpy库，并将其别名为np</span><br>array&nbsp;=&nbsp;np.array([<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>])<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;通过np.array()方法创建一个名为array的array类型，参数是一个list</span><br>array<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;在shell中输入，返回的结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4])</span><br>array.max()<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;获取该array类型中最大的元素值，结果为:</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;4</span><br>array.mean()<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求该array中元素的平均值，结果为:</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;2.5</span><br>array.min()<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;获取该array中元素的最小值：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;1</span><br>array&nbsp;*&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;直接将该array乘以2，Python将该运算符重载，将每一个元素都乘以了2，其输出结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;array([2,&nbsp;4,&nbsp;6,&nbsp;8])</span><br>array&nbsp;+&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;将每一个元素都加上1，输出结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;array([2,&nbsp;3,&nbsp;4,&nbsp;5])</span><br>array&nbsp;/&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>&nbsp;<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;将每一个元素都除以2，得到浮点数表示的结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;array([&nbsp;0.5,&nbsp;&nbsp;1.&nbsp;,&nbsp;&nbsp;1.5,&nbsp;&nbsp;2.&nbsp;])</span><br>array&nbsp;%&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;Numpy库除了可以对array实现除法运算，还可以实现取模运算，结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;array([1,&nbsp;0,&nbsp;1,&nbsp;0],&nbsp;dtype=int32)</span><br>array.argmax()<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;获取该组数据中元素值最大的一个数据的索引，下标从0开始，其结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;3</span><br></code></pre>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">通过上面的代码片段，我们可以了解Numpy中array类型的基本使用方法。我们可以看到，array其实是一个类，通过传入一个list参数来实例化为一个对象，也就实现了对数据的封装。这个对象中包含对各个元素进行计算的基本方法，例如求平均值、求最大值等。除此之外，我们再看一下关于更高维度数据的处理。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><strong><span style="font-size:15px;color:#007AAA;">2. Numpy对更高维度数据的处理</span></strong></p>
   <p><br></p>
   <pre class="output_wrapper" style="font-size:14px;color:rgb(79,79,79);line-height:1.8;letter-spacing:0px;font-family:'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;"></pre>
   <pre><code class="python language-python hljs" style="margin-left:2px;line-height:18px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">import&nbsp;numpy&nbsp;as&nbsp;nparray&nbsp;=&nbsp;np.array([[1,2],[3,4],[5,6]])#&nbsp;创建一个二维数组，用以表示一个3行2列的矩阵，名为arrayarray#在交互式编程界面中输入array，返回结果为：#&nbsp;array([[1,&nbsp;2],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;4],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5,&nbsp;6]])array.shape#&nbsp;查看数据的维度属性，下面的输出结果元组，代表的是3行2列#&nbsp;(3,&nbsp;2)array.size#&nbsp;查看array中的元素数量，输出结果为：#&nbsp;6array.argmax()#&nbsp;查看元素值最大的元素索引，结果为：#&nbsp;5array.flatten()#&nbsp;将shape为(3,2)的array转换为一行表示，输出结果为：#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6])#&nbsp;我们可以看到，flatten()方法是将多维数据“压平”为一维数组的过程array.reshape(2,3)#&nbsp;将array数据从shape为(3,2)的形式转换为(2,3)的形式：#&nbsp;array([[1,&nbsp;2,&nbsp;3],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,&nbsp;5,&nbsp;6]])<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">as</span>&nbsp;np<br>array&nbsp;=&nbsp;np.array([[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>],[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>],[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">5</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">6</span>]])<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;创建一个二维数组，用以表示一个3行2列的矩阵，名为array</span><br>array<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#在交互式编程界面中输入array，返回结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;array([[1,&nbsp;2],</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;4],</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5,&nbsp;6]])</span><br>array.shape<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;查看数据的维度属性，下面的输出结果元组，代表的是3行2列</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;(3,&nbsp;2)</span><br>array.size<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;查看array中的元素数量，输出结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;6</span><br>array.argmax()<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;查看元素值最大的元素索引，结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;5</span><br>array.flatten()<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;将shape为(3,2)的array转换为一行表示，输出结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;array([1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6])</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;我们可以看到，flatten()方法是将多维数据“压平”为一维数组的过程</span><br>array.reshape(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;将array数据从shape为(3,2)的形式转换为(2,3)的形式：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;array([[1,&nbsp;2,&nbsp;3],</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,&nbsp;5,&nbsp;6]])</span><br></code></pre>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">除此之外，Numpy还包含了创建特殊类别的array类型的方法，例如。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><strong><span style="font-size:15px;color:#007AAA;">3. Numpy创建特殊类别的array类型</span></strong></p>
   <p><br></p>
   <pre class="output_wrapper" style="font-size:14px;color:rgb(79,79,79);line-height:1.8;letter-spacing:0px;font-family:'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;"></pre>
   <pre><code class="python language-python hljs" style="margin-left:2px;line-height:18px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">import&nbsp;numpy&nbsp;as&nbsp;nparray_zeros&nbsp;=&nbsp;np.zeros((2,3,3))#生成结果为：#&nbsp;array([[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]],##&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]]])array_ones&nbsp;=&nbsp;np.ones((2,3,3))#&nbsp;生成所有元素都为1的array，其shape是(2,3,3)array_ones.shape#&nbsp;(2,&nbsp;3,&nbsp;3)array_arange&nbsp;=&nbsp;np.arange(10)#&nbsp;生成一个array，从0递增到10，步长为1，结果为：#&nbsp;array([0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9])array_linespace&nbsp;=&nbsp;np.linspace(0,10,5)#&nbsp;生成一个array从0到10递增，步长为5，结果为：#&nbsp;array([&nbsp;&nbsp;0.&nbsp;,&nbsp;&nbsp;&nbsp;2.5,&nbsp;&nbsp;&nbsp;5.&nbsp;,&nbsp;&nbsp;&nbsp;7.5,&nbsp;&nbsp;10.&nbsp;])<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">as</span>&nbsp;np<br>array_zeros&nbsp;=&nbsp;np.zeros((<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>))<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#生成结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;array([[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]],</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.]]])</span><br>array_ones&nbsp;=&nbsp;np.ones((<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>))<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;生成所有元素都为1的array，其shape是(2,3,3)</span><br>array_ones.shape<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;(2,&nbsp;3,&nbsp;3)</span><br>array_arange&nbsp;=&nbsp;np.arange(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">10</span>)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;生成一个array，从0递增到10，步长为1，结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;array([0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9])</span><br>array_linespace&nbsp;=&nbsp;np.linspace(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">10</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">5</span>)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;生成一个array从0到10递增，步长为5，结果为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;array([&nbsp;&nbsp;0.&nbsp;,&nbsp;&nbsp;&nbsp;2.5,&nbsp;&nbsp;&nbsp;5.&nbsp;,&nbsp;&nbsp;&nbsp;7.5,&nbsp;&nbsp;10.&nbsp;])</span></code></pre>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">Numpy作为Python的一款著名数值计算库，其在基础计算上的功能也是非常完备的，代码如下。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><strong><span style="font-size:15px;color:#007AAA;">4. Numpy基础计算演示</span></strong></p>
   <p><br></p>
   <pre class="output_wrapper" style="font-size:14px;color:rgb(79,79,79);line-height:1.8;letter-spacing:0px;font-family:'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;"></pre>
   <pre><code class="python language-python hljs" style="margin-left:2px;line-height:18px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">import&nbsp;numpy&nbsp;as&nbsp;npnp.abs([1,-2,-3,4])#&nbsp;取绝对值，结果为：array([1,&nbsp;2,&nbsp;3,&nbsp;4])np.sin(np.pi&nbsp;/&nbsp;2)#&nbsp;求余弦值，结果为：1.0np.arctan(1)#&nbsp;求反正切值，结果为：0.78539816339744828np.exp(2)#&nbsp;求自然常数e的2次方，结果为：7.3890560989306504np.power(2,3)#&nbsp;求2的3次方，结果为：8np.dot([1,2],[3,4])#&nbsp;将向量[1,2]与[3,4]求点积，结果为：11np.sqrt(4)#&nbsp;将4开平方，结果为：2.0np.sum([1,2,3,4])#&nbsp;求和，结果为：10np.mean([1,2,3,4])#&nbsp;求平均值，结果为：2.5np.std([1,2,3,4])#&nbsp;求标准差，结果为：1.1180339887498949<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">as</span>&nbsp;np<br>np.abs([<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>])<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;取绝对值，结果为：array([1,&nbsp;2,&nbsp;3,&nbsp;4])</span><br>np.sin(np.pi&nbsp;/&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求余弦值，结果为：1.0</span><br>np.arctan(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求反正切值，结果为：0.78539816339744828</span><br>np.exp(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求自然常数e的2次方，结果为：7.3890560989306504</span><br>np.power(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求2的3次方，结果为：8</span><br>np.dot([<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>],[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>])<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;将向量[1,2]与[3,4]求点积，结果为：11</span><br>np.sqrt(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;将4开平方，结果为：2.0</span><br>np.sum([<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>])<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求和，结果为：10</span><br>np.mean([<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>])<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求平均值，结果为：2.5</span><br>np.std([<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>])<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求标准差，结果为：1.1180339887498949</span></code></pre>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">除此之外，Numpy所包含的基本计算功能还有很多，例如将array切分、拼接、倒序等。</span></p>
   <p><br></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><strong><span style="color:#007AAA;font-size:18px;">02 线性代数相关</span></strong></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">我们在前面介绍了array类型及其基本操作方法，了解到使用array类型可以表示向量、矩阵和多维张量。线性代数计算在科学计算领域非常重要，在机器学习和数据挖掘领域，线性代数相关函数的使用也是非常频繁的。下面，我们介绍一下Numpy为我们提供的线性代数操作。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><strong><span style="font-size:15px;color:#007AAA;">5. Numpy提供的线性代数操作</span></strong></p>
   <p><br></p>
   <pre class="output_wrapper" style="font-size:14px;color:rgb(79,79,79);line-height:1.8;letter-spacing:0px;font-family:'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;"></pre>
   <pre><code class="python language-python hljs" style="margin-left:2px;line-height:18px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">import&nbsp;numpy&nbsp;as&nbsp;npvector_a&nbsp;=&nbsp;np.array([1,2,3])vector_b&nbsp;=&nbsp;np.array([2,3,4])#&nbsp;定义两个向量vector_a与vector_bnp.dot(vector_a,vector_b)#&nbsp;将两个向量相乘，在这里也就是点乘，结果为20vector_a.dot(vector_b)#&nbsp;将vector_a与vector_b相乘，结果为20np.dot(vector_a,vector_b.T)'''将一个行向量与一个列向量叉乘的结果相当于将两个行向量求点积，在这里我们测试了dot()方法。其中array类型的T()方法表示转置。测试结果表明：dot()方法对于两个向量默认求其点积。对于符合叉乘格式的矩阵，自动进行叉乘。我们看一下下面这个例子：'''matrix_a&nbsp;=&nbsp;np.array([[1,2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])#&nbsp;定义一个2行2列的方阵matrix_b&nbsp;=&nbsp;np.dot(matrix_a,matrix_a.T)#&nbsp;这里将该方阵与其转置叉乘，将结果赋予matrix_b变量matrix_b'''结果为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])'''np.linalg.norm([1,2])#&nbsp;求一个向量的范数的值，结果为2.2360679774997898#&nbsp;如果norm()方法没有指定第二个参数，则默认为求2范数。np.linalg.norm([1,-2],1)#&nbsp;指定第二个参数值为1，即求1范数，我们在前面介绍过，1范数的结果即为向量中各元素绝对值之和，结果为3.0np.linalg.norm([1,2,3,4],np.inf)#&nbsp;求向量的无穷范数，其中np.inf表示正无穷，也就是向量中元素值最大的那个，其结果为4.0np.linalg.norm([1,2,3,4],-np.inf)#&nbsp;同理，求负无穷范数的结果为1，也就是向量中元素的最小值np.linalg.norm(matrix_b)#&nbsp;除了向量可以求范数，矩阵也可以有类似的运算，即为F范数，结果为29.866369046136157np.linalg.det(matrix_a)#&nbsp;求矩阵matrix_a的行列式，结果为-2.0000000000000004np.trace(matrix_a)#&nbsp;求矩阵matrix_a的迹，结果为5np.linalg.matrix_rank(matrix_a)#&nbsp;求矩阵的秩，结果为2vector_a&nbsp;*&nbsp;vector_b#&nbsp;使用*符号将两个向量相乘，是将两个向量中的元素分别相乘，也就是前面我们所讲到的哈达马乘积，结果为array([&nbsp;2,&nbsp;&nbsp;6,&nbsp;12])vector_a&nbsp;**&nbsp;vector_b#&nbsp;使用二元运算符**对两个向量进行操作，结果为array([&nbsp;1,&nbsp;&nbsp;8,&nbsp;81],&nbsp;dtype=int32)#&nbsp;表示将向量vector_a中元素对应vector_b中的元素值求幂运算。例如最终结果[1,8,81]可以表示为：#&nbsp;[1*1,2*2*2,3*3*3*3]np.linalg.pinv(matrix_a)'''求矩阵的逆矩阵，方法pinv()求的是伪逆矩阵，结果为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])不使用伪逆矩阵的算法，直接使用逆矩阵的方法是inv()，即np.linalg.inv(matrix_a)结果相同，也为：array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])'''<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">as</span>&nbsp;np<br><br>vector_a&nbsp;=&nbsp;np.array([<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>])<br>vector_b&nbsp;=&nbsp;np.array([<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>])<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;定义两个向量vector_a与vector_b</span><br><br>np.dot(vector_a,vector_b)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;将两个向量相乘，在这里也就是点乘，结果为20</span><br><br>vector_a.dot(vector_b)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;将vector_a与vector_b相乘，结果为20</span><br>np.dot(vector_a,vector_b.T)<br><span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">'''<br>将一个行向量与一个列向量叉乘的结果相当于将两个行向量求点积，在这里我们测试了dot()方法。其中array类型的T()方法表示转置。<br>测试结果表明：<br>dot()方法对于两个向量默认求其点积。对于符合叉乘格式的矩阵，自动进行叉乘。<br>我们看一下下面这个例子：<br>'''</span><br>matrix_a&nbsp;=&nbsp;np.array([[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>]])<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;定义一个2行2列的方阵</span><br>matrix_b&nbsp;=&nbsp;np.dot(matrix_a,matrix_a.T)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;这里将该方阵与其转置叉乘，将结果赋予matrix_b变量</span><br>matrix_b<br><span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">'''<br>结果为：<br>array([[&nbsp;5,&nbsp;11],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])<br>'''</span><br><br>np.linalg.norm([<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>])<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求一个向量的范数的值，结果为2.2360679774997898</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;如果norm()方法没有指定第二个参数，则默认为求2范数。</span><br>np.linalg.norm([<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-2</span>],<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;指定第二个参数值为1，即求1范数，我们在前面介绍过，1范数的结果即为向量中各元素绝对值之和，结果为3.0</span><br>np.linalg.norm([<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>],np.inf)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求向量的无穷范数，其中np.inf表示正无穷，也就是向量中元素值最大的那个，其结果为4.0</span><br>np.linalg.norm([<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>],-np.inf)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;同理，求负无穷范数的结果为1，也就是向量中元素的最小值</span><br>np.linalg.norm(matrix_b)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;除了向量可以求范数，矩阵也可以有类似的运算，即为F范数，结果为29.866369046136157</span><br>np.linalg.det(matrix_a)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求矩阵matrix_a的行列式，结果为-2.0000000000000004</span><br><br>np.trace(matrix_a)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求矩阵matrix_a的迹，结果为5</span><br><br>np.linalg.matrix_rank(matrix_a)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求矩阵的秩，结果为2</span><br><br>vector_a&nbsp;*&nbsp;vector_b<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;使用*符号将两个向量相乘，是将两个向量中的元素分别相乘，也就是前面我们所讲到的哈达马乘积，结果为array([&nbsp;2,&nbsp;&nbsp;6,&nbsp;12])</span><br>vector_a&nbsp;**&nbsp;vector_b<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;使用二元运算符**对两个向量进行操作，结果为array([&nbsp;1,&nbsp;&nbsp;8,&nbsp;81],&nbsp;dtype=int32)</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;表示将向量vector_a中元素对应vector_b中的元素值求幂运算。例如最终结果[1,8,81]可以表示为：</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;[1*1,2*2*2,3*3*3*3]</span><br><br><br>np.linalg.pinv(matrix_a)<br><span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">'''<br>求矩阵的逆矩阵，方法pinv()求的是伪逆矩阵，结果为：<br>array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])<br>不使用伪逆矩阵的算法，直接使用逆矩阵的方法是inv()，即<br>np.linalg.inv(matrix_a)<br>结果相同，也为：<br>array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])<br>'''</span></code></pre>
   <p><br></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><strong><span style="color:#007AAA;font-size:18px;">03 矩阵的高级函数</span></strong></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">我们在前面学习了Numpy的基本数据类型array，同时了解了一些基本的数学运算方法。其实除了前面我们所提到的对矩阵求逆、求秩、求转置等基本运算之外，Numpy还为我们提供了矩阵的分解等更高级的函数。</span></p>
   <p><br></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">矩阵分解(decomposition, factorization)是将矩阵拆解为若干个矩阵的相乘的过程。在数值分析，常常被用来实现一些矩阵运算的快速算法，在机器学习领域有非常重要的作用。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">例如我们在前面介绍过线性降维的PCA算法，其中就涉及矩阵分解的步骤。今日头条、亚马逊网上商城这类互联网产品，总会根据我们的个人喜好给我们推送一些它认为我们会感兴趣的资讯或商品，这类用于推送消息的系统称为</span><strong><span style="font-size:15px;color:#007AAA;">推荐系统</span></strong><span style="font-size:15px;color:#493B3B;">(Recommendation System)。</span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;"><br></span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">在推荐系统的实现过程中，就用到了矩阵分解算法。例如主流的开源大数据计算引擎Spark在ml机器学习库中通过ALS算法实现了推荐系统，也有的推荐系统采用SVD算法来实现整套系统中的矩阵分解过程。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">在Numpy中，为我们提供了基于SVD算法的矩阵分解，SVD算法即为奇异值分解法，相对于矩阵的特征值分解法，它可以对非方阵形式的矩阵进行分解，将一个矩阵A分解为如下形式：</span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><br></p>
   <p style="text-align:center;"><span style="color:rgb(73,59,59);font-size:15px;">A = U∑V</span><span style="font-size:12px;"><sup style="color:rgb(73,59,59);"><span>T</span></sup></span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">式中，A代表需要被分解的矩阵，设其维度是m×n。U矩阵是被分解为的三个矩阵之一，它是一个m×m的方阵，构成这个矩阵的向量是正交的，被称为</span><strong><span style="font-size:15px;color:#007AAA;">左奇异向量</span></strong><span style="font-size:15px;color:#493B3B;">；</span><span style="text-align:center;font-size:15px;color:rgb(73,59,59);">∑</span><span style="font-size:15px;color:#493B3B;">是一个m×n的向量，它的特点是除了对角线中的元素外，其余元素都为0。V是一个n×n的方阵，它的转置也是一个方阵，与U矩阵类似，构成这个矩阵的向量也是正交的，被称为</span><strong><span style="font-size:15px;color:#007AAA;">右奇异向量</span></strong><span style="font-size:15px;color:#493B3B;">。整个奇异值分解算法矩阵的形式如图4-1所示，具体算法实现在此不再赘述。</span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><br></p>
   <p style="text-align:center;"><img class="rich_pages" style="width:300px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/KfLGF0ibu6cKs9BX1CeQvQdoiaicS6lfYtWtz5rsFazoNC8KhicaAN6HZgpuzYNDJ5LgrgHlk0skR34t6zib3s5WzuQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="text-align:center;line-height:1.75em;letter-spacing:0px;"><span style="color:#7F7F7F;font-size:14px;">▲图4-1 SVD算法的矩阵形式</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">我们使用Numpy演示一下SVD算法的使用。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><strong><span style="font-size:15px;color:#007AAA;">6. SVD算法演示</span></strong></p>
   <p><br></p>
   <pre class="output_wrapper" style="font-size:14px;color:rgb(79,79,79);line-height:1.8;letter-spacing:0px;font-family:'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;"></pre>
   <pre><code class="python language-python hljs" style="margin-left:2px;line-height:18px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">import&nbsp;numpy&nbsp;as&nbsp;npmatrix&nbsp;=&nbsp;np.array([&nbsp;&nbsp;&nbsp;&nbsp;[1,2],&nbsp;&nbsp;&nbsp;&nbsp;[3,4]])another_matrix&nbsp;=&nbsp;np.dot(matrix,matrix.T)#&nbsp;生成一个矩阵&nbsp;another_matrixprint(another_matrix)'''该矩阵为：array([[&nbsp;5,&nbsp;11],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])'''U,s,V&nbsp;=&nbsp;np.linalg.svd(another_matrix,2)#&nbsp;使用奇异值分解法将该矩阵进行分解，分解得到三个子矩阵U,s,V#&nbsp;在s矩阵的基础上，生成S矩阵为：S&nbsp;=&nbsp;np.array([[s[0],0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,s[1]]])#&nbsp;我们在下面看一下生成的几个矩阵的样子print(U)'''[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]'''print(s)'''[&nbsp;29.86606875&nbsp;&nbsp;&nbsp;0.13393125]'''print(V)'''[[-0.40455358&nbsp;-0.9145143&nbsp;]&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]'''#&nbsp;利用生成的U,S,V三个矩阵，我们可以重建回原来的矩阵another_matrixnp.dot(U,np.dot(S,V))#&nbsp;输出结果为:'''array([[&nbsp;&nbsp;5.,&nbsp;&nbsp;11.],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;11.,&nbsp;&nbsp;25.]])'''<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">as</span>&nbsp;np<br><br>matrix&nbsp;=&nbsp;np.array([<br>&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>],<br>&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>]])<br><br>another_matrix&nbsp;=&nbsp;np.dot(matrix,matrix.T)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;生成一个矩阵&nbsp;another_matrix</span><br>print(another_matrix)<br><span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">'''<br>该矩阵为：<br>array([[&nbsp;5,&nbsp;11],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[11,&nbsp;25]])<br>'''</span><br><br>U,s,V&nbsp;=&nbsp;np.linalg.svd(another_matrix,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;使用奇异值分解法将该矩阵进行分解，分解得到三个子矩阵U,s,V</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;在s矩阵的基础上，生成S矩阵为：</span><br>S&nbsp;=&nbsp;np.array([[s[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>],<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>,s[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>]]])<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;我们在下面看一下生成的几个矩阵的样子</span><br>print(U)<br><span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">'''<br>[[-0.40455358&nbsp;-0.9145143&nbsp;]<br>&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]<br>'''</span><br>print(s)<br><span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">'''<br>[&nbsp;29.86606875&nbsp;&nbsp;&nbsp;0.13393125]<br>'''</span><br>print(V)<br><span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">'''<br>[[-0.40455358&nbsp;-0.9145143&nbsp;]<br>&nbsp;[-0.9145143&nbsp;&nbsp;&nbsp;0.40455358]]<br>'''</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;利用生成的U,S,V三个矩阵，我们可以重建回原来的矩阵another_matrix</span><br>np.dot(U,np.dot(S,V))<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;输出结果为:</span><br><span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">'''<br>array([[&nbsp;&nbsp;5.,&nbsp;&nbsp;11.],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;11.,&nbsp;&nbsp;25.]])<br>'''</span><br></code></pre>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">在上面的代码片段中，s向量表示的是分解后的<span style="color:rgb(73,59,59);font-size:15px;text-align:center;">∑</span>矩阵中对角线上的元素，所以我们在这里面引入了一个S矩阵，将s向量中的元素放置在这个矩阵中，用以验证分解后的矩阵重建回原先的矩阵A的过程。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">仔细的读者可能会注意到，为什么这里使用SVD算法生成的矩阵U与<span style="text-align:center;color:rgb(73,59,59);font-size:15px;">V</span></span><span style="text-align:center;color:rgb(73,59,59);font-size:12px;"><sup style="color:rgb(73,59,59);"><span style="text-align:center;color:rgb(73,59,59);">T</span></sup></span><span style="font-size:15px;color:#493B3B;">是相同的。大家可能会注意到在上面的代码片段中，为何多了一个生成矩阵another_matrix的过程。这是因为一个矩阵与其转置相乘之后的矩阵是对称矩阵（矩阵中的元素沿着对角线对称），将对称矩阵进行分解后的结果可以表示为：</span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><br></p>
   <p style="text-align:center;"><span style="text-align:center;color:rgb(73,59,59);font-size:15px;">A = V∑V</span><span style="font-size:12px;"><sup style="text-align:center;color:rgb(73,59,59);font-family:'微软雅黑', 0;"><span>T</span></sup></span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">通过观察上式，我们不难发现U与V矩阵是相同的，因为这个例子中，U与V矩阵本身也是对称矩阵，不论它的转置与否形式都是一样的。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">我们在第2章介绍过用于线性降维的PCA算法，该算法中有一个步骤是将协方差矩阵分解然后重建，下面我们演示一下使用Numpy的SVD算法来实现PCA算法的例子：</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><strong><span style="font-size:15px;color:#007AAA;">7. 基于SVD实现PCA算法</span></strong></p>
   <p><br></p>
   <pre class="output_wrapper" style="font-size:14px;color:rgb(79,79,79);line-height:1.8;letter-spacing:0px;font-family:'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;"></pre>
   <pre><code class="python language-python hljs" style="margin-left:2px;line-height:18px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">import&nbsp;numpy&nbsp;as&nbsp;np#&nbsp;零均值化，即中心化，是数据的预处理方法def&nbsp;zero_centered(data):&nbsp;&nbsp;&nbsp;&nbsp;matrix_mean&nbsp;=&nbsp;np.mean(data,&nbsp;axis=0)&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data&nbsp;-&nbsp;matrix_meandef&nbsp;pca_eig(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;#&nbsp;也可以用&nbsp;np.cov()&nbsp;方法&nbsp;&nbsp;&nbsp;&nbsp;eig_values,&nbsp;eig_vectors&nbsp;=&nbsp;np.linalg.eig(np.mat(cov_mat))&nbsp;&nbsp;#&nbsp;求特征值和特征向量，特征向量是列向量&nbsp;&nbsp;&nbsp;&nbsp;value_indices&nbsp;=&nbsp;np.argsort(eig_values)&nbsp;&nbsp;#&nbsp;将特征值从小到大排序&nbsp;&nbsp;&nbsp;&nbsp;n_vectors&nbsp;=&nbsp;eig_vectors[:,&nbsp;value_indices[-1:-(n&nbsp;+&nbsp;1):-1]]&nbsp;&nbsp;#&nbsp;最大的n个特征值对应的特征向量&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new_data&nbsp;*&nbsp;n_vectors&nbsp;&nbsp;#&nbsp;返回低维特征空间的数据def&nbsp;pca_svd(data,&nbsp;n):&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;&nbsp;&nbsp;U,&nbsp;s,&nbsp;V&nbsp;=&nbsp;np.linalg.svd(cov_mat)&nbsp;&nbsp;#&nbsp;将协方差矩阵奇异值分解&nbsp;&nbsp;&nbsp;&nbsp;pc&nbsp;=&nbsp;np.dot(new_data,&nbsp;U)&nbsp;&nbsp;#&nbsp;返回矩阵的第一个列向量即是降维后的结果&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;pc[:,&nbsp;0]def&nbsp;unit_test():&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;np.array(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[2.5,&nbsp;2.4],&nbsp;[0.5,&nbsp;0.7],&nbsp;[2.2,&nbsp;2.9],&nbsp;[1.9,&nbsp;2.2],&nbsp;[3.1,&nbsp;3.0],&nbsp;[2.3,&nbsp;2.7],&nbsp;[2,&nbsp;1.6],&nbsp;[1,&nbsp;1.1],&nbsp;[1.5,&nbsp;1.6],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1.1,&nbsp;0.9]])&nbsp;&nbsp;&nbsp;&nbsp;result_eig&nbsp;=&nbsp;pca_eig(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用常规的特征值分解法，将2维数据降到1维&nbsp;&nbsp;&nbsp;&nbsp;print(result_eig)&nbsp;&nbsp;&nbsp;&nbsp;result_svd&nbsp;=&nbsp;pca_svd(data,&nbsp;1)&nbsp;&nbsp;#&nbsp;使用奇异值分解法将协方差矩阵分解，得到降维结果&nbsp;&nbsp;&nbsp;&nbsp;print(result_svd)if&nbsp;__name__&nbsp;==&nbsp;'__main__':&nbsp;&nbsp;&nbsp;&nbsp;unit_test()<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">as</span>&nbsp;np<br><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;零均值化，即中心化，是数据的预处理方法</span><br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">def</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">zero_centered</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(data)</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;matrix_mean&nbsp;=&nbsp;np.mean(data,&nbsp;axis=<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">return</span>&nbsp;data&nbsp;-&nbsp;matrix_mean<br><br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">def</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">pca_eig</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(data,&nbsp;n)</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)<br>&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;也可以用&nbsp;np.cov()&nbsp;方法</span><br>&nbsp;&nbsp;&nbsp;&nbsp;eig_values,&nbsp;eig_vectors&nbsp;=&nbsp;np.linalg.eig(np.mat(cov_mat))&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;求特征值和特征向量，特征向量是列向量</span><br>&nbsp;&nbsp;&nbsp;&nbsp;value_indices&nbsp;=&nbsp;np.argsort(eig_values)&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;将特征值从小到大排序</span><br>&nbsp;&nbsp;&nbsp;&nbsp;n_vectors&nbsp;=&nbsp;eig_vectors[:,&nbsp;value_indices[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-1</span>:-(n&nbsp;+&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>):<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-1</span>]]&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;最大的n个特征值对应的特征向量</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">return</span>&nbsp;new_data&nbsp;*&nbsp;n_vectors&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;返回低维特征空间的数据</span><br><br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">def</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">pca_svd</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(data,&nbsp;n)</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;new_data&nbsp;=&nbsp;zero_centered(data)<br>&nbsp;&nbsp;&nbsp;&nbsp;cov_mat&nbsp;=&nbsp;np.dot(new_data.T,&nbsp;new_data)<br>&nbsp;&nbsp;&nbsp;&nbsp;U,&nbsp;s,&nbsp;V&nbsp;=&nbsp;np.linalg.svd(cov_mat)&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;将协方差矩阵奇异值分解</span><br>&nbsp;&nbsp;&nbsp;&nbsp;pc&nbsp;=&nbsp;np.dot(new_data,&nbsp;U)&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;返回矩阵的第一个列向量即是降维后的结果</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">return</span>&nbsp;pc[:,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>]<br><br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">def</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">unit_test</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;np.array(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2.5</span>,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2.4</span>],&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0.5</span>,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0.7</span>],&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2.2</span>,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2.9</span>],&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1.9</span>,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2.2</span>],&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3.1</span>,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3.0</span>],&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2.3</span>,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2.7</span>],&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1.6</span>],&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1.1</span>],&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1.5</span>,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1.6</span>],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1.1</span>,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0.9</span>]])<br>&nbsp;&nbsp;&nbsp;&nbsp;result_eig&nbsp;=&nbsp;pca_eig(data,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>)&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;使用常规的特征值分解法，将2维数据降到1维</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print(result_eig)<br>&nbsp;&nbsp;&nbsp;&nbsp;result_svd&nbsp;=&nbsp;pca_svd(data,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>)&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;使用奇异值分解法将协方差矩阵分解，得到降维结果</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print(result_svd)<br><br><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;__name__&nbsp;==&nbsp;<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">'__main__'</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;unit_test()<br></code></pre>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">经过降维的数据为：</span></p>
   <p><br></p>
   <pre class="output_wrapper" style="font-size:14px;color:rgb(79,79,79);line-height:1.8;letter-spacing:0px;font-family:'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;"></pre>
   <pre><code class="python language-python hljs" style="margin-left:2px;line-height:18px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">[-0.82797019&nbsp;&nbsp;1.77758033&nbsp;-0.99219749&nbsp;-0.27421042&nbsp;-1.67580142&nbsp;-0.9129491&nbsp;&nbsp;0.09910944&nbsp;&nbsp;1.14457216&nbsp;&nbsp;0.43804614&nbsp;&nbsp;1.22382056]<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1.77758033</span>&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-0.99219749</span>&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-0.27421042</span>&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-1.67580142</span>&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-0.9129491</span><br>&nbsp;&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0.09910944</span>&nbsp;&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1.14457216</span>&nbsp;&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0.43804614</span>&nbsp;&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1.22382056</span>]<br></code></pre>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">我们可以看到，数据已经从2维的变为1维的了，这两个PCA算法的计算结果是相同的。其中pca_eig() 函数是使用常规的特征值分解方法来求解的，读者可以参照前面讲述的PCA算法过程来理解这段代码。pca_svd() 函数使用奇异值分解法来求解的。这段代码虽然相对精简，但是背后是经过复杂的数学推导的，下面简要阐述一下PCA算法中奇异值分解的步骤。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">1) PCA算法中得到样本的协方差矩阵是经过零均值化处理的，将其去掉常数部分，则也可表示为：</span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;text-align:center;"><span style="color:rgb(73,59,59);text-align:center;font-size:15px;">C = X</span><span style="color:rgb(73,59,59);font-size:12px;"><sup style="text-align:center;color:rgb(73,59,59);"><span style="color:rgb(73,59,59);">T</span></sup></span><span style="text-align:justify;font-size:15px;color:rgb(73,59,59);">X</span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;"><br></span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">其中，X是经过中心化处理后的样本矩阵X. 前面我们介绍过，一个矩阵与其转置矩阵相乘的结果是一个对称矩阵。观察到协方差矩阵C便是一个对称矩阵，那么将其进行奇异值分解后则可以表示为：</span></p>
   <p><br></p>
   <p style="font-size:16px;text-align:center;"><span style="color:rgb(73,59,59);font-size:15px;">C = V∑V</span><span style="font-size:12px;"><sup style="color:rgb(73,59,59);"><span>T</span></sup></span></p>
   <p style="font-size:16px;"><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">2) 将经过中心化的样本矩阵X进行奇异值分解，可以得到：</span></p>
   <p><br></p>
   <p style="text-align:center;"><span style="text-align:center;color:rgb(73,59,59);font-size:15px;">X = U∑V</span><span style="text-align:center;font-size:12px;"><sup style="color:rgb(73,59,59);"><span style="text-align:center;">T</span></sup></span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">因此，我们可以得到：</span></p>
   <p><br></p>
   <p style="text-align:center;"><span style="text-align:center;color:rgb(73,59,59);font-size:15px;">X</span><span style="text-align:center;color:rgb(73,59,59);font-size:12px;"><sup><span style="text-align:center;color:rgb(73,59,59);">T</span></sup></span><span style="font-size:15px;color:rgb(73,59,59);">X&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p>
   <p style="text-align:center;">= (<span style="text-align:center;color:rgb(73,59,59);font-size:15px;">U∑V</span><span style="text-align:center;font-size:12px;"><sup style="color:rgb(73,59,59);"><span>T</span></sup></span>)<span style="font-size:16px;text-align:center;"><span style="text-align:center;color:rgb(73,59,59);font-size:12px;"><sup><span>T</span></sup></span>(</span><span style="text-align:center;color:rgb(73,59,59);font-size:15px;">U∑V</span><span style="text-align:center;font-size:12px;"><sup style="color:rgb(73,59,59);"><span>T</span></sup></span><span style="font-size:16px;text-align:center;">)</span></p>
   <p style="text-align:center;"><span style="font-size:16px;text-align:center;">=&nbsp;<span style="text-align:center;color:rgb(73,59,59);font-size:15px;"><span style="color:rgb(73,59,59);font-size:15px;text-align:center;">V∑</span></span><span style="text-align:center;color:rgb(73,59,59);font-size:12px;"><sup><span>T</span></sup></span><span style="text-align:center;font-size:15px;color:rgb(73,59,59);">U<span style="text-align:center;color:rgb(73,59,59);font-size:12px;"><sup><span>T</span></sup></span><span style="text-align:center;font-size:15px;color:rgb(73,59,59);">U<span style="text-align:center;color:rgb(73,59,59);font-size:15px;">∑V</span><span style="text-align:center;font-size:12px;"><sup style="color:rgb(73,59,59);"><span>T&nbsp; &nbsp; &nbsp;&nbsp;</span></sup></span></span></span></span></p>
   <p style="text-align:center;"><span style="color:rgb(73,59,59);font-size:15px;">=&nbsp;<span style="color:rgb(73,59,59);text-align:center;">V∑</span></span><span style="text-align:center;color:rgb(73,59,59);font-size:12px;"><sup><span>2</span></sup></span><span style="text-align:center;font-size:15px;color:rgb(73,59,59);">V<span style="font-size:12px;"><sup><span>T&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></sup></span></span></p>
   <pre style="font-size:16px;"><br></pre>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">奇异矩阵V中的列对应着PCA算法主成分中的主方向，因此可以得到主成分为：</span></p>
   <p><br></p>
   <p style="text-align:center;">XV&nbsp;<span style="text-align:center;">= </span><span style="text-align:center;color:rgb(73,59,59);font-size:15px;">U∑V</span><span style="text-align:center;font-size:12px;"><sup style="color:rgb(73,59,59);"><span>T</span></sup></span><span style="text-align:center;color:rgb(73,59,59);font-size:15px;">V =&nbsp;<span style="color:rgb(73,59,59);font-size:15px;text-align:center;">U∑</span></span></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">关于更详细的数学推倒过程，读者可参考该网址：</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="color:rgb(127,127,127);font-size:14px;">https://stats.stackexchange.com/questions/134282/relationship-between-svd-and-pca-how-to-use-svd-to-perform-pca</span></p>
   <p><br></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><span style="font-size:15px;color:#493B3B;">Numpy除了为我们提供常规的数学计算函数和矩阵相关操作之外，还提供了很多功能丰富的模块，随机数模块就是其中一部分。利用随机数模块可以生成随机数矩阵，比Python自带的随机数模块功能要强大，我们看一下下面这个例子。</span></p>
   <p><br></p>
   <p style="line-height:1.75em;letter-spacing:0px;"><strong><span style="font-size:15px;color:#007AAA;">8. Numpy的随机数功能演示</span></strong></p>
   <p><br></p>
   <pre><code class="python language-python hljs" style="margin-left:2px;line-height:18px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">import&nbsp;numpy&nbsp;as&nbsp;np#&nbsp;置随机数种子：np.random.seed()#&nbsp;从[1,3)中生成一个整数的随机数，连续生成10个np.random.randint(1,3,10)#&nbsp;返回：array([2,&nbsp;2,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;2,&nbsp;1,&nbsp;2,&nbsp;2])#&nbsp;若要连续产生[1,3)之间的浮点数，可以使用下述方法：2*np.random.random(10)&nbsp;+&nbsp;1'''返回：array([&nbsp;1.25705585,&nbsp;&nbsp;2.38059578,&nbsp;&nbsp;1.73232769,&nbsp;&nbsp;2.12303283,&nbsp;&nbsp;2.33946996,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.28020734,&nbsp;&nbsp;2.15724069,&nbsp;&nbsp;1.32845829,&nbsp;&nbsp;2.91361293,&nbsp;&nbsp;1.78637408])'''np.random.uniform(1,3,10)'''返回：array([&nbsp;1.37993226,&nbsp;&nbsp;1.38412227,&nbsp;&nbsp;1.18063785,&nbsp;&nbsp;1.75985962,&nbsp;&nbsp;1.42775752,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.62100074,&nbsp;&nbsp;1.71768721,&nbsp;&nbsp;1.50131522,&nbsp;&nbsp;2.20297121,&nbsp;&nbsp;1.08585819])'''#&nbsp;生成一个满足正太分布(高斯分布)的矩阵，其维度是4*4np.random.normal(size=(4,4))'''返回：array([[-1.81525915,&nbsp;-2.02236963,&nbsp;&nbsp;0.90969106,&nbsp;&nbsp;0.25448426],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1.04177298,&nbsp;-0.35408201,&nbsp;&nbsp;1.67850233,&nbsp;-0.70361323],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.30710761,&nbsp;&nbsp;0.57461312,&nbsp;-0.37867596,&nbsp;-0.74010685],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.94046747,&nbsp;&nbsp;2.37124816,&nbsp;-0.78503777,&nbsp;-0.33485225]])'''#&nbsp;随机产生10个，n=5,p=0.5的二项分布数据:np.random.binomial(n=5,p=0.5,size=10)#&nbsp;返回：array([2,&nbsp;0,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;4,&nbsp;2])data&nbsp;=&nbsp;np.arange(10)&nbsp;#&nbsp;产生一个0到9的序列np.random.choice(data,5)&nbsp;#&nbsp;从data数据中随机采集5个样本，采集过程是有放回的#&nbsp;返回：array([0,&nbsp;0,&nbsp;1,&nbsp;6,&nbsp;2])np.random.choice(data,5,replace=False)&nbsp;#从data数据中随机采集5个样本，采集过程是没有放回的#&nbsp;返回：array([0,&nbsp;4,&nbsp;3,&nbsp;9,&nbsp;7])np.random.permutation(data)&nbsp;#&nbsp;对data进行乱序，返回乱序结果#&nbsp;返回：array([2,&nbsp;8,&nbsp;6,&nbsp;4,&nbsp;9,&nbsp;1,&nbsp;3,&nbsp;5,&nbsp;7,&nbsp;0])np.random.shuffle(data)&nbsp;#&nbsp;对data进行乱序，并替换为新的dataprint(data)#&nbsp;输出：[1&nbsp;2&nbsp;8&nbsp;4&nbsp;3&nbsp;6&nbsp;9&nbsp;0&nbsp;5&nbsp;7]<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">as</span>&nbsp;np<br><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;置随机数种子：</span><br>np.random.seed()<br><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;从[1,3)中生成一个整数的随机数，连续生成10个</span><br>np.random.randint(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">10</span>)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;返回：array([2,&nbsp;2,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;2,&nbsp;1,&nbsp;2,&nbsp;2])</span><br><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;若要连续产生[1,3)之间的浮点数，可以使用下述方法：</span><br><span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>*np.random.random(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">10</span>)&nbsp;+&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span><br><span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">'''<br>返回：<br>array([&nbsp;1.25705585,&nbsp;&nbsp;2.38059578,&nbsp;&nbsp;1.73232769,&nbsp;&nbsp;2.12303283,&nbsp;&nbsp;2.33946996,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.28020734,&nbsp;&nbsp;2.15724069,&nbsp;&nbsp;1.32845829,&nbsp;&nbsp;2.91361293,&nbsp;&nbsp;1.78637408])<br>'''</span><br><br>np.random.uniform(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">3</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">10</span>)<br><span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">'''<br>返回：<br>array([&nbsp;1.37993226,&nbsp;&nbsp;1.38412227,&nbsp;&nbsp;1.18063785,&nbsp;&nbsp;1.75985962,&nbsp;&nbsp;1.42775752,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.62100074,&nbsp;&nbsp;1.71768721,&nbsp;&nbsp;1.50131522,&nbsp;&nbsp;2.20297121,&nbsp;&nbsp;1.08585819])<br>'''</span><br><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;生成一个满足正太分布(高斯分布)的矩阵，其维度是4*4</span><br>np.random.normal(size=(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">4</span>))<br><span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">'''<br>返回：<br>array([[-1.81525915,&nbsp;-2.02236963,&nbsp;&nbsp;0.90969106,&nbsp;&nbsp;0.25448426],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1.04177298,&nbsp;-0.35408201,&nbsp;&nbsp;1.67850233,&nbsp;-0.70361323],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.30710761,&nbsp;&nbsp;0.57461312,&nbsp;-0.37867596,&nbsp;-0.74010685],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.94046747,&nbsp;&nbsp;2.37124816,&nbsp;-0.78503777,&nbsp;-0.33485225]])<br>'''</span><br><br><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;随机产生10个，n=5,p=0.5的二项分布数据:</span><br>np.random.binomial(n=<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">5</span>,p=<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0.5</span>,size=<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">10</span>)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;返回：array([2,&nbsp;0,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;1,&nbsp;3,&nbsp;3,&nbsp;4,&nbsp;2])</span><br><br>data&nbsp;=&nbsp;np.arange(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">10</span>)&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;产生一个0到9的序列</span><br><br>np.random.choice(data,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">5</span>)&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;从data数据中随机采集5个样本，采集过程是有放回的</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;返回：array([0,&nbsp;0,&nbsp;1,&nbsp;6,&nbsp;2])</span><br><br>np.random.choice(data,<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">5</span>,replace=<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">False</span>)&nbsp;<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#从data数据中随机采集5个样本，采集过程是没有放回的</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;返回：array([0,&nbsp;4,&nbsp;3,&nbsp;9,&nbsp;7])</span><br><br>np.random.permutation(data)&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;对data进行乱序，返回乱序结果</span><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;返回：array([2,&nbsp;8,&nbsp;6,&nbsp;4,&nbsp;9,&nbsp;1,&nbsp;3,&nbsp;5,&nbsp;7,&nbsp;0])</span><br><br>np.random.shuffle(data)&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;对data进行乱序，并替换为新的data</span><br>print(data)<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">#&nbsp;输出：[1&nbsp;2&nbsp;8&nbsp;4&nbsp;3&nbsp;6&nbsp;9&nbsp;0&nbsp;5&nbsp;7]</span></code></pre>
   <p style="line-height:1.75em;letter-spacing:0px;"><br></p>
   <p style="font-size:16px;font-family:'微软雅黑';line-height:1.75em;"><span style="color:rgb(127,127,127);font-size:14px;">关于作者：</span><span style="color:rgb(127,127,127);font-size:14px;">王天庆，长期从事分布式系统、数据科学与工程、人工智能等方面的研究与开发，在人脸识别方面有丰富的实践经验。现就职某世界100强企业的数据实验室，从事数据科学相关技术领域的预研工作。</span></p>
   <p style="font-size:16px;font-family:'微软雅黑';line-height:1.75em;"><span style="color:rgb(127,127,127);font-size:14px;"><span style="letter-spacing:.544px;">本文摘编自《</span>Python人脸识别：从入门到工程实践<span style="letter-spacing:.544px;">》，经出版方授权发布。</span></span></p>
   <p style="font-size:16px;font-family:'微软雅黑';line-height:1.75em;"><br></p>
   <p style="font-size:16px;font-family:'微软雅黑';text-align:center;"><span style="color:rgb(127,127,127);font-size:14px;letter-spacing:.544px;">延伸阅读《</span><span style="color:rgb(127,127,127);font-size:14px;letter-spacing:.544px;text-align:justify;"><span style="letter-spacing:.544px;"><span style="letter-spacing:.544px;"><span style="letter-spacing:.544px;"><span style="letter-spacing:.544px;"><span style="letter-spacing:.544px;">Python人脸识别</span></span></span></span></span></span><span style="color:rgb(127,127,127);font-size:14px;letter-spacing:.544px;">》</span><br></p>
   <p style="font-family:'微软雅黑';min-height:1em;letter-spacing:.544px;text-align:center;font-size:14px;color:rgb(63,63,63);line-height:1.75em;"><span style="color:rgb(127,127,127);"><span style="letter-spacing:.544px;">点击上图了解及购买</span></span></p>
   <p style="font-family:'微软雅黑';min-height:1em;letter-spacing:.544px;font-size:14px;color:rgb(63,63,63);text-align:center;line-height:1.75em;"><span style="color:rgb(127,127,127);">转载请联系微信：DoctorData</span></p>
   <p style="font-size:16px;font-family:'微软雅黑';min-height:1em;letter-spacing:.544px;text-align:center;"><br></p>
   <p style="font-size:16px;font-family:'微软雅黑';min-height:1em;letter-spacing:.544px;line-height:1.75em;"><strong><span style="color:rgb(127,127,127);font-size:14px;">推荐语：</span></strong><span style="color:rgb(127,127,127);font-size:14px;">华为资深AI工程师撰写，全面讲解人脸识别各项基础技术、原理和算法，从零实现工程级人脸识别引擎。</span></p>
   <p><br></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;text-align:center;line-height:1.75em;"><img title="音符" style="letter-spacing:.544px;line-height:25.6px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPiaJQXWGyC9wrUzIicibgXayrgibTYarT3A1yzttbtaO0JlV21wMqroGYT3QtPq2C7HMYsvicSB2p7dTBg/640?" alt="640?"></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;text-align:center;line-height:1.75em;"><br></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;text-align:center;line-height:1.75em;"><span style="font-size:15px;color:rgb(73,59,59);">据统计，99%的大咖都完成了这个神操作</span></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;text-align:center;line-height:1.75em;"><span style="font-size:15px;color:rgb(73,59,59);">▼</span></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;text-align:center;line-height:1.75em;"><br></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;text-align:center;line-height:1.75em;"><img class="rich_pages" style="width:273px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/KfLGF0ibu6cJmXkAITIpknZ8zcoh12627WuIN0F7w9mpOTDJkO1lU1flVPjb4NghlSK1h0NNl94SDR5sz2lzJBw/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;text-align:center;line-height:1.75em;"><br></p>
   <p style="min-height:1em;font-family:'-apple-system-font', BlinkMacSystemFont, Arial, sans-serif;font-size:17px;letter-spacing:.5px;line-height:1.75em;"><span style="color:rgb(0,122,170);font-family:'微软雅黑';font-size:20px;">更多精彩</span></p>
   <p style="min-height:1em;font-family:'-apple-system-font', BlinkMacSystemFont, Arial, sans-serif;font-size:17px;letter-spacing:.5px;line-height:1.75em;"><br></p>
   <p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(73,59,59);">在公众号后台对话框输入以下</span><strong><span style="font-size:15px;color:rgb(0,122,170);">关键词</span></strong></p>
   <p style="line-height:1.75em;"><span style="font-size:15px;color:rgb(73,59,59);">查看更多优质内容！</span></p>
   <p style="line-height:1.75em;"><br></p>
   <p style="line-height:1.75em;"><strong style="color:rgb(73,59,59);"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">PPT</span></strong><span>&nbsp;</span></span></strong><span style="font-size:15px;color:rgb(73,59,59);">|</span><strong style="color:rgb(73,59,59);"><span style="font-size:15px;"><span>&nbsp;</span><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">报告</span></strong><span>&nbsp;</span></span></strong><span style="font-size:15px;color:rgb(73,59,59);">|</span><strong style="color:rgb(73,59,59);"><span style="font-size:15px;"><span>&nbsp;</span><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">读书</span></strong><span>&nbsp;</span></span></strong><span style="font-size:15px;color:rgb(73,59,59);">|</span><strong style="color:rgb(73,59,59);"><span style="font-size:15px;">&nbsp;<strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">书单&nbsp;</span></strong></span></strong><span style="font-size:15px;color:rgb(73,59,59);">|</span><strong style="color:rgb(73,59,59);"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">&nbsp;<span style="color:rgb(73,59,59);"><strong style="font-size:16px;"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);"><strong style="color:rgb(73,59,59);"><span><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">干货</span></strong></span></strong></span></strong></span></strong></span><span style="color:rgb(73,59,59);">&nbsp;</span></span></strong></span></strong></p>
   <p style="line-height:1.75em;"><strong style="color:rgb(73,59,59);"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">大数据</span></strong></span></strong><strong style="color:rgb(73,59,59);"><span style="font-size:15px;">&nbsp;</span></strong><span style="font-size:15px;">|</span><strong style="color:rgb(73,59,59);"><span style="font-size:15px;">&nbsp;<strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">揭秘</span></strong><span>&nbsp;</span></span></strong><span style="font-size:15px;color:rgb(73,59,59);">|</span><strong style="color:rgb(73,59,59);"><span style="font-size:15px;">&nbsp;<strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">Python&nbsp;</span></strong></span></strong><span style="font-size:15px;color:rgb(73,59,59);">|</span><strong style="color:rgb(73,59,59);"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">&nbsp;</span></strong></span></strong><strong style="color:rgb(73,59,59);"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);"><strong style="color:rgb(73,59,59);font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">可视化</span></strong></span></strong></span></strong></p>
   <p style="line-height:1.75em;"><strong style="color:rgb(73,59,59);"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);"><strong style="color:rgb(73,59,59);font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);"><span><span><strong style="letter-spacing:.544px;color:rgb(73,59,59);font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);"><strong style="color:rgb(73,59,59);font-size:16px;"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">AI</span></strong></span></strong></span></strong></span></span></span></strong></span></strong></span></strong><span style="font-size:15px;color:rgb(73,59,59);">&nbsp;|&nbsp;<strong style="letter-spacing:.544px;font-size:16px;"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">人工智能<strong style="color:rgb(73,59,59);letter-spacing:.544px;font-size:16px;"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">&nbsp;</span></strong></span></strong></span></strong></span></strong></span><span style="font-size:15px;color:rgb(73,59,59);">|</span><span style="font-size:15px;color:rgb(73,59,59);"><strong style="letter-spacing:.544px;font-size:16px;"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);"><strong style="color:rgb(73,59,59);letter-spacing:.544px;font-size:16px;"><span style="font-size:15px;">&nbsp;<strong style="letter-spacing:.544px;font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);"><strong style="color:rgb(73,59,59);font-size:16px;"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">5G</span></strong></span></strong><span style="color:rgb(73,59,59);">&nbsp;</span></span></strong></span></strong></span></strong></span></strong></span><span style="font-size:15px;color:rgb(73,59,59);">|</span><span style="font-size:15px;color:rgb(73,59,59);"><strong style="letter-spacing:.544px;font-size:16px;"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);"><strong style="color:rgb(73,59,59);letter-spacing:.544px;font-size:16px;"><span style="font-size:15px;"><strong style="letter-spacing:.544px;font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);"><span style="color:rgb(73,59,59);">&nbsp;<strong style="letter-spacing:.544px;font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">区块链</span></strong></span></span></strong></span></strong></span></strong></span></strong></span></p>
   <p style="line-height:1.75em;"><span style="font-size:15px;"><span><span style="color:rgb(0,122,170);"><strong>机器学习</strong></span></span><span style="color:rgb(73,59,59);">&nbsp;|&nbsp;</span></span><span style="font-size:15px;color:rgb(73,59,59);"><strong style="font-size:16px;"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">深度学习</span></strong></span></strong></span><span style="font-size:15px;color:rgb(73,59,59);">&nbsp;|&nbsp;</span><span style="font-size:15px;color:rgb(73,59,59);"><strong style="font-size:16px;"><span style="font-size:15px;"><strong style="font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">神经网络</span></strong></span></strong></span></p>
   <p style="line-height:1.75em;"><span style="font-size:15px;"><strong style="color:rgb(73,59,59);font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">1024&nbsp;</span></strong></span><span style="font-size:15px;color:rgb(73,59,59);">|</span><span style="font-size:15px;"><strong style="color:rgb(73,59,59);font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">&nbsp;段子&nbsp;</span></strong></span><span style="font-size:15px;color:rgb(73,59,59);">|</span><span style="font-size:15px;"><strong style="color:rgb(73,59,59);font-size:16px;"><span style="font-size:15px;color:rgb(0,122,170);">&nbsp;数学</span></strong><span style="color:rgb(73,59,59);">&nbsp;|&nbsp;</span><span><span style="color:rgb(0,122,170);"><strong>高考</strong></span></span></span></p>
   <p style="min-height:1em;font-family:'-apple-system-font', BlinkMacSystemFont, Arial, sans-serif;font-size:17px;letter-spacing:.5px;line-height:1.75em;"><br></p>
   <p style="line-height:1.75em;"><span style="color:rgb(0,122,170);font-size:20px;">猜你想看</span></p>
   <p><br></p>
   <ul class="list-paddingleft-2" style="list-style-type:square;">
    <li><p style="text-align:justify;line-height:1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODE1NDYyMA==&amp;mid=2653392741&amp;idx=2&amp;sn=f700d8d3ce2c6b83b2b18ebbcf527316&amp;chksm=bd1c37768a6bbe605afb7e5b5f2c9cab66e24de0bfcf7761ea498ba129df65a5fbcb6f49e5e9&amp;scene=21#wechat_redirect" rel="nofollow"><span style="color:rgb(0,128,255);line-height:25.6px;font-size:15px;">真正零基础Python入门：手把手教你从变量和赋值语句学起</span></a><br></p></li>
    <li><p style="text-align:justify;line-height:1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODE1NDYyMA==&amp;mid=2653392724&amp;idx=2&amp;sn=f5fb9384cd98eb2955369e99ccd6234b&amp;chksm=bd1c37478a6bbe5190ba6ab9918037c49ad399f9d455f968c1048128dfa0b78e1077ae4282ed&amp;scene=21#wechat_redirect" rel="nofollow" style="letter-spacing:.544px;"><span style="color:rgb(0,128,255);line-height:25.6px;font-size:15px;">Python实操：手把手教你用Matplotlib把数据画出来</span></a><br></p></li>
    <li><p style="text-align:justify;line-height:1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODE1NDYyMA==&amp;mid=2653392624&amp;idx=1&amp;sn=58baa4d295367bfb19204474bbe9c757&amp;chksm=bd1c36e38a6bbff52b111bb583d3b47827fc2f6c1fe87cfb950bf87d616b97723e3a5fb8c637&amp;scene=21#wechat_redirect" rel="nofollow" style="letter-spacing:.544px;"><span style="color:rgb(0,128,255);line-height:25.6px;font-size:15px;">有关华为、5G、芯片和操作系统，这些书你读过几本？</span></a><br></p></li>
    <li><p style="text-align:justify;line-height:1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODE1NDYyMA==&amp;mid=2653392598&amp;idx=2&amp;sn=a271ed4ccfbd1caa0f6c9ce1837273fb&amp;chksm=bd1c36c58a6bbfd31da3d746b9f5bcb8bea4b74d6986c99d6aaef2d9e3ef648ae94271bb65b5&amp;scene=21#wechat_redirect" rel="nofollow" style="letter-spacing:.544px;"><span style="color:rgb(0,128,255);line-height:25.6px;font-size:15px;">什么是数据？数据科学家需要掌握哪些技能？终于有人讲明白了</span></a><br></p></li>
   </ul>
   <p style="text-align:justify;line-height:1.75em;"><br></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;"><br></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;min-height:1em;color:rgb(62,62,62);text-align:center;line-height:1.75em;"><span style="font-size:20px;font-style:italic;text-align:justify;color:rgb(0,122,170);">Q:</span><span style="color:rgb(73,59,59);">&nbsp;你在用哪些工具做数学运算？</span></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;min-height:1em;color:rgb(62,62,62);text-align:center;line-height:1.75em;"><span style="color:rgb(73,59,59);">欢迎留言与大家分享</span></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;min-height:1em;color:rgb(62,62,62);text-align:center;line-height:1.75em;"><span style="color:rgb(136,136,136);font-size:14px;">觉得不错，请把这篇文章分享给你的朋友</span></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;min-height:1em;color:rgb(62,62,62);text-align:center;line-height:1.75em;"><span style="color:rgb(136,136,136);font-size:14px;">转载 / 投稿请联系：baiyu@hzbook.com</span></p>
   <p style="font-size:16px;font-family:'微软雅黑';letter-spacing:.544px;min-height:1em;color:rgb(62,62,62);text-align:center;line-height:1.75em;"><span style="color:rgb(136,136,136);font-size:14px;">更多精彩，请在后台点击“历史文章”查看</span></p>
   <p style="line-height:1.75em;"><img style="line-height:25.6px;width:558px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/KfLGF0ibu6cI6yiax4muuJvS6ywtkAXeVBHj0fiaQ9zOzAvFaEdy6LFmm6SCQSRMcvDu0gJCZlbIOC3gnnKXctkicg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="line-height:1.75em;"><img class="__bg_gif" style="font-family:'微软雅黑';font-size:16px;letter-spacing:.544px;color:rgb(62,62,62);vertical-align:middle;width:32px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/sySibtTNlGDUlOv9qqJgwfWxI9IHPymKm4aYFkJ6WOIVUtZ7ft8bDvrQTtodvXf2nkZ7a8SYL4e6oL8bfhzYdJw/640?wx_fmt=gif" alt="640?wx_fmt=gif"><span style="font-family:'微软雅黑';letter-spacing:.544px;color:rgb(62,62,62);font-size:12px;">点击<span style="color:rgb(52,83,145);">阅读原文</span>，了解更多</span></p> 
  </div> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
