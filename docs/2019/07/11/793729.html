<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>快乐的强化学习1——Q_Learning及其实现方法 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="快乐的强化学习1——Q_Learning及其实现方法" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="快乐的强化学习1——Q_Learning及其实现方法 学习前言 简介 Q-Learning算法的实现 具体实现代码 GITHUB下载连接 学习前言 刚刚从大学毕业，近来闲来无事，开始了机器学习的旅程，深度学习是机器学习的重要一环，其可以使得机器自我尝试，并通过结果进行学习。 在机器学习的过程中，我自网上了解到大神morvanzhou，一个从土木工程转向了计算机的“聪明绝顶”的、英语特好的男人。本篇文章便是按照他的深度学习教程中的Qlearning部分撰写的。 morvanzhou的python个人主页，请有兴趣的同学关注大神morvanzhou的python教程。 简介 Q-Learning是一种value-based算法，即通过判断每一步进行的价值value来进行下一步的动作，以人物的左右移动为例子，Q-Learning的核心Q-Table可以按照如下表示： 环境 &#39;Left‘ ‘Right’ 1 0 0.125 2 0.001 0.132 3 0.013 0.231 当人物处于环境1的时候，此时进行’Right‘步骤的得分为0.125，进行’Left‘步骤的得分为0，此时对于Q-Learning算法而言，其会优先选择进行’Right‘步骤，此时人物往右方向走一步，抵达同时新环境，在新环境下，Q-Learning算法会进行新的判断。在实际运用中，如果人物处于环境1，我们在进行算法初始化的时候给给予其一个e_greedy值，处于0-1之间，在e_greedy值的几率内，其会选择分值大的’Right‘步骤，如果不在则随机选择。这种设定可以让算法更多的进行尝试。 Q-Learning算法的实现 接下来我将以小男孩取得玩具为例子，讲述Q-Learning算法的执行过程。 在一开始的时候假设小男孩不知道玩具在哪里，他的Q_Table一片空白，此时他开始观测自己所处的环境，这个环境是环境1，并将这个环境加入到Q_Table中。此时，他不知道左右两个环境的情况，所以向左走向右走的得分都是0，这两个得分都是小男孩心中预测出来的，并不是真实的左右两个环境的得分，我们给这个得分一个名字叫做q_predict。 环境 &#39;Left‘ ‘Right’ 1 0 0 他往左走往右走都是有可能的，如果他往左走，他会到达环境0，环境0是一个深渊，然后小男孩就挂了。此时环境会给他一个反馈得分，由于他掉入了深渊，所以他的得分是-1，这个得分是环境0的实际得分，与上面小男孩处于环境1对环境0的预测得分不同，我们给这个得分一个名字叫做q_target，由于这个得分与上一步预测的环境0的得分不同，所以我们需要对上一个表格进行更新，这个得分会乘上学习率后在环境1的’Left’ Action得到体现。此时他的Q_Table表为。 环境 &#39;Left‘ ‘Right’ 1 -0.01 0 此时小男孩重生了，在这一轮他会选择往右走，此时他又到达了一个新环境，此时他开始观测自己所处的环境，这个环境是环境2，并将这个环境加入到Q_Table中。此时，他不知道这个新环境的情况，向左走和向右走对他来说是一样的，所以这个新环境的左右两个Actions得分都是0。 环境 &#39;Left‘ ‘Right’ 1 -0.01 0 2 0 0 此时他会随机选择一个方向走，之后不断重复探测新环境和走回旧环境的过程，如果他在不断测试中找到了最后的toys，他会得到正数得分，这个得分会一步一步驱使他走向toys。在经过许多次的尝试之后，小男孩会找到一条最快通向玩具的道路。假设环境4就是玩具，小男孩在经过多次尝试后，最后的Q_Table可能是这样。 环境 &#39;Left‘ ‘Right’ 1 -0.020 0.033 2 0.001 0.154 3 0.000 0.547 对于Q-Learning算法的主体而言，Q-Learning算法主要由两个对象组成，分别是Q-Learning的大脑和大环境。 Q-Learning的大脑包括以下部分，其对应的功能为 模块名称 作用/功能 初始化 初始化学习率、可执行动作、Q_table等参数 动作选择 根据小男孩当前所处的环境和Q_table进行动作选择 学习 根据小男孩当前所处的环境对其它环境的预测情况q_predict和下一步环境的实际情况q_target更新Q_table表 确认是否存在该环境 由于在学习之前环境是未知的，当进入一个新环境时，需要生成一个得分都为0的动作表格 大环境包括以下部分，其对应的功能为 模块名称 作用/功能 初始化 初始化环境参数、用于构建环境 图画更新 用于更新当前的图画，便于用户观察 环境观察 用于返回当前环境情况 终点观察 用于返回是否到达终点 更新坐标 用于更新当前所处位置 下一环境获取 用于获取下一步的环境的实际情况 参数归零 用于每一个世代坐标和当前行走步数的归零 在完成两个对象的构建后，需要有一个主函数将两个对象联系起来使用，主函数需要完成以下功能，我将以伪代码的形式呈现： 初始化测试环境对象 初始化Q-Learning的大脑对象 for episode in range(TIMES): 环境观察 图画更新 while(1): 终点观察 if(到达终点): 打印当前进行世代数，共使用多少步数 参数归零 break; 动作选择 获取下一步的环境的实际情况 学习 更新坐标 图画更新 在观察完Q_Learning算法的伪代码形式我们可以发现，其大脑每次学习的过程都是在获取下一步的环境的实际情况之后的，学习函数对Q-Table表更新的重要参数之一就是获取下一步的环境的实际情况。具体来说，在进行学习过程时，Q-Learning的大脑对象会根据所处的当前环境对各个动作的预测得分和下一步的环境的实际情况（最大得分）对当前环境的Q-Table表进行更新，具体的代码如下所示： def learn(self,observation_now,action,score,observation_after,done): self.check_observation(observation_after) #检查是否存在下一步的环境对应的方向状态 q_predict = self.q_table.loc[observation_now,action] #所处的当前环境对下一个动作的预测得分 if done: q_influence = score #如果完成了则下一个环境的实际情况得分为1 else: q_influence = score + self.gamma * self.q_table.loc[observation_after, :].max() #如果未完成则取下一个环境若干个动作中的最大得分作为这个环境的价值传递给当前环境 self.q_table.loc[observation_now, action] += self.lr * (q_influence - q_predict) #更新当前观测状态对应的Q值 具体实现代码 具体的实现代码分为三个部分，这是第一部分，Q-Learning的大脑： import numpy as np import pandas as pd class QL: def __init__(self, actions, learning_rate=0.05, reward_decay=0.9, e_greedy=0.9): self.actions = actions #初始化可以进行的各种行为，传入为列表 self.lr = learning_rate #学习率，用于更新Q_table的值 self.gamma = reward_decay #当没有到达终点时，下一环境对当前环境的影响 self.epsilon = e_greedy #随机选择几率为1-e_greedy，当处于e_greedy内时，不随机选择。 self.q_table = pd.DataFrame(columns=self.actions, dtype=np.float64) #生成q_table，列向量为columns def choose_action(self,observation): self.check_observation(observation) #检测是否到达过这个点，如果没到达过，在Q表中增加这个节点 action_list = self.q_table.loc[observation,:] #取出当前observation所在的不同方向 if(np.random.uniform() &lt; self.epsilon): #如果在epsilon几率内 action = np.random.choice(action_list[action_list == np.max(action_list)].index) #选出当前observation中Q值最大的方向 else: action = np.random.choice(self.actions) #如果不在epsilon内，则随机选择一个动作 return action #返回应当做的action def learn(self,observation_now,action,score,observation_after,done): self.check_observation(observation_after) #检查是否存在下一环境对应的方向状态 q_predict = self.q_table.loc[observation_now,action] #获得当前状态下，当前所作动作所对应的预测得分 if done: q_target = score #如果完成了则q_target为下一个环境的实际情况得分，本例子中此时score为1 else: q_target = score + self.gamma * self.q_table.loc[observation_after, :].max() #如果未完成则取下一个环境若干个动作中的最大得分作为这个环境的价值传递给当前环境 #根据所处的当前环境对各个动作的预测得分和下一步的环境的实际情况更新当前环境的q表 self.q_table.loc[observation_now, action] += self.lr * (q_target - q_predict) def check_observation(self,observation): if observation not in self.q_table.index: #如果不存在 self.q_table = self.q_table.append( #则通过series函数生成新的一列 pd.Series( [0]*len(self.actions), index=self.actions, name=observation,) ) 第二部分是环境的构建： import numpy as np import pandas as pd import time class Env: def __init__(self,column,maze_column): self.column = column #表示地图的长度 self.maze_column = maze_column - 1 #宝藏所在的位置 self.x = 0 #初始化x self.map = np.arange(column) #给予每个地点一个标号 self.count = 0 #用于技术一共走了多少步 def draw(self): a = [] for j in range(self.column) : #更新图画 if j == self.x: a.append(&#39;o&#39;) elif j == self.maze_column: a.append(&#39;m&#39;) else: a.append(&#39;_&#39;) interaction = &#39;&#39;.join(a) print(&#39;\r{}&#39;.format(interaction),end = &#39;&#39;) def get_observation(self): return self.map[self.x] #返回现在在所 def get_terminal(self): if self.x == self.maze_column: #如果得到了宝藏，则返回已经完成 done = True else: done = False return done def update_place(self,action): self.count += 1 #更新的时候表示已经走了一步 if action == &#39;right&#39;: if self.x &lt; self.column - 1: self.x += 1 elif action == &#39;left&#39;: #left if self.x &gt; 0: self.x -= 1 def get_target(self,action): if action == &#39;right&#39;: #获得下一步的环境的实际情况 if self.x + 1 == self.maze_column: score = 1 pre_done = True else: score = 0 pre_done = False return self.map[self.x + 1],score,pre_done elif action == &#39;left&#39;: #left if self.x - 1 == self.maze_column: score = 1 pre_done = Ture else: score = 0 pre_done = False return self.map[self.x - 1],score,pre_done def retry(self): #初始化 self.x = 0 self.count = 0 其运行的主函数为： from Env import Env from QL import QL import numpy as np import time LONG = 6 #总长度为6 MAZE_PLACE = 6 #宝藏在第六位 TIMES = 15 #进行15次迭代 people = QL([&#39;left&#39;,&#39;right&#39;]) #生成QLearn主体的对象，包含left和right site = Env(LONG,MAZE_PLACE) #生成测试环境 for episode in range(TIMES): state = site.get_observation() #观察初始环境 site.draw() #生成图像 time.sleep(0.3) #暂停 while(1): done = site.get_terminal() #判断当前环境是否到达最后 if done: #如果到达，则初始化 interaction = &#39;\n第%s次世代，共使用步数：%s。&#39;%(episode+1 ,site.count) print(interaction) site.retry() time.sleep(2) break action = people.choose_action(state) #获得下一步方向 state_after,score,pre_done = site.get_target(action) #获得下一步的环境的实际情况 people.learn(state,action,score,state_after,pre_done) #根据所处的当前环境对各个动作的预测得分和下一步的环境的实际情况更新当前环境的q表 site.update_place(action) #更新位置 state = state_after #状态更新 site.draw() #更新画布 time.sleep(0.3) print(people.q_table) 每一段代码我都给予了详细的注释，三个文件的名称分别为 QL.py，Env.py，Test.py。 （不知道为什么这个编辑器给我生成了个什么网页……- -） GITHUB下载连接 https://github.com/bubbliiiing/Reinforcement-Learning 希望得到朋友们的喜欢。 有不懂的朋友可以评论询问噢。" />
<meta property="og:description" content="快乐的强化学习1——Q_Learning及其实现方法 学习前言 简介 Q-Learning算法的实现 具体实现代码 GITHUB下载连接 学习前言 刚刚从大学毕业，近来闲来无事，开始了机器学习的旅程，深度学习是机器学习的重要一环，其可以使得机器自我尝试，并通过结果进行学习。 在机器学习的过程中，我自网上了解到大神morvanzhou，一个从土木工程转向了计算机的“聪明绝顶”的、英语特好的男人。本篇文章便是按照他的深度学习教程中的Qlearning部分撰写的。 morvanzhou的python个人主页，请有兴趣的同学关注大神morvanzhou的python教程。 简介 Q-Learning是一种value-based算法，即通过判断每一步进行的价值value来进行下一步的动作，以人物的左右移动为例子，Q-Learning的核心Q-Table可以按照如下表示： 环境 &#39;Left‘ ‘Right’ 1 0 0.125 2 0.001 0.132 3 0.013 0.231 当人物处于环境1的时候，此时进行’Right‘步骤的得分为0.125，进行’Left‘步骤的得分为0，此时对于Q-Learning算法而言，其会优先选择进行’Right‘步骤，此时人物往右方向走一步，抵达同时新环境，在新环境下，Q-Learning算法会进行新的判断。在实际运用中，如果人物处于环境1，我们在进行算法初始化的时候给给予其一个e_greedy值，处于0-1之间，在e_greedy值的几率内，其会选择分值大的’Right‘步骤，如果不在则随机选择。这种设定可以让算法更多的进行尝试。 Q-Learning算法的实现 接下来我将以小男孩取得玩具为例子，讲述Q-Learning算法的执行过程。 在一开始的时候假设小男孩不知道玩具在哪里，他的Q_Table一片空白，此时他开始观测自己所处的环境，这个环境是环境1，并将这个环境加入到Q_Table中。此时，他不知道左右两个环境的情况，所以向左走向右走的得分都是0，这两个得分都是小男孩心中预测出来的，并不是真实的左右两个环境的得分，我们给这个得分一个名字叫做q_predict。 环境 &#39;Left‘ ‘Right’ 1 0 0 他往左走往右走都是有可能的，如果他往左走，他会到达环境0，环境0是一个深渊，然后小男孩就挂了。此时环境会给他一个反馈得分，由于他掉入了深渊，所以他的得分是-1，这个得分是环境0的实际得分，与上面小男孩处于环境1对环境0的预测得分不同，我们给这个得分一个名字叫做q_target，由于这个得分与上一步预测的环境0的得分不同，所以我们需要对上一个表格进行更新，这个得分会乘上学习率后在环境1的’Left’ Action得到体现。此时他的Q_Table表为。 环境 &#39;Left‘ ‘Right’ 1 -0.01 0 此时小男孩重生了，在这一轮他会选择往右走，此时他又到达了一个新环境，此时他开始观测自己所处的环境，这个环境是环境2，并将这个环境加入到Q_Table中。此时，他不知道这个新环境的情况，向左走和向右走对他来说是一样的，所以这个新环境的左右两个Actions得分都是0。 环境 &#39;Left‘ ‘Right’ 1 -0.01 0 2 0 0 此时他会随机选择一个方向走，之后不断重复探测新环境和走回旧环境的过程，如果他在不断测试中找到了最后的toys，他会得到正数得分，这个得分会一步一步驱使他走向toys。在经过许多次的尝试之后，小男孩会找到一条最快通向玩具的道路。假设环境4就是玩具，小男孩在经过多次尝试后，最后的Q_Table可能是这样。 环境 &#39;Left‘ ‘Right’ 1 -0.020 0.033 2 0.001 0.154 3 0.000 0.547 对于Q-Learning算法的主体而言，Q-Learning算法主要由两个对象组成，分别是Q-Learning的大脑和大环境。 Q-Learning的大脑包括以下部分，其对应的功能为 模块名称 作用/功能 初始化 初始化学习率、可执行动作、Q_table等参数 动作选择 根据小男孩当前所处的环境和Q_table进行动作选择 学习 根据小男孩当前所处的环境对其它环境的预测情况q_predict和下一步环境的实际情况q_target更新Q_table表 确认是否存在该环境 由于在学习之前环境是未知的，当进入一个新环境时，需要生成一个得分都为0的动作表格 大环境包括以下部分，其对应的功能为 模块名称 作用/功能 初始化 初始化环境参数、用于构建环境 图画更新 用于更新当前的图画，便于用户观察 环境观察 用于返回当前环境情况 终点观察 用于返回是否到达终点 更新坐标 用于更新当前所处位置 下一环境获取 用于获取下一步的环境的实际情况 参数归零 用于每一个世代坐标和当前行走步数的归零 在完成两个对象的构建后，需要有一个主函数将两个对象联系起来使用，主函数需要完成以下功能，我将以伪代码的形式呈现： 初始化测试环境对象 初始化Q-Learning的大脑对象 for episode in range(TIMES): 环境观察 图画更新 while(1): 终点观察 if(到达终点): 打印当前进行世代数，共使用多少步数 参数归零 break; 动作选择 获取下一步的环境的实际情况 学习 更新坐标 图画更新 在观察完Q_Learning算法的伪代码形式我们可以发现，其大脑每次学习的过程都是在获取下一步的环境的实际情况之后的，学习函数对Q-Table表更新的重要参数之一就是获取下一步的环境的实际情况。具体来说，在进行学习过程时，Q-Learning的大脑对象会根据所处的当前环境对各个动作的预测得分和下一步的环境的实际情况（最大得分）对当前环境的Q-Table表进行更新，具体的代码如下所示： def learn(self,observation_now,action,score,observation_after,done): self.check_observation(observation_after) #检查是否存在下一步的环境对应的方向状态 q_predict = self.q_table.loc[observation_now,action] #所处的当前环境对下一个动作的预测得分 if done: q_influence = score #如果完成了则下一个环境的实际情况得分为1 else: q_influence = score + self.gamma * self.q_table.loc[observation_after, :].max() #如果未完成则取下一个环境若干个动作中的最大得分作为这个环境的价值传递给当前环境 self.q_table.loc[observation_now, action] += self.lr * (q_influence - q_predict) #更新当前观测状态对应的Q值 具体实现代码 具体的实现代码分为三个部分，这是第一部分，Q-Learning的大脑： import numpy as np import pandas as pd class QL: def __init__(self, actions, learning_rate=0.05, reward_decay=0.9, e_greedy=0.9): self.actions = actions #初始化可以进行的各种行为，传入为列表 self.lr = learning_rate #学习率，用于更新Q_table的值 self.gamma = reward_decay #当没有到达终点时，下一环境对当前环境的影响 self.epsilon = e_greedy #随机选择几率为1-e_greedy，当处于e_greedy内时，不随机选择。 self.q_table = pd.DataFrame(columns=self.actions, dtype=np.float64) #生成q_table，列向量为columns def choose_action(self,observation): self.check_observation(observation) #检测是否到达过这个点，如果没到达过，在Q表中增加这个节点 action_list = self.q_table.loc[observation,:] #取出当前observation所在的不同方向 if(np.random.uniform() &lt; self.epsilon): #如果在epsilon几率内 action = np.random.choice(action_list[action_list == np.max(action_list)].index) #选出当前observation中Q值最大的方向 else: action = np.random.choice(self.actions) #如果不在epsilon内，则随机选择一个动作 return action #返回应当做的action def learn(self,observation_now,action,score,observation_after,done): self.check_observation(observation_after) #检查是否存在下一环境对应的方向状态 q_predict = self.q_table.loc[observation_now,action] #获得当前状态下，当前所作动作所对应的预测得分 if done: q_target = score #如果完成了则q_target为下一个环境的实际情况得分，本例子中此时score为1 else: q_target = score + self.gamma * self.q_table.loc[observation_after, :].max() #如果未完成则取下一个环境若干个动作中的最大得分作为这个环境的价值传递给当前环境 #根据所处的当前环境对各个动作的预测得分和下一步的环境的实际情况更新当前环境的q表 self.q_table.loc[observation_now, action] += self.lr * (q_target - q_predict) def check_observation(self,observation): if observation not in self.q_table.index: #如果不存在 self.q_table = self.q_table.append( #则通过series函数生成新的一列 pd.Series( [0]*len(self.actions), index=self.actions, name=observation,) ) 第二部分是环境的构建： import numpy as np import pandas as pd import time class Env: def __init__(self,column,maze_column): self.column = column #表示地图的长度 self.maze_column = maze_column - 1 #宝藏所在的位置 self.x = 0 #初始化x self.map = np.arange(column) #给予每个地点一个标号 self.count = 0 #用于技术一共走了多少步 def draw(self): a = [] for j in range(self.column) : #更新图画 if j == self.x: a.append(&#39;o&#39;) elif j == self.maze_column: a.append(&#39;m&#39;) else: a.append(&#39;_&#39;) interaction = &#39;&#39;.join(a) print(&#39;\r{}&#39;.format(interaction),end = &#39;&#39;) def get_observation(self): return self.map[self.x] #返回现在在所 def get_terminal(self): if self.x == self.maze_column: #如果得到了宝藏，则返回已经完成 done = True else: done = False return done def update_place(self,action): self.count += 1 #更新的时候表示已经走了一步 if action == &#39;right&#39;: if self.x &lt; self.column - 1: self.x += 1 elif action == &#39;left&#39;: #left if self.x &gt; 0: self.x -= 1 def get_target(self,action): if action == &#39;right&#39;: #获得下一步的环境的实际情况 if self.x + 1 == self.maze_column: score = 1 pre_done = True else: score = 0 pre_done = False return self.map[self.x + 1],score,pre_done elif action == &#39;left&#39;: #left if self.x - 1 == self.maze_column: score = 1 pre_done = Ture else: score = 0 pre_done = False return self.map[self.x - 1],score,pre_done def retry(self): #初始化 self.x = 0 self.count = 0 其运行的主函数为： from Env import Env from QL import QL import numpy as np import time LONG = 6 #总长度为6 MAZE_PLACE = 6 #宝藏在第六位 TIMES = 15 #进行15次迭代 people = QL([&#39;left&#39;,&#39;right&#39;]) #生成QLearn主体的对象，包含left和right site = Env(LONG,MAZE_PLACE) #生成测试环境 for episode in range(TIMES): state = site.get_observation() #观察初始环境 site.draw() #生成图像 time.sleep(0.3) #暂停 while(1): done = site.get_terminal() #判断当前环境是否到达最后 if done: #如果到达，则初始化 interaction = &#39;\n第%s次世代，共使用步数：%s。&#39;%(episode+1 ,site.count) print(interaction) site.retry() time.sleep(2) break action = people.choose_action(state) #获得下一步方向 state_after,score,pre_done = site.get_target(action) #获得下一步的环境的实际情况 people.learn(state,action,score,state_after,pre_done) #根据所处的当前环境对各个动作的预测得分和下一步的环境的实际情况更新当前环境的q表 site.update_place(action) #更新位置 state = state_after #状态更新 site.draw() #更新画布 time.sleep(0.3) print(people.q_table) 每一段代码我都给予了详细的注释，三个文件的名称分别为 QL.py，Env.py，Test.py。 （不知道为什么这个编辑器给我生成了个什么网页……- -） GITHUB下载连接 https://github.com/bubbliiiing/Reinforcement-Learning 希望得到朋友们的喜欢。 有不懂的朋友可以评论询问噢。" />
<link rel="canonical" href="https://uzzz.org/2019/07/11/793729.html" />
<meta property="og:url" content="https://uzzz.org/2019/07/11/793729.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-11T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"快乐的强化学习1——Q_Learning及其实现方法 学习前言 简介 Q-Learning算法的实现 具体实现代码 GITHUB下载连接 学习前言 刚刚从大学毕业，近来闲来无事，开始了机器学习的旅程，深度学习是机器学习的重要一环，其可以使得机器自我尝试，并通过结果进行学习。 在机器学习的过程中，我自网上了解到大神morvanzhou，一个从土木工程转向了计算机的“聪明绝顶”的、英语特好的男人。本篇文章便是按照他的深度学习教程中的Qlearning部分撰写的。 morvanzhou的python个人主页，请有兴趣的同学关注大神morvanzhou的python教程。 简介 Q-Learning是一种value-based算法，即通过判断每一步进行的价值value来进行下一步的动作，以人物的左右移动为例子，Q-Learning的核心Q-Table可以按照如下表示： 环境 &#39;Left‘ ‘Right’ 1 0 0.125 2 0.001 0.132 3 0.013 0.231 当人物处于环境1的时候，此时进行’Right‘步骤的得分为0.125，进行’Left‘步骤的得分为0，此时对于Q-Learning算法而言，其会优先选择进行’Right‘步骤，此时人物往右方向走一步，抵达同时新环境，在新环境下，Q-Learning算法会进行新的判断。在实际运用中，如果人物处于环境1，我们在进行算法初始化的时候给给予其一个e_greedy值，处于0-1之间，在e_greedy值的几率内，其会选择分值大的’Right‘步骤，如果不在则随机选择。这种设定可以让算法更多的进行尝试。 Q-Learning算法的实现 接下来我将以小男孩取得玩具为例子，讲述Q-Learning算法的执行过程。 在一开始的时候假设小男孩不知道玩具在哪里，他的Q_Table一片空白，此时他开始观测自己所处的环境，这个环境是环境1，并将这个环境加入到Q_Table中。此时，他不知道左右两个环境的情况，所以向左走向右走的得分都是0，这两个得分都是小男孩心中预测出来的，并不是真实的左右两个环境的得分，我们给这个得分一个名字叫做q_predict。 环境 &#39;Left‘ ‘Right’ 1 0 0 他往左走往右走都是有可能的，如果他往左走，他会到达环境0，环境0是一个深渊，然后小男孩就挂了。此时环境会给他一个反馈得分，由于他掉入了深渊，所以他的得分是-1，这个得分是环境0的实际得分，与上面小男孩处于环境1对环境0的预测得分不同，我们给这个得分一个名字叫做q_target，由于这个得分与上一步预测的环境0的得分不同，所以我们需要对上一个表格进行更新，这个得分会乘上学习率后在环境1的’Left’ Action得到体现。此时他的Q_Table表为。 环境 &#39;Left‘ ‘Right’ 1 -0.01 0 此时小男孩重生了，在这一轮他会选择往右走，此时他又到达了一个新环境，此时他开始观测自己所处的环境，这个环境是环境2，并将这个环境加入到Q_Table中。此时，他不知道这个新环境的情况，向左走和向右走对他来说是一样的，所以这个新环境的左右两个Actions得分都是0。 环境 &#39;Left‘ ‘Right’ 1 -0.01 0 2 0 0 此时他会随机选择一个方向走，之后不断重复探测新环境和走回旧环境的过程，如果他在不断测试中找到了最后的toys，他会得到正数得分，这个得分会一步一步驱使他走向toys。在经过许多次的尝试之后，小男孩会找到一条最快通向玩具的道路。假设环境4就是玩具，小男孩在经过多次尝试后，最后的Q_Table可能是这样。 环境 &#39;Left‘ ‘Right’ 1 -0.020 0.033 2 0.001 0.154 3 0.000 0.547 对于Q-Learning算法的主体而言，Q-Learning算法主要由两个对象组成，分别是Q-Learning的大脑和大环境。 Q-Learning的大脑包括以下部分，其对应的功能为 模块名称 作用/功能 初始化 初始化学习率、可执行动作、Q_table等参数 动作选择 根据小男孩当前所处的环境和Q_table进行动作选择 学习 根据小男孩当前所处的环境对其它环境的预测情况q_predict和下一步环境的实际情况q_target更新Q_table表 确认是否存在该环境 由于在学习之前环境是未知的，当进入一个新环境时，需要生成一个得分都为0的动作表格 大环境包括以下部分，其对应的功能为 模块名称 作用/功能 初始化 初始化环境参数、用于构建环境 图画更新 用于更新当前的图画，便于用户观察 环境观察 用于返回当前环境情况 终点观察 用于返回是否到达终点 更新坐标 用于更新当前所处位置 下一环境获取 用于获取下一步的环境的实际情况 参数归零 用于每一个世代坐标和当前行走步数的归零 在完成两个对象的构建后，需要有一个主函数将两个对象联系起来使用，主函数需要完成以下功能，我将以伪代码的形式呈现： 初始化测试环境对象 初始化Q-Learning的大脑对象 for episode in range(TIMES): 环境观察 图画更新 while(1): 终点观察 if(到达终点): 打印当前进行世代数，共使用多少步数 参数归零 break; 动作选择 获取下一步的环境的实际情况 学习 更新坐标 图画更新 在观察完Q_Learning算法的伪代码形式我们可以发现，其大脑每次学习的过程都是在获取下一步的环境的实际情况之后的，学习函数对Q-Table表更新的重要参数之一就是获取下一步的环境的实际情况。具体来说，在进行学习过程时，Q-Learning的大脑对象会根据所处的当前环境对各个动作的预测得分和下一步的环境的实际情况（最大得分）对当前环境的Q-Table表进行更新，具体的代码如下所示： def learn(self,observation_now,action,score,observation_after,done): self.check_observation(observation_after) #检查是否存在下一步的环境对应的方向状态 q_predict = self.q_table.loc[observation_now,action] #所处的当前环境对下一个动作的预测得分 if done: q_influence = score #如果完成了则下一个环境的实际情况得分为1 else: q_influence = score + self.gamma * self.q_table.loc[observation_after, :].max() #如果未完成则取下一个环境若干个动作中的最大得分作为这个环境的价值传递给当前环境 self.q_table.loc[observation_now, action] += self.lr * (q_influence - q_predict) #更新当前观测状态对应的Q值 具体实现代码 具体的实现代码分为三个部分，这是第一部分，Q-Learning的大脑： import numpy as np import pandas as pd class QL: def __init__(self, actions, learning_rate=0.05, reward_decay=0.9, e_greedy=0.9): self.actions = actions #初始化可以进行的各种行为，传入为列表 self.lr = learning_rate #学习率，用于更新Q_table的值 self.gamma = reward_decay #当没有到达终点时，下一环境对当前环境的影响 self.epsilon = e_greedy #随机选择几率为1-e_greedy，当处于e_greedy内时，不随机选择。 self.q_table = pd.DataFrame(columns=self.actions, dtype=np.float64) #生成q_table，列向量为columns def choose_action(self,observation): self.check_observation(observation) #检测是否到达过这个点，如果没到达过，在Q表中增加这个节点 action_list = self.q_table.loc[observation,:] #取出当前observation所在的不同方向 if(np.random.uniform() &lt; self.epsilon): #如果在epsilon几率内 action = np.random.choice(action_list[action_list == np.max(action_list)].index) #选出当前observation中Q值最大的方向 else: action = np.random.choice(self.actions) #如果不在epsilon内，则随机选择一个动作 return action #返回应当做的action def learn(self,observation_now,action,score,observation_after,done): self.check_observation(observation_after) #检查是否存在下一环境对应的方向状态 q_predict = self.q_table.loc[observation_now,action] #获得当前状态下，当前所作动作所对应的预测得分 if done: q_target = score #如果完成了则q_target为下一个环境的实际情况得分，本例子中此时score为1 else: q_target = score + self.gamma * self.q_table.loc[observation_after, :].max() #如果未完成则取下一个环境若干个动作中的最大得分作为这个环境的价值传递给当前环境 #根据所处的当前环境对各个动作的预测得分和下一步的环境的实际情况更新当前环境的q表 self.q_table.loc[observation_now, action] += self.lr * (q_target - q_predict) def check_observation(self,observation): if observation not in self.q_table.index: #如果不存在 self.q_table = self.q_table.append( #则通过series函数生成新的一列 pd.Series( [0]*len(self.actions), index=self.actions, name=observation,) ) 第二部分是环境的构建： import numpy as np import pandas as pd import time class Env: def __init__(self,column,maze_column): self.column = column #表示地图的长度 self.maze_column = maze_column - 1 #宝藏所在的位置 self.x = 0 #初始化x self.map = np.arange(column) #给予每个地点一个标号 self.count = 0 #用于技术一共走了多少步 def draw(self): a = [] for j in range(self.column) : #更新图画 if j == self.x: a.append(&#39;o&#39;) elif j == self.maze_column: a.append(&#39;m&#39;) else: a.append(&#39;_&#39;) interaction = &#39;&#39;.join(a) print(&#39;\\r{}&#39;.format(interaction),end = &#39;&#39;) def get_observation(self): return self.map[self.x] #返回现在在所 def get_terminal(self): if self.x == self.maze_column: #如果得到了宝藏，则返回已经完成 done = True else: done = False return done def update_place(self,action): self.count += 1 #更新的时候表示已经走了一步 if action == &#39;right&#39;: if self.x &lt; self.column - 1: self.x += 1 elif action == &#39;left&#39;: #left if self.x &gt; 0: self.x -= 1 def get_target(self,action): if action == &#39;right&#39;: #获得下一步的环境的实际情况 if self.x + 1 == self.maze_column: score = 1 pre_done = True else: score = 0 pre_done = False return self.map[self.x + 1],score,pre_done elif action == &#39;left&#39;: #left if self.x - 1 == self.maze_column: score = 1 pre_done = Ture else: score = 0 pre_done = False return self.map[self.x - 1],score,pre_done def retry(self): #初始化 self.x = 0 self.count = 0 其运行的主函数为： from Env import Env from QL import QL import numpy as np import time LONG = 6 #总长度为6 MAZE_PLACE = 6 #宝藏在第六位 TIMES = 15 #进行15次迭代 people = QL([&#39;left&#39;,&#39;right&#39;]) #生成QLearn主体的对象，包含left和right site = Env(LONG,MAZE_PLACE) #生成测试环境 for episode in range(TIMES): state = site.get_observation() #观察初始环境 site.draw() #生成图像 time.sleep(0.3) #暂停 while(1): done = site.get_terminal() #判断当前环境是否到达最后 if done: #如果到达，则初始化 interaction = &#39;\\n第%s次世代，共使用步数：%s。&#39;%(episode+1 ,site.count) print(interaction) site.retry() time.sleep(2) break action = people.choose_action(state) #获得下一步方向 state_after,score,pre_done = site.get_target(action) #获得下一步的环境的实际情况 people.learn(state,action,score,state_after,pre_done) #根据所处的当前环境对各个动作的预测得分和下一步的环境的实际情况更新当前环境的q表 site.update_place(action) #更新位置 state = state_after #状态更新 site.draw() #更新画布 time.sleep(0.3) print(people.q_table) 每一段代码我都给予了详细的注释，三个文件的名称分别为 QL.py，Env.py，Test.py。 （不知道为什么这个编辑器给我生成了个什么网页……- -） GITHUB下载连接 https://github.com/bubbliiiing/Reinforcement-Learning 希望得到朋友们的喜欢。 有不懂的朋友可以评论询问噢。","@type":"BlogPosting","url":"https://uzzz.org/2019/07/11/793729.html","headline":"快乐的强化学习1——Q_Learning及其实现方法","dateModified":"2019-07-11T00:00:00+08:00","datePublished":"2019-07-11T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/07/11/793729.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>快乐的强化学习1——Q_Learning及其实现方法</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div id="content_views" class="markdown_views prism-tomorrow-night-eighties"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> 
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path> 
  </svg> 
  <p></p>
  <div class="toc">
   <h3>快乐的强化学习1——Q_Learning及其实现方法</h3>
   <ul>
    <li><a href="#_2" rel="nofollow" data-token="f0dcc12be3983864a58485851606c19e">学习前言</a></li>
    <ul>
     <li><a href="#_9" rel="nofollow" data-token="d11eb9aed67dcdd9ec5fbd244737327b">简介</a></li>
     <li><a href="#QLearning_18" rel="nofollow" data-token="0dbe4b728e0439f75d74228f0ca16f2d">Q-Learning算法的实现</a></li>
     <li><a href="#_89" rel="nofollow" data-token="aefdd78eddcfd3a0d976ac5144cebc9a">具体实现代码</a></li>
     <li><a href="#GITHUB_247" rel="nofollow" data-token="465046f00b2c465d548e1c45026dc245">GITHUB下载连接</a></li>
    </ul>
   </ul>
  </div>
  <p></p> 
  <h1><a id="_2"></a>学习前言</h1> 
  <p>刚刚从大学毕业，近来闲来无事，开始了机器学习的旅程，深度学习是机器学习的重要一环，其可以使得机器自我尝试，并通过结果进行学习。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723165901974.jpg#pic_center" alt="在这里插入图片描述"><br> 在机器学习的过程中，我自网上了解到大神morvanzhou，一个从土木工程转向了计算机的“聪明绝顶”的、英语特好的男人。本篇文章便是按照他的深度学习教程中的Qlearning部分撰写的。<br> <a href="https://morvanzhou.github.io/" rel="nofollow">morvanzhou的python个人主页</a>，请有兴趣的同学关注大神morvanzhou的python教程。</p> 
  <h2><a id="_9"></a>简介</h2> 
  <p>Q-Learning是一种value-based算法，即通过判断每一步进行的价值value来进行下一步的动作，以人物的左右移动为例子，Q-Learning的核心Q-Table可以按照如下表示：</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="center">环境</th> 
     <th align="center">'Left‘</th> 
     <th align="center">‘Right’</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td align="center">1</td> 
     <td align="center">0</td> 
     <td align="center">0.125</td> 
    </tr> 
    <tr> 
     <td align="center">2</td> 
     <td align="center">0.001</td> 
     <td align="center">0.132</td> 
    </tr> 
    <tr> 
     <td align="center">3</td> 
     <td align="center">0.013</td> 
     <td align="center">0.231</td> 
    </tr> 
   </tbody> 
  </table>
  <p><strong>当人物处于环境1的时候，此时进行’Right‘步骤的得分为0.125，进行’Left‘步骤的得分为0，此时对于Q-Learning算法而言，其会优先选择进行’Right‘步骤，此时人物往右方向走一步，抵达同时新环境，在新环境下，Q-Learning算法会进行新的判断。在实际运用中，如果人物处于环境1，我们在进行算法初始化的时候给给予其一个e_greedy值，处于0-1之间，在e_greedy值的几率内，其会选择分值大的’Right‘步骤，如果不在则随机选择。这种设定可以让算法更多的进行尝试。</strong></p> 
  <h2><a id="QLearning_18"></a>Q-Learning算法的实现</h2> 
  <p>接下来我将以小男孩取得玩具为例子，讲述Q-Learning算法的执行过程。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190713104623618.png" alt="小男孩取得玩具"><br> 在一开始的时候假设小男孩不知道玩具在哪里，他的Q_Table一片空白，此时他开始观测自己所处的环境，这个环境是环境1，并将这个环境加入到Q_Table中。此时，他不知道左右两个环境的情况，所以向左走向右走的得分都是0，这<strong>两个得分都是小男孩心中预测出来的，并不是真实的左右两个环境的得分，我们给这个得分一个名字叫做q_predict</strong>。</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="center">环境</th> 
     <th align="center">'Left‘</th> 
     <th align="center">‘Right’</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td align="center">1</td> 
     <td align="center">0</td> 
     <td align="center">0</td> 
    </tr> 
   </tbody> 
  </table>
  <p>他往左走往右走都是有可能的，如果他往左走，他会到达环境0，环境0是一个深渊，然后小男孩就挂了。此时环境会给他一个反馈得分，由于他掉入了深渊，所以他的得分是-1，<strong>这个得分是环境0的实际得分，与上面小男孩处于环境1对环境0的预测得分不同，我们给这个得分一个名字叫做q_target</strong>，<strong>由于这个得分与上一步预测的环境0的得分不同，所以我们需要对上一个表格进行更新</strong>，这个得分会乘上学习率后在环境1的’Left’ Action得到体现。此时他的Q_Table表为。</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="center">环境</th> 
     <th align="center">'Left‘</th> 
     <th align="center">‘Right’</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td align="center">1</td> 
     <td align="center">-0.01</td> 
     <td align="center">0</td> 
    </tr> 
   </tbody> 
  </table>
  <p>此时小男孩重生了，在这一轮他会选择往右走，此时他又到达了一个新环境，此时他开始观测自己所处的环境，这个环境是环境2，并将这个环境加入到Q_Table中。此时，他不知道这个新环境的情况，向左走和向右走对他来说是一样的，所以这个新环境的左右两个Actions得分都是0。</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="center">环境</th> 
     <th align="center">'Left‘</th> 
     <th align="center">‘Right’</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td align="center">1</td> 
     <td align="center">-0.01</td> 
     <td align="center">0</td> 
    </tr> 
    <tr> 
     <td align="center">2</td> 
     <td align="center">0</td> 
     <td align="center">0</td> 
    </tr> 
   </tbody> 
  </table>
  <p>此时他会随机选择一个方向走，之后不断重复探测新环境和走回旧环境的过程，如果他在不断测试中找到了最后的toys，他会得到正数得分，这个得分会一步一步驱使他走向toys。在经过许多次的尝试之后，小男孩会找到一条最快通向玩具的道路。假设环境4就是玩具，小男孩在经过多次尝试后，最后的Q_Table可能是这样。</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="center">环境</th> 
     <th align="center">'Left‘</th> 
     <th align="center">‘Right’</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td align="center">1</td> 
     <td align="center">-0.020</td> 
     <td align="center">0.033</td> 
    </tr> 
    <tr> 
     <td align="center">2</td> 
     <td align="center">0.001</td> 
     <td align="center">0.154</td> 
    </tr> 
    <tr> 
     <td align="center">3</td> 
     <td align="center">0.000</td> 
     <td align="center">0.547</td> 
    </tr> 
   </tbody> 
  </table>
  <p>对于Q-Learning算法的主体而言，Q-Learning算法主要由<strong>两个对象</strong>组成，分别是<strong>Q-Learning的大脑</strong>和<strong>大环境</strong>。<br> Q-Learning的大脑包括以下部分，其对应的功能为</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="center">模块名称</th> 
     <th align="center">作用/功能</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td align="center">初始化</td> 
     <td align="center">初始化学习率、可执行动作、Q_table等参数</td> 
    </tr> 
    <tr> 
     <td align="center">动作选择</td> 
     <td align="center">根据小男孩当前所处的环境和Q_table进行动作选择</td> 
    </tr> 
    <tr> 
     <td align="center">学习</td> 
     <td align="center">根据小男孩当前所处的环境对其它环境的预测情况q_predict和下一步环境的实际情况q_target更新Q_table表</td> 
    </tr> 
    <tr> 
     <td align="center">确认是否存在该环境</td> 
     <td align="center">由于在学习之前环境是未知的，当进入一个新环境时，需要生成一个得分都为0的动作表格</td> 
    </tr> 
   </tbody> 
  </table>
  <p>大环境包括以下部分，其对应的功能为</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="center">模块名称</th> 
     <th align="center">作用/功能</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td align="center">初始化</td> 
     <td align="center">初始化环境参数、用于构建环境</td> 
    </tr> 
    <tr> 
     <td align="center">图画更新</td> 
     <td align="center">用于更新当前的图画，便于用户观察</td> 
    </tr> 
    <tr> 
     <td align="center">环境观察</td> 
     <td align="center">用于返回当前环境情况</td> 
    </tr> 
    <tr> 
     <td align="center">终点观察</td> 
     <td align="center">用于返回是否到达终点</td> 
    </tr> 
    <tr> 
     <td align="center">更新坐标</td> 
     <td align="center">用于更新当前所处位置</td> 
    </tr> 
    <tr> 
     <td align="center">下一环境获取</td> 
     <td align="center">用于获取下一步的环境的实际情况</td> 
    </tr> 
    <tr> 
     <td align="center">参数归零</td> 
     <td align="center">用于每一个世代坐标和当前行走步数的归零</td> 
    </tr> 
   </tbody> 
  </table>
  <p>在完成两个对象的构建后，需要有一个主函数将<strong>两个对象</strong>联系起来使用，主函数需要完成以下功能，我将以伪代码的形式呈现：</p> 
  <pre><code>初始化测试环境对象
初始化Q-Learning的大脑对象
for episode in range(TIMES):
	环境观察
	图画更新
	while(1):
		终点观察
		if(到达终点):
			打印当前进行世代数，共使用多少步数
			参数归零
			break;
		动作选择
		获取下一步的环境的实际情况
		学习
		更新坐标
		图画更新
</code></pre> 
  <p>在观察完Q_Learning算法的伪代码形式我们可以发现，其大脑每次<strong>学习</strong>的过程都是在获取下一步的环境的实际情况之后的，学习函数对Q-Table表更新的重要参数之一就是获取下一步的环境的实际情况。具体来说，在进行学习过程时，Q-Learning的大脑对象会根据<strong>所处的当前环境对各个动作的预测得分</strong>和<strong>下一步的环境的实际情况（最大得分）<strong>对</strong>当前环境的Q-Table表</strong>进行更新，具体的代码如下所示：</p> 
  <pre><code class="prism language-python"> <span class="token keyword">def</span> <span class="token function">learn</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>observation_now<span class="token punctuation">,</span>action<span class="token punctuation">,</span>score<span class="token punctuation">,</span>observation_after<span class="token punctuation">,</span>done<span class="token punctuation">)</span><span class="token punctuation">:</span>
     self<span class="token punctuation">.</span>check_observation<span class="token punctuation">(</span>observation_after<span class="token punctuation">)</span>        <span class="token comment">#检查是否存在下一步的环境对应的方向状态</span>
     q_predict <span class="token operator">=</span> self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>observation_now<span class="token punctuation">,</span>action<span class="token punctuation">]</span>        <span class="token comment">#所处的当前环境对下一个动作的预测得分</span>
     <span class="token keyword">if</span> done<span class="token punctuation">:</span>
         q_influence <span class="token operator">=</span> score     <span class="token comment">#如果完成了则下一个环境的实际情况得分为1</span>
     <span class="token keyword">else</span><span class="token punctuation">:</span>
         q_influence <span class="token operator">=</span> score <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>observation_after<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#如果未完成则取下一个环境若干个动作中的最大得分作为这个环境的价值传递给当前环境</span>
     self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>observation_now<span class="token punctuation">,</span> action<span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>lr <span class="token operator">*</span> <span class="token punctuation">(</span>q_influence <span class="token operator">-</span> q_predict<span class="token punctuation">)</span>  <span class="token comment">#更新当前观测状态对应的Q值</span>
</code></pre> 
  <h2><a id="_89"></a>具体实现代码</h2> 
  <p>具体的实现代码分为三个部分，这是第一部分，Q-Learning的大脑：</p> 
  <pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd

<span class="token keyword">class</span> <span class="token class-name">QL</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> learning_rate<span class="token operator">=</span><span class="token number">0.05</span><span class="token punctuation">,</span> reward_decay<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">,</span> e_greedy<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>actions <span class="token operator">=</span> actions      <span class="token comment">#初始化可以进行的各种行为，传入为列表</span>
        self<span class="token punctuation">.</span>lr <span class="token operator">=</span> learning_rate     <span class="token comment">#学习率，用于更新Q_table的值</span>
        self<span class="token punctuation">.</span>gamma <span class="token operator">=</span> reward_decay   <span class="token comment">#当没有到达终点时，下一环境对当前环境的影响</span>
        self<span class="token punctuation">.</span>epsilon <span class="token operator">=</span> e_greedy     <span class="token comment">#随机选择几率为1-e_greedy，当处于e_greedy内时，不随机选择。</span>
        self<span class="token punctuation">.</span>q_table <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>columns<span class="token operator">=</span>self<span class="token punctuation">.</span>actions<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float64<span class="token punctuation">)</span>     <span class="token comment">#生成q_table，列向量为columns</span>

    <span class="token keyword">def</span> <span class="token function">choose_action</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>observation<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>check_observation<span class="token punctuation">(</span>observation<span class="token punctuation">)</span>        <span class="token comment">#检测是否到达过这个点，如果没到达过，在Q表中增加这个节点</span>
        action_list <span class="token operator">=</span> self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>observation<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span>           <span class="token comment">#取出当前observation所在的不同方向</span>
        
        <span class="token keyword">if</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>epsilon<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#如果在epsilon几率内</span>
            action <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>action_list<span class="token punctuation">[</span>action_list <span class="token operator">==</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>action_list<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">)</span>    <span class="token comment">#选出当前observation中Q值最大的方向</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            action <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actions<span class="token punctuation">)</span>      <span class="token comment">#如果不在epsilon内，则随机选择一个动作</span>
        <span class="token keyword">return</span> action                                    <span class="token comment">#返回应当做的action</span>

    <span class="token keyword">def</span> <span class="token function">learn</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>observation_now<span class="token punctuation">,</span>action<span class="token punctuation">,</span>score<span class="token punctuation">,</span>observation_after<span class="token punctuation">,</span>done<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>check_observation<span class="token punctuation">(</span>observation_after<span class="token punctuation">)</span>        <span class="token comment">#检查是否存在下一环境对应的方向状态</span>
        q_predict <span class="token operator">=</span> self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>observation_now<span class="token punctuation">,</span>action<span class="token punctuation">]</span>        <span class="token comment">#获得当前状态下，当前所作动作所对应的预测得分</span>
        <span class="token keyword">if</span> done<span class="token punctuation">:</span>
            q_target <span class="token operator">=</span> score     <span class="token comment">#如果完成了则q_target为下一个环境的实际情况得分，本例子中此时score为1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            q_target <span class="token operator">=</span> score <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>observation_after<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#如果未完成则取下一个环境若干个动作中的最大得分作为这个环境的价值传递给当前环境</span>
        <span class="token comment">#根据所处的当前环境对各个动作的预测得分和下一步的环境的实际情况更新当前环境的q表</span>
        self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>observation_now<span class="token punctuation">,</span> action<span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>lr <span class="token operator">*</span> <span class="token punctuation">(</span>q_target <span class="token operator">-</span> q_predict<span class="token punctuation">)</span>  

    <span class="token keyword">def</span> <span class="token function">check_observation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>observation<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> observation <span class="token operator">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>index<span class="token punctuation">:</span>               <span class="token comment">#如果不存在 </span>
            self<span class="token punctuation">.</span>q_table <span class="token operator">=</span> self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>append<span class="token punctuation">(</span>                 <span class="token comment">#则通过series函数生成新的一列</span>
                pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>
                    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>actions<span class="token punctuation">)</span><span class="token punctuation">,</span>
                    index<span class="token operator">=</span>self<span class="token punctuation">.</span>actions<span class="token punctuation">,</span>
                    name<span class="token operator">=</span>observation<span class="token punctuation">,</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
</code></pre> 
  <p>第二部分是环境的构建：</p> 
  <pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd
<span class="token keyword">import</span> time 

<span class="token keyword">class</span> <span class="token class-name">Env</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>column<span class="token punctuation">,</span>maze_column<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>column <span class="token operator">=</span> column                        <span class="token comment">#表示地图的长度</span>
        self<span class="token punctuation">.</span>maze_column <span class="token operator">=</span> maze_column <span class="token operator">-</span> <span class="token number">1</span>          <span class="token comment">#宝藏所在的位置</span>
        self<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span>                                  <span class="token comment">#初始化x</span>
        self<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>column<span class="token punctuation">)</span>                <span class="token comment">#给予每个地点一个标号</span>
        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>                              <span class="token comment">#用于技术一共走了多少步</span>
        

    <span class="token keyword">def</span> <span class="token function">draw</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>column<span class="token punctuation">)</span> <span class="token punctuation">:</span>               <span class="token comment">#更新图画</span>
            <span class="token keyword">if</span> j <span class="token operator">==</span> self<span class="token punctuation">.</span>x<span class="token punctuation">:</span>
                a<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'o'</span><span class="token punctuation">)</span>
            <span class="token keyword">elif</span> j <span class="token operator">==</span> self<span class="token punctuation">.</span>maze_column<span class="token punctuation">:</span>
                a<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'m'</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                a<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">)</span>
        interaction <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\r{}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>interaction<span class="token punctuation">)</span><span class="token punctuation">,</span>end <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span>
        

    <span class="token keyword">def</span> <span class="token function">get_observation</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>x<span class="token punctuation">]</span>                     <span class="token comment">#返回现在在所</span>


    <span class="token keyword">def</span> <span class="token function">get_terminal</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>x <span class="token operator">==</span> self<span class="token punctuation">.</span>maze_column<span class="token punctuation">:</span>              <span class="token comment">#如果得到了宝藏，则返回已经完成</span>
            done <span class="token operator">=</span> <span class="token boolean">True</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            done <span class="token operator">=</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> done


    <span class="token keyword">def</span> <span class="token function">update_place</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>action<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>                              <span class="token comment">#更新的时候表示已经走了一步</span>
        <span class="token keyword">if</span> action <span class="token operator">==</span> <span class="token string">'right'</span><span class="token punctuation">:</span>                                  
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>x <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>column <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">'left'</span><span class="token punctuation">:</span>   <span class="token comment">#left</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>x <span class="token operator">-=</span> <span class="token number">1</span>

    <span class="token keyword">def</span> <span class="token function">get_target</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>action<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> action <span class="token operator">==</span> <span class="token string">'right'</span><span class="token punctuation">:</span>                        <span class="token comment">#获得下一步的环境的实际情况</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>maze_column<span class="token punctuation">:</span>
                score <span class="token operator">=</span> <span class="token number">1</span>
                pre_done <span class="token operator">=</span> <span class="token boolean">True</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                score <span class="token operator">=</span> <span class="token number">0</span>
                pre_done <span class="token operator">=</span> <span class="token boolean">False</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>score<span class="token punctuation">,</span>pre_done
        <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">'left'</span><span class="token punctuation">:</span>   <span class="token comment">#left</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>x <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>maze_column<span class="token punctuation">:</span>
                score <span class="token operator">=</span> <span class="token number">1</span>
                pre_done <span class="token operator">=</span> Ture
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                score <span class="token operator">=</span> <span class="token number">0</span>
                pre_done <span class="token operator">=</span> <span class="token boolean">False</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>score<span class="token punctuation">,</span>pre_done
        


    <span class="token keyword">def</span> <span class="token function">retry</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#初始化</span>
        self<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span>
        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>
</code></pre> 
  <p>其运行的主函数为：</p> 
  <pre><code class="prism language-python"><span class="token keyword">from</span> Env <span class="token keyword">import</span> Env
<span class="token keyword">from</span> QL <span class="token keyword">import</span> QL
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> time

LONG <span class="token operator">=</span> <span class="token number">6</span>                    <span class="token comment">#总长度为6</span>
MAZE_PLACE <span class="token operator">=</span> <span class="token number">6</span>              <span class="token comment">#宝藏在第六位</span>
TIMES <span class="token operator">=</span> <span class="token number">15</span>                  <span class="token comment">#进行15次迭代</span>

people <span class="token operator">=</span> QL<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'left'</span><span class="token punctuation">,</span><span class="token string">'right'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>       <span class="token comment">#生成QLearn主体的对象，包含left和right</span>
site <span class="token operator">=</span> Env<span class="token punctuation">(</span>LONG<span class="token punctuation">,</span>MAZE_PLACE<span class="token punctuation">)</span>         <span class="token comment">#生成测试环境</span>
<span class="token keyword">for</span> episode <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>TIMES<span class="token punctuation">)</span><span class="token punctuation">:</span>
    state <span class="token operator">=</span> site<span class="token punctuation">.</span>get_observation<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#观察初始环境</span>
    site<span class="token punctuation">.</span>draw<span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token comment">#生成图像</span>
    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.3</span><span class="token punctuation">)</span>                 <span class="token comment">#暂停</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        done <span class="token operator">=</span> site<span class="token punctuation">.</span>get_terminal<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#判断当前环境是否到达最后</span>
        <span class="token keyword">if</span> done<span class="token punctuation">:</span>                    <span class="token comment">#如果到达，则初始化</span>
            interaction <span class="token operator">=</span> <span class="token string">'\n第%s次世代，共使用步数：%s。'</span><span class="token operator">%</span><span class="token punctuation">(</span>episode<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">,</span>site<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>interaction<span class="token punctuation">)</span>
            site<span class="token punctuation">.</span>retry<span class="token punctuation">(</span><span class="token punctuation">)</span>
            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span>
        action <span class="token operator">=</span> people<span class="token punctuation">.</span>choose_action<span class="token punctuation">(</span>state<span class="token punctuation">)</span>                        <span class="token comment">#获得下一步方向</span>
        state_after<span class="token punctuation">,</span>score<span class="token punctuation">,</span>pre_done <span class="token operator">=</span> site<span class="token punctuation">.</span>get_target<span class="token punctuation">(</span>action<span class="token punctuation">)</span>    <span class="token comment">#获得下一步的环境的实际情况</span>
        people<span class="token punctuation">.</span>learn<span class="token punctuation">(</span>state<span class="token punctuation">,</span>action<span class="token punctuation">,</span>score<span class="token punctuation">,</span>state_after<span class="token punctuation">,</span>pre_done<span class="token punctuation">)</span>       <span class="token comment">#根据所处的当前环境对各个动作的预测得分和下一步的环境的实际情况更新当前环境的q表</span>
        site<span class="token punctuation">.</span>update_place<span class="token punctuation">(</span>action<span class="token punctuation">)</span>                                   <span class="token comment">#更新位置</span>
        state <span class="token operator">=</span> state_after                                         <span class="token comment">#状态更新</span>
        site<span class="token punctuation">.</span>draw<span class="token punctuation">(</span><span class="token punctuation">)</span>                                                 <span class="token comment">#更新画布</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.3</span><span class="token punctuation">)</span>
    

<span class="token keyword">print</span><span class="token punctuation">(</span>people<span class="token punctuation">.</span>q_table<span class="token punctuation">)</span>

</code></pre> 
  <p>每一段代码我都给予了详细的注释，三个文件的名称分别为 <a href="http://QL.py" rel="nofollow">QL.py</a>，<a href="http://Env.py" rel="nofollow" data-token="c2ebbc8cdb33de93e29d0eeb5f301d4c">Env.py</a>，<a href="http://Test.py" rel="nofollow" data-token="9fb0ad000621785e6237a402a2d4c86f">Test.py</a>。<br> （不知道为什么这个编辑器给我生成了个什么网页……- -）</p> 
  <h2><a id="GITHUB_247"></a>GITHUB下载连接</h2> 
  <p><a href="https://github.com/bubbliiiing/Reinforcement-Learning" rel="nofollow">https://github.com/bubbliiiing/Reinforcement-Learning</a></p> 
  <p>希望得到朋友们的喜欢。</p> 
  <p><strong>有不懂的朋友可以评论询问噢。</strong></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e44c3c0e64.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
