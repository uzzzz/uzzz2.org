<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>hive 开窗函数理解区别range和row以及默认省略语句 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="hive 开窗函数理解区别range和row以及默认省略语句" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="数据准备：name，orderdate，cost jack,2017-01-01,10 tony,2017-01-02,15 jack,2017-02-03,23 tony,2017-01-01,29 jack,2017-01-01,46 jack,2017-04-06,42 tony,2017-01-07,50 jack,2017-01-08,55 mart,2017-04-08,62 mart,2017-04-09,68 neil,2017-05-10,12 mart,2017-04-11,75 neil,2017-06-12,80 mart,2017-04-13,94 需求 查询在2017年4月份购买过的顾客及总人数 查询顾客的购买明细及月购买总额 上述的场景,要将cost按照日期进行累加 查询顾客上次的购买时间 查询前20%时间的订单信息 创建hive表并导入数据 create table business( name string, orderdate string, cost int ) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;,&#39;; &nbsp; load data local inpath &quot;/opt/module/datas/business.txt&quot; into table business; 按需求查询数据 查询在2017年4月份购买过的顾客及总人数 select name,count(*) over () from business where substring(orderdate,1,7) = &#39;2017-04&#39; group by name; 查询每个月购买总额及顾客的购买明细 select name,orderdate,cost,sum(cost) over(partition by month(orderdate)) from&nbsp;business; 上述的场景,要将cost按照日期进行累加 &nbsp; select name,orderdate,cost, sum(cost) over() as s1, sum(cost) over(partition by name) as s2, sum(cost) over(partition by name order by orderdate ) as s3, sum(cost) over(partition by name order by orderdate rows between UNBOUNDED PRECEDING and current row ) as s4 from business; +-------+-------------+-------+------+------+------+------+ | name &nbsp;| &nbsp;orderdate &nbsp;| cost &nbsp;| &nbsp;s1 &nbsp;| &nbsp;s2 &nbsp;| &nbsp;s3 &nbsp;| &nbsp;s4 &nbsp;| +-------+-------------+-------+------+------+------+------+ | jack &nbsp;| 2017-01-01 &nbsp;| 10 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 10 &nbsp; | | jack &nbsp;| 2017-01-01 &nbsp;| 46 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 56 &nbsp; | | jack &nbsp;| 2017-01-08 &nbsp;| 55 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 111 &nbsp;| 111 &nbsp;| | jack &nbsp;| 2017-02-03 &nbsp;| 23 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 134 &nbsp;| 134 &nbsp;| | jack &nbsp;| 2017-04-06 &nbsp;| 42 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 176 &nbsp;| 176 &nbsp;| | mart &nbsp;| 2017-04-08 &nbsp;| 62 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 62 &nbsp; | 62 &nbsp; | | mart &nbsp;| 2017-04-09 &nbsp;| 68 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 130 &nbsp;| 130 &nbsp;| | mart &nbsp;| 2017-04-11 &nbsp;| 75 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 205 &nbsp;| 205 &nbsp;| | mart &nbsp;| 2017-04-13 &nbsp;| 94 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 299 &nbsp;| 299 &nbsp;| | neil &nbsp;| 2017-05-10 &nbsp;| 12 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 12 &nbsp; | 12 &nbsp; | | neil &nbsp;| 2017-06-12 &nbsp;| 80 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 92 &nbsp; | 92 &nbsp; | | tony &nbsp;| 2017-01-01 &nbsp;| 29 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 29 &nbsp; | 29 &nbsp; | | tony &nbsp;| 2017-01-02 &nbsp;| 15 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 44 &nbsp; | 44 &nbsp; | | tony &nbsp;| 2017-01-07 &nbsp;| 50 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 94 &nbsp; | 94 &nbsp; | +-------+-------------+-------+------+------+------+------+ &nbsp; select name,orderdate,cost, sum(cost) over(range between unbounded preceding and current row) as s1, sum(cost) over(partition by name range between unbounded preceding and current row) as s2, sum(cost) over(partition by name order by orderdate range between unbounded preceding and current row) as s3, sum(cost) over(partition by name order by orderdate rows between UNBOUNDED PRECEDING and current row ) as s4, sum(cost) over(partition by name&nbsp; rows between UNBOUNDED PRECEDING and current row ) as s5 from business; +-------+-------------+-------+------+------+------+------+ | name &nbsp;| &nbsp;orderdate &nbsp;| cost &nbsp;| &nbsp;s1 &nbsp;| &nbsp;s2 &nbsp;| &nbsp;s3 &nbsp;| &nbsp;s4 &nbsp;| +-------+-------------+-------+------+------+------+------+ | jack &nbsp;| 2017-01-01 &nbsp;| 10 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 10 &nbsp; | | jack &nbsp;| 2017-01-01 &nbsp;| 46 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 56 &nbsp; | | jack &nbsp;| 2017-01-08 &nbsp;| 55 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 111 &nbsp;| 111 &nbsp;| | jack &nbsp;| 2017-02-03 &nbsp;| 23 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 134 &nbsp;| 134 &nbsp;| | jack &nbsp;| 2017-04-06 &nbsp;| 42 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 176 &nbsp;| 176 &nbsp;| | mart &nbsp;| 2017-04-08 &nbsp;| 62 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 62 &nbsp; | 62 &nbsp; | | mart &nbsp;| 2017-04-09 &nbsp;| 68 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 130 &nbsp;| 130 &nbsp;| | mart &nbsp;| 2017-04-11 &nbsp;| 75 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 205 &nbsp;| 205 &nbsp;| | mart &nbsp;| 2017-04-13 &nbsp;| 94 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 299 &nbsp;| 299 &nbsp;| | neil &nbsp;| 2017-05-10 &nbsp;| 12 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 12 &nbsp; | 12 &nbsp; | | neil &nbsp;| 2017-06-12 &nbsp;| 80 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 92 &nbsp; | 92 &nbsp; | | tony &nbsp;| 2017-01-01 &nbsp;| 29 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 29 &nbsp; | 29 &nbsp; | | tony &nbsp;| 2017-01-02 &nbsp;| 15 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 44 &nbsp; | 44 &nbsp; | | tony &nbsp;| 2017-01-07 &nbsp;| 50 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 94 &nbsp; | 94 &nbsp; | +-------+-------------+-------+------+------+------+------+ &nbsp; 两者运行结果一致, 说明省略的 即range between unbounded preceding and current row 官方给出了说省略 的是row&nbsp;between unbounded preceding and unbounded following 如果有order by 则是省略的range&nbsp;between unbounded preceding and unbounded following 个人解释: s1&nbsp; range没有partition 所以current row 没有界限 和unbounded following 一致 结果(此处不再显示演示结果)&nbsp; s2&nbsp;&nbsp;unbounded preceding 即 同一个partition中的首行 不受order by 影响, current row 即当前行 ,当前行即name=jack&nbsp;, 因为此处为range开窗范围 range 代表name=jack的所有行, 所以结果为5个jack行之和, 关于range和row的区别请参照&nbsp;https://blog.csdn.net/xinqiku/article/details/96362796 s3&nbsp;unbounded preceding 即 同一个partition中的首行 不受order by 影响,&nbsp;current row 受order by orderdate影响 , 当前行即 name=jack,&nbsp;orderdate =2017-01-01 联合, 又因为是range开窗 所以结果为2行name=jack,&nbsp;orderdate =2017-01-01之和 (如果current row 改成unbounded following , unbounded following 则不受order by 影响 而直接指向partition的末行 结果为jack五行之和 ,此处不再显示演示结果) s4&nbsp;unbounded preceding 即 同一个partition中的首行 , current row 因为是row 开窗范围, 即当前行name=jack这一行的和, 如果当前行移到下一行,即为当前行之前的所有行之和 此为刚接触hive 总结规律所写, 不当之处请大佬留言赐教! &nbsp; 查询顾客上次的购买时间 select&nbsp; name, orderdate, cost, lag(orderdate, 1 ,&#39;1970-01-01&#39;) over(partition by name order by orderdate) from business 查询前20%时间的订单信息 SELECT * FROM ( &nbsp;&nbsp; &nbsp;SELECT * &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;,ntile(5) OVER ( &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ORDER BY orderdate &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;) n &nbsp;&nbsp; &nbsp;FROM orders &nbsp;&nbsp; &nbsp;) t WHERE t.n = 1; 解释: SELECT * &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;,ntile(5) OVER ( &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ORDER BY orderdate &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;) n &nbsp;&nbsp; &nbsp;FROM orders +----------------+---------------------+----------------+----+ | business.name &nbsp;| business.orderdate &nbsp;| business.cost &nbsp;| n &nbsp;| +----------------+---------------------+----------------+----+ | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp;| | tony &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 29 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp;| | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 46 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp;| | tony &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-02 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2 &nbsp;| | tony &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-07 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 50 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2 &nbsp;| | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-08 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 55 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2 &nbsp;| | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-02-03 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 23 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3 &nbsp;| | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-06 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 42 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3 &nbsp;| | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-08 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 62 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3 &nbsp;| | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-09 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 68 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 4 &nbsp;| | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 75 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 4 &nbsp;| | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 94 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 4 &nbsp;| | neil &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-05-10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 5 &nbsp;| | neil &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-06-12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 80 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 5 &nbsp;| +----------------+---------------------+----------------+----+ 输出为后续加了 n字段数字分为5桶 每桶为一样数字, 让后再查询此表 得出前20%数据 ntile 参考&nbsp;https://blog.csdn.net/BabyFish13/article/details/78550601 &nbsp;" />
<meta property="og:description" content="数据准备：name，orderdate，cost jack,2017-01-01,10 tony,2017-01-02,15 jack,2017-02-03,23 tony,2017-01-01,29 jack,2017-01-01,46 jack,2017-04-06,42 tony,2017-01-07,50 jack,2017-01-08,55 mart,2017-04-08,62 mart,2017-04-09,68 neil,2017-05-10,12 mart,2017-04-11,75 neil,2017-06-12,80 mart,2017-04-13,94 需求 查询在2017年4月份购买过的顾客及总人数 查询顾客的购买明细及月购买总额 上述的场景,要将cost按照日期进行累加 查询顾客上次的购买时间 查询前20%时间的订单信息 创建hive表并导入数据 create table business( name string, orderdate string, cost int ) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;,&#39;; &nbsp; load data local inpath &quot;/opt/module/datas/business.txt&quot; into table business; 按需求查询数据 查询在2017年4月份购买过的顾客及总人数 select name,count(*) over () from business where substring(orderdate,1,7) = &#39;2017-04&#39; group by name; 查询每个月购买总额及顾客的购买明细 select name,orderdate,cost,sum(cost) over(partition by month(orderdate)) from&nbsp;business; 上述的场景,要将cost按照日期进行累加 &nbsp; select name,orderdate,cost, sum(cost) over() as s1, sum(cost) over(partition by name) as s2, sum(cost) over(partition by name order by orderdate ) as s3, sum(cost) over(partition by name order by orderdate rows between UNBOUNDED PRECEDING and current row ) as s4 from business; +-------+-------------+-------+------+------+------+------+ | name &nbsp;| &nbsp;orderdate &nbsp;| cost &nbsp;| &nbsp;s1 &nbsp;| &nbsp;s2 &nbsp;| &nbsp;s3 &nbsp;| &nbsp;s4 &nbsp;| +-------+-------------+-------+------+------+------+------+ | jack &nbsp;| 2017-01-01 &nbsp;| 10 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 10 &nbsp; | | jack &nbsp;| 2017-01-01 &nbsp;| 46 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 56 &nbsp; | | jack &nbsp;| 2017-01-08 &nbsp;| 55 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 111 &nbsp;| 111 &nbsp;| | jack &nbsp;| 2017-02-03 &nbsp;| 23 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 134 &nbsp;| 134 &nbsp;| | jack &nbsp;| 2017-04-06 &nbsp;| 42 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 176 &nbsp;| 176 &nbsp;| | mart &nbsp;| 2017-04-08 &nbsp;| 62 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 62 &nbsp; | 62 &nbsp; | | mart &nbsp;| 2017-04-09 &nbsp;| 68 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 130 &nbsp;| 130 &nbsp;| | mart &nbsp;| 2017-04-11 &nbsp;| 75 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 205 &nbsp;| 205 &nbsp;| | mart &nbsp;| 2017-04-13 &nbsp;| 94 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 299 &nbsp;| 299 &nbsp;| | neil &nbsp;| 2017-05-10 &nbsp;| 12 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 12 &nbsp; | 12 &nbsp; | | neil &nbsp;| 2017-06-12 &nbsp;| 80 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 92 &nbsp; | 92 &nbsp; | | tony &nbsp;| 2017-01-01 &nbsp;| 29 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 29 &nbsp; | 29 &nbsp; | | tony &nbsp;| 2017-01-02 &nbsp;| 15 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 44 &nbsp; | 44 &nbsp; | | tony &nbsp;| 2017-01-07 &nbsp;| 50 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 94 &nbsp; | 94 &nbsp; | +-------+-------------+-------+------+------+------+------+ &nbsp; select name,orderdate,cost, sum(cost) over(range between unbounded preceding and current row) as s1, sum(cost) over(partition by name range between unbounded preceding and current row) as s2, sum(cost) over(partition by name order by orderdate range between unbounded preceding and current row) as s3, sum(cost) over(partition by name order by orderdate rows between UNBOUNDED PRECEDING and current row ) as s4, sum(cost) over(partition by name&nbsp; rows between UNBOUNDED PRECEDING and current row ) as s5 from business; +-------+-------------+-------+------+------+------+------+ | name &nbsp;| &nbsp;orderdate &nbsp;| cost &nbsp;| &nbsp;s1 &nbsp;| &nbsp;s2 &nbsp;| &nbsp;s3 &nbsp;| &nbsp;s4 &nbsp;| +-------+-------------+-------+------+------+------+------+ | jack &nbsp;| 2017-01-01 &nbsp;| 10 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 10 &nbsp; | | jack &nbsp;| 2017-01-01 &nbsp;| 46 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 56 &nbsp; | | jack &nbsp;| 2017-01-08 &nbsp;| 55 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 111 &nbsp;| 111 &nbsp;| | jack &nbsp;| 2017-02-03 &nbsp;| 23 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 134 &nbsp;| 134 &nbsp;| | jack &nbsp;| 2017-04-06 &nbsp;| 42 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 176 &nbsp;| 176 &nbsp;| | mart &nbsp;| 2017-04-08 &nbsp;| 62 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 62 &nbsp; | 62 &nbsp; | | mart &nbsp;| 2017-04-09 &nbsp;| 68 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 130 &nbsp;| 130 &nbsp;| | mart &nbsp;| 2017-04-11 &nbsp;| 75 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 205 &nbsp;| 205 &nbsp;| | mart &nbsp;| 2017-04-13 &nbsp;| 94 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 299 &nbsp;| 299 &nbsp;| | neil &nbsp;| 2017-05-10 &nbsp;| 12 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 12 &nbsp; | 12 &nbsp; | | neil &nbsp;| 2017-06-12 &nbsp;| 80 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 92 &nbsp; | 92 &nbsp; | | tony &nbsp;| 2017-01-01 &nbsp;| 29 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 29 &nbsp; | 29 &nbsp; | | tony &nbsp;| 2017-01-02 &nbsp;| 15 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 44 &nbsp; | 44 &nbsp; | | tony &nbsp;| 2017-01-07 &nbsp;| 50 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 94 &nbsp; | 94 &nbsp; | +-------+-------------+-------+------+------+------+------+ &nbsp; 两者运行结果一致, 说明省略的 即range between unbounded preceding and current row 官方给出了说省略 的是row&nbsp;between unbounded preceding and unbounded following 如果有order by 则是省略的range&nbsp;between unbounded preceding and unbounded following 个人解释: s1&nbsp; range没有partition 所以current row 没有界限 和unbounded following 一致 结果(此处不再显示演示结果)&nbsp; s2&nbsp;&nbsp;unbounded preceding 即 同一个partition中的首行 不受order by 影响, current row 即当前行 ,当前行即name=jack&nbsp;, 因为此处为range开窗范围 range 代表name=jack的所有行, 所以结果为5个jack行之和, 关于range和row的区别请参照&nbsp;https://blog.csdn.net/xinqiku/article/details/96362796 s3&nbsp;unbounded preceding 即 同一个partition中的首行 不受order by 影响,&nbsp;current row 受order by orderdate影响 , 当前行即 name=jack,&nbsp;orderdate =2017-01-01 联合, 又因为是range开窗 所以结果为2行name=jack,&nbsp;orderdate =2017-01-01之和 (如果current row 改成unbounded following , unbounded following 则不受order by 影响 而直接指向partition的末行 结果为jack五行之和 ,此处不再显示演示结果) s4&nbsp;unbounded preceding 即 同一个partition中的首行 , current row 因为是row 开窗范围, 即当前行name=jack这一行的和, 如果当前行移到下一行,即为当前行之前的所有行之和 此为刚接触hive 总结规律所写, 不当之处请大佬留言赐教! &nbsp; 查询顾客上次的购买时间 select&nbsp; name, orderdate, cost, lag(orderdate, 1 ,&#39;1970-01-01&#39;) over(partition by name order by orderdate) from business 查询前20%时间的订单信息 SELECT * FROM ( &nbsp;&nbsp; &nbsp;SELECT * &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;,ntile(5) OVER ( &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ORDER BY orderdate &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;) n &nbsp;&nbsp; &nbsp;FROM orders &nbsp;&nbsp; &nbsp;) t WHERE t.n = 1; 解释: SELECT * &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;,ntile(5) OVER ( &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ORDER BY orderdate &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;) n &nbsp;&nbsp; &nbsp;FROM orders +----------------+---------------------+----------------+----+ | business.name &nbsp;| business.orderdate &nbsp;| business.cost &nbsp;| n &nbsp;| +----------------+---------------------+----------------+----+ | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp;| | tony &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 29 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp;| | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 46 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp;| | tony &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-02 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2 &nbsp;| | tony &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-07 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 50 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2 &nbsp;| | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-08 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 55 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2 &nbsp;| | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-02-03 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 23 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3 &nbsp;| | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-06 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 42 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3 &nbsp;| | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-08 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 62 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3 &nbsp;| | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-09 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 68 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 4 &nbsp;| | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 75 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 4 &nbsp;| | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 94 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 4 &nbsp;| | neil &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-05-10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 5 &nbsp;| | neil &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-06-12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 80 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 5 &nbsp;| +----------------+---------------------+----------------+----+ 输出为后续加了 n字段数字分为5桶 每桶为一样数字, 让后再查询此表 得出前20%数据 ntile 参考&nbsp;https://blog.csdn.net/BabyFish13/article/details/78550601 &nbsp;" />
<link rel="canonical" href="https://uzzz.org/2019/07/20/795178.html" />
<meta property="og:url" content="https://uzzz.org/2019/07/20/795178.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-20T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"数据准备：name，orderdate，cost jack,2017-01-01,10 tony,2017-01-02,15 jack,2017-02-03,23 tony,2017-01-01,29 jack,2017-01-01,46 jack,2017-04-06,42 tony,2017-01-07,50 jack,2017-01-08,55 mart,2017-04-08,62 mart,2017-04-09,68 neil,2017-05-10,12 mart,2017-04-11,75 neil,2017-06-12,80 mart,2017-04-13,94 需求 查询在2017年4月份购买过的顾客及总人数 查询顾客的购买明细及月购买总额 上述的场景,要将cost按照日期进行累加 查询顾客上次的购买时间 查询前20%时间的订单信息 创建hive表并导入数据 create table business( name string, orderdate string, cost int ) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;,&#39;; &nbsp; load data local inpath &quot;/opt/module/datas/business.txt&quot; into table business; 按需求查询数据 查询在2017年4月份购买过的顾客及总人数 select name,count(*) over () from business where substring(orderdate,1,7) = &#39;2017-04&#39; group by name; 查询每个月购买总额及顾客的购买明细 select name,orderdate,cost,sum(cost) over(partition by month(orderdate)) from&nbsp;business; 上述的场景,要将cost按照日期进行累加 &nbsp; select name,orderdate,cost, sum(cost) over() as s1, sum(cost) over(partition by name) as s2, sum(cost) over(partition by name order by orderdate ) as s3, sum(cost) over(partition by name order by orderdate rows between UNBOUNDED PRECEDING and current row ) as s4 from business; +-------+-------------+-------+------+------+------+------+ | name &nbsp;| &nbsp;orderdate &nbsp;| cost &nbsp;| &nbsp;s1 &nbsp;| &nbsp;s2 &nbsp;| &nbsp;s3 &nbsp;| &nbsp;s4 &nbsp;| +-------+-------------+-------+------+------+------+------+ | jack &nbsp;| 2017-01-01 &nbsp;| 10 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 10 &nbsp; | | jack &nbsp;| 2017-01-01 &nbsp;| 46 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 56 &nbsp; | | jack &nbsp;| 2017-01-08 &nbsp;| 55 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 111 &nbsp;| 111 &nbsp;| | jack &nbsp;| 2017-02-03 &nbsp;| 23 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 134 &nbsp;| 134 &nbsp;| | jack &nbsp;| 2017-04-06 &nbsp;| 42 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 176 &nbsp;| 176 &nbsp;| | mart &nbsp;| 2017-04-08 &nbsp;| 62 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 62 &nbsp; | 62 &nbsp; | | mart &nbsp;| 2017-04-09 &nbsp;| 68 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 130 &nbsp;| 130 &nbsp;| | mart &nbsp;| 2017-04-11 &nbsp;| 75 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 205 &nbsp;| 205 &nbsp;| | mart &nbsp;| 2017-04-13 &nbsp;| 94 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 299 &nbsp;| 299 &nbsp;| | neil &nbsp;| 2017-05-10 &nbsp;| 12 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 12 &nbsp; | 12 &nbsp; | | neil &nbsp;| 2017-06-12 &nbsp;| 80 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 92 &nbsp; | 92 &nbsp; | | tony &nbsp;| 2017-01-01 &nbsp;| 29 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 29 &nbsp; | 29 &nbsp; | | tony &nbsp;| 2017-01-02 &nbsp;| 15 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 44 &nbsp; | 44 &nbsp; | | tony &nbsp;| 2017-01-07 &nbsp;| 50 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 94 &nbsp; | 94 &nbsp; | +-------+-------------+-------+------+------+------+------+ &nbsp; select name,orderdate,cost, sum(cost) over(range between unbounded preceding and current row) as s1, sum(cost) over(partition by name range between unbounded preceding and current row) as s2, sum(cost) over(partition by name order by orderdate range between unbounded preceding and current row) as s3, sum(cost) over(partition by name order by orderdate rows between UNBOUNDED PRECEDING and current row ) as s4, sum(cost) over(partition by name&nbsp; rows between UNBOUNDED PRECEDING and current row ) as s5 from business; +-------+-------------+-------+------+------+------+------+ | name &nbsp;| &nbsp;orderdate &nbsp;| cost &nbsp;| &nbsp;s1 &nbsp;| &nbsp;s2 &nbsp;| &nbsp;s3 &nbsp;| &nbsp;s4 &nbsp;| +-------+-------------+-------+------+------+------+------+ | jack &nbsp;| 2017-01-01 &nbsp;| 10 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 10 &nbsp; | | jack &nbsp;| 2017-01-01 &nbsp;| 46 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 56 &nbsp; | | jack &nbsp;| 2017-01-08 &nbsp;| 55 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 111 &nbsp;| 111 &nbsp;| | jack &nbsp;| 2017-02-03 &nbsp;| 23 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 134 &nbsp;| 134 &nbsp;| | jack &nbsp;| 2017-04-06 &nbsp;| 42 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 176 &nbsp;| 176 &nbsp;| | mart &nbsp;| 2017-04-08 &nbsp;| 62 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 62 &nbsp; | 62 &nbsp; | | mart &nbsp;| 2017-04-09 &nbsp;| 68 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 130 &nbsp;| 130 &nbsp;| | mart &nbsp;| 2017-04-11 &nbsp;| 75 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 205 &nbsp;| 205 &nbsp;| | mart &nbsp;| 2017-04-13 &nbsp;| 94 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 299 &nbsp;| 299 &nbsp;| | neil &nbsp;| 2017-05-10 &nbsp;| 12 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 12 &nbsp; | 12 &nbsp; | | neil &nbsp;| 2017-06-12 &nbsp;| 80 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 92 &nbsp; | 92 &nbsp; | | tony &nbsp;| 2017-01-01 &nbsp;| 29 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 29 &nbsp; | 29 &nbsp; | | tony &nbsp;| 2017-01-02 &nbsp;| 15 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 44 &nbsp; | 44 &nbsp; | | tony &nbsp;| 2017-01-07 &nbsp;| 50 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 94 &nbsp; | 94 &nbsp; | +-------+-------------+-------+------+------+------+------+ &nbsp; 两者运行结果一致, 说明省略的 即range between unbounded preceding and current row 官方给出了说省略 的是row&nbsp;between unbounded preceding and unbounded following 如果有order by 则是省略的range&nbsp;between unbounded preceding and unbounded following 个人解释: s1&nbsp; range没有partition 所以current row 没有界限 和unbounded following 一致 结果(此处不再显示演示结果)&nbsp; s2&nbsp;&nbsp;unbounded preceding 即 同一个partition中的首行 不受order by 影响, current row 即当前行 ,当前行即name=jack&nbsp;, 因为此处为range开窗范围 range 代表name=jack的所有行, 所以结果为5个jack行之和, 关于range和row的区别请参照&nbsp;https://blog.csdn.net/xinqiku/article/details/96362796 s3&nbsp;unbounded preceding 即 同一个partition中的首行 不受order by 影响,&nbsp;current row 受order by orderdate影响 , 当前行即 name=jack,&nbsp;orderdate =2017-01-01 联合, 又因为是range开窗 所以结果为2行name=jack,&nbsp;orderdate =2017-01-01之和 (如果current row 改成unbounded following , unbounded following 则不受order by 影响 而直接指向partition的末行 结果为jack五行之和 ,此处不再显示演示结果) s4&nbsp;unbounded preceding 即 同一个partition中的首行 , current row 因为是row 开窗范围, 即当前行name=jack这一行的和, 如果当前行移到下一行,即为当前行之前的所有行之和 此为刚接触hive 总结规律所写, 不当之处请大佬留言赐教! &nbsp; 查询顾客上次的购买时间 select&nbsp; name, orderdate, cost, lag(orderdate, 1 ,&#39;1970-01-01&#39;) over(partition by name order by orderdate) from business 查询前20%时间的订单信息 SELECT * FROM ( &nbsp;&nbsp; &nbsp;SELECT * &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;,ntile(5) OVER ( &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ORDER BY orderdate &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;) n &nbsp;&nbsp; &nbsp;FROM orders &nbsp;&nbsp; &nbsp;) t WHERE t.n = 1; 解释: SELECT * &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;,ntile(5) OVER ( &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ORDER BY orderdate &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;) n &nbsp;&nbsp; &nbsp;FROM orders +----------------+---------------------+----------------+----+ | business.name &nbsp;| business.orderdate &nbsp;| business.cost &nbsp;| n &nbsp;| +----------------+---------------------+----------------+----+ | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp;| | tony &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 29 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp;| | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 46 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp;| | tony &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-02 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2 &nbsp;| | tony &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-07 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 50 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2 &nbsp;| | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-08 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 55 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2 &nbsp;| | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-02-03 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 23 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3 &nbsp;| | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-06 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 42 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3 &nbsp;| | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-08 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 62 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3 &nbsp;| | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-09 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 68 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 4 &nbsp;| | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 75 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 4 &nbsp;| | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 94 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 4 &nbsp;| | neil &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-05-10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 5 &nbsp;| | neil &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-06-12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 80 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 5 &nbsp;| +----------------+---------------------+----------------+----+ 输出为后续加了 n字段数字分为5桶 每桶为一样数字, 让后再查询此表 得出前20%数据 ntile 参考&nbsp;https://blog.csdn.net/BabyFish13/article/details/78550601 &nbsp;","@type":"BlogPosting","url":"https://uzzz.org/2019/07/20/795178.html","headline":"hive 开窗函数理解区别range和row以及默认省略语句","dateModified":"2019-07-20T00:00:00+08:00","datePublished":"2019-07-20T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/07/20/795178.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>hive 开窗函数理解区别range和row以及默认省略语句</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1>数据准备：name，orderdate，cost</h1> 
  <p style="margin-left:0cm;"><br><span style="color:#000000;">jack,2017-01-01,10<br> tony,2017-01-02,15<br> jack,2017-02-03,23<br> tony,2017-01-01,29<br> jack,2017-01-01,46<br> jack,2017-04-06,42<br> tony,2017-01-07,50<br> jack,2017-01-08,55<br> mart,2017-04-08,62<br> mart,2017-04-09,68<br> neil,2017-05-10,12<br> mart,2017-04-11,75<br> neil,2017-06-12,80<br> mart,2017-04-13,94</span></p> 
  <h1 style="margin-left:0cm;">需求</h1> 
  <ol>
   <li>查询在2017年4月份购买过的顾客及总人数</li> 
   <li>查询顾客的购买明细及月购买总额</li> 
   <li>上述的场景,要将cost按照日期进行累加</li> 
   <li>查询顾客上次的购买时间</li> 
   <li>查询前20%时间的订单信息</li> 
  </ol>
  <h1 style="margin-left:0cm;">创建hive表并导入数据</h1> 
  <p style="margin-left:0cm;"><span style="color:#000000;">create table business(</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">name string, </span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">orderdate string,</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">cost int</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">) ROW FORMAT DELIMITED FIELDS TERMINATED BY ',';</span></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p>load data local inpath "/opt/module/datas/business.txt" into table business;</p> 
  <h1 style="margin-left:0cm;">按需求查询数据</h1> 
  <p style="margin-left:0cm;">查询在2017年4月份购买过的顾客及总人数</p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">select name,count(*) over () </span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">from business</span></p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">where substring(orderdate,1,7) = '2017-04' </span></p> 
  <p>group by name;</p> 
  <p>查询每个月购买总额及顾客的购买明细</p> 
  <p style="margin-left:0cm;"><span style="color:#000000;">select name,orderdate,cost,sum(cost) over(partition by month(orderdate)) from</span>&nbsp;business;</p> 
  <h2>上述的场景,要将cost按照日期进行累加</h2> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p>select name,orderdate,cost,<br> sum(cost) over() as s1,<br> sum(cost) over(partition by name) as s2,<br> sum(cost) over(partition by name order by orderdate ) as s3,<br> sum(cost) over(partition by name order by orderdate rows between UNBOUNDED PRECEDING and current row ) as s4<br> from business;</p> 
  <p>+-------+-------------+-------+------+------+------+------+<br> | name &nbsp;| &nbsp;orderdate &nbsp;| cost &nbsp;| &nbsp;s1 &nbsp;| &nbsp;s2 &nbsp;| &nbsp;s3 &nbsp;| &nbsp;s4 &nbsp;|<br> +-------+-------------+-------+------+------+------+------+<br> | jack &nbsp;| 2017-01-01 &nbsp;| 10 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 10 &nbsp; |<br> | jack &nbsp;| 2017-01-01 &nbsp;| 46 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 56 &nbsp; |<br> | jack &nbsp;| 2017-01-08 &nbsp;| 55 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 111 &nbsp;| 111 &nbsp;|<br> | jack &nbsp;| 2017-02-03 &nbsp;| 23 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 134 &nbsp;| 134 &nbsp;|<br> | jack &nbsp;| 2017-04-06 &nbsp;| 42 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 176 &nbsp;| 176 &nbsp;|<br> | mart &nbsp;| 2017-04-08 &nbsp;| 62 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 62 &nbsp; | 62 &nbsp; |<br> | mart &nbsp;| 2017-04-09 &nbsp;| 68 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 130 &nbsp;| 130 &nbsp;|<br> | mart &nbsp;| 2017-04-11 &nbsp;| 75 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 205 &nbsp;| 205 &nbsp;|<br> | mart &nbsp;| 2017-04-13 &nbsp;| 94 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 299 &nbsp;| 299 &nbsp;|<br> | neil &nbsp;| 2017-05-10 &nbsp;| 12 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 12 &nbsp; | 12 &nbsp; |<br> | neil &nbsp;| 2017-06-12 &nbsp;| 80 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 92 &nbsp; | 92 &nbsp; |<br> | tony &nbsp;| 2017-01-01 &nbsp;| 29 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 29 &nbsp; | 29 &nbsp; |<br> | tony &nbsp;| 2017-01-02 &nbsp;| 15 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 44 &nbsp; | 44 &nbsp; |<br> | tony &nbsp;| 2017-01-07 &nbsp;| 50 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 94 &nbsp; | 94 &nbsp; |<br> +-------+-------------+-------+------+------+------+------+<br> &nbsp;</p> 
  <p>select name,orderdate,cost,<br> sum(cost) over(range between unbounded preceding and current row) as s1,<br> sum(cost) over(partition by name range between unbounded preceding and current row) as s2,<br> sum(cost) over(partition by name order by orderdate range between unbounded preceding and current row) as s3,<br> sum(cost) over(partition by name order by orderdate rows between UNBOUNDED PRECEDING and current row ) as s4,</p> 
  <p>sum(cost) over(partition by name&nbsp; rows between UNBOUNDED PRECEDING and current row ) as s5<br> from business;</p> 
  <p>+-------+-------------+-------+------+------+------+------+<br> | name &nbsp;| &nbsp;orderdate &nbsp;| cost &nbsp;| &nbsp;s1 &nbsp;| &nbsp;s2 &nbsp;| &nbsp;s3 &nbsp;| &nbsp;s4 &nbsp;|<br> +-------+-------------+-------+------+------+------+------+<br> | jack &nbsp;| 2017-01-01 &nbsp;| 10 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 10 &nbsp; |<br> | jack &nbsp;| 2017-01-01 &nbsp;| 46 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 56 &nbsp; | 56 &nbsp; |<br> | jack &nbsp;| 2017-01-08 &nbsp;| 55 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 111 &nbsp;| 111 &nbsp;|<br> | jack &nbsp;| 2017-02-03 &nbsp;| 23 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 134 &nbsp;| 134 &nbsp;|<br> | jack &nbsp;| 2017-04-06 &nbsp;| 42 &nbsp; &nbsp;| 661 &nbsp;| 176 &nbsp;| 176 &nbsp;| 176 &nbsp;|<br> | mart &nbsp;| 2017-04-08 &nbsp;| 62 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 62 &nbsp; | 62 &nbsp; |<br> | mart &nbsp;| 2017-04-09 &nbsp;| 68 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 130 &nbsp;| 130 &nbsp;|<br> | mart &nbsp;| 2017-04-11 &nbsp;| 75 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 205 &nbsp;| 205 &nbsp;|<br> | mart &nbsp;| 2017-04-13 &nbsp;| 94 &nbsp; &nbsp;| 661 &nbsp;| 299 &nbsp;| 299 &nbsp;| 299 &nbsp;|<br> | neil &nbsp;| 2017-05-10 &nbsp;| 12 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 12 &nbsp; | 12 &nbsp; |<br> | neil &nbsp;| 2017-06-12 &nbsp;| 80 &nbsp; &nbsp;| 661 &nbsp;| 92 &nbsp; | 92 &nbsp; | 92 &nbsp; |<br> | tony &nbsp;| 2017-01-01 &nbsp;| 29 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 29 &nbsp; | 29 &nbsp; |<br> | tony &nbsp;| 2017-01-02 &nbsp;| 15 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 44 &nbsp; | 44 &nbsp; |<br> | tony &nbsp;| 2017-01-07 &nbsp;| 50 &nbsp; &nbsp;| 661 &nbsp;| 94 &nbsp; | 94 &nbsp; | 94 &nbsp; |<br> +-------+-------------+-------+------+------+------+------+<br> &nbsp;</p> 
  <p>两者运行结果一致, 说明省略的 即range between unbounded preceding and current row</p> 
  <p>官方给出了说省略 的是row&nbsp;between unbounded preceding and unbounded following</p> 
  <p>如果有order by 则是省略的range&nbsp;between unbounded preceding and unbounded following</p> 
  <p>个人解释:</p> 
  <p>s1&nbsp; range没有partition 所以current row 没有界限 和unbounded following 一致 结果(此处不再显示演示结果)&nbsp;</p> 
  <p>s2&nbsp;&nbsp;unbounded preceding 即 同一个partition中的首行 不受order by 影响, current row 即当前行 ,当前行即name=jack&nbsp;, 因为此处为range开窗范围</p> 
  <p>range 代表name=jack的所有行, 所以结果为5个jack行之和, 关于range和row的区别请参照&nbsp;<a href="https://blog.csdn.net/xinqiku/article/details/96362796" rel="nofollow" data-token="60d163b5fc0e33039c5162c30d76842a">https://blog.csdn.net/xinqiku/article/details/96362796</a></p> 
  <p>s3&nbsp;unbounded preceding 即 同一个partition中的首行 不受order by 影响,&nbsp;current row 受order by orderdate影响 , 当前行即 name=jack,&nbsp;orderdate =2017-01-01 联合, 又因为是range开窗 所以结果为2行name=jack,&nbsp;orderdate =2017-01-01之和 (如果current row 改成unbounded following , unbounded following 则不受order by 影响 而直接指向partition的末行 结果为jack五行之和 ,此处不再显示演示结果)</p> 
  <p>s4&nbsp;unbounded preceding 即 同一个partition中的首行 , current row 因为是row 开窗范围, 即当前行name=jack这一行的和, 如果当前行移到下一行,即为当前行之前的所有行之和</p> 
  <p>此为刚接触hive 总结规律所写, 不当之处请大佬留言赐教!</p> 
  <p>&nbsp;</p> 
  <h2>查询顾客上次的购买时间</h2> 
  <p>select&nbsp;<br> name, orderdate, cost,<br> lag(orderdate, 1 ,'1970-01-01') over(partition by name order by orderdate)<br> from<br> business</p> 
  <h2>查询前20%时间的订单信息</h2> 
  <p>SELECT *<br> FROM (<br> &nbsp;&nbsp; &nbsp;SELECT *<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;,ntile(5) OVER (<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ORDER BY orderdate<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;) n<br> &nbsp;&nbsp; &nbsp;FROM orders<br> &nbsp;&nbsp; &nbsp;) t<br> WHERE t.n = 1;</p> 
  <p>解释:</p> 
  <p>SELECT *<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;,ntile(5) OVER (<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ORDER BY orderdate<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;) n<br> &nbsp;&nbsp; &nbsp;FROM orders</p> 
  <p>+----------------+---------------------+----------------+----+<br> | business.name &nbsp;| business.orderdate &nbsp;| business.cost &nbsp;| n &nbsp;|<br> +----------------+---------------------+----------------+----+<br> | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp;|<br> | tony &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 29 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp;|<br> | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 46 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 1 &nbsp;|<br> | tony &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-02 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2 &nbsp;|<br> | tony &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-07 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 50 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2 &nbsp;|<br> | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-01-08 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 55 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2 &nbsp;|<br> | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-02-03 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 23 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3 &nbsp;|<br> | jack &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-06 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 42 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3 &nbsp;|<br> | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-08 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 62 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 3 &nbsp;|<br> | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-09 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 68 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 4 &nbsp;|<br> | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 75 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 4 &nbsp;|<br> | mart &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-04-13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 94 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 4 &nbsp;|<br> | neil &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-05-10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 5 &nbsp;|<br> | neil &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 2017-06-12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 80 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 5 &nbsp;|<br> +----------------+---------------------+----------------+----+</p> 
  <p>输出为后续加了 n字段数字分为5桶 每桶为一样数字, 让后再查询此表 得出前20%数据</p> 
  <p>ntile 参考&nbsp;<a href="https://blog.csdn.net/BabyFish13/article/details/78550601" rel="nofollow" data-token="4c8c13f3a2c7d8acc4b958b9eea4bf13">https://blog.csdn.net/BabyFish13/article/details/78550601</a></p> 
  <p>&nbsp;</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
