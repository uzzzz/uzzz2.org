<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>PCA - python实现（二） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="PCA - python实现（二）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="文章目录 一、简单概念介绍 1.1 numpy 的 .std() 和 pandas 的 .std() 函数之间是不同的 1.2 np.linalg.svd() 1.3 PCA的应用 二、PCA 计算过程 2.1 Feature Normalization 特征归一化 2.2 计算降维矩阵 2.2.1 首先计算样本特征的协方差矩阵 2.2.2 计算协方差矩阵的特征值和特征向量 2.3 降维计算 2.4 贡献率 （降维的k的值的选择） 三、python 实现 3.1 二维的PCA 3.2 多维PCA用于面部数据 四、 重构原数据 有趣的事，Python永远不会缺席 培训说明 一、简单概念介绍 1.1 numpy 的 .std() 和 pandas 的 .std() 函数之间是不同的   默认情况下，numpy 计算的是总体标准偏差，ddof = 0。另一方面，pandas 计算的是样本标准偏差，ddof = 1。如果我们知道所有的分数，那么我们就有了总体——因此，要使用 pandas 进行归一化处理，我们需要将“ddof”设置为 0。 在统计学中，多年的经验总结出： 如是总体,标准差公式根号内除以 n， 如是样本,标准差公式根号内除以 （n-1）， 因为我们大量接触的是样本,所以普遍使用根号内除以（n-1)。 公式意义 ：所有数减去平均值,它的平方和除以数的个数（或个数减一), 再把所得值开根号,就是1/2次方,得到的数就是这组数的标准差。 1.2 np.linalg.svd() 函数：np.linalg.svd(a,full_matrices=1,compute_uv=1) np.linalg.inv()：矩阵求逆 np.linalg.det()：矩阵求行列式（标量） SVD（Singular Value Decomposition，奇异值分解）是一种因子分解运算，将一个矩阵分解为3个矩阵的乘积，**np.linalg.svd()**函数返回3个矩阵——U、Sigma和V，其中U和V是正交矩阵，Sigma包含输入矩阵的奇异值。 使用diag函数生成完整的奇异值矩阵。将分解出的3个矩阵相乘U * np.diag(Sigma) * V np.diag(array) 返回一个矩阵的对角线元素，或者创建一个对角阵   array是一个1维数组时，结果形成一个以一维数组为对角线元素的矩阵   array是一个二维矩阵时，结果输出矩阵的对角线元素 import numpy as np a = np.arange(1, 4) b = np.arange(1, 10).reshape(3, 3) print(&#39;np.diag(a)&#39;,np.diag(a)) print(&#39;np.diag(b)&#39;,np.diag(b)) &#39;&#39;&#39;结果 np.diag(a) [[1 0 0] [0 2 0] [0 0 3]] np.diag(b) [1 5 9] &#39;&#39;&#39; 参数： a是一个形如(M,N)矩阵 full_matrices的取值是为0或者1，默认值为1，这时u的大小为(M,M)，v的大小为(N,N) 。否则u的大小为(M,K)，v的大小为(K,N) ，K=min(M,N)。 compute_uv的取值是为0或者1，默认值为1，表示计算u,s,v。为0的时候只计算s。 返回值： 总共有三个返回值u,s,v u大小为(M,M)，s大小为(M,N)，v大小为(N,N)。                  A = u * s * v   其中s是对矩阵a的奇异值分解。s除了对角元素不为0，其他元素都为0，并且对角元素从大到小排列。s中有n个奇异值，一般排在后面的比较接近0，所以仅保留比较大的r个奇异值。   注 因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。 import numpy as np D = np.mat(&#39;4 11 14;8 7 -2&#39;) U,Sigma,V = np.linalg.svd(D,full_matrices=False) print(&#39;U,Sigma,V&#39;,U,Sigma,V) print (&#39;U * np.diag(Sigma) * V&#39;,U * np.diag(Sigma) * V) &#39;&#39;&#39;结果 U,Sigma,V [[-0.9486833 -0.31622777][-0.31622777 0.9486833 ]] [18.97366596 9.48683298] [[-0.33333333 -0.66666667 -0.66666667][ 0.66666667 0.33333333 -0.66666667]] U * np.diag(Sigma) * V [[ 4. 11. 14.] [ 8. 7. -2.]] &#39;&#39;&#39; 1.3 PCA的应用 1. 数据压缩 数据压缩或者数据降维首先能够减少内存或者硬盘的使用， 如果内存不足或者 计算的时候出现内存溢出等问题， 就需要使用PCA获取低维度的样本特征。 其次， 数据降维能够加快机器学习的速度。 2. 数据可视化   在很多情况下， 可能我们需要查看样本特征， 但是高维度的特征根本无法观察， 这个时候我们可以将样本的特征降维到2D或者3D， 也就是将样本的特征维数降到 2个特征或者3个特征， 这样我们就可以采用可视化观察数据。 二、PCA 计算过程 2.1 Feature Normalization 特征归一化   首先要对训练样本的特征进行归一化， 特别强调的是， 归一化操作只能在训练样本中进行， 不能才CV集(验证集)合或者测试集合中进行， 也就是说归一化操作计算的各个参数只能由训练样本得到， 然后测试样本根据这里得到的参数进行归一化， 而不能直接和训练样本放在一起进行归一化。   另外， 在训练PCA降维矩阵的过程中，也不能使用CV样本或者测试样本， 这样做是不对的。 有很多人在使用PCA训练降维矩阵的时候， 直接使用所有的样本进行训练， 这样实际上相当于作弊的， 这样的话降维矩阵是在包含训练样本和测试样本以及CV样本的情况下训练得到的， 在进行测试的时候， 测试样本会存在很大的优越性， 因为它已经知道了要降维到的空间情况。 X = (X - X.mean()) / X.std() 2.2 计算降维矩阵 2.2.1 首先计算样本特征的协方差矩阵 X = np.matrix(X) cov = (X.T* X) / X.shape[0] # cov是(M,N) 2.2.2 计算协方差矩阵的特征值和特征向量 U, S, V = np.linalg.svd(cov) # 返回值u(M,M),s(M,N),v(N,N) # 因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来 # sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。   U 则是计算得到的协方差矩阵的所有特征向量， 每一列都是一个特征向量， 并且特征向量是根据特征大小由大到小进行排序的， U 的维度为 n * n 。 U 也被称为降维矩阵。 利用U 可以将样本进行降维。 默认的U 是包含协方差矩阵的所有特征向量， 如果想要将样本降维到 k 维， 那么就可以选取 U 的前 k 列， Uk 则可以用来对样本降维到 k 维。 这样 Uk 的维度为 n * k 2.3 降维计算   获得降维矩阵后， 即可通过降维矩阵将样本映射到低维空间上。X 是 m * n的， 那么降维后就变为 m * k 的维度， 每一行表示一个样本的特征。 # k是要降的维度 def project_data(X, U, k): U_reduced = U[:,:k] return np.dot(X, U_reduced) 2.4 贡献率 （降维的k的值的选择）   k 越大， 也就是使用的U 中的特征向量越多， 那么导致的降维误差越小， 也就是更多的保留的原来的特征的特性。 反之亦然。   从信息论的角度来看， 如果选择的 k 越大， 也就是系统的熵越大， 那么就可以认为保留的原来样本特征的不确定性也就越大， 就更加接近真实的样本数据。 如果 k 比较小， 那么系统的熵较小， 保留的原来的样本特征的不确定性就越少， 导致降维后的数据不够真实。   因为在 对协方差矩阵进行奇异值分解的时候返回了 S , S 为协方差矩阵的特征值， 并且 S 是对角矩阵， 维度为 n * n， 计算 k 的取值如下： 差异性的百分比:就是前 k 个特征值之和除以所有的特征值之和也就是特征值的总和比上前K个特征值，一般来说贡献率要大于95%才不影响表达原始数据。 三、python 实现 3.1 二维的PCA 数据下载： 链接：https://pan.baidu.com/s/1eCLjOP45R3TEvAqKWuK9Hg 提取码：qppx # coding = utf-8 # 2019/7/29 Luckyxxt：有趣的事，Python永远不会缺席！ import numpy as np import pandas as pd import matplotlib.pyplot as plt from scipy.io import loadmat data = loadmat(&#39;./PCA/data/ex7data1.mat&#39;) print(&#39;data.keys:&#39;,data.keys()) # data.keys: dict_keys([&#39;__header__&#39;, &#39;__version__&#39;, &#39;__globals__&#39;, &#39;X&#39;]) X = data[&#39;X&#39;] print(&#39;X.shape&#39;,X.shape)#(50, 2) fig = plt.figure(figsize=(12,8)) ax1 = fig.add_subplot(1,1,1) ax1.scatter(X[:,0],X[:,1],c=[&#39;r&#39;,&#39;g&#39;]) plt.show() # PCA的算法相当简单。 在确保数据被归一化之后，输出仅仅是原始数据的协方差矩阵的奇异值分解。 print(&#39;type(X)&#39;,type(X))#type(X) &lt;class &#39;numpy.ndarray&#39;&gt; print(&#39;X.mean()&#39;,X.mean())#平均值X.mean() 4.496035565920988 print(&#39;X.std()&#39;,X.std())#标准差X.std() 1.201784846469418 def pca(X): # normalize the features X = (X - X.mean()) / X.std() # compute the covariance matrix X = np.matrix(X) print(&#39;type(X)&#39;,type(X),X.shape)#type(X) &lt;class &#39;numpy.matrixlib.defmatrix.matrix&#39;&gt; (50, 2) cov = (X.T* X) / X.shape[0]#cov.shape (2, 2) print(&#39;cov.shape&#39;,cov.shape) # perform SVD cov是(M,N) U, S, V = np.linalg.svd(cov)#返回值u(M,M),s(M,N),v(N,N) #因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。 print(&#39;U.shape, S.shape, V.shape&#39;, U.shape, S.shape, V.shape)#(2, 2) (2,) (2, 2) return U, S, V U, S, V = pca(X) print(&#39;U, S, V&#39;,U, S, V) # 现在我们有主成分（矩阵U），我们可以用这些来将原始数据投影到一个较低维的空间中。 # 对于这个任务，我们将实现一个计算投影并且仅选择顶部K个分量的函数，有效地减少了维数。 def project_data(X, U, k): U_reduced = U[:,:k] print(&#39;U_reduced.shape&#39;,U_reduced.shape)#U_reduced.shape (2, 1) return np.dot(X, U_reduced) Z = project_data(X, U, 1) print(&#39;Z&#39;,Z.shape)#(50, 1)#二维数据降到了一维 3.2 多维PCA用于面部数据 # coding = utf-8 # 2019/7/29 Luckyxxt：有趣的事，Python永远不会缺席！ import pandas as pd import numpy as np import matplotlib.pyplot as plt from scipy.io import loadmat faces = loadmat(&#39;./PCA/data/ex7faces.mat&#39;) print(&#39;faces.keys()&#39;,faces.keys()) X = faces[&#39;X&#39;] print(&#39;X.shape&#39;,X.shape) # faces.keys() dict_keys([&#39;__header__&#39;, &#39;__version__&#39;, &#39;__globals__&#39;, &#39;X&#39;]) # X.shape (5000, 1024) # 渲染数据集中的前100张脸的函数 face = np.reshape(X[3,:], (32, 32)) # 看起来很糟糕。 这些只有32 x 32灰度的图像（它也是侧面渲染，但我们现在可以忽略）。 # 我们的下一步是在面数据集上运行PCA，并取得前100个主要特征。 plt.imshow(face) plt.show() def pca(X): # normalize the features X = (X - X.mean()) / X.std() # compute the covariance matrix X = np.matrix(X) print(&#39;type(X)&#39;,type(X),X.shape)#type(X) &lt;class &#39;numpy.matrixlib.defmatrix.matrix&#39;&gt; (50, 2) cov = (X.T* X) / X.shape[0]#cov.shape (2, 2) print(&#39;cov.shape&#39;,cov.shape) # perform SVD cov是(M,N) U, S, V = np.linalg.svd(cov)#返回值u(M,M),s(M,N),v(N,N) #因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。 print(&#39;U.shape, S.shape, V.shape&#39;, U.shape, S.shape, V.shape)#(2, 2) (2,) (2, 2) return U, S, V def project_data(X, U, k): U_reduced = U[:,:k] return np.dot(X, U_reduced) U, S, V = pca(X) Z = project_data(X, U, 100) print(&#39;Z.shape&#39;,Z.shape)#Z.shape (5000, 100) 四、 重构原数据   重构reconstruction， 根据降维后数据重构原数据，即数据还原。 def recover_data(Z, U): m, n = Z.shape if n &gt;= U.shape[0]: raise ValueError(&#39;Z dimension is &gt;= U, you should recover from lower dimension to higher&#39;) return Z @ U[:, :n].T 有趣的事，Python永远不会缺席 欢迎关注小婷儿的博客 &nbsp;&nbsp;&nbsp;&nbsp;文章内容来源于小婷儿的学习笔记，部分整理自网络，若有侵权或不当之处还请谅解 &nbsp;&nbsp;&nbsp;&nbsp;如需转发，请注明出处：小婷儿的博客python&nbsp;&nbsp;&nbsp;&nbsp;https://www.cnblogs.com/xxtalhr/ 博客园 https://www.cnblogs.com/xxtalhr/ CSDN https://blog.csdn.net/u010986753 有问题请在博客下留言或加作者： &nbsp;&nbsp;&nbsp;&nbsp; 微信：tinghai87605025 联系我加微信群 &nbsp;&nbsp;&nbsp;&nbsp; QQ ：87605025 &nbsp;&nbsp;&nbsp;&nbsp; python QQ交流群：py_data 483766429 培训说明 OCP培训说明连接 https://mp.weixin.qq.com/s/2cymJ4xiBPtTaHu16HkiuA OCM培训说明连接 https://mp.weixin.qq.com/s/7-R6Cz8RcJKduVv6YlAxJA &nbsp;&nbsp;&nbsp;&nbsp; 小婷儿的python正在成长中，其中还有很多不足之处，随着学习和工作的深入，会对以往的博客内容逐步改进和完善哒。重要的事多说几遍。。。。。。" />
<meta property="og:description" content="文章目录 一、简单概念介绍 1.1 numpy 的 .std() 和 pandas 的 .std() 函数之间是不同的 1.2 np.linalg.svd() 1.3 PCA的应用 二、PCA 计算过程 2.1 Feature Normalization 特征归一化 2.2 计算降维矩阵 2.2.1 首先计算样本特征的协方差矩阵 2.2.2 计算协方差矩阵的特征值和特征向量 2.3 降维计算 2.4 贡献率 （降维的k的值的选择） 三、python 实现 3.1 二维的PCA 3.2 多维PCA用于面部数据 四、 重构原数据 有趣的事，Python永远不会缺席 培训说明 一、简单概念介绍 1.1 numpy 的 .std() 和 pandas 的 .std() 函数之间是不同的   默认情况下，numpy 计算的是总体标准偏差，ddof = 0。另一方面，pandas 计算的是样本标准偏差，ddof = 1。如果我们知道所有的分数，那么我们就有了总体——因此，要使用 pandas 进行归一化处理，我们需要将“ddof”设置为 0。 在统计学中，多年的经验总结出： 如是总体,标准差公式根号内除以 n， 如是样本,标准差公式根号内除以 （n-1）， 因为我们大量接触的是样本,所以普遍使用根号内除以（n-1)。 公式意义 ：所有数减去平均值,它的平方和除以数的个数（或个数减一), 再把所得值开根号,就是1/2次方,得到的数就是这组数的标准差。 1.2 np.linalg.svd() 函数：np.linalg.svd(a,full_matrices=1,compute_uv=1) np.linalg.inv()：矩阵求逆 np.linalg.det()：矩阵求行列式（标量） SVD（Singular Value Decomposition，奇异值分解）是一种因子分解运算，将一个矩阵分解为3个矩阵的乘积，**np.linalg.svd()**函数返回3个矩阵——U、Sigma和V，其中U和V是正交矩阵，Sigma包含输入矩阵的奇异值。 使用diag函数生成完整的奇异值矩阵。将分解出的3个矩阵相乘U * np.diag(Sigma) * V np.diag(array) 返回一个矩阵的对角线元素，或者创建一个对角阵   array是一个1维数组时，结果形成一个以一维数组为对角线元素的矩阵   array是一个二维矩阵时，结果输出矩阵的对角线元素 import numpy as np a = np.arange(1, 4) b = np.arange(1, 10).reshape(3, 3) print(&#39;np.diag(a)&#39;,np.diag(a)) print(&#39;np.diag(b)&#39;,np.diag(b)) &#39;&#39;&#39;结果 np.diag(a) [[1 0 0] [0 2 0] [0 0 3]] np.diag(b) [1 5 9] &#39;&#39;&#39; 参数： a是一个形如(M,N)矩阵 full_matrices的取值是为0或者1，默认值为1，这时u的大小为(M,M)，v的大小为(N,N) 。否则u的大小为(M,K)，v的大小为(K,N) ，K=min(M,N)。 compute_uv的取值是为0或者1，默认值为1，表示计算u,s,v。为0的时候只计算s。 返回值： 总共有三个返回值u,s,v u大小为(M,M)，s大小为(M,N)，v大小为(N,N)。                  A = u * s * v   其中s是对矩阵a的奇异值分解。s除了对角元素不为0，其他元素都为0，并且对角元素从大到小排列。s中有n个奇异值，一般排在后面的比较接近0，所以仅保留比较大的r个奇异值。   注 因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。 import numpy as np D = np.mat(&#39;4 11 14;8 7 -2&#39;) U,Sigma,V = np.linalg.svd(D,full_matrices=False) print(&#39;U,Sigma,V&#39;,U,Sigma,V) print (&#39;U * np.diag(Sigma) * V&#39;,U * np.diag(Sigma) * V) &#39;&#39;&#39;结果 U,Sigma,V [[-0.9486833 -0.31622777][-0.31622777 0.9486833 ]] [18.97366596 9.48683298] [[-0.33333333 -0.66666667 -0.66666667][ 0.66666667 0.33333333 -0.66666667]] U * np.diag(Sigma) * V [[ 4. 11. 14.] [ 8. 7. -2.]] &#39;&#39;&#39; 1.3 PCA的应用 1. 数据压缩 数据压缩或者数据降维首先能够减少内存或者硬盘的使用， 如果内存不足或者 计算的时候出现内存溢出等问题， 就需要使用PCA获取低维度的样本特征。 其次， 数据降维能够加快机器学习的速度。 2. 数据可视化   在很多情况下， 可能我们需要查看样本特征， 但是高维度的特征根本无法观察， 这个时候我们可以将样本的特征降维到2D或者3D， 也就是将样本的特征维数降到 2个特征或者3个特征， 这样我们就可以采用可视化观察数据。 二、PCA 计算过程 2.1 Feature Normalization 特征归一化   首先要对训练样本的特征进行归一化， 特别强调的是， 归一化操作只能在训练样本中进行， 不能才CV集(验证集)合或者测试集合中进行， 也就是说归一化操作计算的各个参数只能由训练样本得到， 然后测试样本根据这里得到的参数进行归一化， 而不能直接和训练样本放在一起进行归一化。   另外， 在训练PCA降维矩阵的过程中，也不能使用CV样本或者测试样本， 这样做是不对的。 有很多人在使用PCA训练降维矩阵的时候， 直接使用所有的样本进行训练， 这样实际上相当于作弊的， 这样的话降维矩阵是在包含训练样本和测试样本以及CV样本的情况下训练得到的， 在进行测试的时候， 测试样本会存在很大的优越性， 因为它已经知道了要降维到的空间情况。 X = (X - X.mean()) / X.std() 2.2 计算降维矩阵 2.2.1 首先计算样本特征的协方差矩阵 X = np.matrix(X) cov = (X.T* X) / X.shape[0] # cov是(M,N) 2.2.2 计算协方差矩阵的特征值和特征向量 U, S, V = np.linalg.svd(cov) # 返回值u(M,M),s(M,N),v(N,N) # 因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来 # sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。   U 则是计算得到的协方差矩阵的所有特征向量， 每一列都是一个特征向量， 并且特征向量是根据特征大小由大到小进行排序的， U 的维度为 n * n 。 U 也被称为降维矩阵。 利用U 可以将样本进行降维。 默认的U 是包含协方差矩阵的所有特征向量， 如果想要将样本降维到 k 维， 那么就可以选取 U 的前 k 列， Uk 则可以用来对样本降维到 k 维。 这样 Uk 的维度为 n * k 2.3 降维计算   获得降维矩阵后， 即可通过降维矩阵将样本映射到低维空间上。X 是 m * n的， 那么降维后就变为 m * k 的维度， 每一行表示一个样本的特征。 # k是要降的维度 def project_data(X, U, k): U_reduced = U[:,:k] return np.dot(X, U_reduced) 2.4 贡献率 （降维的k的值的选择）   k 越大， 也就是使用的U 中的特征向量越多， 那么导致的降维误差越小， 也就是更多的保留的原来的特征的特性。 反之亦然。   从信息论的角度来看， 如果选择的 k 越大， 也就是系统的熵越大， 那么就可以认为保留的原来样本特征的不确定性也就越大， 就更加接近真实的样本数据。 如果 k 比较小， 那么系统的熵较小， 保留的原来的样本特征的不确定性就越少， 导致降维后的数据不够真实。   因为在 对协方差矩阵进行奇异值分解的时候返回了 S , S 为协方差矩阵的特征值， 并且 S 是对角矩阵， 维度为 n * n， 计算 k 的取值如下： 差异性的百分比:就是前 k 个特征值之和除以所有的特征值之和也就是特征值的总和比上前K个特征值，一般来说贡献率要大于95%才不影响表达原始数据。 三、python 实现 3.1 二维的PCA 数据下载： 链接：https://pan.baidu.com/s/1eCLjOP45R3TEvAqKWuK9Hg 提取码：qppx # coding = utf-8 # 2019/7/29 Luckyxxt：有趣的事，Python永远不会缺席！ import numpy as np import pandas as pd import matplotlib.pyplot as plt from scipy.io import loadmat data = loadmat(&#39;./PCA/data/ex7data1.mat&#39;) print(&#39;data.keys:&#39;,data.keys()) # data.keys: dict_keys([&#39;__header__&#39;, &#39;__version__&#39;, &#39;__globals__&#39;, &#39;X&#39;]) X = data[&#39;X&#39;] print(&#39;X.shape&#39;,X.shape)#(50, 2) fig = plt.figure(figsize=(12,8)) ax1 = fig.add_subplot(1,1,1) ax1.scatter(X[:,0],X[:,1],c=[&#39;r&#39;,&#39;g&#39;]) plt.show() # PCA的算法相当简单。 在确保数据被归一化之后，输出仅仅是原始数据的协方差矩阵的奇异值分解。 print(&#39;type(X)&#39;,type(X))#type(X) &lt;class &#39;numpy.ndarray&#39;&gt; print(&#39;X.mean()&#39;,X.mean())#平均值X.mean() 4.496035565920988 print(&#39;X.std()&#39;,X.std())#标准差X.std() 1.201784846469418 def pca(X): # normalize the features X = (X - X.mean()) / X.std() # compute the covariance matrix X = np.matrix(X) print(&#39;type(X)&#39;,type(X),X.shape)#type(X) &lt;class &#39;numpy.matrixlib.defmatrix.matrix&#39;&gt; (50, 2) cov = (X.T* X) / X.shape[0]#cov.shape (2, 2) print(&#39;cov.shape&#39;,cov.shape) # perform SVD cov是(M,N) U, S, V = np.linalg.svd(cov)#返回值u(M,M),s(M,N),v(N,N) #因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。 print(&#39;U.shape, S.shape, V.shape&#39;, U.shape, S.shape, V.shape)#(2, 2) (2,) (2, 2) return U, S, V U, S, V = pca(X) print(&#39;U, S, V&#39;,U, S, V) # 现在我们有主成分（矩阵U），我们可以用这些来将原始数据投影到一个较低维的空间中。 # 对于这个任务，我们将实现一个计算投影并且仅选择顶部K个分量的函数，有效地减少了维数。 def project_data(X, U, k): U_reduced = U[:,:k] print(&#39;U_reduced.shape&#39;,U_reduced.shape)#U_reduced.shape (2, 1) return np.dot(X, U_reduced) Z = project_data(X, U, 1) print(&#39;Z&#39;,Z.shape)#(50, 1)#二维数据降到了一维 3.2 多维PCA用于面部数据 # coding = utf-8 # 2019/7/29 Luckyxxt：有趣的事，Python永远不会缺席！ import pandas as pd import numpy as np import matplotlib.pyplot as plt from scipy.io import loadmat faces = loadmat(&#39;./PCA/data/ex7faces.mat&#39;) print(&#39;faces.keys()&#39;,faces.keys()) X = faces[&#39;X&#39;] print(&#39;X.shape&#39;,X.shape) # faces.keys() dict_keys([&#39;__header__&#39;, &#39;__version__&#39;, &#39;__globals__&#39;, &#39;X&#39;]) # X.shape (5000, 1024) # 渲染数据集中的前100张脸的函数 face = np.reshape(X[3,:], (32, 32)) # 看起来很糟糕。 这些只有32 x 32灰度的图像（它也是侧面渲染，但我们现在可以忽略）。 # 我们的下一步是在面数据集上运行PCA，并取得前100个主要特征。 plt.imshow(face) plt.show() def pca(X): # normalize the features X = (X - X.mean()) / X.std() # compute the covariance matrix X = np.matrix(X) print(&#39;type(X)&#39;,type(X),X.shape)#type(X) &lt;class &#39;numpy.matrixlib.defmatrix.matrix&#39;&gt; (50, 2) cov = (X.T* X) / X.shape[0]#cov.shape (2, 2) print(&#39;cov.shape&#39;,cov.shape) # perform SVD cov是(M,N) U, S, V = np.linalg.svd(cov)#返回值u(M,M),s(M,N),v(N,N) #因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。 print(&#39;U.shape, S.shape, V.shape&#39;, U.shape, S.shape, V.shape)#(2, 2) (2,) (2, 2) return U, S, V def project_data(X, U, k): U_reduced = U[:,:k] return np.dot(X, U_reduced) U, S, V = pca(X) Z = project_data(X, U, 100) print(&#39;Z.shape&#39;,Z.shape)#Z.shape (5000, 100) 四、 重构原数据   重构reconstruction， 根据降维后数据重构原数据，即数据还原。 def recover_data(Z, U): m, n = Z.shape if n &gt;= U.shape[0]: raise ValueError(&#39;Z dimension is &gt;= U, you should recover from lower dimension to higher&#39;) return Z @ U[:, :n].T 有趣的事，Python永远不会缺席 欢迎关注小婷儿的博客 &nbsp;&nbsp;&nbsp;&nbsp;文章内容来源于小婷儿的学习笔记，部分整理自网络，若有侵权或不当之处还请谅解 &nbsp;&nbsp;&nbsp;&nbsp;如需转发，请注明出处：小婷儿的博客python&nbsp;&nbsp;&nbsp;&nbsp;https://www.cnblogs.com/xxtalhr/ 博客园 https://www.cnblogs.com/xxtalhr/ CSDN https://blog.csdn.net/u010986753 有问题请在博客下留言或加作者： &nbsp;&nbsp;&nbsp;&nbsp; 微信：tinghai87605025 联系我加微信群 &nbsp;&nbsp;&nbsp;&nbsp; QQ ：87605025 &nbsp;&nbsp;&nbsp;&nbsp; python QQ交流群：py_data 483766429 培训说明 OCP培训说明连接 https://mp.weixin.qq.com/s/2cymJ4xiBPtTaHu16HkiuA OCM培训说明连接 https://mp.weixin.qq.com/s/7-R6Cz8RcJKduVv6YlAxJA &nbsp;&nbsp;&nbsp;&nbsp; 小婷儿的python正在成长中，其中还有很多不足之处，随着学习和工作的深入，会对以往的博客内容逐步改进和完善哒。重要的事多说几遍。。。。。。" />
<link rel="canonical" href="https://uzzz.org/2019/07/29/795252.html" />
<meta property="og:url" content="https://uzzz.org/2019/07/29/795252.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"文章目录 一、简单概念介绍 1.1 numpy 的 .std() 和 pandas 的 .std() 函数之间是不同的 1.2 np.linalg.svd() 1.3 PCA的应用 二、PCA 计算过程 2.1 Feature Normalization 特征归一化 2.2 计算降维矩阵 2.2.1 首先计算样本特征的协方差矩阵 2.2.2 计算协方差矩阵的特征值和特征向量 2.3 降维计算 2.4 贡献率 （降维的k的值的选择） 三、python 实现 3.1 二维的PCA 3.2 多维PCA用于面部数据 四、 重构原数据 有趣的事，Python永远不会缺席 培训说明 一、简单概念介绍 1.1 numpy 的 .std() 和 pandas 的 .std() 函数之间是不同的   默认情况下，numpy 计算的是总体标准偏差，ddof = 0。另一方面，pandas 计算的是样本标准偏差，ddof = 1。如果我们知道所有的分数，那么我们就有了总体——因此，要使用 pandas 进行归一化处理，我们需要将“ddof”设置为 0。 在统计学中，多年的经验总结出： 如是总体,标准差公式根号内除以 n， 如是样本,标准差公式根号内除以 （n-1）， 因为我们大量接触的是样本,所以普遍使用根号内除以（n-1)。 公式意义 ：所有数减去平均值,它的平方和除以数的个数（或个数减一), 再把所得值开根号,就是1/2次方,得到的数就是这组数的标准差。 1.2 np.linalg.svd() 函数：np.linalg.svd(a,full_matrices=1,compute_uv=1) np.linalg.inv()：矩阵求逆 np.linalg.det()：矩阵求行列式（标量） SVD（Singular Value Decomposition，奇异值分解）是一种因子分解运算，将一个矩阵分解为3个矩阵的乘积，**np.linalg.svd()**函数返回3个矩阵——U、Sigma和V，其中U和V是正交矩阵，Sigma包含输入矩阵的奇异值。 使用diag函数生成完整的奇异值矩阵。将分解出的3个矩阵相乘U * np.diag(Sigma) * V np.diag(array) 返回一个矩阵的对角线元素，或者创建一个对角阵   array是一个1维数组时，结果形成一个以一维数组为对角线元素的矩阵   array是一个二维矩阵时，结果输出矩阵的对角线元素 import numpy as np a = np.arange(1, 4) b = np.arange(1, 10).reshape(3, 3) print(&#39;np.diag(a)&#39;,np.diag(a)) print(&#39;np.diag(b)&#39;,np.diag(b)) &#39;&#39;&#39;结果 np.diag(a) [[1 0 0] [0 2 0] [0 0 3]] np.diag(b) [1 5 9] &#39;&#39;&#39; 参数： a是一个形如(M,N)矩阵 full_matrices的取值是为0或者1，默认值为1，这时u的大小为(M,M)，v的大小为(N,N) 。否则u的大小为(M,K)，v的大小为(K,N) ，K=min(M,N)。 compute_uv的取值是为0或者1，默认值为1，表示计算u,s,v。为0的时候只计算s。 返回值： 总共有三个返回值u,s,v u大小为(M,M)，s大小为(M,N)，v大小为(N,N)。                  A = u * s * v   其中s是对矩阵a的奇异值分解。s除了对角元素不为0，其他元素都为0，并且对角元素从大到小排列。s中有n个奇异值，一般排在后面的比较接近0，所以仅保留比较大的r个奇异值。   注 因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。 import numpy as np D = np.mat(&#39;4 11 14;8 7 -2&#39;) U,Sigma,V = np.linalg.svd(D,full_matrices=False) print(&#39;U,Sigma,V&#39;,U,Sigma,V) print (&#39;U * np.diag(Sigma) * V&#39;,U * np.diag(Sigma) * V) &#39;&#39;&#39;结果 U,Sigma,V [[-0.9486833 -0.31622777][-0.31622777 0.9486833 ]] [18.97366596 9.48683298] [[-0.33333333 -0.66666667 -0.66666667][ 0.66666667 0.33333333 -0.66666667]] U * np.diag(Sigma) * V [[ 4. 11. 14.] [ 8. 7. -2.]] &#39;&#39;&#39; 1.3 PCA的应用 1. 数据压缩 数据压缩或者数据降维首先能够减少内存或者硬盘的使用， 如果内存不足或者 计算的时候出现内存溢出等问题， 就需要使用PCA获取低维度的样本特征。 其次， 数据降维能够加快机器学习的速度。 2. 数据可视化   在很多情况下， 可能我们需要查看样本特征， 但是高维度的特征根本无法观察， 这个时候我们可以将样本的特征降维到2D或者3D， 也就是将样本的特征维数降到 2个特征或者3个特征， 这样我们就可以采用可视化观察数据。 二、PCA 计算过程 2.1 Feature Normalization 特征归一化   首先要对训练样本的特征进行归一化， 特别强调的是， 归一化操作只能在训练样本中进行， 不能才CV集(验证集)合或者测试集合中进行， 也就是说归一化操作计算的各个参数只能由训练样本得到， 然后测试样本根据这里得到的参数进行归一化， 而不能直接和训练样本放在一起进行归一化。   另外， 在训练PCA降维矩阵的过程中，也不能使用CV样本或者测试样本， 这样做是不对的。 有很多人在使用PCA训练降维矩阵的时候， 直接使用所有的样本进行训练， 这样实际上相当于作弊的， 这样的话降维矩阵是在包含训练样本和测试样本以及CV样本的情况下训练得到的， 在进行测试的时候， 测试样本会存在很大的优越性， 因为它已经知道了要降维到的空间情况。 X = (X - X.mean()) / X.std() 2.2 计算降维矩阵 2.2.1 首先计算样本特征的协方差矩阵 X = np.matrix(X) cov = (X.T* X) / X.shape[0] # cov是(M,N) 2.2.2 计算协方差矩阵的特征值和特征向量 U, S, V = np.linalg.svd(cov) # 返回值u(M,M),s(M,N),v(N,N) # 因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来 # sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。   U 则是计算得到的协方差矩阵的所有特征向量， 每一列都是一个特征向量， 并且特征向量是根据特征大小由大到小进行排序的， U 的维度为 n * n 。 U 也被称为降维矩阵。 利用U 可以将样本进行降维。 默认的U 是包含协方差矩阵的所有特征向量， 如果想要将样本降维到 k 维， 那么就可以选取 U 的前 k 列， Uk 则可以用来对样本降维到 k 维。 这样 Uk 的维度为 n * k 2.3 降维计算   获得降维矩阵后， 即可通过降维矩阵将样本映射到低维空间上。X 是 m * n的， 那么降维后就变为 m * k 的维度， 每一行表示一个样本的特征。 # k是要降的维度 def project_data(X, U, k): U_reduced = U[:,:k] return np.dot(X, U_reduced) 2.4 贡献率 （降维的k的值的选择）   k 越大， 也就是使用的U 中的特征向量越多， 那么导致的降维误差越小， 也就是更多的保留的原来的特征的特性。 反之亦然。   从信息论的角度来看， 如果选择的 k 越大， 也就是系统的熵越大， 那么就可以认为保留的原来样本特征的不确定性也就越大， 就更加接近真实的样本数据。 如果 k 比较小， 那么系统的熵较小， 保留的原来的样本特征的不确定性就越少， 导致降维后的数据不够真实。   因为在 对协方差矩阵进行奇异值分解的时候返回了 S , S 为协方差矩阵的特征值， 并且 S 是对角矩阵， 维度为 n * n， 计算 k 的取值如下： 差异性的百分比:就是前 k 个特征值之和除以所有的特征值之和也就是特征值的总和比上前K个特征值，一般来说贡献率要大于95%才不影响表达原始数据。 三、python 实现 3.1 二维的PCA 数据下载： 链接：https://pan.baidu.com/s/1eCLjOP45R3TEvAqKWuK9Hg 提取码：qppx # coding = utf-8 # 2019/7/29 Luckyxxt：有趣的事，Python永远不会缺席！ import numpy as np import pandas as pd import matplotlib.pyplot as plt from scipy.io import loadmat data = loadmat(&#39;./PCA/data/ex7data1.mat&#39;) print(&#39;data.keys:&#39;,data.keys()) # data.keys: dict_keys([&#39;__header__&#39;, &#39;__version__&#39;, &#39;__globals__&#39;, &#39;X&#39;]) X = data[&#39;X&#39;] print(&#39;X.shape&#39;,X.shape)#(50, 2) fig = plt.figure(figsize=(12,8)) ax1 = fig.add_subplot(1,1,1) ax1.scatter(X[:,0],X[:,1],c=[&#39;r&#39;,&#39;g&#39;]) plt.show() # PCA的算法相当简单。 在确保数据被归一化之后，输出仅仅是原始数据的协方差矩阵的奇异值分解。 print(&#39;type(X)&#39;,type(X))#type(X) &lt;class &#39;numpy.ndarray&#39;&gt; print(&#39;X.mean()&#39;,X.mean())#平均值X.mean() 4.496035565920988 print(&#39;X.std()&#39;,X.std())#标准差X.std() 1.201784846469418 def pca(X): # normalize the features X = (X - X.mean()) / X.std() # compute the covariance matrix X = np.matrix(X) print(&#39;type(X)&#39;,type(X),X.shape)#type(X) &lt;class &#39;numpy.matrixlib.defmatrix.matrix&#39;&gt; (50, 2) cov = (X.T* X) / X.shape[0]#cov.shape (2, 2) print(&#39;cov.shape&#39;,cov.shape) # perform SVD cov是(M,N) U, S, V = np.linalg.svd(cov)#返回值u(M,M),s(M,N),v(N,N) #因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。 print(&#39;U.shape, S.shape, V.shape&#39;, U.shape, S.shape, V.shape)#(2, 2) (2,) (2, 2) return U, S, V U, S, V = pca(X) print(&#39;U, S, V&#39;,U, S, V) # 现在我们有主成分（矩阵U），我们可以用这些来将原始数据投影到一个较低维的空间中。 # 对于这个任务，我们将实现一个计算投影并且仅选择顶部K个分量的函数，有效地减少了维数。 def project_data(X, U, k): U_reduced = U[:,:k] print(&#39;U_reduced.shape&#39;,U_reduced.shape)#U_reduced.shape (2, 1) return np.dot(X, U_reduced) Z = project_data(X, U, 1) print(&#39;Z&#39;,Z.shape)#(50, 1)#二维数据降到了一维 3.2 多维PCA用于面部数据 # coding = utf-8 # 2019/7/29 Luckyxxt：有趣的事，Python永远不会缺席！ import pandas as pd import numpy as np import matplotlib.pyplot as plt from scipy.io import loadmat faces = loadmat(&#39;./PCA/data/ex7faces.mat&#39;) print(&#39;faces.keys()&#39;,faces.keys()) X = faces[&#39;X&#39;] print(&#39;X.shape&#39;,X.shape) # faces.keys() dict_keys([&#39;__header__&#39;, &#39;__version__&#39;, &#39;__globals__&#39;, &#39;X&#39;]) # X.shape (5000, 1024) # 渲染数据集中的前100张脸的函数 face = np.reshape(X[3,:], (32, 32)) # 看起来很糟糕。 这些只有32 x 32灰度的图像（它也是侧面渲染，但我们现在可以忽略）。 # 我们的下一步是在面数据集上运行PCA，并取得前100个主要特征。 plt.imshow(face) plt.show() def pca(X): # normalize the features X = (X - X.mean()) / X.std() # compute the covariance matrix X = np.matrix(X) print(&#39;type(X)&#39;,type(X),X.shape)#type(X) &lt;class &#39;numpy.matrixlib.defmatrix.matrix&#39;&gt; (50, 2) cov = (X.T* X) / X.shape[0]#cov.shape (2, 2) print(&#39;cov.shape&#39;,cov.shape) # perform SVD cov是(M,N) U, S, V = np.linalg.svd(cov)#返回值u(M,M),s(M,N),v(N,N) #因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。 print(&#39;U.shape, S.shape, V.shape&#39;, U.shape, S.shape, V.shape)#(2, 2) (2,) (2, 2) return U, S, V def project_data(X, U, k): U_reduced = U[:,:k] return np.dot(X, U_reduced) U, S, V = pca(X) Z = project_data(X, U, 100) print(&#39;Z.shape&#39;,Z.shape)#Z.shape (5000, 100) 四、 重构原数据   重构reconstruction， 根据降维后数据重构原数据，即数据还原。 def recover_data(Z, U): m, n = Z.shape if n &gt;= U.shape[0]: raise ValueError(&#39;Z dimension is &gt;= U, you should recover from lower dimension to higher&#39;) return Z @ U[:, :n].T 有趣的事，Python永远不会缺席 欢迎关注小婷儿的博客 &nbsp;&nbsp;&nbsp;&nbsp;文章内容来源于小婷儿的学习笔记，部分整理自网络，若有侵权或不当之处还请谅解 &nbsp;&nbsp;&nbsp;&nbsp;如需转发，请注明出处：小婷儿的博客python&nbsp;&nbsp;&nbsp;&nbsp;https://www.cnblogs.com/xxtalhr/ 博客园 https://www.cnblogs.com/xxtalhr/ CSDN https://blog.csdn.net/u010986753 有问题请在博客下留言或加作者： &nbsp;&nbsp;&nbsp;&nbsp; 微信：tinghai87605025 联系我加微信群 &nbsp;&nbsp;&nbsp;&nbsp; QQ ：87605025 &nbsp;&nbsp;&nbsp;&nbsp; python QQ交流群：py_data 483766429 培训说明 OCP培训说明连接 https://mp.weixin.qq.com/s/2cymJ4xiBPtTaHu16HkiuA OCM培训说明连接 https://mp.weixin.qq.com/s/7-R6Cz8RcJKduVv6YlAxJA &nbsp;&nbsp;&nbsp;&nbsp; 小婷儿的python正在成长中，其中还有很多不足之处，随着学习和工作的深入，会对以往的博客内容逐步改进和完善哒。重要的事多说几遍。。。。。。","@type":"BlogPosting","url":"https://uzzz.org/2019/07/29/795252.html","headline":"PCA - python实现（二）","dateModified":"2019-07-29T00:00:00+08:00","datePublished":"2019-07-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/07/29/795252.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>PCA - python实现（二）</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> 
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path> 
  </svg> 
  <p></p>
  <div class="toc">
   <h3>文章目录</h3>
   <ul>
    <li><a href="#_1" rel="nofollow" data-token="8e638214651213e3eabab51c64dc110a">一、简单概念介绍</a></li>
    <ul>
     <li><a href="#11_numpy__std__pandas__std__2" rel="nofollow" data-token="8771c2ee6f9597bbb83d77f446bb1614">1.1 numpy 的 .std() 和 pandas 的 .std() 函数之间是不同的</a></li>
     <li><a href="#12_nplinalgsvd_14" rel="nofollow" data-token="61b424ce3886ae3a183510dc3aa81bc7">1.2 np.linalg.svd()</a></li>
     <li><a href="#13_PCA_71" rel="nofollow" data-token="16a9db7504f08f8908c9955ac5929ca6">1.3 PCA的应用</a></li>
    </ul>
    <li><a href="#PCA__80" rel="nofollow" data-token="e0aa07c031e0f9334d08177ca77bf2b2">二、PCA 计算过程</a></li>
    <ul>
     <li><a href="#21_Feature_Normalization__81" rel="nofollow" data-token="e88e2568f8bb77d58f0cc5731bbc1710">2.1 Feature Normalization 特征归一化</a></li>
     <li><a href="#22__90" rel="nofollow" data-token="2040ec4b75c3c6c4c604d14645e450c1">2.2 计算降维矩阵</a></li>
     <ul>
      <li><a href="#221__91" rel="nofollow" data-token="11b1c2bb3666e18e4362cdec66bfe46e">2.2.1 首先计算样本特征的协方差矩阵</a></li>
      <li><a href="#222__99" rel="nofollow" data-token="b25df6e9f6287ea0615b5abd2d526e60">2.2.2 计算协方差矩阵的特征值和特征向量</a></li>
     </ul>
     <li><a href="#23__109" rel="nofollow" data-token="2419af9e1b10a09ca3acf178879a7e67">2.3 降维计算</a></li>
     <li><a href="#24___k_118" rel="nofollow" data-token="89881d78f93392d8036b20c93ebd2825">2.4 贡献率 （降维的k的值的选择）</a></li>
    </ul>
    <li><a href="#python__126" rel="nofollow" data-token="5bedae7e3c7992d098cd6a39936f61f6">三、python 实现</a></li>
    <ul>
     <li><a href="#31_PCA_127" rel="nofollow" data-token="3826c29e3591bf18f4dfdf846b45e1fa">3.1 二维的PCA</a></li>
     <li><a href="#32_PCA_184" rel="nofollow" data-token="b96bb581f626987463d3215caaa75f3a">3.2 多维PCA用于面部数据</a></li>
    </ul>
    <li><a href="#__232" rel="nofollow" data-token="3252bdef5a51cd67feace1d61b97adc5">四、 重构原数据</a></li>
    <li><a href="#Python_246" rel="nofollow" data-token="d068da90a65c052037d2c74ae20bcd59">有趣的事，Python永远不会缺席</a></li>
    <li><a href="#strongstrongbr_260" rel="nofollow" data-token="8281e399b3d06b167c7a70580150051c"><strong>培训说明</strong><br></a></li>
   </ul>
  </div>
  <p></p> 
  <h1><a id="_1"></a>一、简单概念介绍</h1> 
  <h2><a id="11_numpy__std__pandas__std__2"></a>1.1 numpy 的 .std() 和 pandas 的 .std() 函数之间是不同的</h2> 
  <p>  默认情况下，numpy 计算的是总体标准偏差，ddof = 0。另一方面，pandas 计算的是样本标准偏差，ddof = 1。如果我们知道所有的分数，那么我们就有了总体——因此，要使用 pandas 进行归一化处理，我们需要将“ddof”设置为 0。</p> 
  <p><strong>在统计学中，多年的经验总结出：</strong></p> 
  <ul> 
   <li>如是总体,标准差公式根号内除以 n，</li> 
   <li>如是样本,标准差公式根号内除以 （n-1），</li> 
   <li>因为我们大量接触的是样本,所以普遍使用根号内除以（n-1)。</li> 
  </ul> 
  <p><strong>公式意义</strong> ：所有数减去平均值,它的平方和除以数的个数（或个数减一),<br> 再把所得值开根号,就是1/2次方,得到的数就是这组数的标准差。</p> 
  <h2><a id="12_nplinalgsvd_14"></a>1.2 np.linalg.svd()</h2> 
  <p><strong>函数：np.linalg.svd(a,full_matrices=1,compute_uv=1)</strong></p> 
  <ul> 
   <li>np.linalg.inv()：矩阵求逆</li> 
   <li>np.linalg.det()：矩阵求行列式（标量）</li> 
   <li>SVD（Singular Value Decomposition，奇异值分解）是一种因子分解运算，将一个矩阵分解为3个矩阵的乘积，**np.linalg.svd()**函数返回3个矩阵——U、Sigma和V，其中U和V是正交矩阵，Sigma包含输入矩阵的奇异值。</li> 
   <li>使用diag函数生成完整的奇异值矩阵。将分解出的3个矩阵相乘<strong>U * np.diag(Sigma) * V</strong></li> 
   <li>np.diag(array) 返回一个矩阵的对角线元素，或者创建一个对角阵<br>   array是一个1维数组时，结果形成一个以一维数组为对角线元素的矩阵<br>   array是一个二维矩阵时，结果输出矩阵的对角线元素</li> 
  </ul> 
  <pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
a <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'np.diag(a)'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'np.diag(b)'</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token triple-quoted-string string">'''结果 np.diag(a) [[1 0 0] [0 2 0] [0 0 3]] np.diag(b) [1 5 9] '''</span>
</code></pre> 
  <p><strong>参数：</strong></p> 
  <ul> 
   <li>a是一个形如(M,N)矩阵</li> 
   <li>full_matrices的取值是为0或者1，默认值为1，这时u的大小为(M,M)，v的大小为(N,N) 。否则u的大小为(M,K)，v的大小为(K,N) ，K=min(M,N)。</li> 
   <li>compute_uv的取值是为0或者1，默认值为1，表示计算u,s,v。为0的时候只计算s。</li> 
  </ul> 
  <p><strong>返回值：</strong></p> 
  <p>总共有三个返回值u,s,v<br> u大小为(M,M)，s大小为(M,N)，v大小为(N,N)。</p> 
  <p>                 <strong>A = u * s * v</strong></p> 
  <p>  其中s是对矩阵a的奇异值分解。s除了对角元素不为0，其他元素都为0，并且对角元素从大到小排列。s中有n个奇异值，一般排在后面的比较接近0，所以仅保留比较大的r个奇异值。<br>   <strong>注</strong> 因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。</p> 
  <pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
D <span class="token operator">=</span> np<span class="token punctuation">.</span>mat<span class="token punctuation">(</span><span class="token string">'4 11 14;8 7 -2'</span><span class="token punctuation">)</span>
U<span class="token punctuation">,</span>Sigma<span class="token punctuation">,</span>V <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>svd<span class="token punctuation">(</span>D<span class="token punctuation">,</span>full_matrices<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'U,Sigma,V'</span><span class="token punctuation">,</span>U<span class="token punctuation">,</span>Sigma<span class="token punctuation">,</span>V<span class="token punctuation">)</span>
<span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'U * np.diag(Sigma) * V'</span><span class="token punctuation">,</span>U <span class="token operator">*</span> np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span>Sigma<span class="token punctuation">)</span> <span class="token operator">*</span> V<span class="token punctuation">)</span>
<span class="token triple-quoted-string string">'''结果 U,Sigma,V [[-0.9486833 -0.31622777][-0.31622777 0.9486833 ]] [18.97366596 9.48683298] [[-0.33333333 -0.66666667 -0.66666667][ 0.66666667 0.33333333 -0.66666667]] U * np.diag(Sigma) * V [[ 4. 11. 14.] [ 8. 7. -2.]] '''</span>
</code></pre> 
  <h2><a id="13_PCA_71"></a>1.3 PCA的应用</h2> 
  <p><strong>1. 数据压缩</strong></p> 
  <ul> 
   <li>数据压缩或者数据降维首先能够减少内存或者硬盘的使用， 如果内存不足或者<br> 计算的时候出现内存溢出等问题， 就需要使用PCA获取低维度的样本特征。</li> 
   <li>其次， 数据降维能够加快机器学习的速度。</li> 
  </ul> 
  <p><strong>2. 数据可视化</strong><br>   在很多情况下， 可能我们需要查看样本特征， 但是高维度的特征根本无法观察， 这个时候我们可以将样本的特征降维到2D或者3D， 也就是将样本的特征维数降到 2个特征或者3个特征， 这样我们就可以采用可视化观察数据。</p> 
  <h1><a id="PCA__80"></a>二、PCA 计算过程</h1> 
  <h2><a id="21_Feature_Normalization__81"></a>2.1 Feature Normalization 特征归一化</h2> 
  <p>  首先要对训练样本的特征进行归一化， 特别强调的是， 归一化操作只能在训练样本中进行， 不能才CV集(验证集)合或者测试集合中进行， 也就是说归一化操作计算的各个参数只能由训练样本得到， 然后测试样本根据这里得到的参数进行归一化， 而不能直接和训练样本放在一起进行归一化。<br>   另外， 在训练PCA降维矩阵的过程中，也不能使用CV样本或者测试样本， 这样做是不对的。 有很多人在使用PCA训练降维矩阵的时候， 直接使用所有的样本进行训练， 这样实际上相当于作弊的， 这样的话降维矩阵是在包含训练样本和测试样本以及CV样本的情况下训练得到的， 在进行测试的时候， 测试样本会存在很大的优越性， 因为它已经知道了要降维到的空间情况。</p> 
  <pre><code class="prism language-python">X <span class="token operator">=</span> <span class="token punctuation">(</span>X <span class="token operator">-</span> X<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> X<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
  <h2><a id="22__90"></a>2.2 计算降维矩阵</h2> 
  <h3><a id="221__91"></a>2.2.1 首先计算样本特征的协方差矩阵</h3> 
  <pre><code class="prism language-python">X <span class="token operator">=</span> np<span class="token punctuation">.</span>matrix<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
cov <span class="token operator">=</span> <span class="token punctuation">(</span>X<span class="token punctuation">.</span>T<span class="token operator">*</span> X<span class="token punctuation">)</span> <span class="token operator">/</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token comment"># cov是(M,N)</span>
</code></pre> 
  <h3><a id="222__99"></a>2.2.2 计算协方差矩阵的特征值和特征向量</h3> 
  <pre><code class="prism language-python">U<span class="token punctuation">,</span> S<span class="token punctuation">,</span> V <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>svd<span class="token punctuation">(</span>cov<span class="token punctuation">)</span>
<span class="token comment"># 返回值u(M,M),s(M,N),v(N,N)</span>
<span class="token comment"># 因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来</span>
<span class="token comment"># sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。</span>
</code></pre> 
  <p>  <strong>U</strong> 则是计算得到的协方差矩阵的所有特征向量， 每一列都是一个特征向量， 并且特征向量是根据特征大小由大到小进行排序的， U 的维度为 n * n 。 U 也被称为<strong>降维矩阵</strong>。 利用U 可以将样本进行降维。 默认的U 是包含协方差矩阵的所有特征向量， 如果想要将样本降维到 k 维， 那么就可以选取 U 的前 k 列， Uk 则可以用来对样本降维到 k 维。 这样 Uk 的维度为 n * k</p> 
  <h2><a id="23__109"></a>2.3 降维计算</h2> 
  <p>  获得降维矩阵后， 即可通过降维矩阵将样本映射到低维空间上。X 是 m * n的， 那么降维后就变为 m * k 的维度， 每一行表示一个样本的特征。</p> 
  <pre><code class="prism language-python"><span class="token comment"># k是要降的维度</span>
<span class="token keyword">def</span> <span class="token function">project_data</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> U<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    U_reduced <span class="token operator">=</span> U<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span>
    <span class="token keyword">return</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">,</span> U_reduced<span class="token punctuation">)</span>
    
</code></pre> 
  <h2><a id="24___k_118"></a>2.4 贡献率 （降维的k的值的选择）</h2> 
  <p>  k 越大， 也就是使用的U 中的特征向量越多， 那么导致的降维误差越小， 也就是更多的保留的原来的特征的特性。 反之亦然。<br>   从信息论的角度来看， 如果选择的 k 越大， 也就是系统的熵越大， 那么就可以认为保留的原来样本特征的不确定性也就越大， 就更加接近真实的样本数据。 如果 k 比较小， 那么系统的熵较小， 保留的原来的样本特征的不确定性就越少， 导致降维后的数据不够真实。<br>   因为在 对协方差矩阵进行奇异值分解的时候返回了 S , <strong>S 为协方差矩阵的特征值</strong>， 并且 S 是对角矩阵， 维度为 n * n， 计算 k 的取值如下：</p> 
  <p><strong>差异性的百分比:就是前 k 个特征值之和除以所有的特征值之和也就是特征值的总和比上前K个特征值，一般来说贡献率要大于95%才不影响表达原始数据。</strong></p> 
  <center>
   <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190826150200113.png"> 
  </center>
  <h1><a id="python__126"></a>三、python 实现</h1> 
  <h2><a id="31_PCA_127"></a>3.1 二维的PCA</h2> 
  <p><strong>数据下载：</strong><br> 链接：https://pan.baidu.com/s/1eCLjOP45R3TEvAqKWuK9Hg<br> 提取码：qppx</p> 
  <pre><code class="prism language-python"><span class="token comment"># coding = utf-8</span>
<span class="token comment"># 2019/7/29 Luckyxxt：有趣的事，Python永远不会缺席！</span>
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>io <span class="token keyword">import</span> loadmat
data <span class="token operator">=</span> loadmat<span class="token punctuation">(</span><span class="token string">'./PCA/data/ex7data1.mat'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'data.keys:'</span><span class="token punctuation">,</span>data<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># data.keys: dict_keys(['__header__', '__version__', '__globals__', 'X'])</span>
X <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'X'</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'X.shape'</span><span class="token punctuation">,</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment">#(50, 2)</span>

fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ax1 <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
ax1<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># PCA的算法相当简单。 在确保数据被归一化之后，输出仅仅是原始数据的协方差矩阵的奇异值分解。</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'type(X)'</span><span class="token punctuation">,</span><span class="token builtin">type</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#type(X) &lt;class 'numpy.ndarray'&gt;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'X.mean()'</span><span class="token punctuation">,</span>X<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#平均值X.mean() 4.496035565920988</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'X.std()'</span><span class="token punctuation">,</span>X<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#标准差X.std() 1.201784846469418</span>

<span class="token keyword">def</span> <span class="token function">pca</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># normalize the features</span>
    X <span class="token operator">=</span> <span class="token punctuation">(</span>X <span class="token operator">-</span> X<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> X<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># compute the covariance matrix</span>
    X <span class="token operator">=</span> np<span class="token punctuation">.</span>matrix<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'type(X)'</span><span class="token punctuation">,</span><span class="token builtin">type</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment">#type(X) &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt; (50, 2)</span>
    cov <span class="token operator">=</span> <span class="token punctuation">(</span>X<span class="token punctuation">.</span>T<span class="token operator">*</span> X<span class="token punctuation">)</span> <span class="token operator">/</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment">#cov.shape (2, 2)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cov.shape'</span><span class="token punctuation">,</span>cov<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
    <span class="token comment"># perform SVD cov是(M,N)</span>
    U<span class="token punctuation">,</span> S<span class="token punctuation">,</span> V <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>svd<span class="token punctuation">(</span>cov<span class="token punctuation">)</span><span class="token comment">#返回值u(M,M),s(M,N),v(N,N)</span>
    <span class="token comment">#因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'U.shape, S.shape, V.shape'</span><span class="token punctuation">,</span> U<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> S<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> V<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment">#(2, 2) (2,) (2, 2)</span>
    <span class="token keyword">return</span> U<span class="token punctuation">,</span> S<span class="token punctuation">,</span> V

U<span class="token punctuation">,</span> S<span class="token punctuation">,</span> V <span class="token operator">=</span> pca<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'U, S, V'</span><span class="token punctuation">,</span>U<span class="token punctuation">,</span> S<span class="token punctuation">,</span> V<span class="token punctuation">)</span>
<span class="token comment"># 现在我们有主成分（矩阵U），我们可以用这些来将原始数据投影到一个较低维的空间中。</span>
<span class="token comment"># 对于这个任务，我们将实现一个计算投影并且仅选择顶部K个分量的函数，有效地减少了维数。</span>

<span class="token keyword">def</span> <span class="token function">project_data</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> U<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    U_reduced <span class="token operator">=</span> U<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'U_reduced.shape'</span><span class="token punctuation">,</span>U_reduced<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment">#U_reduced.shape (2, 1)</span>
    <span class="token keyword">return</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">,</span> U_reduced<span class="token punctuation">)</span>

Z <span class="token operator">=</span> project_data<span class="token punctuation">(</span>X<span class="token punctuation">,</span> U<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Z'</span><span class="token punctuation">,</span>Z<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment">#(50, 1)#二维数据降到了一维</span>
</code></pre> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190729205353135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA5ODY3NTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <h2><a id="32_PCA_184"></a>3.2 多维PCA用于面部数据</h2> 
  <pre><code class="prism language-python"><span class="token comment"># coding = utf-8</span>
<span class="token comment"># 2019/7/29 Luckyxxt：有趣的事，Python永远不会缺席！</span>
<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>io <span class="token keyword">import</span> loadmat
faces <span class="token operator">=</span> loadmat<span class="token punctuation">(</span><span class="token string">'./PCA/data/ex7faces.mat'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'faces.keys()'</span><span class="token punctuation">,</span>faces<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
X <span class="token operator">=</span> faces<span class="token punctuation">[</span><span class="token string">'X'</span><span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'X.shape'</span><span class="token punctuation">,</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
<span class="token comment"># faces.keys() dict_keys(['__header__', '__version__', '__globals__', 'X'])</span>
<span class="token comment"># X.shape (5000, 1024)</span>

<span class="token comment"># 渲染数据集中的前100张脸的函数</span>

face <span class="token operator">=</span> np<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>X<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 看起来很糟糕。 这些只有32 x 32灰度的图像（它也是侧面渲染，但我们现在可以忽略）。</span>
<span class="token comment"># 我们的下一步是在面数据集上运行PCA，并取得前100个主要特征。</span>
plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>face<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">pca</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># normalize the features</span>
    X <span class="token operator">=</span> <span class="token punctuation">(</span>X <span class="token operator">-</span> X<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> X<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># compute the covariance matrix</span>
    X <span class="token operator">=</span> np<span class="token punctuation">.</span>matrix<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'type(X)'</span><span class="token punctuation">,</span><span class="token builtin">type</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment">#type(X) &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt; (50, 2)</span>
    cov <span class="token operator">=</span> <span class="token punctuation">(</span>X<span class="token punctuation">.</span>T<span class="token operator">*</span> X<span class="token punctuation">)</span> <span class="token operator">/</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment">#cov.shape (2, 2)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cov.shape'</span><span class="token punctuation">,</span>cov<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
    <span class="token comment"># perform SVD cov是(M,N)</span>
    U<span class="token punctuation">,</span> S<span class="token punctuation">,</span> V <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>svd<span class="token punctuation">(</span>cov<span class="token punctuation">)</span><span class="token comment">#返回值u(M,M),s(M,N),v(N,N)</span>
    <span class="token comment">#因为sigma是除了对角元素不为0，其他元素都为0。所以返回的时候，作为一维矩阵返回。本来sigma应该是由3个值的，但是因为最后一个值为0，所以直接省略了。</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'U.shape, S.shape, V.shape'</span><span class="token punctuation">,</span> U<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> S<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> V<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment">#(2, 2) (2,) (2, 2)</span>
    <span class="token keyword">return</span> U<span class="token punctuation">,</span> S<span class="token punctuation">,</span> V

<span class="token keyword">def</span> <span class="token function">project_data</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> U<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    U_reduced <span class="token operator">=</span> U<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span>
    <span class="token keyword">return</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">,</span> U_reduced<span class="token punctuation">)</span>

U<span class="token punctuation">,</span> S<span class="token punctuation">,</span> V <span class="token operator">=</span> pca<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
Z <span class="token operator">=</span> project_data<span class="token punctuation">(</span>X<span class="token punctuation">,</span> U<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Z.shape'</span><span class="token punctuation">,</span>Z<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment">#Z.shape (5000, 100)</span>
</code></pre> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190729205652283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA5ODY3NTM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <h1><a id="__232"></a>四、 重构原数据</h1> 
  <p>  重构reconstruction， 根据降维后数据重构原数据，即数据还原。</p> 
  <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">recover_data</span><span class="token punctuation">(</span>Z<span class="token punctuation">,</span> U<span class="token punctuation">)</span><span class="token punctuation">:</span>
    m<span class="token punctuation">,</span> n <span class="token operator">=</span> Z<span class="token punctuation">.</span>shape

    <span class="token keyword">if</span> n <span class="token operator">&gt;=</span> U<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'Z dimension is &gt;= U, you should recover from lower dimension to higher'</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> Z @ U<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>T

</code></pre> 
  <h1><a id="Python_246"></a>有趣的事，Python永远不会缺席</h1> 
  <p><strong>欢迎关注小婷儿的博客</strong><br><br> &nbsp;&nbsp;&nbsp;&nbsp;文章内容来源于小婷儿的学习笔记，部分整理自网络，若有侵权或不当之处还请谅解</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;如需转发，请注明出处：小婷儿的博客python&nbsp;&nbsp;&nbsp;&nbsp;https://www.cnblogs.com/xxtalhr/<br><br> <strong>博客园</strong> https://www.cnblogs.com/xxtalhr/<br><br> <strong>CSDN</strong> https://blog.csdn.net/u010986753<br></p> 
  <p><strong>有问题请在博客下留言或加作者：</strong><br> &nbsp;&nbsp;&nbsp;&nbsp; 微信：tinghai87605025 联系我加微信群<br> &nbsp;&nbsp;&nbsp;&nbsp; QQ ：87605025<br> &nbsp;&nbsp;&nbsp;&nbsp; python QQ交流群：py_data 483766429</p> 
  <center>
   <img src="https://img2018.cnblogs.com/blog/1400528/201905/1400528-20190519213410020-442219723.png">
   <center> 
   </center>
   <h1><a id="strongstrongbr_260"></a><strong>培训说明</strong><br></h1> 
   <p><strong>OCP培训说明连接</strong> https://mp.weixin.qq.com/s/2cymJ4xiBPtTaHu16HkiuA<br><br> <strong>OCM培训说明连接</strong> https://mp.weixin.qq.com/s/7-R6Cz8RcJKduVv6YlAxJA<br></p> 
   <p>&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://blog.csdn.net/u010986753" rel="nofollow" data-token="00af8a43619c14227713449ee386ce37">小婷儿的python</a>正在成长中，其中还有很多不足之处，随着学习和工作的深入，会对以往的博客内容逐步改进和完善哒。重要的事多说几遍。。。。。。</p> 
  </center> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e44c3c0e64.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
