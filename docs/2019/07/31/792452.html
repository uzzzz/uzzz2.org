<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>HDFS常用命令/API+上传下载过程（三） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="HDFS常用命令/API+上传下载过程（三）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="文章目录 1. Hadoop 1.1 Hadoop发展历程 2. Hadoop的作用（解决了什么问题）/运行模式/基础组件及架构 3.学会阅读HDFS源码，并自己阅读一段HDFS的源码(推荐HDFS上传/下载过程) 4. Hadoop中各个组件的通信方式，RPC/Http等 5. 学会写WordCount（Java/Python-Hadoop Streaming） 6. 理解MapReduce的执行过程 7. Yarn在Hadoop中的作用 2. HDFS 1. 认识HDFS 1.1 Blocks 1.2 Namenode &amp; Datanode 1.3 Block Caching 1.4 HDFS Federation 1.5 HDFS HA 2. HDFS是用来解决什么问题的 3. HDFS设计与架构 3.1 设计目标 3.2 HDFS不适合的应用类型 4. 熟悉HDFS常用命令 5. Python操作HDFS的其他API 6. 观察上传后的文件，上传大于128M的文件与小于128M的文件有何区别？ 7. 启动HDFS后，会分别启动哪些进程？ 8. NameNode是如何组织文件中的元信息的，edits log与fsImage的区别？ 【Task 3】HDFS常用命令/API+上传下载过程 阅读Google三大论文，并总结 Hadoop的作用（解决了什么问题）/运行模式/基础组件及架构 学会阅读HDFS源码，并自己阅读一段HDFS的源码(推荐HDFS上传/下载过程)【可选】 Hadoop中各个组件的通信方式，RPC/Http等 学会写WordCount（Java/Python-Hadoop Streaming），理解分布式/单机运行模式的区别 理解MapReduce的执行过程 Yarn在Hadoop中的作用 认识HDFS HDFS是用来解决什么问题的 HDFS设计与架构 熟悉hdfs常用命令 Python操作HDFS的其他API 观察上传后的文件，上传大于128M的文件与小于128M的文件有何区别？ 启动HDFS后，会分别启动NameNode/DataNode/SecondaryNameNode，这些进程的的作用分别是什么？ NameNode是如何组织文件中的元信息的，edits log与fsImage的区别？使用hdfs oiv命令观察HDFS上的文件的metadata HDFS文件上传下载过程，源码阅读与整理。 这里特别说明一下，在上一个任务中主要是对Hadoop集群进行了搭建，本次任务对Hadoop和HDFS进行深入的学习。 1. Hadoop 1.1 Hadoop发展历程 Google三大理论 简单总结下： 1. GFS-2003 2003年，Google发布Google File System论文，这是一个可扩展的分布式文件系统，用于大型的、分布式的、对大量数据进行访问的应用。它运行于廉价的普通硬件上，提供容错功能。从根本上说：文件被分割成很多块，使用冗余的方式储存于商用机器集群上。 2. MapReduce—-2004 紧随其后的就是2004年公布的 MapReduce论文，论文描述了大数据的分布式计算方式，主要思想是将任务分解然后在多台处理能力较弱的计算节点中同时处理，然后将结果合并从而完成大数据处理。 传说中，Google使用它计算他们的搜索索引。而Mikio L. Braun认为其工作模式应该是：Google把所有抓取的页面都放置于他们的集群上，然后每天使用MapReduce来重算。 3. BigTable—-2006 Bigtable发布于2006年，启发了无数的NoSQL数据库，比如：Cassandra、HBase等等。Cassandra架构中有一半是模仿Bigtable，包括了数据模型、SSTables以及提前写日志（另一半是模仿Amazon的Dynamo数据库，使用点对点集群模式）。 4. GFS,MapReduce 和 BigTable三者关系如下 Google的后面两篇论文——MapReduce 和 BigTable都是以GFS为基础。三大基础核心技术构建出了完整的分布式运算架构。 2. Hadoop的作用（解决了什么问题）/运行模式/基础组件及架构 Hadoop是一个开源框架，可编写和运行分布式应用处理大规模数据。 Hadoop框架的核心是HDFS和MapReduce。其中 HDFS 是分布式文件系统，MapReduce 是分布式数据处理模型和执行环境。 随着数据的来源途径越来越多，数据的格式也越来越复杂，数据量越来越大，传统的数据库已经很难满足需求，Hadoop就是为了解决这个问题而诞生的。其底层的分布式文件系统具有高拓展性，通过数据冗余保证数据不丢失和提交计算效率，同时可以存储各种格式的数据。同时其还支持多种计算框架，既可以进行离线计算也可以进行在线实时计算。 Hadoop有三种运行模式：单机模式、伪分布式模式、完全分布式模式。 单机模式 默认模式。 不对配置文件进行修改。 使用本地文件系统，而不是分布式文件系统。 Hadoop不会启动NameNode、DataNode、JobTracker、TaskTracker等守护进程，Map()和Reduce()任务作为同一个进程的不同部分来执行的。 用于对MapReduce程序的逻辑进行调试，确保程序的正确。 伪分布式模式 在一台主机模拟多主机。 Hadoop启动NameNode、DataNode、JobTracker、TaskTracker这些守护进程都在同一台机器上运行，是相互独立的Java进程。 在这种模式下，Hadoop使用的是分布式文件系统，各个作业也是由JobTraker服务，来管理的独立进程。在单机模式之上增加了代码调试功能，允许检查内存使用情况，HDFS输入输出，以及其他的守护进程交互。类似于完全分布式模式，因此，这种模式常用来开发测试Hadoop程序的执行是否正确。 -修改3个配置文件：core-site.xml（Hadoop集群的特性，作用于全部进程及客户端）、hdfs-site.xml（配置HDFS集群的工作属性）、mapred-site.xml（配置MapReduce集群的属性） 格式化文件系统 完全分布式模式 Hadoop的守护进程运行在由多台主机搭建的集群上，是真正的生产环境。 在所有的主机上安装JDK和Hadoop，组成相互连通的网络。 在主机间设置SSH免密码登录，把各从节点生成的公钥添加到主节点的信任列表。 修改3个配置文件：core-site.xml、hdfs-site.xml、mapred-site.xml，指定NameNode和JobTraker的位置和端口，设置文件的副本等参数 3.学会阅读HDFS源码，并自己阅读一段HDFS的源码(推荐HDFS上传/下载过程) 这里有两篇写的很好的博客 Hadoop之HDFS原理及文件上传下载源码分析（上） Hadoop之HDFS原理及文件上传下载源码分析（下） 4. Hadoop中各个组件的通信方式，RPC/Http等 Hadoop RPC机制的使用 RPC，即Remote Procdure Call，中文名：远程过程调用； 它允许一台计算机程序远程调用另外一台计算机的子程序，而不用去关心底层的网络通信细节，对我们来说是透明的。因此，它经常用于分布式网络通信中。 RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 Hadoop的进程间交互都是通过RPC来进行的，比如Namenode与Datanode直接，Jobtracker与Tasktracker之间等。 Hadoop的运行就是建立在RPC基础之上的。 RPC的显著特点 （1）透明性：远程调用其他机器上的程序，对用户来说就像是调用本地方法一样； （2）高性能：RPC Server能够并发处理多个来自Client的请求； （3）可控性：jdk中已经提供了一个RPC框架—RMI，但是该PRC框架过于重量级并且可控之处比较少，所以Hadoop RPC实现了自定义的PRC框架。 RPC的基本流程 （1）RPC采用了C/S的模式； （2）Client端发送一个带有参数的请求信息到Server； （3）Server接收到这个请求以后，根据发送过来的参数调用相应的程序，然后把自己计算好的结果发送给Client端； （4）Client端接收到结果后继续运行； Hadoop中的RPC机制 同其他RPC框架一样，Hadoop RPC分为四个部分： （1）序列化层：Clent与Server端通信传递的信息采用了Hadoop里提供的序列化类或自定义的Writable类型； （2）函数调用层：Hadoop RPC通过动态代理以及java反射实现函数调用； （3）网络传输层：Hadoop RPC采用了基于TCP/IP的socket机制； （4）服务器端框架层：RPC Server利用java NIO以及采用了事件驱动的I/O模型，提高RPC Server的并发处理能力； Hadoop RPC在整个Hadoop中应用非常广泛，Client、DataNode、NameNode之间的通讯全靠它了。例如：我们平时操作HDFS的时候，使用的是FileSystem类，它的内部有个DFSClient对象，这个对象负责与NameNode打交道。在运行时，DFSClient在本地创建一个NameNode的代理，然后就操作这个代理，这个代理就会通过网络，远程调用到NameNode的方法，也能返回值。 5. 学会写WordCount（Java/Python-Hadoop Streaming） 用python写MapReduce函数——以WordCount为例 MapReduce任务—WordCount 1. Python MapReduce 代码 使用python写MapReduce的“诀窍”是利用Hadoop流的API，通过STDIN(标准输入)、STDOUT(标准输出)在Map函数和Reduce函数之间传递数据。 我们唯一需要做的是利用Python的sys.stdin读取输入数据，并把我们的输出传送给sys.stdout。Hadoop流将会帮助我们处理别的任何事情。 1.1Map阶段：mapper.py 把文件保存到hadoop/test/code/mapper.py #!/usr/bin/env python import sys for line in sys.stdin: line = line.strip() words = line.split() for word in words: print &quot;%s\t%s&quot; % (word, 1) 增加mapper.py的可执行权限 chmod +x hadoop/test/code/mapper.py 1.2.Reduce阶段：reducer.py #!/usr/bin/env python from operator import itemgetter import sys current_word = None current_count = 0 word = None for line in sys.stdin: line = line.strip() word, count = line.split(&#39;\t&#39;, 1) try: count = int(count) except ValueError: continue if current_word == word: current_count += count else: if current_word: print &quot;%s\t%s&quot; % (current_word, current_count) current_count = count current_word = word if word == current_word: print &quot;%s\t%s&quot; % (current_word, current_count) 增加reducer.py的可执行权限 chmod +x hadoop/test/code/reducer.py 功能性测试mapper.py 和 reducer.py cd test/code //执行命令 echo &quot;foo foo quux labs foo bar quux&quot; | ./mapper.py //输出内容如下 foo 1 foo 1 quux 1 labs 1 foo 1 bar 1 quux 1 //执行命令 echo &quot;foo foo quux labs foo bar quux&quot; | ./mapper.py | sort -k1,1 | ./reducer.py //输出内容 bar 1 foo 3 labs 1 2. 在Hadoop上运行python代码 Plain Text UTF-8 Plain Text UTF-8 Plain Text UTF-8 把上面的文件放到hadoop/test/datas/目录下，并把本地的数据文件拷贝到分布式文件系统HDFS中 hdfs dfs -put datas /datas 可以在浏览器里输入：“192.168.1.105:50070”， 在Utilities-Browse the file system里查看上传的文件。 　　 执行MapReduce job hadoop jar /usr/local/hadoop/share/hadoop/tools/lib/hadoop-streaming-2.5.0-cdh5.3.6.jar \ -input /datas \ -output /test/out \ -mapper &quot;python mapper.py&quot; \ -reducer &quot;python reducer.py&quot; \ -file ./mapper.py \ -file ./reducer.py 第一行是指明用到的streaming包的位置，第二行指明原文件在HDFS上的路径，第三行是输出结果在HDFS上的路径，输出路径原来不能存在，已存在的话会报错，最后两行指明Map方法和Reduce方法程序路径。 jar包的名字特别注意，到指定的文件夹中看看是否正确。 查看生成的文件 hdfs dfs -rm -f /datas/out/part-00000 成功！ 解决方案：直接在log4j日志中去除告警信息。在/usr/local/hadoop/etc/hadoop/log4j.properties文件中添加 log4j.logger.org.apache.hadoop.util.NativeCodeLoader=ERROR 6. 理解MapReduce的执行过程 首先说下Hadoop 的四大组件： HDFS，分布式存储系统；MapReduce，分布式计算系统；YARN： hadoop 的资源调度系统。；Common： 以上三大组件的底层支撑组件，主要提供基础工具包和 RPC 框架等。 Mapreduce 是一个分布式运算程序的编程框架，是用户开发“基于 hadoop的数据分析 应用”的核心框架。 Mapreduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 hadoop 集群上。 从整体层面上看，有五个独立的实体： - 客户端，提交 MapReduce 作业。 - YARN 资源管理器（YARN resource manager），负责协调集群上计算机资源的分配。 - YARN 节点管理器（YARN node manager），负责启动和监视集群中机器上的计算容器（container）。 - MapReduce的 application master，负责协调MapReduce 作业的任务。MRAppMaster 和 MapReduce 任务运行在容器中，该容器由资源管理器进行调度（schedule）[此处理解为划分、分配更为合适] 且由节点管理器进行管理。 - 分布式文件系统（通常是 HDFS），用来在其他实体间共享作业文件。 参考：MapReduce执行过程 7. Yarn在Hadoop中的作用 Yarn是Hadoop集群的资源管理系统。Yarn可以提高资源的利用率。Yarn的另一个目标就是拓展Hadoop，使得它不仅仅可以支持MapReduce计算，还能很方便的管理诸如Hive、Hbase、Pig、Spark/Shark等应用。这种新的架构设计能够使得各种类型的应用运行在Hadoop上面，并通过Yarn从系统层面进行统一的管理，也就是说，有了Yarn，各种应用就可以互不干扰的运行在同一个Hadoop系统中，共享整个集群资源。 参考：Hadoop Yarn详解 2. HDFS 深入理解HDFS：Hadoop分布式文件系统 1. 认识HDFS 在现代的企业环境中，单机容量往往无法存储大量数据，需要跨机器存储。统一管理分布在集群上的文件系统称为分布式文件系统。而一旦在系统中，引入网络，就不可避免地引入了所有网络编程的复杂性，例如挑战之一是如果保证在节点不可用的时候数据不丢失。 传统的网络文件系统（NFS）虽然也称为分布式文件系统，但是其存在一些限制。由于NFS中，文件是存储在单机上，因此无法提供可靠性保证，当很多客户端同时访问NFS Server时，很容易造成服务器压力，造成性能瓶颈。另外如果要对NFS中的文件中进行操作，需要首先同步到本地，这些修改在同步到服务端之前，其他客户端是不可见的。某种程度上，NFS不是一种典型的分布式系统，虽然它的文件的确放在远端（单一）的服务器上面。 HDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。 1.1 Blocks 物理磁盘中有块的概念，磁盘的物理Block是磁盘操作最小的单元，读写操作均以Block为最小单元，一般为512 Byte。文件系统在物理Block之上抽象了另一层概念，文件系统Block物理磁盘Block的整数倍。通常为几KB。Hadoop提供的df、fsck这类运维工具都是在文件系统的Block级别上进行操作。 HDFS的Block块比一般单机文件系统大得多，默认为128M。HDFS的文件被拆分成block-sized的chunk，chunk作为独立单元存储。比Block小的文件不会占用整个Block，只会占据实际大小。例如， 如果一个文件大小为1M，则在HDFS中只会占用1M的空间，而不是128M。 HDFS的Block为什么这么大？ 是为了最小化查找（seek）时间，控制定位文件与传输文件所用的时间比例。假设定位到Block所需的时间为10ms，磁盘传输速度为100M/s。如果要将定位到Block所用时间占传输时间的比例控制1%，则Block大小需要约100M。 但是如果Block设置过大，在MapReduce任务中，Map或者Reduce任务的个数 如果小于集群机器数量，会使得作业运行效率很低。 Block抽象的好处 block的拆分使得单个文件大小可以大于整个磁盘的容量，构成文件的Block可以分布在整个集群， 理论上，单个文件可以占据集群中所有机器的磁盘。 Block的抽象也简化了存储系统，对于Block，无需关注其权限，所有者等内容（这些内容都在文件级别上进行控制）。 Block作为容错和高可用机制中的副本单元，即以Block为单位进行复制。 1.2 Namenode &amp; Datanode 整个HDFS集群由Namenode和Datanode构成master-worker（主从）模式。Namenode复杂构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。 Namenode Namenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式： namespcae image- edit log 但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。 在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制： 1）备份持久化元数据 将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。 2）Secondary Namenode Secondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。 Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。 在HA中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。 Datanode 数据节点负责存储和提取Block，读写请求可能来自namenode，也可能直接来自客户端。数据节点周期性向Namenode汇报自己节点上所存储的Block相关信息。 1.3 Block Caching DataNode通常直接从磁盘读取数据，但是频繁使用的Block可以在内存中缓存。默认情况下，一个Block只有一个数据节点会缓存。但是可以针对每个文件可以个性化配置。 作业调度器可以利用缓存提升性能，例如MapReduce可以把任务运行在有Block缓存的节点上。 用户或者应用可以向NameNode发送缓存指令（缓存哪个文件，缓存多久）， 缓存池的概念用于管理一组缓存的权限和资源。 1.4 HDFS Federation 我们知道NameNode的内存会制约文件数量，HDFS Federation提供了一种横向扩展NameNode的方式。在Federation模式中，每个NameNode管理命名空间的一部分，例如一个NameNode管理/user目录下的文件， 另一个NameNode管理/share目录下的文件。 每个NameNode管理一个namespace volumn，所有volumn构成文件系统的元数据。每个NameNode同时维护一个Block Pool，保存Block的节点映射等信息。各NameNode之间是独立的，一个节点的失败不会导致其他节点管理的文件不可用。 客户端使用mount table将文件路径映射到NameNode。mount table是在Namenode群组之上封装了一层，这一层也是一个Hadoop文件系统的实现，通过viewfs:协议访问。 1.5 HDFS HA 在HDFS集群中，NameNode依然是单点故障（SPOF）。元数据同时写到多个文件系统以及Second NameNode定期checkpoint有利于保护数据丢失，但是并不能提高可用性。 这是因为NameNode是唯一一个对文件元数据和file-block映射负责的地方， 当它挂了之后，包括MapReduce在内的作业都无法进行读写。 当NameNode故障时，常规的做法是使用元数据备份重新启动一个NameNode。元数据备份可能来源于： 多文件系统写入中的备份 Second NameNode的检查点文件 启动新的Namenode之后，需要重新配置客户端和DataNode的NameNode信息。另外重启耗时一般比较久，稍具规模的集群重启经常需要几十分钟甚至数小时，造成重启耗时的原因大致有： 1） 元数据镜像文件载入到内存耗时较长。 2） 需要重放edit log 3） 需要收到来自DataNode的状态报告并且满足条件后才能离开安全模式提供写服务。 Hadoop的HA方案 采用HA的HDFS集群配置两个NameNode，分别处于Active和Standby状态。当Active NameNode故障之后，Standby接过责任继续提供服务，用户没有明显的中断感觉。一般耗时在几十秒到数分钟。 HA涉及到的主要实现逻辑有 1） 主备需共享edit log存储 主NameNode和待命的NameNode共享一份edit log，当主备切换时，Standby通过回放edit log同步数据。 共享存储通常有2种选择 NFS：传统的网络文件系统 QJM：quorum journal manager QJM是专门为HDFS的HA实现而设计的，用来提供高可用的edit log。 QJM运行一组journal node，edit log必须写到大部分的journal nodes。通常使用3个节点，因此允许一个节点失败，类似ZooKeeper。注意QJM没有使用ZK，虽然HDFS HA的确使用了ZK来选举主Namenode。一般推荐使用QJM。 2）DataNode需要同时往主备发送Block Report 因为Block映射数据存储在内存中（不是在磁盘上），为了在Active NameNode挂掉之后，新的NameNode能够快速启动，不需要等待来自Datanode的Block Report，DataNode需要同时向主备两个NameNode发送Block Report。 3）客户端需要配置failover模式（对用户透明） Namenode的切换对客户端来说是无感知的，通过客户端库来实现。客户端在配置文件中使用的HDFS URI是逻辑路径，映射到一对Namenode地址。客户端会不断尝试每一个Namenode地址直到成功。 4）Standby替代Secondary NameNode 如果没有启用HA，HDFS独立运行一个守护进程作为Secondary Namenode。定期checkpoint，合并镜像文件和edit日志。 如果当主Namenode失败时，备份Namenode正在关机（停止 Standby），运维人员依然可以从头启动备份Namenode，这样比没有HA的时候更省事，算是一种改进，因为重启整个过程已经标准化到Hadoop内部，无需运维进行复杂的切换操作。 NameNode的切换通过代failover controller来实现。failover controller有多种实现，默认实现使用ZooKeeper来保证只有一个Namenode处于active状态。 每个Namenode运行一个轻量级的failover controller进程，该进程使用简单的心跳机制来监控Namenode的存活状态并在Namenode失败是触发failover。Failover可以由运维手动触发，例如在日常维护中需要切换主Namenode，这种情况graceful failover，非手动触发的failover称为ungraceful failover。 在ungraceful failover的情况下，没有办法确定失败（被判定为失败）的节点是否停止运行，也就是说触发failover后，之前的主Namenode可能还在运行。QJM一次只允许一个Namenode写edit log，但是之前的主Namenode仍然可以接受读请求。Hadoop使用fencing来杀掉之前的Namenode。Fencing通过收回之前Namenode对共享的edit log的访问权限、关闭其网络端口使得原有的Namenode不能再继续接受服务请求。使用STONITH技术也可以将之前的主Namenode关机。 最后，HA方案中Namenode的切换对客户端来说是不可见的，前面已经介绍过，主要通过客户端库来完成。 2. HDFS是用来解决什么问题的 单机文件系统的限制：     早期计算机中的文件是由单机的操作系统来进行管理的，单机中的文件管理存在以下不足：     ①存储容量的限制。     ②读写性能的限制。     ③容灾能力不足。     当文件特别大的时候，上面三个问题凸显。 行业现状：     ①数据格式多样化。各业务系统数据库中的结构化数据；日志文件等半结构化数据；视频、图片等非结构化数据。传统的数据库已经满足不了我们的存储需求。     ②每天各种类型的数据以GB、TB的速度增长。单机的文件系统已管理不了如此大的数据量。 HDFS就是为了解决上面这些问题而生的：     ①HDFS是一种允许文件通过网络在多台机器上分享的文件系统。     ②HDFS将一个大文件分割成多个数据块，将这些数据块分散存储在多台机器上。     ③虽然HDFS会将文件分割成多个数据块，但在程序和用户看来就跟操作本地磁盘中的文件一样。     ④针对一个文件，可以并发读取它的数据块，增加了读取的性能。     ⑤HDFS存储的容量具有巨大的扩展性。     ⑥HDFS可以保证系统中的某些节点脱机时整个系统仍然能持续运行，并保证数据不丢失。 为什么不使用配有大量硬盘的单台机器来存储文件？     ①随着计算机硬件技术的发展，单台机器硬盘存储容量不断提升，但硬盘数据读取速度却提升缓慢。     ②硬盘寻址速度的提升远远不如网络传输速度的提升。如果数据的访问包含大量的硬盘寻址，那么读取大量数据就会花费更长的时间。 参考：https://www.jianshu.com/p/1a762fb5f842 3. HDFS设计与架构 3.1 设计目标 存储非常大的文件：这里非常大指的是几百M、G、或者TB级别。实际应用中已有很多集群存储的数据达到PB级别。根据Hadoop官网，Yahoo！的Hadoop集群约有10万颗CPU，运行在4万个机器节点上。更多世界上的Hadoop集群使用情况，参考Hadoop官网. 采用流式的数据访问方式: HDFS基于这样的一个假设：最有效的数据处理模式是一次写入、多次读取数据集经常从数据源生成或者拷贝一次，然后在其上做很多分析工作 分析工作经常读取其中的大部分数据，即使不是全部。 因此读取整个数据集所需时间比读取第一条记录的延时更重要。 运行于商业硬件上: Hadoop不需要特别贵的、reliable的机器，可运行于普通商用机器（可以从多家供应商采购） 商用机器不代表低端机器在集群中（尤其是大的集群），节点失败率是比较高的HDFS的目标是确保集群在节点失败的时候不会让用户感觉到明显的中断。 3.2 HDFS不适合的应用类型 有些场景不适合使用HDFS来存储数据。下面列举几个： 1） 低延时的数据访问 对延时要求在毫秒级别的应用，不适合采用HDFS。HDFS是为高吞吐数据传输设计的,因此可能牺牲延时HBase更适合低延时的数据访问。 2）大量小文件 文件的元数据（如目录结构，文件block的节点列表，block-node mapping）保存在NameNode的内存中， 整个文件系统的文件数量会受限于NameNode的内存大小。 经验而言，一个文件/目录/文件块一般占有150字节的元数据内存空间。如果有100万个文件，每个文件占用1个文件块，则需要大约300M的内存。因此十亿级别的文件数量在现有商用机器上难以支持。 3）多方读写，需要任意的文件修改 HDFS采用追加（append-only）的方式写入数据。不支持文件任意offset的修改。不支持多个写入器（writer）。 4. 熟悉HDFS常用命令 hadoop HDFS常用文件操作命令 HDFS常用命令 hdfs version:查看版本 1、查询 hdfs dfs -ls / ：列出/目录下的文件和目录 hdfs dfs -ls -R / ：列出/目录下的所有文件，由于有-R参数，会在文件夹和子文件夹下执行ls操作。 2、新建文件夹 hdfs dfs -mkdir -p /home/testdata/ 3、查看hdfs文件中的内容 hdfs dfs -cat /home/testdata/1.txt 4、删除文件 hdfs dfs -rm -f /home/testdata/1.txt 5、删除文件夹 hdfs dfs -rm -r /home/testdata 5. Python操作HDFS的其他API 1.安装依赖包 pip install hdfs 2.连接 # 连接hdfs服务 from hdfs import InsecureClient client = InsecureClient(&#39;http://183.168.10.11:50070&#39;, user=&#39;root&#39;) 3.列出当前目录下的所有文件 print client.list(&#39;/&#39;) 4.创建新文件，并写入内容 data = &#39;&#39;&#39; this is new file by lys！ &#39;&#39;&#39; with client.write(&#39;/foodir/myfile.txt&#39;) as writer: writer.write(data) 5.读取文件 with client.read(&#39;/foodir/myfile.txt&#39;) as reader: data = reader.read() print data 6.文件追加内容 # 通过设置append参数，向一个已经存在的文件追加写入数据 with client.write(&#39;/foodir/myfile.txt&#39;, append=True) as writer: writer.write(&#39;this is append text by lys! \n&#39;) 7.重命名 client.rename(&#39;/foodir/myfile.txt&#39;, &#39;/foodir/myfile2.txt&#39;) 8.下载到指定目录 # 下载到指定目录/home client.download(&#39;/foodir/myfile.txt&#39;, &#39;/home/myfile.txt&#39;, n_threads=3) 9.创建文件夹 client.makedirs(&#39;/testdiretory&#39;) 10.上传文件 client.upload(‘目标路径’, ‘本地源路径’) client.upload(&#39;/testdiretory/myfile.txt&#39;,&#39;/home/myfile.txt&#39; ) 11.设置权限 client.set_permission(filepath, 777) 6. 观察上传后的文件，上传大于128M的文件与小于128M的文件有何区别？ 文件块越大，寻址时间越短，但磁盘传输时间越长； 文件块越小，寻址时间越长，但磁盘传输时间越短。 为什么HDFS中块（block）不能设置太大，也不能设置太小？ 如果块设置过大， 一方面，从磁盘传输数据的时间会明显大于寻址时间，导致程序在处理这块数据时，变得非常慢； 另一方面，mapreduce中的map任务通常一次只处理一个块中的数据，如果块过大运行速度也会很慢。 如果块设置过小， 一方面存放大量小文件会占用NameNode中大量内存来存储元数据，而NameNode的内存是有限的，不可取； 另一方面文件块过小，寻址时间增大，导致程序一直在找block的开始位置。 因而，块适当设置大一些，减少寻址时间，那么传输一个由多个块组成的文件的时间主要取决于磁盘的传输速率。 HDFS中块（block）的大小为什么设置为128M？ HDFS中平均寻址时间大概为10ms； 经过前人的大量测试发现，寻址时间为传输时间的1%时，为最佳状态； 所以最佳传输时间为10ms/0.01=1000ms=1s 目前磁盘的传输速率普遍为100MB/s； 计算出最佳block大小：100MB/s x 1s = 100MB 所以我们设定block大小为128MB。 ps：实际在工业生产中，磁盘传输速率为200MB/s时，一般设定block大小为256MB ；磁盘传输速率为400MB/s时，一般设定block大小为512MB 参考：：https://blog.csdn.net/wx1528159409/article/details/84260023 7. 启动HDFS后，会分别启动哪些进程？ (1) Hadoop namenode : NameNode, SecondaryNameNode, ResourceManager datanode : DataNode, NodeManager (2) Zookeeper（安装Zookeeper的机器要为奇数台，这里有3台） QuorumPeerManager 8. NameNode是如何组织文件中的元信息的，edits log与fsImage的区别？ Fsimage文件：HDFS文件系统元数据的一个永久性的检查点，其中包含HDFS文件系统的所有目录和文件idnode的序列化信息； Fsimage.md5文件：是镜像文件的 md5 校验文件，这个校验文件是为了判断镜像文件是否被修改； Edits文件：存放HDFS文件系统的所有更新操作，文件系统客户端执行的所有写操作首先会被记录到Edits文件中 seen_txid文件：它代表的是 namenode 里面的 edits_* 文件的尾数，namenode 重启的时候，会按照 seen_txid 的数字， 循序从头跑 edits_0000001~ 到 seen_txid 的数字 VERSION文件：记录了当前NameNode的一些信息 图解： VERSION文件内容的含义？ 1.namespaceID是文件系统的唯一标识符，格式化文件系统后就会生成这个ID 2.clusterID是系统生成的集群的ID; 3.cTime是namenode存储系统创建是时间，第一次格式化系统就是0，再次格式化时就会更新; 4.storagetype说明文件存储的是什么系统存储的信息，可能是namenode/datanode 5.bolckpoolID是针对每一个namespace对应的bolckpool的ID，包含存储节点的IP等信息 参考：https://blog.csdn.net/qq_39657909/article/details/85233287" />
<meta property="og:description" content="文章目录 1. Hadoop 1.1 Hadoop发展历程 2. Hadoop的作用（解决了什么问题）/运行模式/基础组件及架构 3.学会阅读HDFS源码，并自己阅读一段HDFS的源码(推荐HDFS上传/下载过程) 4. Hadoop中各个组件的通信方式，RPC/Http等 5. 学会写WordCount（Java/Python-Hadoop Streaming） 6. 理解MapReduce的执行过程 7. Yarn在Hadoop中的作用 2. HDFS 1. 认识HDFS 1.1 Blocks 1.2 Namenode &amp; Datanode 1.3 Block Caching 1.4 HDFS Federation 1.5 HDFS HA 2. HDFS是用来解决什么问题的 3. HDFS设计与架构 3.1 设计目标 3.2 HDFS不适合的应用类型 4. 熟悉HDFS常用命令 5. Python操作HDFS的其他API 6. 观察上传后的文件，上传大于128M的文件与小于128M的文件有何区别？ 7. 启动HDFS后，会分别启动哪些进程？ 8. NameNode是如何组织文件中的元信息的，edits log与fsImage的区别？ 【Task 3】HDFS常用命令/API+上传下载过程 阅读Google三大论文，并总结 Hadoop的作用（解决了什么问题）/运行模式/基础组件及架构 学会阅读HDFS源码，并自己阅读一段HDFS的源码(推荐HDFS上传/下载过程)【可选】 Hadoop中各个组件的通信方式，RPC/Http等 学会写WordCount（Java/Python-Hadoop Streaming），理解分布式/单机运行模式的区别 理解MapReduce的执行过程 Yarn在Hadoop中的作用 认识HDFS HDFS是用来解决什么问题的 HDFS设计与架构 熟悉hdfs常用命令 Python操作HDFS的其他API 观察上传后的文件，上传大于128M的文件与小于128M的文件有何区别？ 启动HDFS后，会分别启动NameNode/DataNode/SecondaryNameNode，这些进程的的作用分别是什么？ NameNode是如何组织文件中的元信息的，edits log与fsImage的区别？使用hdfs oiv命令观察HDFS上的文件的metadata HDFS文件上传下载过程，源码阅读与整理。 这里特别说明一下，在上一个任务中主要是对Hadoop集群进行了搭建，本次任务对Hadoop和HDFS进行深入的学习。 1. Hadoop 1.1 Hadoop发展历程 Google三大理论 简单总结下： 1. GFS-2003 2003年，Google发布Google File System论文，这是一个可扩展的分布式文件系统，用于大型的、分布式的、对大量数据进行访问的应用。它运行于廉价的普通硬件上，提供容错功能。从根本上说：文件被分割成很多块，使用冗余的方式储存于商用机器集群上。 2. MapReduce—-2004 紧随其后的就是2004年公布的 MapReduce论文，论文描述了大数据的分布式计算方式，主要思想是将任务分解然后在多台处理能力较弱的计算节点中同时处理，然后将结果合并从而完成大数据处理。 传说中，Google使用它计算他们的搜索索引。而Mikio L. Braun认为其工作模式应该是：Google把所有抓取的页面都放置于他们的集群上，然后每天使用MapReduce来重算。 3. BigTable—-2006 Bigtable发布于2006年，启发了无数的NoSQL数据库，比如：Cassandra、HBase等等。Cassandra架构中有一半是模仿Bigtable，包括了数据模型、SSTables以及提前写日志（另一半是模仿Amazon的Dynamo数据库，使用点对点集群模式）。 4. GFS,MapReduce 和 BigTable三者关系如下 Google的后面两篇论文——MapReduce 和 BigTable都是以GFS为基础。三大基础核心技术构建出了完整的分布式运算架构。 2. Hadoop的作用（解决了什么问题）/运行模式/基础组件及架构 Hadoop是一个开源框架，可编写和运行分布式应用处理大规模数据。 Hadoop框架的核心是HDFS和MapReduce。其中 HDFS 是分布式文件系统，MapReduce 是分布式数据处理模型和执行环境。 随着数据的来源途径越来越多，数据的格式也越来越复杂，数据量越来越大，传统的数据库已经很难满足需求，Hadoop就是为了解决这个问题而诞生的。其底层的分布式文件系统具有高拓展性，通过数据冗余保证数据不丢失和提交计算效率，同时可以存储各种格式的数据。同时其还支持多种计算框架，既可以进行离线计算也可以进行在线实时计算。 Hadoop有三种运行模式：单机模式、伪分布式模式、完全分布式模式。 单机模式 默认模式。 不对配置文件进行修改。 使用本地文件系统，而不是分布式文件系统。 Hadoop不会启动NameNode、DataNode、JobTracker、TaskTracker等守护进程，Map()和Reduce()任务作为同一个进程的不同部分来执行的。 用于对MapReduce程序的逻辑进行调试，确保程序的正确。 伪分布式模式 在一台主机模拟多主机。 Hadoop启动NameNode、DataNode、JobTracker、TaskTracker这些守护进程都在同一台机器上运行，是相互独立的Java进程。 在这种模式下，Hadoop使用的是分布式文件系统，各个作业也是由JobTraker服务，来管理的独立进程。在单机模式之上增加了代码调试功能，允许检查内存使用情况，HDFS输入输出，以及其他的守护进程交互。类似于完全分布式模式，因此，这种模式常用来开发测试Hadoop程序的执行是否正确。 -修改3个配置文件：core-site.xml（Hadoop集群的特性，作用于全部进程及客户端）、hdfs-site.xml（配置HDFS集群的工作属性）、mapred-site.xml（配置MapReduce集群的属性） 格式化文件系统 完全分布式模式 Hadoop的守护进程运行在由多台主机搭建的集群上，是真正的生产环境。 在所有的主机上安装JDK和Hadoop，组成相互连通的网络。 在主机间设置SSH免密码登录，把各从节点生成的公钥添加到主节点的信任列表。 修改3个配置文件：core-site.xml、hdfs-site.xml、mapred-site.xml，指定NameNode和JobTraker的位置和端口，设置文件的副本等参数 3.学会阅读HDFS源码，并自己阅读一段HDFS的源码(推荐HDFS上传/下载过程) 这里有两篇写的很好的博客 Hadoop之HDFS原理及文件上传下载源码分析（上） Hadoop之HDFS原理及文件上传下载源码分析（下） 4. Hadoop中各个组件的通信方式，RPC/Http等 Hadoop RPC机制的使用 RPC，即Remote Procdure Call，中文名：远程过程调用； 它允许一台计算机程序远程调用另外一台计算机的子程序，而不用去关心底层的网络通信细节，对我们来说是透明的。因此，它经常用于分布式网络通信中。 RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 Hadoop的进程间交互都是通过RPC来进行的，比如Namenode与Datanode直接，Jobtracker与Tasktracker之间等。 Hadoop的运行就是建立在RPC基础之上的。 RPC的显著特点 （1）透明性：远程调用其他机器上的程序，对用户来说就像是调用本地方法一样； （2）高性能：RPC Server能够并发处理多个来自Client的请求； （3）可控性：jdk中已经提供了一个RPC框架—RMI，但是该PRC框架过于重量级并且可控之处比较少，所以Hadoop RPC实现了自定义的PRC框架。 RPC的基本流程 （1）RPC采用了C/S的模式； （2）Client端发送一个带有参数的请求信息到Server； （3）Server接收到这个请求以后，根据发送过来的参数调用相应的程序，然后把自己计算好的结果发送给Client端； （4）Client端接收到结果后继续运行； Hadoop中的RPC机制 同其他RPC框架一样，Hadoop RPC分为四个部分： （1）序列化层：Clent与Server端通信传递的信息采用了Hadoop里提供的序列化类或自定义的Writable类型； （2）函数调用层：Hadoop RPC通过动态代理以及java反射实现函数调用； （3）网络传输层：Hadoop RPC采用了基于TCP/IP的socket机制； （4）服务器端框架层：RPC Server利用java NIO以及采用了事件驱动的I/O模型，提高RPC Server的并发处理能力； Hadoop RPC在整个Hadoop中应用非常广泛，Client、DataNode、NameNode之间的通讯全靠它了。例如：我们平时操作HDFS的时候，使用的是FileSystem类，它的内部有个DFSClient对象，这个对象负责与NameNode打交道。在运行时，DFSClient在本地创建一个NameNode的代理，然后就操作这个代理，这个代理就会通过网络，远程调用到NameNode的方法，也能返回值。 5. 学会写WordCount（Java/Python-Hadoop Streaming） 用python写MapReduce函数——以WordCount为例 MapReduce任务—WordCount 1. Python MapReduce 代码 使用python写MapReduce的“诀窍”是利用Hadoop流的API，通过STDIN(标准输入)、STDOUT(标准输出)在Map函数和Reduce函数之间传递数据。 我们唯一需要做的是利用Python的sys.stdin读取输入数据，并把我们的输出传送给sys.stdout。Hadoop流将会帮助我们处理别的任何事情。 1.1Map阶段：mapper.py 把文件保存到hadoop/test/code/mapper.py #!/usr/bin/env python import sys for line in sys.stdin: line = line.strip() words = line.split() for word in words: print &quot;%s\t%s&quot; % (word, 1) 增加mapper.py的可执行权限 chmod +x hadoop/test/code/mapper.py 1.2.Reduce阶段：reducer.py #!/usr/bin/env python from operator import itemgetter import sys current_word = None current_count = 0 word = None for line in sys.stdin: line = line.strip() word, count = line.split(&#39;\t&#39;, 1) try: count = int(count) except ValueError: continue if current_word == word: current_count += count else: if current_word: print &quot;%s\t%s&quot; % (current_word, current_count) current_count = count current_word = word if word == current_word: print &quot;%s\t%s&quot; % (current_word, current_count) 增加reducer.py的可执行权限 chmod +x hadoop/test/code/reducer.py 功能性测试mapper.py 和 reducer.py cd test/code //执行命令 echo &quot;foo foo quux labs foo bar quux&quot; | ./mapper.py //输出内容如下 foo 1 foo 1 quux 1 labs 1 foo 1 bar 1 quux 1 //执行命令 echo &quot;foo foo quux labs foo bar quux&quot; | ./mapper.py | sort -k1,1 | ./reducer.py //输出内容 bar 1 foo 3 labs 1 2. 在Hadoop上运行python代码 Plain Text UTF-8 Plain Text UTF-8 Plain Text UTF-8 把上面的文件放到hadoop/test/datas/目录下，并把本地的数据文件拷贝到分布式文件系统HDFS中 hdfs dfs -put datas /datas 可以在浏览器里输入：“192.168.1.105:50070”， 在Utilities-Browse the file system里查看上传的文件。 　　 执行MapReduce job hadoop jar /usr/local/hadoop/share/hadoop/tools/lib/hadoop-streaming-2.5.0-cdh5.3.6.jar \ -input /datas \ -output /test/out \ -mapper &quot;python mapper.py&quot; \ -reducer &quot;python reducer.py&quot; \ -file ./mapper.py \ -file ./reducer.py 第一行是指明用到的streaming包的位置，第二行指明原文件在HDFS上的路径，第三行是输出结果在HDFS上的路径，输出路径原来不能存在，已存在的话会报错，最后两行指明Map方法和Reduce方法程序路径。 jar包的名字特别注意，到指定的文件夹中看看是否正确。 查看生成的文件 hdfs dfs -rm -f /datas/out/part-00000 成功！ 解决方案：直接在log4j日志中去除告警信息。在/usr/local/hadoop/etc/hadoop/log4j.properties文件中添加 log4j.logger.org.apache.hadoop.util.NativeCodeLoader=ERROR 6. 理解MapReduce的执行过程 首先说下Hadoop 的四大组件： HDFS，分布式存储系统；MapReduce，分布式计算系统；YARN： hadoop 的资源调度系统。；Common： 以上三大组件的底层支撑组件，主要提供基础工具包和 RPC 框架等。 Mapreduce 是一个分布式运算程序的编程框架，是用户开发“基于 hadoop的数据分析 应用”的核心框架。 Mapreduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 hadoop 集群上。 从整体层面上看，有五个独立的实体： - 客户端，提交 MapReduce 作业。 - YARN 资源管理器（YARN resource manager），负责协调集群上计算机资源的分配。 - YARN 节点管理器（YARN node manager），负责启动和监视集群中机器上的计算容器（container）。 - MapReduce的 application master，负责协调MapReduce 作业的任务。MRAppMaster 和 MapReduce 任务运行在容器中，该容器由资源管理器进行调度（schedule）[此处理解为划分、分配更为合适] 且由节点管理器进行管理。 - 分布式文件系统（通常是 HDFS），用来在其他实体间共享作业文件。 参考：MapReduce执行过程 7. Yarn在Hadoop中的作用 Yarn是Hadoop集群的资源管理系统。Yarn可以提高资源的利用率。Yarn的另一个目标就是拓展Hadoop，使得它不仅仅可以支持MapReduce计算，还能很方便的管理诸如Hive、Hbase、Pig、Spark/Shark等应用。这种新的架构设计能够使得各种类型的应用运行在Hadoop上面，并通过Yarn从系统层面进行统一的管理，也就是说，有了Yarn，各种应用就可以互不干扰的运行在同一个Hadoop系统中，共享整个集群资源。 参考：Hadoop Yarn详解 2. HDFS 深入理解HDFS：Hadoop分布式文件系统 1. 认识HDFS 在现代的企业环境中，单机容量往往无法存储大量数据，需要跨机器存储。统一管理分布在集群上的文件系统称为分布式文件系统。而一旦在系统中，引入网络，就不可避免地引入了所有网络编程的复杂性，例如挑战之一是如果保证在节点不可用的时候数据不丢失。 传统的网络文件系统（NFS）虽然也称为分布式文件系统，但是其存在一些限制。由于NFS中，文件是存储在单机上，因此无法提供可靠性保证，当很多客户端同时访问NFS Server时，很容易造成服务器压力，造成性能瓶颈。另外如果要对NFS中的文件中进行操作，需要首先同步到本地，这些修改在同步到服务端之前，其他客户端是不可见的。某种程度上，NFS不是一种典型的分布式系统，虽然它的文件的确放在远端（单一）的服务器上面。 HDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。 1.1 Blocks 物理磁盘中有块的概念，磁盘的物理Block是磁盘操作最小的单元，读写操作均以Block为最小单元，一般为512 Byte。文件系统在物理Block之上抽象了另一层概念，文件系统Block物理磁盘Block的整数倍。通常为几KB。Hadoop提供的df、fsck这类运维工具都是在文件系统的Block级别上进行操作。 HDFS的Block块比一般单机文件系统大得多，默认为128M。HDFS的文件被拆分成block-sized的chunk，chunk作为独立单元存储。比Block小的文件不会占用整个Block，只会占据实际大小。例如， 如果一个文件大小为1M，则在HDFS中只会占用1M的空间，而不是128M。 HDFS的Block为什么这么大？ 是为了最小化查找（seek）时间，控制定位文件与传输文件所用的时间比例。假设定位到Block所需的时间为10ms，磁盘传输速度为100M/s。如果要将定位到Block所用时间占传输时间的比例控制1%，则Block大小需要约100M。 但是如果Block设置过大，在MapReduce任务中，Map或者Reduce任务的个数 如果小于集群机器数量，会使得作业运行效率很低。 Block抽象的好处 block的拆分使得单个文件大小可以大于整个磁盘的容量，构成文件的Block可以分布在整个集群， 理论上，单个文件可以占据集群中所有机器的磁盘。 Block的抽象也简化了存储系统，对于Block，无需关注其权限，所有者等内容（这些内容都在文件级别上进行控制）。 Block作为容错和高可用机制中的副本单元，即以Block为单位进行复制。 1.2 Namenode &amp; Datanode 整个HDFS集群由Namenode和Datanode构成master-worker（主从）模式。Namenode复杂构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。 Namenode Namenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式： namespcae image- edit log 但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。 在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制： 1）备份持久化元数据 将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。 2）Secondary Namenode Secondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。 Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。 在HA中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。 Datanode 数据节点负责存储和提取Block，读写请求可能来自namenode，也可能直接来自客户端。数据节点周期性向Namenode汇报自己节点上所存储的Block相关信息。 1.3 Block Caching DataNode通常直接从磁盘读取数据，但是频繁使用的Block可以在内存中缓存。默认情况下，一个Block只有一个数据节点会缓存。但是可以针对每个文件可以个性化配置。 作业调度器可以利用缓存提升性能，例如MapReduce可以把任务运行在有Block缓存的节点上。 用户或者应用可以向NameNode发送缓存指令（缓存哪个文件，缓存多久）， 缓存池的概念用于管理一组缓存的权限和资源。 1.4 HDFS Federation 我们知道NameNode的内存会制约文件数量，HDFS Federation提供了一种横向扩展NameNode的方式。在Federation模式中，每个NameNode管理命名空间的一部分，例如一个NameNode管理/user目录下的文件， 另一个NameNode管理/share目录下的文件。 每个NameNode管理一个namespace volumn，所有volumn构成文件系统的元数据。每个NameNode同时维护一个Block Pool，保存Block的节点映射等信息。各NameNode之间是独立的，一个节点的失败不会导致其他节点管理的文件不可用。 客户端使用mount table将文件路径映射到NameNode。mount table是在Namenode群组之上封装了一层，这一层也是一个Hadoop文件系统的实现，通过viewfs:协议访问。 1.5 HDFS HA 在HDFS集群中，NameNode依然是单点故障（SPOF）。元数据同时写到多个文件系统以及Second NameNode定期checkpoint有利于保护数据丢失，但是并不能提高可用性。 这是因为NameNode是唯一一个对文件元数据和file-block映射负责的地方， 当它挂了之后，包括MapReduce在内的作业都无法进行读写。 当NameNode故障时，常规的做法是使用元数据备份重新启动一个NameNode。元数据备份可能来源于： 多文件系统写入中的备份 Second NameNode的检查点文件 启动新的Namenode之后，需要重新配置客户端和DataNode的NameNode信息。另外重启耗时一般比较久，稍具规模的集群重启经常需要几十分钟甚至数小时，造成重启耗时的原因大致有： 1） 元数据镜像文件载入到内存耗时较长。 2） 需要重放edit log 3） 需要收到来自DataNode的状态报告并且满足条件后才能离开安全模式提供写服务。 Hadoop的HA方案 采用HA的HDFS集群配置两个NameNode，分别处于Active和Standby状态。当Active NameNode故障之后，Standby接过责任继续提供服务，用户没有明显的中断感觉。一般耗时在几十秒到数分钟。 HA涉及到的主要实现逻辑有 1） 主备需共享edit log存储 主NameNode和待命的NameNode共享一份edit log，当主备切换时，Standby通过回放edit log同步数据。 共享存储通常有2种选择 NFS：传统的网络文件系统 QJM：quorum journal manager QJM是专门为HDFS的HA实现而设计的，用来提供高可用的edit log。 QJM运行一组journal node，edit log必须写到大部分的journal nodes。通常使用3个节点，因此允许一个节点失败，类似ZooKeeper。注意QJM没有使用ZK，虽然HDFS HA的确使用了ZK来选举主Namenode。一般推荐使用QJM。 2）DataNode需要同时往主备发送Block Report 因为Block映射数据存储在内存中（不是在磁盘上），为了在Active NameNode挂掉之后，新的NameNode能够快速启动，不需要等待来自Datanode的Block Report，DataNode需要同时向主备两个NameNode发送Block Report。 3）客户端需要配置failover模式（对用户透明） Namenode的切换对客户端来说是无感知的，通过客户端库来实现。客户端在配置文件中使用的HDFS URI是逻辑路径，映射到一对Namenode地址。客户端会不断尝试每一个Namenode地址直到成功。 4）Standby替代Secondary NameNode 如果没有启用HA，HDFS独立运行一个守护进程作为Secondary Namenode。定期checkpoint，合并镜像文件和edit日志。 如果当主Namenode失败时，备份Namenode正在关机（停止 Standby），运维人员依然可以从头启动备份Namenode，这样比没有HA的时候更省事，算是一种改进，因为重启整个过程已经标准化到Hadoop内部，无需运维进行复杂的切换操作。 NameNode的切换通过代failover controller来实现。failover controller有多种实现，默认实现使用ZooKeeper来保证只有一个Namenode处于active状态。 每个Namenode运行一个轻量级的failover controller进程，该进程使用简单的心跳机制来监控Namenode的存活状态并在Namenode失败是触发failover。Failover可以由运维手动触发，例如在日常维护中需要切换主Namenode，这种情况graceful failover，非手动触发的failover称为ungraceful failover。 在ungraceful failover的情况下，没有办法确定失败（被判定为失败）的节点是否停止运行，也就是说触发failover后，之前的主Namenode可能还在运行。QJM一次只允许一个Namenode写edit log，但是之前的主Namenode仍然可以接受读请求。Hadoop使用fencing来杀掉之前的Namenode。Fencing通过收回之前Namenode对共享的edit log的访问权限、关闭其网络端口使得原有的Namenode不能再继续接受服务请求。使用STONITH技术也可以将之前的主Namenode关机。 最后，HA方案中Namenode的切换对客户端来说是不可见的，前面已经介绍过，主要通过客户端库来完成。 2. HDFS是用来解决什么问题的 单机文件系统的限制：     早期计算机中的文件是由单机的操作系统来进行管理的，单机中的文件管理存在以下不足：     ①存储容量的限制。     ②读写性能的限制。     ③容灾能力不足。     当文件特别大的时候，上面三个问题凸显。 行业现状：     ①数据格式多样化。各业务系统数据库中的结构化数据；日志文件等半结构化数据；视频、图片等非结构化数据。传统的数据库已经满足不了我们的存储需求。     ②每天各种类型的数据以GB、TB的速度增长。单机的文件系统已管理不了如此大的数据量。 HDFS就是为了解决上面这些问题而生的：     ①HDFS是一种允许文件通过网络在多台机器上分享的文件系统。     ②HDFS将一个大文件分割成多个数据块，将这些数据块分散存储在多台机器上。     ③虽然HDFS会将文件分割成多个数据块，但在程序和用户看来就跟操作本地磁盘中的文件一样。     ④针对一个文件，可以并发读取它的数据块，增加了读取的性能。     ⑤HDFS存储的容量具有巨大的扩展性。     ⑥HDFS可以保证系统中的某些节点脱机时整个系统仍然能持续运行，并保证数据不丢失。 为什么不使用配有大量硬盘的单台机器来存储文件？     ①随着计算机硬件技术的发展，单台机器硬盘存储容量不断提升，但硬盘数据读取速度却提升缓慢。     ②硬盘寻址速度的提升远远不如网络传输速度的提升。如果数据的访问包含大量的硬盘寻址，那么读取大量数据就会花费更长的时间。 参考：https://www.jianshu.com/p/1a762fb5f842 3. HDFS设计与架构 3.1 设计目标 存储非常大的文件：这里非常大指的是几百M、G、或者TB级别。实际应用中已有很多集群存储的数据达到PB级别。根据Hadoop官网，Yahoo！的Hadoop集群约有10万颗CPU，运行在4万个机器节点上。更多世界上的Hadoop集群使用情况，参考Hadoop官网. 采用流式的数据访问方式: HDFS基于这样的一个假设：最有效的数据处理模式是一次写入、多次读取数据集经常从数据源生成或者拷贝一次，然后在其上做很多分析工作 分析工作经常读取其中的大部分数据，即使不是全部。 因此读取整个数据集所需时间比读取第一条记录的延时更重要。 运行于商业硬件上: Hadoop不需要特别贵的、reliable的机器，可运行于普通商用机器（可以从多家供应商采购） 商用机器不代表低端机器在集群中（尤其是大的集群），节点失败率是比较高的HDFS的目标是确保集群在节点失败的时候不会让用户感觉到明显的中断。 3.2 HDFS不适合的应用类型 有些场景不适合使用HDFS来存储数据。下面列举几个： 1） 低延时的数据访问 对延时要求在毫秒级别的应用，不适合采用HDFS。HDFS是为高吞吐数据传输设计的,因此可能牺牲延时HBase更适合低延时的数据访问。 2）大量小文件 文件的元数据（如目录结构，文件block的节点列表，block-node mapping）保存在NameNode的内存中， 整个文件系统的文件数量会受限于NameNode的内存大小。 经验而言，一个文件/目录/文件块一般占有150字节的元数据内存空间。如果有100万个文件，每个文件占用1个文件块，则需要大约300M的内存。因此十亿级别的文件数量在现有商用机器上难以支持。 3）多方读写，需要任意的文件修改 HDFS采用追加（append-only）的方式写入数据。不支持文件任意offset的修改。不支持多个写入器（writer）。 4. 熟悉HDFS常用命令 hadoop HDFS常用文件操作命令 HDFS常用命令 hdfs version:查看版本 1、查询 hdfs dfs -ls / ：列出/目录下的文件和目录 hdfs dfs -ls -R / ：列出/目录下的所有文件，由于有-R参数，会在文件夹和子文件夹下执行ls操作。 2、新建文件夹 hdfs dfs -mkdir -p /home/testdata/ 3、查看hdfs文件中的内容 hdfs dfs -cat /home/testdata/1.txt 4、删除文件 hdfs dfs -rm -f /home/testdata/1.txt 5、删除文件夹 hdfs dfs -rm -r /home/testdata 5. Python操作HDFS的其他API 1.安装依赖包 pip install hdfs 2.连接 # 连接hdfs服务 from hdfs import InsecureClient client = InsecureClient(&#39;http://183.168.10.11:50070&#39;, user=&#39;root&#39;) 3.列出当前目录下的所有文件 print client.list(&#39;/&#39;) 4.创建新文件，并写入内容 data = &#39;&#39;&#39; this is new file by lys！ &#39;&#39;&#39; with client.write(&#39;/foodir/myfile.txt&#39;) as writer: writer.write(data) 5.读取文件 with client.read(&#39;/foodir/myfile.txt&#39;) as reader: data = reader.read() print data 6.文件追加内容 # 通过设置append参数，向一个已经存在的文件追加写入数据 with client.write(&#39;/foodir/myfile.txt&#39;, append=True) as writer: writer.write(&#39;this is append text by lys! \n&#39;) 7.重命名 client.rename(&#39;/foodir/myfile.txt&#39;, &#39;/foodir/myfile2.txt&#39;) 8.下载到指定目录 # 下载到指定目录/home client.download(&#39;/foodir/myfile.txt&#39;, &#39;/home/myfile.txt&#39;, n_threads=3) 9.创建文件夹 client.makedirs(&#39;/testdiretory&#39;) 10.上传文件 client.upload(‘目标路径’, ‘本地源路径’) client.upload(&#39;/testdiretory/myfile.txt&#39;,&#39;/home/myfile.txt&#39; ) 11.设置权限 client.set_permission(filepath, 777) 6. 观察上传后的文件，上传大于128M的文件与小于128M的文件有何区别？ 文件块越大，寻址时间越短，但磁盘传输时间越长； 文件块越小，寻址时间越长，但磁盘传输时间越短。 为什么HDFS中块（block）不能设置太大，也不能设置太小？ 如果块设置过大， 一方面，从磁盘传输数据的时间会明显大于寻址时间，导致程序在处理这块数据时，变得非常慢； 另一方面，mapreduce中的map任务通常一次只处理一个块中的数据，如果块过大运行速度也会很慢。 如果块设置过小， 一方面存放大量小文件会占用NameNode中大量内存来存储元数据，而NameNode的内存是有限的，不可取； 另一方面文件块过小，寻址时间增大，导致程序一直在找block的开始位置。 因而，块适当设置大一些，减少寻址时间，那么传输一个由多个块组成的文件的时间主要取决于磁盘的传输速率。 HDFS中块（block）的大小为什么设置为128M？ HDFS中平均寻址时间大概为10ms； 经过前人的大量测试发现，寻址时间为传输时间的1%时，为最佳状态； 所以最佳传输时间为10ms/0.01=1000ms=1s 目前磁盘的传输速率普遍为100MB/s； 计算出最佳block大小：100MB/s x 1s = 100MB 所以我们设定block大小为128MB。 ps：实际在工业生产中，磁盘传输速率为200MB/s时，一般设定block大小为256MB ；磁盘传输速率为400MB/s时，一般设定block大小为512MB 参考：：https://blog.csdn.net/wx1528159409/article/details/84260023 7. 启动HDFS后，会分别启动哪些进程？ (1) Hadoop namenode : NameNode, SecondaryNameNode, ResourceManager datanode : DataNode, NodeManager (2) Zookeeper（安装Zookeeper的机器要为奇数台，这里有3台） QuorumPeerManager 8. NameNode是如何组织文件中的元信息的，edits log与fsImage的区别？ Fsimage文件：HDFS文件系统元数据的一个永久性的检查点，其中包含HDFS文件系统的所有目录和文件idnode的序列化信息； Fsimage.md5文件：是镜像文件的 md5 校验文件，这个校验文件是为了判断镜像文件是否被修改； Edits文件：存放HDFS文件系统的所有更新操作，文件系统客户端执行的所有写操作首先会被记录到Edits文件中 seen_txid文件：它代表的是 namenode 里面的 edits_* 文件的尾数，namenode 重启的时候，会按照 seen_txid 的数字， 循序从头跑 edits_0000001~ 到 seen_txid 的数字 VERSION文件：记录了当前NameNode的一些信息 图解： VERSION文件内容的含义？ 1.namespaceID是文件系统的唯一标识符，格式化文件系统后就会生成这个ID 2.clusterID是系统生成的集群的ID; 3.cTime是namenode存储系统创建是时间，第一次格式化系统就是0，再次格式化时就会更新; 4.storagetype说明文件存储的是什么系统存储的信息，可能是namenode/datanode 5.bolckpoolID是针对每一个namespace对应的bolckpool的ID，包含存储节点的IP等信息 参考：https://blog.csdn.net/qq_39657909/article/details/85233287" />
<link rel="canonical" href="https://uzzz.org/2019/07/31/792452.html" />
<meta property="og:url" content="https://uzzz.org/2019/07/31/792452.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-31T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"文章目录 1. Hadoop 1.1 Hadoop发展历程 2. Hadoop的作用（解决了什么问题）/运行模式/基础组件及架构 3.学会阅读HDFS源码，并自己阅读一段HDFS的源码(推荐HDFS上传/下载过程) 4. Hadoop中各个组件的通信方式，RPC/Http等 5. 学会写WordCount（Java/Python-Hadoop Streaming） 6. 理解MapReduce的执行过程 7. Yarn在Hadoop中的作用 2. HDFS 1. 认识HDFS 1.1 Blocks 1.2 Namenode &amp; Datanode 1.3 Block Caching 1.4 HDFS Federation 1.5 HDFS HA 2. HDFS是用来解决什么问题的 3. HDFS设计与架构 3.1 设计目标 3.2 HDFS不适合的应用类型 4. 熟悉HDFS常用命令 5. Python操作HDFS的其他API 6. 观察上传后的文件，上传大于128M的文件与小于128M的文件有何区别？ 7. 启动HDFS后，会分别启动哪些进程？ 8. NameNode是如何组织文件中的元信息的，edits log与fsImage的区别？ 【Task 3】HDFS常用命令/API+上传下载过程 阅读Google三大论文，并总结 Hadoop的作用（解决了什么问题）/运行模式/基础组件及架构 学会阅读HDFS源码，并自己阅读一段HDFS的源码(推荐HDFS上传/下载过程)【可选】 Hadoop中各个组件的通信方式，RPC/Http等 学会写WordCount（Java/Python-Hadoop Streaming），理解分布式/单机运行模式的区别 理解MapReduce的执行过程 Yarn在Hadoop中的作用 认识HDFS HDFS是用来解决什么问题的 HDFS设计与架构 熟悉hdfs常用命令 Python操作HDFS的其他API 观察上传后的文件，上传大于128M的文件与小于128M的文件有何区别？ 启动HDFS后，会分别启动NameNode/DataNode/SecondaryNameNode，这些进程的的作用分别是什么？ NameNode是如何组织文件中的元信息的，edits log与fsImage的区别？使用hdfs oiv命令观察HDFS上的文件的metadata HDFS文件上传下载过程，源码阅读与整理。 这里特别说明一下，在上一个任务中主要是对Hadoop集群进行了搭建，本次任务对Hadoop和HDFS进行深入的学习。 1. Hadoop 1.1 Hadoop发展历程 Google三大理论 简单总结下： 1. GFS-2003 2003年，Google发布Google File System论文，这是一个可扩展的分布式文件系统，用于大型的、分布式的、对大量数据进行访问的应用。它运行于廉价的普通硬件上，提供容错功能。从根本上说：文件被分割成很多块，使用冗余的方式储存于商用机器集群上。 2. MapReduce—-2004 紧随其后的就是2004年公布的 MapReduce论文，论文描述了大数据的分布式计算方式，主要思想是将任务分解然后在多台处理能力较弱的计算节点中同时处理，然后将结果合并从而完成大数据处理。 传说中，Google使用它计算他们的搜索索引。而Mikio L. Braun认为其工作模式应该是：Google把所有抓取的页面都放置于他们的集群上，然后每天使用MapReduce来重算。 3. BigTable—-2006 Bigtable发布于2006年，启发了无数的NoSQL数据库，比如：Cassandra、HBase等等。Cassandra架构中有一半是模仿Bigtable，包括了数据模型、SSTables以及提前写日志（另一半是模仿Amazon的Dynamo数据库，使用点对点集群模式）。 4. GFS,MapReduce 和 BigTable三者关系如下 Google的后面两篇论文——MapReduce 和 BigTable都是以GFS为基础。三大基础核心技术构建出了完整的分布式运算架构。 2. Hadoop的作用（解决了什么问题）/运行模式/基础组件及架构 Hadoop是一个开源框架，可编写和运行分布式应用处理大规模数据。 Hadoop框架的核心是HDFS和MapReduce。其中 HDFS 是分布式文件系统，MapReduce 是分布式数据处理模型和执行环境。 随着数据的来源途径越来越多，数据的格式也越来越复杂，数据量越来越大，传统的数据库已经很难满足需求，Hadoop就是为了解决这个问题而诞生的。其底层的分布式文件系统具有高拓展性，通过数据冗余保证数据不丢失和提交计算效率，同时可以存储各种格式的数据。同时其还支持多种计算框架，既可以进行离线计算也可以进行在线实时计算。 Hadoop有三种运行模式：单机模式、伪分布式模式、完全分布式模式。 单机模式 默认模式。 不对配置文件进行修改。 使用本地文件系统，而不是分布式文件系统。 Hadoop不会启动NameNode、DataNode、JobTracker、TaskTracker等守护进程，Map()和Reduce()任务作为同一个进程的不同部分来执行的。 用于对MapReduce程序的逻辑进行调试，确保程序的正确。 伪分布式模式 在一台主机模拟多主机。 Hadoop启动NameNode、DataNode、JobTracker、TaskTracker这些守护进程都在同一台机器上运行，是相互独立的Java进程。 在这种模式下，Hadoop使用的是分布式文件系统，各个作业也是由JobTraker服务，来管理的独立进程。在单机模式之上增加了代码调试功能，允许检查内存使用情况，HDFS输入输出，以及其他的守护进程交互。类似于完全分布式模式，因此，这种模式常用来开发测试Hadoop程序的执行是否正确。 -修改3个配置文件：core-site.xml（Hadoop集群的特性，作用于全部进程及客户端）、hdfs-site.xml（配置HDFS集群的工作属性）、mapred-site.xml（配置MapReduce集群的属性） 格式化文件系统 完全分布式模式 Hadoop的守护进程运行在由多台主机搭建的集群上，是真正的生产环境。 在所有的主机上安装JDK和Hadoop，组成相互连通的网络。 在主机间设置SSH免密码登录，把各从节点生成的公钥添加到主节点的信任列表。 修改3个配置文件：core-site.xml、hdfs-site.xml、mapred-site.xml，指定NameNode和JobTraker的位置和端口，设置文件的副本等参数 3.学会阅读HDFS源码，并自己阅读一段HDFS的源码(推荐HDFS上传/下载过程) 这里有两篇写的很好的博客 Hadoop之HDFS原理及文件上传下载源码分析（上） Hadoop之HDFS原理及文件上传下载源码分析（下） 4. Hadoop中各个组件的通信方式，RPC/Http等 Hadoop RPC机制的使用 RPC，即Remote Procdure Call，中文名：远程过程调用； 它允许一台计算机程序远程调用另外一台计算机的子程序，而不用去关心底层的网络通信细节，对我们来说是透明的。因此，它经常用于分布式网络通信中。 RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 Hadoop的进程间交互都是通过RPC来进行的，比如Namenode与Datanode直接，Jobtracker与Tasktracker之间等。 Hadoop的运行就是建立在RPC基础之上的。 RPC的显著特点 （1）透明性：远程调用其他机器上的程序，对用户来说就像是调用本地方法一样； （2）高性能：RPC Server能够并发处理多个来自Client的请求； （3）可控性：jdk中已经提供了一个RPC框架—RMI，但是该PRC框架过于重量级并且可控之处比较少，所以Hadoop RPC实现了自定义的PRC框架。 RPC的基本流程 （1）RPC采用了C/S的模式； （2）Client端发送一个带有参数的请求信息到Server； （3）Server接收到这个请求以后，根据发送过来的参数调用相应的程序，然后把自己计算好的结果发送给Client端； （4）Client端接收到结果后继续运行； Hadoop中的RPC机制 同其他RPC框架一样，Hadoop RPC分为四个部分： （1）序列化层：Clent与Server端通信传递的信息采用了Hadoop里提供的序列化类或自定义的Writable类型； （2）函数调用层：Hadoop RPC通过动态代理以及java反射实现函数调用； （3）网络传输层：Hadoop RPC采用了基于TCP/IP的socket机制； （4）服务器端框架层：RPC Server利用java NIO以及采用了事件驱动的I/O模型，提高RPC Server的并发处理能力； Hadoop RPC在整个Hadoop中应用非常广泛，Client、DataNode、NameNode之间的通讯全靠它了。例如：我们平时操作HDFS的时候，使用的是FileSystem类，它的内部有个DFSClient对象，这个对象负责与NameNode打交道。在运行时，DFSClient在本地创建一个NameNode的代理，然后就操作这个代理，这个代理就会通过网络，远程调用到NameNode的方法，也能返回值。 5. 学会写WordCount（Java/Python-Hadoop Streaming） 用python写MapReduce函数——以WordCount为例 MapReduce任务—WordCount 1. Python MapReduce 代码 使用python写MapReduce的“诀窍”是利用Hadoop流的API，通过STDIN(标准输入)、STDOUT(标准输出)在Map函数和Reduce函数之间传递数据。 我们唯一需要做的是利用Python的sys.stdin读取输入数据，并把我们的输出传送给sys.stdout。Hadoop流将会帮助我们处理别的任何事情。 1.1Map阶段：mapper.py 把文件保存到hadoop/test/code/mapper.py #!/usr/bin/env python import sys for line in sys.stdin: line = line.strip() words = line.split() for word in words: print &quot;%s\\t%s&quot; % (word, 1) 增加mapper.py的可执行权限 chmod +x hadoop/test/code/mapper.py 1.2.Reduce阶段：reducer.py #!/usr/bin/env python from operator import itemgetter import sys current_word = None current_count = 0 word = None for line in sys.stdin: line = line.strip() word, count = line.split(&#39;\\t&#39;, 1) try: count = int(count) except ValueError: continue if current_word == word: current_count += count else: if current_word: print &quot;%s\\t%s&quot; % (current_word, current_count) current_count = count current_word = word if word == current_word: print &quot;%s\\t%s&quot; % (current_word, current_count) 增加reducer.py的可执行权限 chmod +x hadoop/test/code/reducer.py 功能性测试mapper.py 和 reducer.py cd test/code //执行命令 echo &quot;foo foo quux labs foo bar quux&quot; | ./mapper.py //输出内容如下 foo 1 foo 1 quux 1 labs 1 foo 1 bar 1 quux 1 //执行命令 echo &quot;foo foo quux labs foo bar quux&quot; | ./mapper.py | sort -k1,1 | ./reducer.py //输出内容 bar 1 foo 3 labs 1 2. 在Hadoop上运行python代码 Plain Text UTF-8 Plain Text UTF-8 Plain Text UTF-8 把上面的文件放到hadoop/test/datas/目录下，并把本地的数据文件拷贝到分布式文件系统HDFS中 hdfs dfs -put datas /datas 可以在浏览器里输入：“192.168.1.105:50070”， 在Utilities-Browse the file system里查看上传的文件。 　　 执行MapReduce job hadoop jar /usr/local/hadoop/share/hadoop/tools/lib/hadoop-streaming-2.5.0-cdh5.3.6.jar \\ -input /datas \\ -output /test/out \\ -mapper &quot;python mapper.py&quot; \\ -reducer &quot;python reducer.py&quot; \\ -file ./mapper.py \\ -file ./reducer.py 第一行是指明用到的streaming包的位置，第二行指明原文件在HDFS上的路径，第三行是输出结果在HDFS上的路径，输出路径原来不能存在，已存在的话会报错，最后两行指明Map方法和Reduce方法程序路径。 jar包的名字特别注意，到指定的文件夹中看看是否正确。 查看生成的文件 hdfs dfs -rm -f /datas/out/part-00000 成功！ 解决方案：直接在log4j日志中去除告警信息。在/usr/local/hadoop/etc/hadoop/log4j.properties文件中添加 log4j.logger.org.apache.hadoop.util.NativeCodeLoader=ERROR 6. 理解MapReduce的执行过程 首先说下Hadoop 的四大组件： HDFS，分布式存储系统；MapReduce，分布式计算系统；YARN： hadoop 的资源调度系统。；Common： 以上三大组件的底层支撑组件，主要提供基础工具包和 RPC 框架等。 Mapreduce 是一个分布式运算程序的编程框架，是用户开发“基于 hadoop的数据分析 应用”的核心框架。 Mapreduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 hadoop 集群上。 从整体层面上看，有五个独立的实体： - 客户端，提交 MapReduce 作业。 - YARN 资源管理器（YARN resource manager），负责协调集群上计算机资源的分配。 - YARN 节点管理器（YARN node manager），负责启动和监视集群中机器上的计算容器（container）。 - MapReduce的 application master，负责协调MapReduce 作业的任务。MRAppMaster 和 MapReduce 任务运行在容器中，该容器由资源管理器进行调度（schedule）[此处理解为划分、分配更为合适] 且由节点管理器进行管理。 - 分布式文件系统（通常是 HDFS），用来在其他实体间共享作业文件。 参考：MapReduce执行过程 7. Yarn在Hadoop中的作用 Yarn是Hadoop集群的资源管理系统。Yarn可以提高资源的利用率。Yarn的另一个目标就是拓展Hadoop，使得它不仅仅可以支持MapReduce计算，还能很方便的管理诸如Hive、Hbase、Pig、Spark/Shark等应用。这种新的架构设计能够使得各种类型的应用运行在Hadoop上面，并通过Yarn从系统层面进行统一的管理，也就是说，有了Yarn，各种应用就可以互不干扰的运行在同一个Hadoop系统中，共享整个集群资源。 参考：Hadoop Yarn详解 2. HDFS 深入理解HDFS：Hadoop分布式文件系统 1. 认识HDFS 在现代的企业环境中，单机容量往往无法存储大量数据，需要跨机器存储。统一管理分布在集群上的文件系统称为分布式文件系统。而一旦在系统中，引入网络，就不可避免地引入了所有网络编程的复杂性，例如挑战之一是如果保证在节点不可用的时候数据不丢失。 传统的网络文件系统（NFS）虽然也称为分布式文件系统，但是其存在一些限制。由于NFS中，文件是存储在单机上，因此无法提供可靠性保证，当很多客户端同时访问NFS Server时，很容易造成服务器压力，造成性能瓶颈。另外如果要对NFS中的文件中进行操作，需要首先同步到本地，这些修改在同步到服务端之前，其他客户端是不可见的。某种程度上，NFS不是一种典型的分布式系统，虽然它的文件的确放在远端（单一）的服务器上面。 HDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。 1.1 Blocks 物理磁盘中有块的概念，磁盘的物理Block是磁盘操作最小的单元，读写操作均以Block为最小单元，一般为512 Byte。文件系统在物理Block之上抽象了另一层概念，文件系统Block物理磁盘Block的整数倍。通常为几KB。Hadoop提供的df、fsck这类运维工具都是在文件系统的Block级别上进行操作。 HDFS的Block块比一般单机文件系统大得多，默认为128M。HDFS的文件被拆分成block-sized的chunk，chunk作为独立单元存储。比Block小的文件不会占用整个Block，只会占据实际大小。例如， 如果一个文件大小为1M，则在HDFS中只会占用1M的空间，而不是128M。 HDFS的Block为什么这么大？ 是为了最小化查找（seek）时间，控制定位文件与传输文件所用的时间比例。假设定位到Block所需的时间为10ms，磁盘传输速度为100M/s。如果要将定位到Block所用时间占传输时间的比例控制1%，则Block大小需要约100M。 但是如果Block设置过大，在MapReduce任务中，Map或者Reduce任务的个数 如果小于集群机器数量，会使得作业运行效率很低。 Block抽象的好处 block的拆分使得单个文件大小可以大于整个磁盘的容量，构成文件的Block可以分布在整个集群， 理论上，单个文件可以占据集群中所有机器的磁盘。 Block的抽象也简化了存储系统，对于Block，无需关注其权限，所有者等内容（这些内容都在文件级别上进行控制）。 Block作为容错和高可用机制中的副本单元，即以Block为单位进行复制。 1.2 Namenode &amp; Datanode 整个HDFS集群由Namenode和Datanode构成master-worker（主从）模式。Namenode复杂构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。 Namenode Namenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式： namespcae image- edit log 但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。 在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制： 1）备份持久化元数据 将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。 2）Secondary Namenode Secondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。 Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。 在HA中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。 Datanode 数据节点负责存储和提取Block，读写请求可能来自namenode，也可能直接来自客户端。数据节点周期性向Namenode汇报自己节点上所存储的Block相关信息。 1.3 Block Caching DataNode通常直接从磁盘读取数据，但是频繁使用的Block可以在内存中缓存。默认情况下，一个Block只有一个数据节点会缓存。但是可以针对每个文件可以个性化配置。 作业调度器可以利用缓存提升性能，例如MapReduce可以把任务运行在有Block缓存的节点上。 用户或者应用可以向NameNode发送缓存指令（缓存哪个文件，缓存多久）， 缓存池的概念用于管理一组缓存的权限和资源。 1.4 HDFS Federation 我们知道NameNode的内存会制约文件数量，HDFS Federation提供了一种横向扩展NameNode的方式。在Federation模式中，每个NameNode管理命名空间的一部分，例如一个NameNode管理/user目录下的文件， 另一个NameNode管理/share目录下的文件。 每个NameNode管理一个namespace volumn，所有volumn构成文件系统的元数据。每个NameNode同时维护一个Block Pool，保存Block的节点映射等信息。各NameNode之间是独立的，一个节点的失败不会导致其他节点管理的文件不可用。 客户端使用mount table将文件路径映射到NameNode。mount table是在Namenode群组之上封装了一层，这一层也是一个Hadoop文件系统的实现，通过viewfs:协议访问。 1.5 HDFS HA 在HDFS集群中，NameNode依然是单点故障（SPOF）。元数据同时写到多个文件系统以及Second NameNode定期checkpoint有利于保护数据丢失，但是并不能提高可用性。 这是因为NameNode是唯一一个对文件元数据和file-block映射负责的地方， 当它挂了之后，包括MapReduce在内的作业都无法进行读写。 当NameNode故障时，常规的做法是使用元数据备份重新启动一个NameNode。元数据备份可能来源于： 多文件系统写入中的备份 Second NameNode的检查点文件 启动新的Namenode之后，需要重新配置客户端和DataNode的NameNode信息。另外重启耗时一般比较久，稍具规模的集群重启经常需要几十分钟甚至数小时，造成重启耗时的原因大致有： 1） 元数据镜像文件载入到内存耗时较长。 2） 需要重放edit log 3） 需要收到来自DataNode的状态报告并且满足条件后才能离开安全模式提供写服务。 Hadoop的HA方案 采用HA的HDFS集群配置两个NameNode，分别处于Active和Standby状态。当Active NameNode故障之后，Standby接过责任继续提供服务，用户没有明显的中断感觉。一般耗时在几十秒到数分钟。 HA涉及到的主要实现逻辑有 1） 主备需共享edit log存储 主NameNode和待命的NameNode共享一份edit log，当主备切换时，Standby通过回放edit log同步数据。 共享存储通常有2种选择 NFS：传统的网络文件系统 QJM：quorum journal manager QJM是专门为HDFS的HA实现而设计的，用来提供高可用的edit log。 QJM运行一组journal node，edit log必须写到大部分的journal nodes。通常使用3个节点，因此允许一个节点失败，类似ZooKeeper。注意QJM没有使用ZK，虽然HDFS HA的确使用了ZK来选举主Namenode。一般推荐使用QJM。 2）DataNode需要同时往主备发送Block Report 因为Block映射数据存储在内存中（不是在磁盘上），为了在Active NameNode挂掉之后，新的NameNode能够快速启动，不需要等待来自Datanode的Block Report，DataNode需要同时向主备两个NameNode发送Block Report。 3）客户端需要配置failover模式（对用户透明） Namenode的切换对客户端来说是无感知的，通过客户端库来实现。客户端在配置文件中使用的HDFS URI是逻辑路径，映射到一对Namenode地址。客户端会不断尝试每一个Namenode地址直到成功。 4）Standby替代Secondary NameNode 如果没有启用HA，HDFS独立运行一个守护进程作为Secondary Namenode。定期checkpoint，合并镜像文件和edit日志。 如果当主Namenode失败时，备份Namenode正在关机（停止 Standby），运维人员依然可以从头启动备份Namenode，这样比没有HA的时候更省事，算是一种改进，因为重启整个过程已经标准化到Hadoop内部，无需运维进行复杂的切换操作。 NameNode的切换通过代failover controller来实现。failover controller有多种实现，默认实现使用ZooKeeper来保证只有一个Namenode处于active状态。 每个Namenode运行一个轻量级的failover controller进程，该进程使用简单的心跳机制来监控Namenode的存活状态并在Namenode失败是触发failover。Failover可以由运维手动触发，例如在日常维护中需要切换主Namenode，这种情况graceful failover，非手动触发的failover称为ungraceful failover。 在ungraceful failover的情况下，没有办法确定失败（被判定为失败）的节点是否停止运行，也就是说触发failover后，之前的主Namenode可能还在运行。QJM一次只允许一个Namenode写edit log，但是之前的主Namenode仍然可以接受读请求。Hadoop使用fencing来杀掉之前的Namenode。Fencing通过收回之前Namenode对共享的edit log的访问权限、关闭其网络端口使得原有的Namenode不能再继续接受服务请求。使用STONITH技术也可以将之前的主Namenode关机。 最后，HA方案中Namenode的切换对客户端来说是不可见的，前面已经介绍过，主要通过客户端库来完成。 2. HDFS是用来解决什么问题的 单机文件系统的限制：     早期计算机中的文件是由单机的操作系统来进行管理的，单机中的文件管理存在以下不足：     ①存储容量的限制。     ②读写性能的限制。     ③容灾能力不足。     当文件特别大的时候，上面三个问题凸显。 行业现状：     ①数据格式多样化。各业务系统数据库中的结构化数据；日志文件等半结构化数据；视频、图片等非结构化数据。传统的数据库已经满足不了我们的存储需求。     ②每天各种类型的数据以GB、TB的速度增长。单机的文件系统已管理不了如此大的数据量。 HDFS就是为了解决上面这些问题而生的：     ①HDFS是一种允许文件通过网络在多台机器上分享的文件系统。     ②HDFS将一个大文件分割成多个数据块，将这些数据块分散存储在多台机器上。     ③虽然HDFS会将文件分割成多个数据块，但在程序和用户看来就跟操作本地磁盘中的文件一样。     ④针对一个文件，可以并发读取它的数据块，增加了读取的性能。     ⑤HDFS存储的容量具有巨大的扩展性。     ⑥HDFS可以保证系统中的某些节点脱机时整个系统仍然能持续运行，并保证数据不丢失。 为什么不使用配有大量硬盘的单台机器来存储文件？     ①随着计算机硬件技术的发展，单台机器硬盘存储容量不断提升，但硬盘数据读取速度却提升缓慢。     ②硬盘寻址速度的提升远远不如网络传输速度的提升。如果数据的访问包含大量的硬盘寻址，那么读取大量数据就会花费更长的时间。 参考：https://www.jianshu.com/p/1a762fb5f842 3. HDFS设计与架构 3.1 设计目标 存储非常大的文件：这里非常大指的是几百M、G、或者TB级别。实际应用中已有很多集群存储的数据达到PB级别。根据Hadoop官网，Yahoo！的Hadoop集群约有10万颗CPU，运行在4万个机器节点上。更多世界上的Hadoop集群使用情况，参考Hadoop官网. 采用流式的数据访问方式: HDFS基于这样的一个假设：最有效的数据处理模式是一次写入、多次读取数据集经常从数据源生成或者拷贝一次，然后在其上做很多分析工作 分析工作经常读取其中的大部分数据，即使不是全部。 因此读取整个数据集所需时间比读取第一条记录的延时更重要。 运行于商业硬件上: Hadoop不需要特别贵的、reliable的机器，可运行于普通商用机器（可以从多家供应商采购） 商用机器不代表低端机器在集群中（尤其是大的集群），节点失败率是比较高的HDFS的目标是确保集群在节点失败的时候不会让用户感觉到明显的中断。 3.2 HDFS不适合的应用类型 有些场景不适合使用HDFS来存储数据。下面列举几个： 1） 低延时的数据访问 对延时要求在毫秒级别的应用，不适合采用HDFS。HDFS是为高吞吐数据传输设计的,因此可能牺牲延时HBase更适合低延时的数据访问。 2）大量小文件 文件的元数据（如目录结构，文件block的节点列表，block-node mapping）保存在NameNode的内存中， 整个文件系统的文件数量会受限于NameNode的内存大小。 经验而言，一个文件/目录/文件块一般占有150字节的元数据内存空间。如果有100万个文件，每个文件占用1个文件块，则需要大约300M的内存。因此十亿级别的文件数量在现有商用机器上难以支持。 3）多方读写，需要任意的文件修改 HDFS采用追加（append-only）的方式写入数据。不支持文件任意offset的修改。不支持多个写入器（writer）。 4. 熟悉HDFS常用命令 hadoop HDFS常用文件操作命令 HDFS常用命令 hdfs version:查看版本 1、查询 hdfs dfs -ls / ：列出/目录下的文件和目录 hdfs dfs -ls -R / ：列出/目录下的所有文件，由于有-R参数，会在文件夹和子文件夹下执行ls操作。 2、新建文件夹 hdfs dfs -mkdir -p /home/testdata/ 3、查看hdfs文件中的内容 hdfs dfs -cat /home/testdata/1.txt 4、删除文件 hdfs dfs -rm -f /home/testdata/1.txt 5、删除文件夹 hdfs dfs -rm -r /home/testdata 5. Python操作HDFS的其他API 1.安装依赖包 pip install hdfs 2.连接 # 连接hdfs服务 from hdfs import InsecureClient client = InsecureClient(&#39;http://183.168.10.11:50070&#39;, user=&#39;root&#39;) 3.列出当前目录下的所有文件 print client.list(&#39;/&#39;) 4.创建新文件，并写入内容 data = &#39;&#39;&#39; this is new file by lys！ &#39;&#39;&#39; with client.write(&#39;/foodir/myfile.txt&#39;) as writer: writer.write(data) 5.读取文件 with client.read(&#39;/foodir/myfile.txt&#39;) as reader: data = reader.read() print data 6.文件追加内容 # 通过设置append参数，向一个已经存在的文件追加写入数据 with client.write(&#39;/foodir/myfile.txt&#39;, append=True) as writer: writer.write(&#39;this is append text by lys! \\n&#39;) 7.重命名 client.rename(&#39;/foodir/myfile.txt&#39;, &#39;/foodir/myfile2.txt&#39;) 8.下载到指定目录 # 下载到指定目录/home client.download(&#39;/foodir/myfile.txt&#39;, &#39;/home/myfile.txt&#39;, n_threads=3) 9.创建文件夹 client.makedirs(&#39;/testdiretory&#39;) 10.上传文件 client.upload(‘目标路径’, ‘本地源路径’) client.upload(&#39;/testdiretory/myfile.txt&#39;,&#39;/home/myfile.txt&#39; ) 11.设置权限 client.set_permission(filepath, 777) 6. 观察上传后的文件，上传大于128M的文件与小于128M的文件有何区别？ 文件块越大，寻址时间越短，但磁盘传输时间越长； 文件块越小，寻址时间越长，但磁盘传输时间越短。 为什么HDFS中块（block）不能设置太大，也不能设置太小？ 如果块设置过大， 一方面，从磁盘传输数据的时间会明显大于寻址时间，导致程序在处理这块数据时，变得非常慢； 另一方面，mapreduce中的map任务通常一次只处理一个块中的数据，如果块过大运行速度也会很慢。 如果块设置过小， 一方面存放大量小文件会占用NameNode中大量内存来存储元数据，而NameNode的内存是有限的，不可取； 另一方面文件块过小，寻址时间增大，导致程序一直在找block的开始位置。 因而，块适当设置大一些，减少寻址时间，那么传输一个由多个块组成的文件的时间主要取决于磁盘的传输速率。 HDFS中块（block）的大小为什么设置为128M？ HDFS中平均寻址时间大概为10ms； 经过前人的大量测试发现，寻址时间为传输时间的1%时，为最佳状态； 所以最佳传输时间为10ms/0.01=1000ms=1s 目前磁盘的传输速率普遍为100MB/s； 计算出最佳block大小：100MB/s x 1s = 100MB 所以我们设定block大小为128MB。 ps：实际在工业生产中，磁盘传输速率为200MB/s时，一般设定block大小为256MB ；磁盘传输速率为400MB/s时，一般设定block大小为512MB 参考：：https://blog.csdn.net/wx1528159409/article/details/84260023 7. 启动HDFS后，会分别启动哪些进程？ (1) Hadoop namenode : NameNode, SecondaryNameNode, ResourceManager datanode : DataNode, NodeManager (2) Zookeeper（安装Zookeeper的机器要为奇数台，这里有3台） QuorumPeerManager 8. NameNode是如何组织文件中的元信息的，edits log与fsImage的区别？ Fsimage文件：HDFS文件系统元数据的一个永久性的检查点，其中包含HDFS文件系统的所有目录和文件idnode的序列化信息； Fsimage.md5文件：是镜像文件的 md5 校验文件，这个校验文件是为了判断镜像文件是否被修改； Edits文件：存放HDFS文件系统的所有更新操作，文件系统客户端执行的所有写操作首先会被记录到Edits文件中 seen_txid文件：它代表的是 namenode 里面的 edits_* 文件的尾数，namenode 重启的时候，会按照 seen_txid 的数字， 循序从头跑 edits_0000001~ 到 seen_txid 的数字 VERSION文件：记录了当前NameNode的一些信息 图解： VERSION文件内容的含义？ 1.namespaceID是文件系统的唯一标识符，格式化文件系统后就会生成这个ID 2.clusterID是系统生成的集群的ID; 3.cTime是namenode存储系统创建是时间，第一次格式化系统就是0，再次格式化时就会更新; 4.storagetype说明文件存储的是什么系统存储的信息，可能是namenode/datanode 5.bolckpoolID是针对每一个namespace对应的bolckpool的ID，包含存储节点的IP等信息 参考：https://blog.csdn.net/qq_39657909/article/details/85233287","@type":"BlogPosting","url":"https://uzzz.org/2019/07/31/792452.html","headline":"HDFS常用命令/API+上传下载过程（三）","dateModified":"2019-07-31T00:00:00+08:00","datePublished":"2019-07-31T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/07/31/792452.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>HDFS常用命令/API+上传下载过程（三）</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-light"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> 
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path> 
  </svg> 
  <p></p>
  <div class="toc">
   <h3>文章目录</h3>
   <ul>
    <li><a href="#1_Hadoop_22" rel="nofollow" data-token="f0fb43daf643de2dd96762250e566375">1. Hadoop</a></li>
    <ul>
     <li><a href="#11_Hadoop_24" rel="nofollow" data-token="036adafa269d1611af78b1b3bef457cf">1.1 Hadoop发展历程</a></li>
     <li><a href="#2_Hadoop_51" rel="nofollow" data-token="79b3def5913c22aa1d37279e01df0c68">2. Hadoop的作用（解决了什么问题）/运行模式/基础组件及架构</a></li>
     <li><a href="#3HDFSHDFSHDFS_82" rel="nofollow" data-token="fbd825e38a87062dd03d49052bb31f1d">3.学会阅读HDFS源码，并自己阅读一段HDFS的源码(推荐HDFS上传/下载过程)</a></li>
     <li><a href="#4_HadoopRPCHttp_88" rel="nofollow" data-token="50318bb3769e12c828d459f1bdf5f44c">4. Hadoop中各个组件的通信方式，RPC/Http等</a></li>
     <li><a href="#5_WordCountJavaPythonHadoop_Streaming_131" rel="nofollow" data-token="a8cd4c149d8bb06e0b16207baafa40f1">5. 学会写WordCount（Java/Python-Hadoop Streaming）</a></li>
     <li><a href="#6_MapReduce_255" rel="nofollow" data-token="f808f268fd299e061893f5a56ae1da4d">6. 理解MapReduce的执行过程</a></li>
     <li><a href="#7_YarnHadoop_261" rel="nofollow" data-token="d00cbf78233070ab184edb0c5c54761e">7. Yarn在Hadoop中的作用</a></li>
    </ul>
    <li><a href="#2_HDFS_266" rel="nofollow" data-token="0c657d766b2e6602cbd201ad38aafa3c">2. HDFS</a></li>
    <ul>
     <li><a href="#1_HDFS_269" rel="nofollow" data-token="ab5fbf9a59cfdf7f2467db4109c54826">1. 认识HDFS</a></li>
     <ul>
      <li><a href="#11_Blocks_275" rel="nofollow" data-token="f63b91681636c25fa8d35fac8bad335b">1.1 Blocks</a></li>
      <li><a href="#12_Namenode__Datanode_292" rel="nofollow" data-token="1cfe46052e39001d403b6f362509a0e5">1.2 Namenode &amp; Datanode</a></li>
      <li><a href="#13_Block_Caching_319" rel="nofollow" data-token="36b3e3337ed3335658365e5d41dbba6f">1.3 Block Caching</a></li>
      <li><a href="#14_HDFS_Federation_325" rel="nofollow" data-token="b68c9831fa8521139100a2245b3d4a32">1.4 HDFS Federation</a></li>
      <li><a href="#15_HDFS_HA_331" rel="nofollow" data-token="a00dc02827e8b23fe8b44b9d3457a7c7">1.5 HDFS HA</a></li>
     </ul>
     <li><a href="#2_HDFS_385" rel="nofollow" data-token="ef01c5ce3834134fc8f4fbb5348b1657">2. HDFS是用来解决什么问题的</a></li>
     <li><a href="#3_HDFS_411" rel="nofollow" data-token="d35d04df8d7832d73c91f4f7ca76ce6d">3. HDFS设计与架构</a></li>
     <ul>
      <li><a href="#31__412" rel="nofollow" data-token="7c2bea5fb574179a5c0b80611fb6a219">3.1 设计目标</a></li>
      <li><a href="#32_HDFS_421" rel="nofollow" data-token="439fbfee35a5d77494acd7db165f603b">3.2 HDFS不适合的应用类型</a></li>
     </ul>
     <li><a href="#4_HDFS_435" rel="nofollow" data-token="ac5bb0eac6ae81a2bb3431024cb592f1">4. 熟悉HDFS常用命令</a></li>
     <li><a href="#5_PythonHDFSAPI_464" rel="nofollow" data-token="62195a57ae3cfd00de3c61db530f5d1e">5. Python操作HDFS的其他API</a></li>
     <li><a href="#6_128M128M_545" rel="nofollow" data-token="9a28c872163a282e0bd2ae90b62489f7">6. 观察上传后的文件，上传大于128M的文件与小于128M的文件有何区别？</a></li>
     <li><a href="#7_HDFS_586" rel="nofollow" data-token="a008b54e35a8f92a3c87238f63b73065">7. 启动HDFS后，会分别启动哪些进程？</a></li>
     <li><a href="#8_NameNodeedits_logfsImage_596" rel="nofollow" data-token="084fe8a2f7288b9da5f4fd67d144fb43">8. NameNode是如何组织文件中的元信息的，edits log与fsImage的区别？</a></li>
    </ul>
   </ul>
  </div>
  <br> 【Task 3】HDFS常用命令/API+上传下载过程
  <br> 阅读Google三大论文，并总结
  <br> Hadoop的作用（解决了什么问题）/运行模式/基础组件及架构
  <br> 学会阅读HDFS源码，并自己阅读一段HDFS的源码(推荐HDFS上传/下载过程)【可选】
  <br> Hadoop中各个组件的通信方式，RPC/Http等
  <br> 学会写WordCount（Java/Python-Hadoop Streaming），理解分布式/单机运行模式的区别
  <br> 理解MapReduce的执行过程
  <br> Yarn在Hadoop中的作用
  <p></p> 
  <p>认识HDFS<br> HDFS是用来解决什么问题的<br> HDFS设计与架构<br> 熟悉hdfs常用命令<br> Python操作HDFS的其他API<br> 观察上传后的文件，上传大于128M的文件与小于128M的文件有何区别？<br> 启动HDFS后，会分别启动NameNode/DataNode/SecondaryNameNode，这些进程的的作用分别是什么？<br> NameNode是如何组织文件中的元信息的，edits log与fsImage的区别？使用hdfs oiv命令观察HDFS上的文件的metadata<br> HDFS文件上传下载过程，源码阅读与整理。</p> 
  <p>这里特别说明一下，在上一个任务中主要是对Hadoop集群进行了搭建，本次任务对Hadoop和HDFS进行深入的学习。</p> 
  <h1><a id="1_Hadoop_22"></a>1. Hadoop</h1> 
  <h2><a id="11_Hadoop_24"></a>1.1 Hadoop发展历程</h2> 
  <p><a href="https://blog.csdn.net/w1573007/article/details/52966742" rel="nofollow" data-token="9d7100fc695a4da4c5637c4521ed7340">Google三大理论</a></p> 
  <p>简单总结下：</p> 
  <p><strong>1. GFS-2003</strong></p> 
  <p>2003年，Google发布Google File System论文，这是一个可扩展的分布式文件系统，用于大型的、分布式的、对大量数据进行访问的应用。它运行于廉价的普通硬件上，提供容错功能。从根本上说：文件被分割成很多块，使用冗余的方式储存于商用机器集群上。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731110327223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R6eXN1bnNoaW5l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>2. MapReduce—-2004</strong></p> 
  <p>紧随其后的就是2004年公布的 MapReduce论文，论文描述了大数据的分布式计算方式，主要思想是将任务分解然后在多台处理能力较弱的计算节点中同时处理，然后将结果合并从而完成大数据处理。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731110353932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R6eXN1bnNoaW5l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731110054298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R6eXN1bnNoaW5l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 传说中，Google使用它计算他们的搜索索引。而Mikio L. Braun认为其工作模式应该是：Google把所有抓取的页面都放置于他们的集群上，然后每天使用MapReduce来重算。</p> 
  <p><strong>3. BigTable—-2006</strong></p> 
  <p>Bigtable发布于2006年，启发了无数的NoSQL数据库，比如：Cassandra、HBase等等。Cassandra架构中有一半是模仿Bigtable，包括了数据模型、SSTables以及提前写日志（另一半是模仿Amazon的Dynamo数据库，使用点对点集群模式）。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731110502606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R6eXN1bnNoaW5l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <p><strong>4. GFS,MapReduce 和 BigTable三者关系如下</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731105942884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R6eXN1bnNoaW5l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> Google的后面两篇论文——MapReduce 和 BigTable都是以GFS为基础。三大基础核心技术构建出了完整的分布式运算架构。</p> 
  <h2><a id="2_Hadoop_51"></a>2. Hadoop的作用（解决了什么问题）/运行模式/基础组件及架构</h2> 
  <p>Hadoop是一个开源框架，可编写和运行分布式应用处理大规模数据。 Hadoop框架的核心是HDFS和MapReduce。其中 HDFS 是分布式文件系统，MapReduce 是分布式数据处理模型和执行环境。</p> 
  <p>随着数据的来源途径越来越多，数据的格式也越来越复杂，数据量越来越大，传统的数据库已经很难满足需求，Hadoop就是为了解决这个问题而诞生的。其底层的分布式文件系统具有高拓展性，通过数据冗余保证数据不丢失和提交计算效率，同时可以存储各种格式的数据。同时其还支持多种计算框架，既可以进行离线计算也可以进行在线实时计算。</p> 
  <p>Hadoop有三种运行模式：单机模式、伪分布式模式、完全分布式模式。</p> 
  <p><strong>单机模式</strong></p> 
  <ul> 
   <li>默认模式。</li> 
   <li>不对配置文件进行修改。</li> 
   <li>使用本地文件系统，而不是分布式文件系统。</li> 
   <li>Hadoop不会启动NameNode、DataNode、JobTracker、TaskTracker等守护进程，Map()和Reduce()任务作为同一个进程的不同部分来执行的。</li> 
   <li>用于对MapReduce程序的逻辑进行调试，确保程序的正确。</li> 
  </ul> 
  <p><strong>伪分布式模式</strong></p> 
  <ul> 
   <li>在一台主机模拟多主机。</li> 
   <li>Hadoop启动NameNode、DataNode、JobTracker、TaskTracker这些守护进程都在同一台机器上运行，是相互独立的Java进程。</li> 
   <li>在这种模式下，Hadoop使用的是分布式文件系统，各个作业也是由JobTraker服务，来管理的独立进程。在单机模式之上增加了代码调试功能，允许检查内存使用情况，HDFS输入输出，以及其他的守护进程交互。类似于完全分布式模式，因此，这种模式常用来开发测试Hadoop程序的执行是否正确。<br> -修改3个配置文件：core-site.xml（Hadoop集群的特性，作用于全部进程及客户端）、hdfs-site.xml（配置HDFS集群的工作属性）、mapred-site.xml（配置MapReduce集群的属性）</li> 
   <li>格式化文件系统</li> 
  </ul> 
  <p><strong>完全分布式模式</strong></p> 
  <ul> 
   <li>Hadoop的守护进程运行在由多台主机搭建的集群上，是真正的生产环境。</li> 
   <li>在所有的主机上安装JDK和Hadoop，组成相互连通的网络。</li> 
   <li>在主机间设置SSH免密码登录，把各从节点生成的公钥添加到主节点的信任列表。</li> 
   <li>修改3个配置文件：core-site.xml、hdfs-site.xml、mapred-site.xml，指定NameNode和JobTraker的位置和端口，设置文件的副本等参数</li> 
  </ul> 
  <h2><a id="3HDFSHDFSHDFS_82"></a>3.学会阅读HDFS源码，并自己阅读一段HDFS的源码(推荐HDFS上传/下载过程)</h2> 
  <p>这里有两篇写的很好的博客</p> 
  <p><a href="https://www.bbsmax.com/A/KE5QXEn3JL/" rel="nofollow" data-token="f01ba3d85d2317e12ae027a37ccf880b">Hadoop之HDFS原理及文件上传下载源码分析（上）</a><br> <a href="https://www.bbsmax.com/A/VGzlVWoO5b/" rel="nofollow" data-token="454e7a89b83c4ac3599e23ce9f59a9e0">Hadoop之HDFS原理及文件上传下载源码分析（下）</a></p> 
  <h2><a id="4_HadoopRPCHttp_88"></a>4. Hadoop中各个组件的通信方式，RPC/Http等</h2> 
  <p><a href="https://www.cnblogs.com/edisonchou/p/4285817.html" rel="nofollow" data-token="0ed98287a2f577ae222858afae0b92b3">Hadoop RPC机制的使用</a></p> 
  <p><strong>RPC，即Remote Procdure Call</strong>，中文名：远程过程调用；</p> 
  <ol> 
   <li>它允许一台计算机程序远程调用另外一台计算机的子程序，而不用去关心底层的网络通信细节，对我们来说是透明的。因此，它经常用于分布式网络通信中。</li> 
  </ol> 
  <ul> 
   <li>RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</li> 
  </ul> 
  <ol start="2"> 
   <li>Hadoop的进程间交互都是通过RPC来进行的，比如Namenode与Datanode直接，Jobtracker与Tasktracker之间等。</li> 
  </ol> 
  <ul> 
   <li>Hadoop的运行就是建立在RPC基础之上的。</li> 
  </ul> 
  <p><strong>RPC的显著特点</strong></p> 
  <p>（1）透明性：远程调用其他机器上的程序，对用户来说就像是调用本地方法一样；</p> 
  <p>（2）高性能：RPC Server能够并发处理多个来自Client的请求；</p> 
  <p>（3）可控性：jdk中已经提供了一个RPC框架—RMI，但是该PRC框架过于重量级并且可控之处比较少，所以Hadoop RPC实现了自定义的PRC框架。</p> 
  <p><strong>RPC的基本流程</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731115146368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R6eXN1bnNoaW5l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> （1）RPC采用了C/S的模式；</p> 
  <p>（2）Client端发送一个带有参数的请求信息到Server；</p> 
  <p>（3）Server接收到这个请求以后，根据发送过来的参数调用相应的程序，然后把自己计算好的结果发送给Client端；</p> 
  <p>（4）Client端接收到结果后继续运行；</p> 
  <p><strong>Hadoop中的RPC机制</strong></p> 
  <p>同其他RPC框架一样，Hadoop RPC分为四个部分：</p> 
  <p>（1）序列化层：Clent与Server端通信传递的信息采用了Hadoop里提供的序列化类或自定义的Writable类型；</p> 
  <p>（2）函数调用层：Hadoop RPC通过动态代理以及java反射实现函数调用；</p> 
  <p>（3）网络传输层：Hadoop RPC采用了基于TCP/IP的socket机制；</p> 
  <p>（4）服务器端框架层：RPC Server利用java NIO以及采用了事件驱动的I/O模型，提高RPC Server的并发处理能力；</p> 
  <ul> 
   <li>Hadoop RPC在整个Hadoop中应用非常广泛，Client、DataNode、NameNode之间的通讯全靠它了。例如：我们平时操作HDFS的时候，使用的是FileSystem类，它的内部有个DFSClient对象，这个对象负责与NameNode打交道。在运行时，DFSClient在本地创建一个NameNode的代理，然后就操作这个代理，这个代理就会通过网络，远程调用到NameNode的方法，也能返回值。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731115345736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R6eXN1bnNoaW5l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li> 
  </ul> 
  <h2><a id="5_WordCountJavaPythonHadoop_Streaming_131"></a>5. 学会写WordCount（Java/Python-Hadoop Streaming）</h2> 
  <p><a href="https://www.cnblogs.com/kaituorensheng/p/3826114.html" rel="nofollow" data-token="e2a9f94773ef72e2036fb5472792b674">用python写MapReduce函数——以WordCount为例</a><br> <a href="https://zhuanlan.zhihu.com/p/75580369" rel="nofollow" data-token="3e41b796bee7583a674924fcfe8a56cc">MapReduce任务—WordCount</a></p> 
  <p><strong>1. Python MapReduce 代码</strong></p> 
  <ul> 
   <li>使用python写MapReduce的“诀窍”是利用Hadoop流的API，通过STDIN(标准输入)、STDOUT(标准输出)在Map函数和Reduce函数之间传递数据。</li> 
   <li>我们唯一需要做的是利用Python的sys.stdin读取输入数据，并把我们的输出传送给sys.stdout。Hadoop流将会帮助我们处理别的任何事情。</li> 
  </ul> 
  <p><strong>1.1Map阶段：<a href="http://mapper.py" rel="nofollow" data-token="3b66f57cc3cb837c0edfb5c3068609fa">mapper.py</a></strong></p> 
  <p>把文件保存到hadoop/test/code/mapper.py</p> 
  <pre><code class="prism language-python"><span class="token comment">#!/usr/bin/env python</span>
<span class="token keyword">import</span> sys
<span class="token keyword">for</span> line <span class="token keyword">in</span> sys<span class="token punctuation">.</span>stdin<span class="token punctuation">:</span>
    line <span class="token operator">=</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
    words <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> word <span class="token keyword">in</span> words<span class="token punctuation">:</span>
        <span class="token keyword">print</span> <span class="token string">"%s\t%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>

</code></pre> 
  <p><strong>增加mapper.py的可执行权限</strong></p> 
  <pre><code class="prism language-python">chmod <span class="token operator">+</span>x hadoop<span class="token operator">/</span>test<span class="token operator">/</span>code<span class="token operator">/</span>mapper<span class="token punctuation">.</span>py
</code></pre> 
  <p><strong>1.2.Reduce阶段：<a href="http://reducer.py" rel="nofollow" data-token="cd7ef4629e75b7e93657c9b0031791b5">reducer.py</a></strong></p> 
  <pre><code class="prism language-python"><span class="token comment">#!/usr/bin/env python</span>
<span class="token keyword">from</span> operator <span class="token keyword">import</span> itemgetter
<span class="token keyword">import</span> sys

current_word <span class="token operator">=</span> <span class="token boolean">None</span>
current_count <span class="token operator">=</span> <span class="token number">0</span>
word <span class="token operator">=</span> <span class="token boolean">None</span>

<span class="token keyword">for</span> line <span class="token keyword">in</span> sys<span class="token punctuation">.</span>stdin<span class="token punctuation">:</span>
    line <span class="token operator">=</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
    word<span class="token punctuation">,</span> count <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        count <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
    <span class="token keyword">except</span> ValueError<span class="token punctuation">:</span>  
        <span class="token keyword">continue</span>
    <span class="token keyword">if</span> current_word <span class="token operator">==</span> word<span class="token punctuation">:</span>
        current_count <span class="token operator">+=</span> count
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> current_word<span class="token punctuation">:</span>
            <span class="token keyword">print</span> <span class="token string">"%s\t%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>current_word<span class="token punctuation">,</span> current_count<span class="token punctuation">)</span>
        current_count <span class="token operator">=</span> count
        current_word <span class="token operator">=</span> word

<span class="token keyword">if</span> word <span class="token operator">==</span> current_word<span class="token punctuation">:</span>  
    <span class="token keyword">print</span> <span class="token string">"%s\t%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>current_word<span class="token punctuation">,</span> current_count<span class="token punctuation">)</span>
</code></pre> 
  <p><strong>增加reducer.py的可执行权限</strong></p> 
  <pre><code class="prism language-python">chmod <span class="token operator">+</span>x hadoop<span class="token operator">/</span>test<span class="token operator">/</span>code<span class="token operator">/</span>reducer<span class="token punctuation">.</span>py
</code></pre> 
  <p><strong><a href="http://xn--mapper-ve4j370gbh0asf5bs6ya.py" rel="nofollow" data-token="1a5898a6c56af2362d77b387ae4cf0d2">功能性测试mapper.py</a> 和 <a href="http://reducer.py" rel="nofollow" data-token="cd7ef4629e75b7e93657c9b0031791b5">reducer.py</a></strong></p> 
  <pre><code class="prism language-python">cd test<span class="token operator">/</span>code
<span class="token operator">//</span>执行命令
echo <span class="token string">"foo foo quux labs foo bar quux"</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>mapper<span class="token punctuation">.</span>py
<span class="token operator">//</span>输出内容如下
foo <span class="token number">1</span>
foo <span class="token number">1</span>
quux    <span class="token number">1</span>
labs    <span class="token number">1</span>
foo <span class="token number">1</span>
bar <span class="token number">1</span>
quux    <span class="token number">1</span>
<span class="token operator">//</span>执行命令
echo <span class="token string">"foo foo quux labs foo bar quux"</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>mapper<span class="token punctuation">.</span>py <span class="token operator">|</span> sort <span class="token operator">-</span>k1<span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>reducer<span class="token punctuation">.</span>py
<span class="token operator">//</span>输出内容
bar <span class="token number">1</span>
foo <span class="token number">3</span>
labs    <span class="token number">1</span>
</code></pre> 
  <p><strong>2. 在Hadoop上运行python代码</strong></p> 
  <p><a href="http://www.gutenberg.org/cache/epub/4300/pg4300.txt" rel="nofollow" data-token="ec7b265c1284a0128548e9f774e36175">Plain Text UTF-8</a><br> <a href="http://www.gutenberg.org/cache/epub/5000/pg5000.txt" rel="nofollow" data-token="3effd267d505a23ad41be282ddab3bae">Plain Text UTF-8</a><br> <a href="http://www.gutenberg.org/cache/epub/20417/pg20417.txt" rel="nofollow" data-token="8fc3672ce1b2c8376d0955bbfebb0f1d">Plain Text UTF-8</a></p> 
  <p>把上面的文件放到hadoop/test/datas/目录下，并把本地的数据文件拷贝到分布式文件系统HDFS中</p> 
  <pre><code>hdfs dfs -put datas /datas
</code></pre> 
  <p>可以在浏览器里输入：“192.168.1.105:50070”， 在Utilities-Browse the file system里查看上传的文件。<img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731124228674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R6eXN1bnNoaW5l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 　　<br> <strong>执行MapReduce job</strong></p> 
  <pre><code>hadoop jar /usr/local/hadoop/share/hadoop/tools/lib/hadoop-streaming-2.5.0-cdh5.3.6.jar \
-input /datas \
-output /test/out \
-mapper "python mapper.py" \
-reducer "python reducer.py" \
-file ./mapper.py \
-file ./reducer.py
</code></pre> 
  <p>第一行是指明用到的streaming包的位置，第二行指明原文件在HDFS上的路径，第三行是输出结果在HDFS上的路径，输出路径原来不能存在，已存在的话会报错，最后两行指明Map方法和Reduce方法程序路径。</p> 
  <p>jar包的名字特别注意，到指定的文件夹中看看是否正确。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731133134476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R6eXN1bnNoaW5l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <pre><code>查看生成的文件
hdfs dfs -rm -f /datas/out/part-00000
</code></pre> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731134437428.png" alt="在这里插入图片描述"><br> 成功！<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731134739531.png" alt="在这里插入图片描述"><br> 解决方案：直接在log4j日志中去除告警信息。在/usr/local/hadoop/etc/hadoop/log4j.properties文件中添加</p> 
  <pre><code>log4j.logger.org.apache.hadoop.util.NativeCodeLoader=ERROR
</code></pre> 
  <h2><a id="6_MapReduce_255"></a>6. 理解MapReduce的执行过程</h2> 
  <p>首先说下Hadoop 的四大组件： HDFS，分布式存储系统；MapReduce，分布式计算系统；YARN： hadoop 的资源调度系统。；Common： 以上三大组件的底层支撑组件，主要提供基础工具包和 RPC 框架等。 Mapreduce 是一个分布式运算程序的编程框架，是用户开发“基于 hadoop的数据分析 应用”的核心框架。 Mapreduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 hadoop 集群上。</p> 
  <p>从整体层面上看，有五个独立的实体： - 客户端，提交 MapReduce 作业。 - YARN 资源管理器（YARN resource manager），负责协调集群上计算机资源的分配。 - YARN 节点管理器（YARN node manager），负责启动和监视集群中机器上的计算容器（container）。 - MapReduce的 application master，负责协调MapReduce 作业的任务。MRAppMaster 和 MapReduce 任务运行在容器中，该容器由资源管理器进行调度（schedule）[此处理解为划分、分配更为合适] 且由节点管理器进行管理。 - 分布式文件系统（通常是 HDFS），用来在其他实体间共享作业文件。</p> 
  <p>参考：<a href="https://zhuanlan.zhihu.com/p/45305945" rel="nofollow" data-token="34c6b62f6cbe9ec4d7177c072e4603b4">MapReduce执行过程</a></p> 
  <h2><a id="7_YarnHadoop_261"></a>7. Yarn在Hadoop中的作用</h2> 
  <p>Yarn是Hadoop集群的资源管理系统。Yarn可以提高资源的利用率。Yarn的另一个目标就是拓展Hadoop，使得它不仅仅可以支持MapReduce计算，还能很方便的管理诸如Hive、Hbase、Pig、Spark/Shark等应用。这种新的架构设计能够使得各种类型的应用运行在Hadoop上面，并通过Yarn从系统层面进行统一的管理，也就是说，有了Yarn，各种应用就可以互不干扰的运行在同一个Hadoop系统中，共享整个集群资源。<br> 参考：<a href="https://blog.csdn.net/suifeng3051/article/details/49486927" rel="nofollow" data-token="0163d8f4acc8a389815d4769b5c652dc">Hadoop Yarn详解</a></p> 
  <h1><a id="2_HDFS_266"></a>2. HDFS</h1> 
  <p><a href="https://blog.csdn.net/bingduanlbd/article/details/51914550#t24" rel="nofollow" data-token="4159b2d48112bff0fc1936f5a16d1a34">深入理解HDFS：Hadoop分布式文件系统</a></p> 
  <h2><a id="1_HDFS_269"></a>1. 认识HDFS</h2> 
  <p>在现代的企业环境中，单机容量往往无法存储大量数据，需要跨机器存储。统一管理分布在集群上的文件系统称为分布式文件系统。而一旦在系统中，引入网络，就不可避免地引入了所有网络编程的复杂性，例如挑战之一是如果保证在节点不可用的时候数据不丢失。<br> 传统的网络文件系统（NFS）虽然也称为分布式文件系统，但是其存在一些限制。由于NFS中，文件是存储在单机上，因此无法提供可靠性保证，当很多客户端同时访问NFS Server时，很容易造成服务器压力，造成性能瓶颈。另外如果要对NFS中的文件中进行操作，需要首先同步到本地，这些修改在同步到服务端之前，其他客户端是不可见的。某种程度上，NFS不是一种典型的分布式系统，虽然它的文件的确放在远端（单一）的服务器上面。<br> HDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731182608672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R6eXN1bnNoaW5l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <h3><a id="11_Blocks_275"></a>1.1 Blocks</h3> 
  <p>物理磁盘中有块的概念，磁盘的物理Block是磁盘操作最小的单元，读写操作均以Block为最小单元，一般为512 Byte。文件系统在物理Block之上抽象了另一层概念，文件系统Block物理磁盘Block的整数倍。通常为几KB。Hadoop提供的df、fsck这类运维工具都是在文件系统的Block级别上进行操作。</p> 
  <p>HDFS的Block块比一般单机文件系统大得多，默认为128M。HDFS的文件被拆分成block-sized的chunk，chunk作为独立单元存储。比Block小的文件不会占用整个Block，只会占据实际大小。例如， 如果一个文件大小为1M，则在HDFS中只会占用1M的空间，而不是128M。</p> 
  <p><strong>HDFS的Block为什么这么大？</strong></p> 
  <p>是为了最小化查找（seek）时间，控制定位文件与传输文件所用的时间比例。假设定位到Block所需的时间为10ms，磁盘传输速度为100M/s。如果要将定位到Block所用时间占传输时间的比例控制1%，则Block大小需要约100M。<br> 但是如果Block设置过大，在MapReduce任务中，Map或者Reduce任务的个数 如果小于集群机器数量，会使得作业运行效率很低。</p> 
  <p><strong>Block抽象的好处</strong></p> 
  <p>block的拆分使得单个文件大小可以大于整个磁盘的容量，构成文件的Block可以分布在整个集群， 理论上，单个文件可以占据集群中所有机器的磁盘。<br> Block的抽象也简化了存储系统，对于Block，无需关注其权限，所有者等内容（这些内容都在文件级别上进行控制）。<br> Block作为容错和高可用机制中的副本单元，即以Block为单位进行复制。</p> 
  <h3><a id="12_Namenode__Datanode_292"></a>1.2 Namenode &amp; Datanode</h3> 
  <p>整个HDFS集群由Namenode和Datanode构成master-worker（主从）模式。Namenode复杂构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。</p> 
  <p><strong>Namenode</strong></p> 
  <p>Namenode存放文件系统树及所有文件、目录的元数据。元数据持久化为2种形式：</p> 
  <p>namespcae image-<br> edit log</p> 
  <p>但是持久化数据中不包括Block所在的节点列表，及文件的Block分布在集群中的哪些节点上，这些信息是在系统重启的时候重新构建（通过Datanode汇报的Block信息）。</p> 
  <p>在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制：<br> 1）备份持久化元数据<br> 将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。</p> 
  <p>2）Secondary Namenode<br> Secondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。<br> Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。</p> 
  <p>在HA中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。</p> 
  <p><strong>Datanode</strong></p> 
  <p>数据节点负责存储和提取Block，读写请求可能来自namenode，也可能直接来自客户端。数据节点周期性向Namenode汇报自己节点上所存储的Block相关信息。</p> 
  <h3><a id="13_Block_Caching_319"></a>1.3 Block Caching</h3> 
  <p>DataNode通常直接从磁盘读取数据，但是频繁使用的Block可以在内存中缓存。默认情况下，一个Block只有一个数据节点会缓存。但是可以针对每个文件可以个性化配置。<br> 作业调度器可以利用缓存提升性能，例如MapReduce可以把任务运行在有Block缓存的节点上。<br> 用户或者应用可以向NameNode发送缓存指令（缓存哪个文件，缓存多久）， 缓存池的概念用于管理一组缓存的权限和资源。</p> 
  <h3><a id="14_HDFS_Federation_325"></a>1.4 HDFS Federation</h3> 
  <p>我们知道NameNode的内存会制约文件数量，HDFS Federation提供了一种横向扩展NameNode的方式。在Federation模式中，每个NameNode管理命名空间的一部分，例如一个NameNode管理/user目录下的文件， 另一个NameNode管理/share目录下的文件。<br> 每个NameNode管理一个namespace volumn，所有volumn构成文件系统的元数据。每个NameNode同时维护一个Block Pool，保存Block的节点映射等信息。各NameNode之间是独立的，一个节点的失败不会导致其他节点管理的文件不可用。<br> 客户端使用mount table将文件路径映射到NameNode。mount table是在Namenode群组之上封装了一层，这一层也是一个Hadoop文件系统的实现，通过viewfs:协议访问。</p> 
  <h3><a id="15_HDFS_HA_331"></a>1.5 HDFS HA</h3> 
  <p>在HDFS集群中，NameNode依然是单点故障（SPOF）。元数据同时写到多个文件系统以及Second NameNode定期checkpoint有利于保护数据丢失，但是并不能提高可用性。<br> 这是因为NameNode是唯一一个对文件元数据和file-block映射负责的地方， 当它挂了之后，包括MapReduce在内的作业都无法进行读写。</p> 
  <p>当NameNode故障时，常规的做法是使用元数据备份重新启动一个NameNode。元数据备份可能来源于：</p> 
  <ul> 
   <li>多文件系统写入中的备份</li> 
   <li>Second NameNode的检查点文件</li> 
  </ul> 
  <p>启动新的Namenode之后，需要重新配置客户端和DataNode的NameNode信息。另外重启耗时一般比较久，稍具规模的集群重启经常需要几十分钟甚至数小时，造成重启耗时的原因大致有：</p> 
  <p>1） 元数据镜像文件载入到内存耗时较长。<br> 2） 需要重放edit log<br> 3） 需要收到来自DataNode的状态报告并且满足条件后才能离开安全模式提供写服务。</p> 
  <p><strong>Hadoop的HA方案</strong></p> 
  <p>采用HA的HDFS集群配置两个NameNode，分别处于Active和Standby状态。当Active NameNode故障之后，Standby接过责任继续提供服务，用户没有明显的中断感觉。一般耗时在几十秒到数分钟。<br> HA涉及到的主要实现逻辑有</p> 
  <p><strong>1） 主备需共享edit log存储</strong></p> 
  <p>主NameNode和待命的NameNode共享一份edit log，当主备切换时，Standby通过回放edit log同步数据。<br> 共享存储通常有2种选择</p> 
  <ul> 
   <li>NFS：传统的网络文件系统</li> 
   <li>QJM：quorum journal manager</li> 
   <li>QJM是专门为HDFS的HA实现而设计的，用来提供高可用的edit log。</li> 
  </ul> 
  <p>QJM运行一组journal node，edit log必须写到大部分的journal nodes。通常使用3个节点，因此允许一个节点失败，类似ZooKeeper。注意QJM没有使用ZK，虽然HDFS HA的确使用了ZK来选举主Namenode。一般推荐使用QJM。</p> 
  <p><strong>2）DataNode需要同时往主备发送Block Report</strong></p> 
  <p>因为Block映射数据存储在内存中（不是在磁盘上），为了在Active NameNode挂掉之后，新的NameNode能够快速启动，不需要等待来自Datanode的Block Report，DataNode需要同时向主备两个NameNode发送Block Report。</p> 
  <p><strong>3）客户端需要配置failover模式（对用户透明）</strong></p> 
  <p>Namenode的切换对客户端来说是无感知的，通过客户端库来实现。客户端在配置文件中使用的HDFS URI是逻辑路径，映射到一对Namenode地址。客户端会不断尝试每一个Namenode地址直到成功。</p> 
  <p><strong>4）Standby替代Secondary NameNode</strong></p> 
  <p>如果没有启用HA，HDFS独立运行一个守护进程作为Secondary Namenode。定期checkpoint，合并镜像文件和edit日志。</p> 
  <p>如果当主Namenode失败时，备份Namenode正在关机（停止 Standby），运维人员依然可以从头启动备份Namenode，这样比没有HA的时候更省事，算是一种改进，因为重启整个过程已经标准化到Hadoop内部，无需运维进行复杂的切换操作。</p> 
  <p>NameNode的切换通过代failover controller来实现。failover controller有多种实现，默认实现使用ZooKeeper来保证只有一个Namenode处于active状态。</p> 
  <p>每个Namenode运行一个轻量级的failover controller进程，该进程使用简单的心跳机制来监控Namenode的存活状态并在Namenode失败是触发failover。Failover可以由运维手动触发，例如在日常维护中需要切换主Namenode，这种情况graceful failover，非手动触发的failover称为ungraceful failover。</p> 
  <p>在ungraceful failover的情况下，没有办法确定失败（被判定为失败）的节点是否停止运行，也就是说触发failover后，之前的主Namenode可能还在运行。QJM一次只允许一个Namenode写edit log，但是之前的主Namenode仍然可以接受读请求。Hadoop使用fencing来杀掉之前的Namenode。Fencing通过收回之前Namenode对共享的edit log的访问权限、关闭其网络端口使得原有的Namenode不能再继续接受服务请求。使用STONITH技术也可以将之前的主Namenode关机。</p> 
  <p>最后，HA方案中Namenode的切换对客户端来说是不可见的，前面已经介绍过，主要通过客户端库来完成。</p> 
  <h2><a id="2_HDFS_385"></a>2. HDFS是用来解决什么问题的</h2> 
  <p><strong>单机文件系统的限制</strong>：<br>     早期计算机中的文件是由单机的操作系统来进行管理的，单机中的文件管理存在以下不足：<br>     ①存储容量的限制。<br>     ②读写性能的限制。<br>     ③容灾能力不足。<br>     当文件特别大的时候，上面三个问题凸显。</p> 
  <p><strong>行业现状</strong>：<br>     ①数据格式多样化。各业务系统数据库中的结构化数据；日志文件等半结构化数据；视频、图片等非结构化数据。传统的数据库已经满足不了我们的存储需求。<br>     ②每天各种类型的数据以GB、TB的速度增长。单机的文件系统已管理不了如此大的数据量。</p> 
  <p><strong>HDFS就是为了解决上面这些问题而生的：</strong><br>     ①HDFS是一种允许文件通过网络在多台机器上分享的文件系统。<br>     ②HDFS将一个大文件分割成多个数据块，将这些数据块分散存储在多台机器上。<br>     ③虽然HDFS会将文件分割成多个数据块，但在程序和用户看来就跟操作本地磁盘中的文件一样。<br>     ④针对一个文件，可以并发读取它的数据块，增加了读取的性能。<br>     ⑤HDFS存储的容量具有巨大的扩展性。<br>     ⑥HDFS可以保证系统中的某些节点脱机时整个系统仍然能持续运行，并保证数据不丢失。</p> 
  <p><strong>为什么不使用配有大量硬盘的单台机器来存储文件？</strong><br>     ①随着计算机硬件技术的发展，单台机器硬盘存储容量不断提升，但硬盘数据读取速度却提升缓慢。<br>     ②硬盘寻址速度的提升远远不如网络传输速度的提升。如果数据的访问包含大量的硬盘寻址，那么读取大量数据就会花费更长的时间。</p> 
  <p>参考：<a href="https://www.jianshu.com/p/1a762fb5f842" rel="nofollow" data-token="5aa390e48c387bd123501857d8b6ec7d">https://www.jianshu.com/p/1a762fb5f842</a></p> 
  <h2><a id="3_HDFS_411"></a>3. HDFS设计与架构</h2> 
  <h3><a id="31__412"></a>3.1 设计目标</h3> 
  <p>存储非常大的文件：这里非常大指的是几百M、G、或者TB级别。实际应用中已有很多集群存储的数据达到PB级别。根据Hadoop官网，Yahoo！的Hadoop集群约有10万颗CPU，运行在4万个机器节点上。更多世界上的Hadoop集群使用情况，参考Hadoop官网.</p> 
  <p>采用流式的数据访问方式: HDFS基于这样的一个假设：最有效的数据处理模式是一次写入、多次读取数据集经常从数据源生成或者拷贝一次，然后在其上做很多分析工作<br> 分析工作经常读取其中的大部分数据，即使不是全部。 因此读取整个数据集所需时间比读取第一条记录的延时更重要。</p> 
  <p>运行于商业硬件上: Hadoop不需要特别贵的、reliable的机器，可运行于普通商用机器（可以从多家供应商采购） 商用机器不代表低端机器在集群中（尤其是大的集群），节点失败率是比较高的HDFS的目标是确保集群在节点失败的时候不会让用户感觉到明显的中断。</p> 
  <h3><a id="32_HDFS_421"></a>3.2 HDFS不适合的应用类型</h3> 
  <p>有些场景不适合使用HDFS来存储数据。下面列举几个：</p> 
  <p><strong>1） 低延时的数据访问</strong><br> 对延时要求在毫秒级别的应用，不适合采用HDFS。HDFS是为高吞吐数据传输设计的,因此可能牺牲延时HBase更适合低延时的数据访问。</p> 
  <p><strong>2）大量小文件</strong><br> 文件的元数据（如目录结构，文件block的节点列表，block-node mapping）保存在NameNode的内存中， 整个文件系统的文件数量会受限于NameNode的内存大小。<br> 经验而言，一个文件/目录/文件块一般占有150字节的元数据内存空间。如果有100万个文件，每个文件占用1个文件块，则需要大约300M的内存。因此十亿级别的文件数量在现有商用机器上难以支持。</p> 
  <p><strong>3）多方读写，需要任意的文件修改</strong><br> HDFS采用追加（append-only）的方式写入数据。不支持文件任意offset的修改。不支持多个写入器（writer）。</p> 
  <h2><a id="4_HDFS_435"></a>4. 熟悉HDFS常用命令</h2> 
  <p><a href="https://segmentfault.com/a/1190000002672666" rel="nofollow" data-token="665ba79adc85acb5d7378a8a713bfaaf">hadoop HDFS常用文件操作命令</a></p> 
  <p><strong>HDFS常用命令</strong></p> 
  <pre><code>hdfs version:查看版本

1、查询

hdfs dfs -ls / ：列出/目录下的文件和目录

hdfs dfs -ls -R / ：列出/目录下的所有文件，由于有-R参数，会在文件夹和子文件夹下执行ls操作。

2、新建文件夹

hdfs dfs -mkdir -p /home/testdata/

3、查看hdfs文件中的内容

hdfs dfs -cat /home/testdata/1.txt

4、删除文件

hdfs dfs -rm -f /home/testdata/1.txt

5、删除文件夹

hdfs dfs -rm -r /home/testdata
</code></pre> 
  <h2><a id="5_PythonHDFSAPI_464"></a>5. Python操作HDFS的其他API</h2> 
  <p><strong>1.安装依赖包</strong></p> 
  <pre><code>pip install hdfs
</code></pre> 
  <p><strong>2.连接</strong></p> 
  <pre><code># 连接hdfs服务
from hdfs import InsecureClient

client = InsecureClient('http://183.168.10.11:50070', user='root')
</code></pre> 
  <p><strong>3.列出当前目录下的所有文件</strong></p> 
  <pre><code>print client.list('/')
</code></pre> 
  <p><strong>4.创建新文件，并写入内容</strong></p> 
  <pre><code>data = '''
this is new file by lys！
'''

with client.write('/foodir/myfile.txt') as writer:
    writer.write(data)
</code></pre> 
  <p><strong>5.读取文件</strong></p> 
  <pre><code>with client.read('/foodir/myfile.txt') as reader:
    data = reader.read()
    print data
</code></pre> 
  <p><strong>6.文件追加内容</strong></p> 
  <pre><code># 通过设置append参数，向一个已经存在的文件追加写入数据
with client.write('/foodir/myfile.txt', append=True) as writer:
    writer.write('this is append text by lys! \n')
</code></pre> 
  <p><strong>7.重命名</strong></p> 
  <pre><code>client.rename('/foodir/myfile.txt', '/foodir/myfile2.txt')
</code></pre> 
  <p><strong>8.下载到指定目录</strong></p> 
  <pre><code># 下载到指定目录/home
client.download('/foodir/myfile.txt', '/home/myfile.txt', n_threads=3)
</code></pre> 
  <p><strong>9.创建文件夹</strong></p> 
  <pre><code>client.makedirs('/testdiretory')
</code></pre> 
  <p><strong>10.上传文件</strong></p> 
  <p>client.upload(‘目标路径’, ‘本地源路径’)</p> 
  <pre><code>client.upload('/testdiretory/myfile.txt','/home/myfile.txt' )
</code></pre> 
  <p><strong>11.设置权限</strong></p> 
  <pre><code>client.set_permission(filepath, 777)
</code></pre> 
  <h2><a id="6_128M128M_545"></a>6. 观察上传后的文件，上传大于128M的文件与小于128M的文件有何区别？</h2> 
  <p>文件块越大，寻址时间越短，但磁盘传输时间越长；</p> 
  <p>文件块越小，寻址时间越长，但磁盘传输时间越短。</p> 
  <p><strong>为什么HDFS中块（block）不能设置太大，也不能设置太小？</strong></p> 
  <ol> 
   <li> <p>如果块设置过大，</p> <p>一方面，从磁盘传输数据的时间会明显大于寻址时间，导致程序在处理这块数据时，变得非常慢；</p> <p>另一方面，mapreduce中的map任务通常一次只处理一个块中的数据，如果块过大运行速度也会很慢。</p> </li> 
   <li> <p>如果块设置过小，</p> <p>一方面存放大量小文件会占用NameNode中大量内存来存储元数据，而NameNode的内存是有限的，不可取；</p> <p>另一方面文件块过小，寻址时间增大，导致程序一直在找block的开始位置。</p> </li> 
  </ol> 
  <p>因而，块适当设置大一些，减少寻址时间，那么传输一个由多个块组成的文件的时间主要取决于磁盘的传输速率。</p> 
  <p><strong>HDFS中块（block）的大小为什么设置为128M？</strong></p> 
  <ol> 
   <li> <p>HDFS中平均寻址时间大概为10ms；</p> </li> 
   <li> <p>经过前人的大量测试发现，寻址时间为传输时间的1%时，为最佳状态；</p> <p>所以最佳传输时间为10ms/0.01=1000ms=1s</p> </li> 
   <li> <p>目前磁盘的传输速率普遍为100MB/s；</p> <p>计算出最佳block大小：100MB/s x 1s = 100MB</p> <p>所以我们设定block大小为128MB。</p> </li> 
  </ol> 
  <p>ps：实际在工业生产中，磁盘传输速率为200MB/s时，一般设定block大小为256MB<br> ；磁盘传输速率为400MB/s时，一般设定block大小为512MB</p> 
  <p>参考：：<a href="https://blog.csdn.net/wx1528159409/article/details/84260023" rel="nofollow" data-token="38ce15502f9c280da0a7f6a271d7433a">https://blog.csdn.net/wx1528159409/article/details/84260023</a></p> 
  <h2><a id="7_HDFS_586"></a>7. 启动HDFS后，会分别启动哪些进程？</h2> 
  <p><strong>(1) Hadoop</strong></p> 
  <p>namenode : NameNode, SecondaryNameNode, ResourceManager</p> 
  <p>datanode : DataNode, NodeManager</p> 
  <p><strong>(2) Zookeeper（安装Zookeeper的机器要为奇数台，这里有3台）</strong></p> 
  <p>QuorumPeerManager</p> 
  <h2><a id="8_NameNodeedits_logfsImage_596"></a>8. NameNode是如何组织文件中的元信息的，edits log与fsImage的区别？</h2> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731185607605.png" alt="在这里插入图片描述"></p> 
  <ol> 
   <li> <p>Fsimage文件：HDFS文件系统元数据的一个永久性的检查点，其中包含<strong>HDFS文件系统的所有目录和文件idnode的序列化信息</strong>；</p> </li> 
   <li> <p>Fsimage.md5文件：是镜像文件的 md5 校验文件，这个校验文件是为了<strong>判断镜像文件是否被修改</strong>；</p> </li> 
   <li> <p>Edits文件：<strong>存放HDFS文件系统的所有更新操作</strong>，文件系统客户端执行的所有写操作首先会被记录到Edits文件中</p> </li> 
   <li> <p>seen_txid文件：它代表的是 namenode 里面的 edits_* 文件的尾数，namenode 重启的时候，会按照 seen_txid 的数字， 循序从头跑 edits_0000001~ 到 seen_txid 的数字</p> </li> 
   <li> <p>VERSION文件：记录了当前NameNode的一些信息</p> </li> 
  </ol> 
  <p>图解：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019073118551721.png" alt="在这里插入图片描述"><br> <strong>VERSION文件内容的含义？</strong><br> 1.namespaceID是文件系统的唯一标识符，格式化文件系统后就会生成这个ID<br> 2.clusterID是系统生成的集群的ID;<br> 3.cTime是namenode存储系统创建是时间，第一次格式化系统就是0，再次格式化时就会更新;<br> 4.storagetype说明文件存储的是什么系统存储的信息，可能是namenode/datanode<br> 5.bolckpoolID是针对每一个namespace对应的bolckpool的ID，包含存储节点的IP等信息</p> 
  <p>参考：<a href="https://blog.csdn.net/qq_39657909/article/details/85233287" rel="nofollow" data-token="0fd3895b08eea074412d71b9ea61efa2">https://blog.csdn.net/qq_39657909/article/details/85233287</a></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e44c3c0e64.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
