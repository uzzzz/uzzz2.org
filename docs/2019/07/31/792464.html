<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Hadoop基础学习 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Hadoop基础学习" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="文章目录 一、理论知识 1.Hadoop的整体印象 2.Hadoop的优势 3.Hadoop可以做什么 4.Hadoop结构 4.1 Hadoop存储--HDFS 4.2 Hadoop计算--MapReduce 4.3 Hadoop资源管理--YARN 5.Hadoop生态 二、Hadoop实际操作 本文内容诸多借鉴，在借鉴处会表示出处，可在出处查看详情. 一、理论知识 参考Hadoop是什么，能干什么，怎么使用 1.Hadoop的整体印象 一句话概括：Hadoop就是存储海量数据和分析海量数据的工具。 Hadoop是由java语言编写的，在分布式服务器集群上存储海量数据并运行分布式分析应用的开源框架，其核心部件是HDFS与MapReduce。 HDFS是一个分布式文件系统：引入存放文件元数据信息的服务器Namenode和实际存放数据的服务器Datanode，对数据进行分布式储存和读取。 MapReduce是一个计算框架：MapReduce的核心思想是把计算任务分配给集群内的服务器里执行。通过对计算任务的拆分（Map计算/Reduce计算）再根据任务调度器（JobTracker）对任务进行分布式计算。 2.Hadoop的优势 高可靠性 ： Hadoop 按位存储和处理数据的能力值得人们信赖。 高扩展性 ： Hadoop 是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以干计的节点中。 高效性 ： Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。 高容错性 ： Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分。 低成本 ： 与一体机、商用数据仓库以及 QlikView、 Yonghong Z- Suites 等数据集市相比，Hadoop 是开源的，项目的软件成本因此会大大降低。Hadoop 带有用 Java 语言编写的框架，因此运行在 linux 生产平台上是非常理想的， Hadoop 上的应用程序也可以使用其他语言编写，比如 C++。 3.Hadoop可以做什么 可以大数据存储：分布式存储 日志处理：擅长日志分析 ETL:数据抽取到oracle、mysql、DB2、mongdb及主流数据库 机器学习: 比如Apache Mahout项目 搜索引擎:Hadoop + lucene实现 数据挖掘：目前比较流行的广告推荐，个性化广告推荐 Hadoop是专为离线和大规模数据分析而设计的，并不适合那种对几个记录随机读写的在线事务处理模式。 实际应用： Flume+Logstash+Kafka+Spark Streaming进行实时日志处理分析 酷狗音乐的大数据平台 4.Hadoop结构 参考Hadoop 系列（一）基本概念 4.1 Hadoop存储–HDFS Hadoop 的存储系统是 HDFS(Hadoop Distributed File System)分布式文件系统，对外部客户端而言，HDFS 就像一个传统的分级文件系统，可以进行创建、删除、移动或重命名文件或文件夹等操作，与 Linux 文件系统类似。 Hadoop HDFS 的架构是基于一组特定的节点构建的(见图s)，这些节名称节点(NameNode，仅一个)，它在 HDFS 内部提供元数据服务；第二名称节点(Secondary NameNode)，名称节点的帮助节点，主要是为了整合元数据操作(注意不是名称节点的备份)；数据节点(DataNode)，它为 HDFS 提供存储块。由于仅有一个 NameNode，因此这是 HDFS 的一个缺点(单点失败，在 Hadoop2.x 后有较大改善)。存储在 HDFS 中的文件被分成块，然后这些块被复制到多个数据节点中(DataNode)，这与传统的 RAID 架构大不相同。块的大小(通常为 128M)和复制的块数量在创建文件时由客户机决定。名称节点可以控制所有文件操作。HDFS 内部的所有通信都基于标准的 TCP/IP 协议。 （1）名称节点（NameNode） 它是一个通常在HDFS架构中单独机器上运行的组件，负责管理文件系统名称空间和控制外部客户机的访问。NameNode决定是否将文件映射到DataNode上的复制块上。对于最常见的3个复制块，第一个复制块存储在同一机架的不同节点上，最后一个复制块存储在不同机架的某个节点上。 （2）数据节点（DataNode） 数据节点也是一个通常在HDFS架构中的单独机器上运行的组件。Hadoop集群包含一个NameNode和大量DataNode。数据节点通常以机架的形式组织，机架通过一个交换机将所有系统连接起来。 数据节点响应来自HDFS客户机的读写请求。它们还响应来自NameNode的创建、删除和复制块的命令。名称节点依赖来自每个数据节点的定期心跳（heartbeat）消息。每条消息都包含一个块报告，名称节点可以根据这个报告验证块映射和其他文件系统元数据。如果数据节点不能发送心跳消息，名称节点将采取修复措施，重新复制在该节点上丢失的块。 （3）第二名称节点（Secondary NameNode） 第二名称节点的作用在于为HDFS中的名称节点提供一个Checkpoint，它只是名称节点的一个助手节点，这也是它在社区内被认为是Checkpoint Node的原因。 如下图所示，fsimage 是 NameNode 启动时对整个文件系统的快照；edits 是在 NameNode 启动后对文件系统的改动序列。 只有在NameNode重启时，edits才会合并到fsimage文件中，从而得到一个文件系统的最新快照。但是在生产环境集群中的NameNode是很少重启的，这意味着当NameNode运行很长时间后，edits文件会变得很大。而当NameNode宕机时，edits就会丢失很多改动。 如图 1-4 所示，Secondary NameNode 会定时到 NameNode 去获取名称节点的 edits，并及时更新到自己 fsimage 上。这样，如果 NameNode 宕机，我们也可以使用 Secondary-NameNode 的信息来恢复 NameNode。并且，如果 Secondary NameNode 新的 fsimage 文件达到一定阈值，它就会将其拷贝回名称节点上，这样 NameNode 在下次重启时会使用这个新的 fsimage 文件，从而减少重启的时间。 举个数据上传的例子来深入理解下HDFS内部是怎么做的。 文件在客户端时会被分块，这里可以看到文件被分为 5 个块，分别是：A、B、C、D、E。同时为了负载均衡，所以每个节点有 3 个块。下面来看看具体步骤： 1.客户端将要上传的文件按 128M 的大小分块。 2.客户端向名称节点发送写数据请求。 3.名称节点记录各个 DataNode 信息，并返回可用的 DataNode 列表。 4.客户端直接向 DataNode 发送分割后的文件块，发送过程以流式写入。 5.写入完成后，DataNode 向 NameNode 发送消息，更新元数据。 这里需要注意： 1.写 1T 文件，需要 3T 的存储，3T 的网络流量。 2.在执行读或写的过程中，NameNode 和 DataNode 通过 HeartBeat 进行保存通信，确定 DataNode 活着。如果发现 DataNode 死掉了，就将死掉的 DataNode 上的数据，放到其他节点去，读取时，读其他节点。 3.宕掉一个节点没关系，还有其他节点可以备份；甚至，宕掉某一个机架也没关系；其他机架上也有备份。 4.2 Hadoop计算–MapReduce MapReduce用于大规模数据集（大于1TB）的并行运算。概念**“Map（映射）”和“Reduce（归纳）”**以及它们的主要思想，都是从函数式编程语言借来的，还有从矢量编程语言借来的特性。 当前的软件实现是指定一个 Map（映射）函数：用来把一组键值对映射成一组新的键值对。指定并发的 Reduce（归纳）函数，用来保证所有映射的键值对中的每一个共享相同的键组，如下图所示。 下面将以 Hadoop 的“Hello World”例程—单词计数来分析MapReduce的逻辑，如下图 所示。一般的 MapReduce 程序会经过以下几个过程：输入（Input）、输入分片（Splitting）、Map阶段、Shuffle阶段、Reduce阶段、输出（Final result）。 1.输入就不用说了，数据一般放在 HDFS 上面就可以了，而且文件是被分块的。关于文件块和文件分片的关系，在输入分片中说明。 2.输入分片：在进行 Map 阶段之前，MapReduce 框架会根据输入文件计算输入分片（split），每个输入分片会对应一个 Map 任务，输入分片往往和 HDFS 的块关系很密切。例如，HDFS 的块的大小是 128M，如果我们输入两个文件，大小分别是 27M、129M，那么 27M 的文件会作为一个输入分片（不足 128M 会被当作一个分片），而 129MB 则是两个输入分片（129-128＝1，不足 128M，所以 1M 也会被当作一个输入分片），所以，一般来说，一个文件块会对应一个分片。如图 1-7 所示，Splitting 对应下面的三个数据应该理解为三个分片。 3.Map 阶段：这个阶段的处理逻辑就是编写好的 Map 函数，因为一个分片对应一个 Map 任务，并且是对应一个文件块，所以这里其实是数据本地化的操作，也就是所谓的移动计算而不是移动数据。如图 1-7 所示，这里的操作其实就是把每句话进行分割，然后得到每个单词，再对每个单词进行映射，得到单词和1的键值对。 4.Shuffle 阶段：这是“奇迹”发生的地方，MapReduce 的核心其实就是 Shuffle。那么 Shuffle 的原理呢？Shuffle 就是将 Map 的输出进行整合，然后作为 Reduce 的输入发送给 Reduce。简单理解就是把所有 Map 的输出按照键进行排序，并且把相对键的键值对整合到同一个组中。如上图所示，Bear、Car、Deer、River 是排序的，并且 Bear 这个键有两个键值对。 5.Reduce 阶段：与 Map 类似，这里也是用户编写程序的地方，可以针对分组后的键值对进行处理。如上图所示，针对同一个键 Bear 的所有值进行了一个加法操作，得到 &lt;Bear，2&gt; 这样的键值对。 6.输出：Reduce 的输出直接写入 HDFS 上，同样这个输出文件也是分块的。 用一张图表示上述的运行流程：MapReduce 的本质就是把一组键值对 &lt;K1，V1&gt; 经过 Map 阶段映射成新的键值对 &lt;K2，V2&gt;；接着经过 Shuffle/Sort 阶段进行排序和“洗牌”，把键值对排序，同时把相同的键的值整合；最后经过 Reduce 阶段，把整合后的键值对组进行逻辑处理，输出到新的键值对 &lt;K3，V3&gt;。这样的一个过程，其实就是 MapReduce 的本质。 Hadoop MapReduce 可以根据其使用的资源管理框架不同，而分为 MR v1 和 YARN/MR v2 版本。 在 MR v1 版本中，资源管理主要是 Jobtracker 和 TaskTracker。Jobtracker 主要负责：作业控制（作业分解和状态监控），主要是 MR 任务以及资源管理；而 TaskTracker 主要是调度 Job 的每一个子任务 task；并且接收 JobTracker 的命令。 在 YARN/MR v2 版本中，YARN 把 JobTracker 的工作分为两个部分： ResourceManager 资源管理器全局管理所有应用程序计算资源的分配。 ApplicationMaster 负责相应的调度和协调。 NodeManager 是每一台机器框架的代理，是执行应用程序的容器，监控应用程序的资源（CPU、内存、硬盘、网络）使用情况，并且向调度器汇报。 4.3 Hadoop资源管理–YARN 当 MapReduce 发展到 2.x 时就不使用 JobTracker 来作为自己的资源管理框架，而选择使用 YARN。这里需要说明的是，如果使用 JobTracker 来作为 Hadoop 集群的资源管理框架的话，那么除了 MapReduce 任务以外，不能够运行其他任务。也就是说，如果我们集群的 MapReduce 任务并没有那么饱满的话，集群资源等于是白白浪费的。所以提出了另外的一个资源管理架构 YARN（Yet Another Resource Manager）。这里需要注意，YARN 不是 JobTracker 的简单升级，而是“大换血”。同时 Hadoop 2.X 也包含了此架构。Apache Hadoop 2.X 项目包含以下模块。 Hadoop Common：为 Hadoop 其他模块提供支持的基础模块。 HDFS：Hadoop：分布式文件系统。 YARN：任务分配和集群资源管理框架。 MapReduce：并行和可扩展的用于处理大数据的模式。 YARN 资源管理框架包括 ResourceManager（资源管理器）、ApplicationMaster、NodeManager（节点管理器）。各个组件描述如下。 ResourceManager 是一个全局的资源管理器，负责整个系统的资源管理和分配。它主要由两个组件构成：调度器（Scheduler）和应用程序管理器（ApplicationManager，AM）。 Scheduler 负责分配最少但满足 Application 运行所需的资源量给 Application。Scheduler 只是基于资源的使用情况进行调度，并不负责监视/跟踪 Application 的状态，当然也不会处理失败的 Task。 ApplicationManager 负责处理客户端提交的 Job 以及协商第一个 Container 以供 ApplicationMaster 运行，并且在 ApplicationMaster 失败的时候会重新启动 ApplicationMaster（YARN 中使用 Resource Container 概念来管理集群的资源，Resource Container 是资源的抽象，每个 Container 包括一定的内存、IO、网络等资源）。 ApplicatonMaster 是一个框架特殊的库，每个 Application 有一个 ApplicationMaster，主要管理和监控部署在 YARN 集群上的各种应用。 NodeManager主要负责启动 ResourceManager 分配给 ApplicationMaster 的 Container，并且会监视 Container 的运行情况。在启动 Container 的时候，NodeManager 会设置一些必要的环境变量以及相关文件；当所有准备工作做好后，才会启动该 Container。启动后，NodeManager 会周期性地监视该 Container 运行占用的资源情况，若是超过了该 Container 所声明的资源量，则会 kill 掉该 Container 所代表的进程。 如图 1-11 所示，该集群上有两个任务（对应 Node2、Node6 上面的 AM），并且 Node2 上面的任务运行有 4 个 Container 来执行任务；而 Node6 上面的任务则有 2 个 Container 来执行任务。 5.Hadoop生态 Hadoop 的生态圈其实就是一群动物在狂欢。我们来看看一些主要的框架。 Hbase HBase（Hadoop Database）是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用 HBase 技术可在廉价 PC Server 上搭建起大规模结构化存储集群。 Hive Hive 是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。 Pig Pig 是一个基于 Hadoop 的大规模数据分析平台，它提供的 SQL-LIKE 语言叫作 Pig Latin。该语言的编译器会把类 SQL 的数据分析请求转换为一系列经过优化处理的 Map-Reduce 运算。 Sqoop Sqoop 是一款开源的工具，主要用于在 Hadoop（Hive）与传统的数据库（MySQL、post-gresql等）间进行数据的传递，可以将一个关系型数据库中的数据导入 Hadoop 的 HDFS 中，也可以将 HDFS 的数据导入关系型数据库中，如下图所示。 Flume Flume 是 Cloudera 提供的一个高可用、高可靠、分布式的海量日志采集、聚合和传输的系统，Flume 支持在日志系统中定制各类数据发送方，用于收集数据。同时，Flume 提供对数据进行简单处理并写到各种数据接受方（可定制）的能力，如下图。 Oozie Oozie 是基于 Hadoop 的调度器，以 XML 的形式写调度流程，可以调度 Mr、Pig、Hive、shell、jar 任务等。 主要的功能如下。 Workflow：顺序执行流程节点，支持 fork（分支多个节点）、join（将多个节点合并为一个）。 Coordinator：定时触发 Workflow。 Bundle Job：绑定多个 Coordinator。 Chukwa Chukwa 是一个开源的、用于监控大型分布式系统的数据收集系统。它构建在 Hadoop 的 HDFS 和 MapReduce 框架上，继承了 Hadoop 的可伸缩性和鲁棒性。Chukwa 还包含了一个强大和灵活的工具集，可用于展示、监控和分析已收集的数据。 ZooKeeper ZooKeeper 是一个开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件，如图 1-15 所示。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 二、Hadoop实际操作 未完待续…" />
<meta property="og:description" content="文章目录 一、理论知识 1.Hadoop的整体印象 2.Hadoop的优势 3.Hadoop可以做什么 4.Hadoop结构 4.1 Hadoop存储--HDFS 4.2 Hadoop计算--MapReduce 4.3 Hadoop资源管理--YARN 5.Hadoop生态 二、Hadoop实际操作 本文内容诸多借鉴，在借鉴处会表示出处，可在出处查看详情. 一、理论知识 参考Hadoop是什么，能干什么，怎么使用 1.Hadoop的整体印象 一句话概括：Hadoop就是存储海量数据和分析海量数据的工具。 Hadoop是由java语言编写的，在分布式服务器集群上存储海量数据并运行分布式分析应用的开源框架，其核心部件是HDFS与MapReduce。 HDFS是一个分布式文件系统：引入存放文件元数据信息的服务器Namenode和实际存放数据的服务器Datanode，对数据进行分布式储存和读取。 MapReduce是一个计算框架：MapReduce的核心思想是把计算任务分配给集群内的服务器里执行。通过对计算任务的拆分（Map计算/Reduce计算）再根据任务调度器（JobTracker）对任务进行分布式计算。 2.Hadoop的优势 高可靠性 ： Hadoop 按位存储和处理数据的能力值得人们信赖。 高扩展性 ： Hadoop 是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以干计的节点中。 高效性 ： Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。 高容错性 ： Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分。 低成本 ： 与一体机、商用数据仓库以及 QlikView、 Yonghong Z- Suites 等数据集市相比，Hadoop 是开源的，项目的软件成本因此会大大降低。Hadoop 带有用 Java 语言编写的框架，因此运行在 linux 生产平台上是非常理想的， Hadoop 上的应用程序也可以使用其他语言编写，比如 C++。 3.Hadoop可以做什么 可以大数据存储：分布式存储 日志处理：擅长日志分析 ETL:数据抽取到oracle、mysql、DB2、mongdb及主流数据库 机器学习: 比如Apache Mahout项目 搜索引擎:Hadoop + lucene实现 数据挖掘：目前比较流行的广告推荐，个性化广告推荐 Hadoop是专为离线和大规模数据分析而设计的，并不适合那种对几个记录随机读写的在线事务处理模式。 实际应用： Flume+Logstash+Kafka+Spark Streaming进行实时日志处理分析 酷狗音乐的大数据平台 4.Hadoop结构 参考Hadoop 系列（一）基本概念 4.1 Hadoop存储–HDFS Hadoop 的存储系统是 HDFS(Hadoop Distributed File System)分布式文件系统，对外部客户端而言，HDFS 就像一个传统的分级文件系统，可以进行创建、删除、移动或重命名文件或文件夹等操作，与 Linux 文件系统类似。 Hadoop HDFS 的架构是基于一组特定的节点构建的(见图s)，这些节名称节点(NameNode，仅一个)，它在 HDFS 内部提供元数据服务；第二名称节点(Secondary NameNode)，名称节点的帮助节点，主要是为了整合元数据操作(注意不是名称节点的备份)；数据节点(DataNode)，它为 HDFS 提供存储块。由于仅有一个 NameNode，因此这是 HDFS 的一个缺点(单点失败，在 Hadoop2.x 后有较大改善)。存储在 HDFS 中的文件被分成块，然后这些块被复制到多个数据节点中(DataNode)，这与传统的 RAID 架构大不相同。块的大小(通常为 128M)和复制的块数量在创建文件时由客户机决定。名称节点可以控制所有文件操作。HDFS 内部的所有通信都基于标准的 TCP/IP 协议。 （1）名称节点（NameNode） 它是一个通常在HDFS架构中单独机器上运行的组件，负责管理文件系统名称空间和控制外部客户机的访问。NameNode决定是否将文件映射到DataNode上的复制块上。对于最常见的3个复制块，第一个复制块存储在同一机架的不同节点上，最后一个复制块存储在不同机架的某个节点上。 （2）数据节点（DataNode） 数据节点也是一个通常在HDFS架构中的单独机器上运行的组件。Hadoop集群包含一个NameNode和大量DataNode。数据节点通常以机架的形式组织，机架通过一个交换机将所有系统连接起来。 数据节点响应来自HDFS客户机的读写请求。它们还响应来自NameNode的创建、删除和复制块的命令。名称节点依赖来自每个数据节点的定期心跳（heartbeat）消息。每条消息都包含一个块报告，名称节点可以根据这个报告验证块映射和其他文件系统元数据。如果数据节点不能发送心跳消息，名称节点将采取修复措施，重新复制在该节点上丢失的块。 （3）第二名称节点（Secondary NameNode） 第二名称节点的作用在于为HDFS中的名称节点提供一个Checkpoint，它只是名称节点的一个助手节点，这也是它在社区内被认为是Checkpoint Node的原因。 如下图所示，fsimage 是 NameNode 启动时对整个文件系统的快照；edits 是在 NameNode 启动后对文件系统的改动序列。 只有在NameNode重启时，edits才会合并到fsimage文件中，从而得到一个文件系统的最新快照。但是在生产环境集群中的NameNode是很少重启的，这意味着当NameNode运行很长时间后，edits文件会变得很大。而当NameNode宕机时，edits就会丢失很多改动。 如图 1-4 所示，Secondary NameNode 会定时到 NameNode 去获取名称节点的 edits，并及时更新到自己 fsimage 上。这样，如果 NameNode 宕机，我们也可以使用 Secondary-NameNode 的信息来恢复 NameNode。并且，如果 Secondary NameNode 新的 fsimage 文件达到一定阈值，它就会将其拷贝回名称节点上，这样 NameNode 在下次重启时会使用这个新的 fsimage 文件，从而减少重启的时间。 举个数据上传的例子来深入理解下HDFS内部是怎么做的。 文件在客户端时会被分块，这里可以看到文件被分为 5 个块，分别是：A、B、C、D、E。同时为了负载均衡，所以每个节点有 3 个块。下面来看看具体步骤： 1.客户端将要上传的文件按 128M 的大小分块。 2.客户端向名称节点发送写数据请求。 3.名称节点记录各个 DataNode 信息，并返回可用的 DataNode 列表。 4.客户端直接向 DataNode 发送分割后的文件块，发送过程以流式写入。 5.写入完成后，DataNode 向 NameNode 发送消息，更新元数据。 这里需要注意： 1.写 1T 文件，需要 3T 的存储，3T 的网络流量。 2.在执行读或写的过程中，NameNode 和 DataNode 通过 HeartBeat 进行保存通信，确定 DataNode 活着。如果发现 DataNode 死掉了，就将死掉的 DataNode 上的数据，放到其他节点去，读取时，读其他节点。 3.宕掉一个节点没关系，还有其他节点可以备份；甚至，宕掉某一个机架也没关系；其他机架上也有备份。 4.2 Hadoop计算–MapReduce MapReduce用于大规模数据集（大于1TB）的并行运算。概念**“Map（映射）”和“Reduce（归纳）”**以及它们的主要思想，都是从函数式编程语言借来的，还有从矢量编程语言借来的特性。 当前的软件实现是指定一个 Map（映射）函数：用来把一组键值对映射成一组新的键值对。指定并发的 Reduce（归纳）函数，用来保证所有映射的键值对中的每一个共享相同的键组，如下图所示。 下面将以 Hadoop 的“Hello World”例程—单词计数来分析MapReduce的逻辑，如下图 所示。一般的 MapReduce 程序会经过以下几个过程：输入（Input）、输入分片（Splitting）、Map阶段、Shuffle阶段、Reduce阶段、输出（Final result）。 1.输入就不用说了，数据一般放在 HDFS 上面就可以了，而且文件是被分块的。关于文件块和文件分片的关系，在输入分片中说明。 2.输入分片：在进行 Map 阶段之前，MapReduce 框架会根据输入文件计算输入分片（split），每个输入分片会对应一个 Map 任务，输入分片往往和 HDFS 的块关系很密切。例如，HDFS 的块的大小是 128M，如果我们输入两个文件，大小分别是 27M、129M，那么 27M 的文件会作为一个输入分片（不足 128M 会被当作一个分片），而 129MB 则是两个输入分片（129-128＝1，不足 128M，所以 1M 也会被当作一个输入分片），所以，一般来说，一个文件块会对应一个分片。如图 1-7 所示，Splitting 对应下面的三个数据应该理解为三个分片。 3.Map 阶段：这个阶段的处理逻辑就是编写好的 Map 函数，因为一个分片对应一个 Map 任务，并且是对应一个文件块，所以这里其实是数据本地化的操作，也就是所谓的移动计算而不是移动数据。如图 1-7 所示，这里的操作其实就是把每句话进行分割，然后得到每个单词，再对每个单词进行映射，得到单词和1的键值对。 4.Shuffle 阶段：这是“奇迹”发生的地方，MapReduce 的核心其实就是 Shuffle。那么 Shuffle 的原理呢？Shuffle 就是将 Map 的输出进行整合，然后作为 Reduce 的输入发送给 Reduce。简单理解就是把所有 Map 的输出按照键进行排序，并且把相对键的键值对整合到同一个组中。如上图所示，Bear、Car、Deer、River 是排序的，并且 Bear 这个键有两个键值对。 5.Reduce 阶段：与 Map 类似，这里也是用户编写程序的地方，可以针对分组后的键值对进行处理。如上图所示，针对同一个键 Bear 的所有值进行了一个加法操作，得到 &lt;Bear，2&gt; 这样的键值对。 6.输出：Reduce 的输出直接写入 HDFS 上，同样这个输出文件也是分块的。 用一张图表示上述的运行流程：MapReduce 的本质就是把一组键值对 &lt;K1，V1&gt; 经过 Map 阶段映射成新的键值对 &lt;K2，V2&gt;；接着经过 Shuffle/Sort 阶段进行排序和“洗牌”，把键值对排序，同时把相同的键的值整合；最后经过 Reduce 阶段，把整合后的键值对组进行逻辑处理，输出到新的键值对 &lt;K3，V3&gt;。这样的一个过程，其实就是 MapReduce 的本质。 Hadoop MapReduce 可以根据其使用的资源管理框架不同，而分为 MR v1 和 YARN/MR v2 版本。 在 MR v1 版本中，资源管理主要是 Jobtracker 和 TaskTracker。Jobtracker 主要负责：作业控制（作业分解和状态监控），主要是 MR 任务以及资源管理；而 TaskTracker 主要是调度 Job 的每一个子任务 task；并且接收 JobTracker 的命令。 在 YARN/MR v2 版本中，YARN 把 JobTracker 的工作分为两个部分： ResourceManager 资源管理器全局管理所有应用程序计算资源的分配。 ApplicationMaster 负责相应的调度和协调。 NodeManager 是每一台机器框架的代理，是执行应用程序的容器，监控应用程序的资源（CPU、内存、硬盘、网络）使用情况，并且向调度器汇报。 4.3 Hadoop资源管理–YARN 当 MapReduce 发展到 2.x 时就不使用 JobTracker 来作为自己的资源管理框架，而选择使用 YARN。这里需要说明的是，如果使用 JobTracker 来作为 Hadoop 集群的资源管理框架的话，那么除了 MapReduce 任务以外，不能够运行其他任务。也就是说，如果我们集群的 MapReduce 任务并没有那么饱满的话，集群资源等于是白白浪费的。所以提出了另外的一个资源管理架构 YARN（Yet Another Resource Manager）。这里需要注意，YARN 不是 JobTracker 的简单升级，而是“大换血”。同时 Hadoop 2.X 也包含了此架构。Apache Hadoop 2.X 项目包含以下模块。 Hadoop Common：为 Hadoop 其他模块提供支持的基础模块。 HDFS：Hadoop：分布式文件系统。 YARN：任务分配和集群资源管理框架。 MapReduce：并行和可扩展的用于处理大数据的模式。 YARN 资源管理框架包括 ResourceManager（资源管理器）、ApplicationMaster、NodeManager（节点管理器）。各个组件描述如下。 ResourceManager 是一个全局的资源管理器，负责整个系统的资源管理和分配。它主要由两个组件构成：调度器（Scheduler）和应用程序管理器（ApplicationManager，AM）。 Scheduler 负责分配最少但满足 Application 运行所需的资源量给 Application。Scheduler 只是基于资源的使用情况进行调度，并不负责监视/跟踪 Application 的状态，当然也不会处理失败的 Task。 ApplicationManager 负责处理客户端提交的 Job 以及协商第一个 Container 以供 ApplicationMaster 运行，并且在 ApplicationMaster 失败的时候会重新启动 ApplicationMaster（YARN 中使用 Resource Container 概念来管理集群的资源，Resource Container 是资源的抽象，每个 Container 包括一定的内存、IO、网络等资源）。 ApplicatonMaster 是一个框架特殊的库，每个 Application 有一个 ApplicationMaster，主要管理和监控部署在 YARN 集群上的各种应用。 NodeManager主要负责启动 ResourceManager 分配给 ApplicationMaster 的 Container，并且会监视 Container 的运行情况。在启动 Container 的时候，NodeManager 会设置一些必要的环境变量以及相关文件；当所有准备工作做好后，才会启动该 Container。启动后，NodeManager 会周期性地监视该 Container 运行占用的资源情况，若是超过了该 Container 所声明的资源量，则会 kill 掉该 Container 所代表的进程。 如图 1-11 所示，该集群上有两个任务（对应 Node2、Node6 上面的 AM），并且 Node2 上面的任务运行有 4 个 Container 来执行任务；而 Node6 上面的任务则有 2 个 Container 来执行任务。 5.Hadoop生态 Hadoop 的生态圈其实就是一群动物在狂欢。我们来看看一些主要的框架。 Hbase HBase（Hadoop Database）是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用 HBase 技术可在廉价 PC Server 上搭建起大规模结构化存储集群。 Hive Hive 是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。 Pig Pig 是一个基于 Hadoop 的大规模数据分析平台，它提供的 SQL-LIKE 语言叫作 Pig Latin。该语言的编译器会把类 SQL 的数据分析请求转换为一系列经过优化处理的 Map-Reduce 运算。 Sqoop Sqoop 是一款开源的工具，主要用于在 Hadoop（Hive）与传统的数据库（MySQL、post-gresql等）间进行数据的传递，可以将一个关系型数据库中的数据导入 Hadoop 的 HDFS 中，也可以将 HDFS 的数据导入关系型数据库中，如下图所示。 Flume Flume 是 Cloudera 提供的一个高可用、高可靠、分布式的海量日志采集、聚合和传输的系统，Flume 支持在日志系统中定制各类数据发送方，用于收集数据。同时，Flume 提供对数据进行简单处理并写到各种数据接受方（可定制）的能力，如下图。 Oozie Oozie 是基于 Hadoop 的调度器，以 XML 的形式写调度流程，可以调度 Mr、Pig、Hive、shell、jar 任务等。 主要的功能如下。 Workflow：顺序执行流程节点，支持 fork（分支多个节点）、join（将多个节点合并为一个）。 Coordinator：定时触发 Workflow。 Bundle Job：绑定多个 Coordinator。 Chukwa Chukwa 是一个开源的、用于监控大型分布式系统的数据收集系统。它构建在 Hadoop 的 HDFS 和 MapReduce 框架上，继承了 Hadoop 的可伸缩性和鲁棒性。Chukwa 还包含了一个强大和灵活的工具集，可用于展示、监控和分析已收集的数据。 ZooKeeper ZooKeeper 是一个开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件，如图 1-15 所示。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 二、Hadoop实际操作 未完待续…" />
<link rel="canonical" href="https://uzzz.org/2019/07/31/792464.html" />
<meta property="og:url" content="https://uzzz.org/2019/07/31/792464.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-31T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"文章目录 一、理论知识 1.Hadoop的整体印象 2.Hadoop的优势 3.Hadoop可以做什么 4.Hadoop结构 4.1 Hadoop存储--HDFS 4.2 Hadoop计算--MapReduce 4.3 Hadoop资源管理--YARN 5.Hadoop生态 二、Hadoop实际操作 本文内容诸多借鉴，在借鉴处会表示出处，可在出处查看详情. 一、理论知识 参考Hadoop是什么，能干什么，怎么使用 1.Hadoop的整体印象 一句话概括：Hadoop就是存储海量数据和分析海量数据的工具。 Hadoop是由java语言编写的，在分布式服务器集群上存储海量数据并运行分布式分析应用的开源框架，其核心部件是HDFS与MapReduce。 HDFS是一个分布式文件系统：引入存放文件元数据信息的服务器Namenode和实际存放数据的服务器Datanode，对数据进行分布式储存和读取。 MapReduce是一个计算框架：MapReduce的核心思想是把计算任务分配给集群内的服务器里执行。通过对计算任务的拆分（Map计算/Reduce计算）再根据任务调度器（JobTracker）对任务进行分布式计算。 2.Hadoop的优势 高可靠性 ： Hadoop 按位存储和处理数据的能力值得人们信赖。 高扩展性 ： Hadoop 是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以干计的节点中。 高效性 ： Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。 高容错性 ： Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分。 低成本 ： 与一体机、商用数据仓库以及 QlikView、 Yonghong Z- Suites 等数据集市相比，Hadoop 是开源的，项目的软件成本因此会大大降低。Hadoop 带有用 Java 语言编写的框架，因此运行在 linux 生产平台上是非常理想的， Hadoop 上的应用程序也可以使用其他语言编写，比如 C++。 3.Hadoop可以做什么 可以大数据存储：分布式存储 日志处理：擅长日志分析 ETL:数据抽取到oracle、mysql、DB2、mongdb及主流数据库 机器学习: 比如Apache Mahout项目 搜索引擎:Hadoop + lucene实现 数据挖掘：目前比较流行的广告推荐，个性化广告推荐 Hadoop是专为离线和大规模数据分析而设计的，并不适合那种对几个记录随机读写的在线事务处理模式。 实际应用： Flume+Logstash+Kafka+Spark Streaming进行实时日志处理分析 酷狗音乐的大数据平台 4.Hadoop结构 参考Hadoop 系列（一）基本概念 4.1 Hadoop存储–HDFS Hadoop 的存储系统是 HDFS(Hadoop Distributed File System)分布式文件系统，对外部客户端而言，HDFS 就像一个传统的分级文件系统，可以进行创建、删除、移动或重命名文件或文件夹等操作，与 Linux 文件系统类似。 Hadoop HDFS 的架构是基于一组特定的节点构建的(见图s)，这些节名称节点(NameNode，仅一个)，它在 HDFS 内部提供元数据服务；第二名称节点(Secondary NameNode)，名称节点的帮助节点，主要是为了整合元数据操作(注意不是名称节点的备份)；数据节点(DataNode)，它为 HDFS 提供存储块。由于仅有一个 NameNode，因此这是 HDFS 的一个缺点(单点失败，在 Hadoop2.x 后有较大改善)。存储在 HDFS 中的文件被分成块，然后这些块被复制到多个数据节点中(DataNode)，这与传统的 RAID 架构大不相同。块的大小(通常为 128M)和复制的块数量在创建文件时由客户机决定。名称节点可以控制所有文件操作。HDFS 内部的所有通信都基于标准的 TCP/IP 协议。 （1）名称节点（NameNode） 它是一个通常在HDFS架构中单独机器上运行的组件，负责管理文件系统名称空间和控制外部客户机的访问。NameNode决定是否将文件映射到DataNode上的复制块上。对于最常见的3个复制块，第一个复制块存储在同一机架的不同节点上，最后一个复制块存储在不同机架的某个节点上。 （2）数据节点（DataNode） 数据节点也是一个通常在HDFS架构中的单独机器上运行的组件。Hadoop集群包含一个NameNode和大量DataNode。数据节点通常以机架的形式组织，机架通过一个交换机将所有系统连接起来。 数据节点响应来自HDFS客户机的读写请求。它们还响应来自NameNode的创建、删除和复制块的命令。名称节点依赖来自每个数据节点的定期心跳（heartbeat）消息。每条消息都包含一个块报告，名称节点可以根据这个报告验证块映射和其他文件系统元数据。如果数据节点不能发送心跳消息，名称节点将采取修复措施，重新复制在该节点上丢失的块。 （3）第二名称节点（Secondary NameNode） 第二名称节点的作用在于为HDFS中的名称节点提供一个Checkpoint，它只是名称节点的一个助手节点，这也是它在社区内被认为是Checkpoint Node的原因。 如下图所示，fsimage 是 NameNode 启动时对整个文件系统的快照；edits 是在 NameNode 启动后对文件系统的改动序列。 只有在NameNode重启时，edits才会合并到fsimage文件中，从而得到一个文件系统的最新快照。但是在生产环境集群中的NameNode是很少重启的，这意味着当NameNode运行很长时间后，edits文件会变得很大。而当NameNode宕机时，edits就会丢失很多改动。 如图 1-4 所示，Secondary NameNode 会定时到 NameNode 去获取名称节点的 edits，并及时更新到自己 fsimage 上。这样，如果 NameNode 宕机，我们也可以使用 Secondary-NameNode 的信息来恢复 NameNode。并且，如果 Secondary NameNode 新的 fsimage 文件达到一定阈值，它就会将其拷贝回名称节点上，这样 NameNode 在下次重启时会使用这个新的 fsimage 文件，从而减少重启的时间。 举个数据上传的例子来深入理解下HDFS内部是怎么做的。 文件在客户端时会被分块，这里可以看到文件被分为 5 个块，分别是：A、B、C、D、E。同时为了负载均衡，所以每个节点有 3 个块。下面来看看具体步骤： 1.客户端将要上传的文件按 128M 的大小分块。 2.客户端向名称节点发送写数据请求。 3.名称节点记录各个 DataNode 信息，并返回可用的 DataNode 列表。 4.客户端直接向 DataNode 发送分割后的文件块，发送过程以流式写入。 5.写入完成后，DataNode 向 NameNode 发送消息，更新元数据。 这里需要注意： 1.写 1T 文件，需要 3T 的存储，3T 的网络流量。 2.在执行读或写的过程中，NameNode 和 DataNode 通过 HeartBeat 进行保存通信，确定 DataNode 活着。如果发现 DataNode 死掉了，就将死掉的 DataNode 上的数据，放到其他节点去，读取时，读其他节点。 3.宕掉一个节点没关系，还有其他节点可以备份；甚至，宕掉某一个机架也没关系；其他机架上也有备份。 4.2 Hadoop计算–MapReduce MapReduce用于大规模数据集（大于1TB）的并行运算。概念**“Map（映射）”和“Reduce（归纳）”**以及它们的主要思想，都是从函数式编程语言借来的，还有从矢量编程语言借来的特性。 当前的软件实现是指定一个 Map（映射）函数：用来把一组键值对映射成一组新的键值对。指定并发的 Reduce（归纳）函数，用来保证所有映射的键值对中的每一个共享相同的键组，如下图所示。 下面将以 Hadoop 的“Hello World”例程—单词计数来分析MapReduce的逻辑，如下图 所示。一般的 MapReduce 程序会经过以下几个过程：输入（Input）、输入分片（Splitting）、Map阶段、Shuffle阶段、Reduce阶段、输出（Final result）。 1.输入就不用说了，数据一般放在 HDFS 上面就可以了，而且文件是被分块的。关于文件块和文件分片的关系，在输入分片中说明。 2.输入分片：在进行 Map 阶段之前，MapReduce 框架会根据输入文件计算输入分片（split），每个输入分片会对应一个 Map 任务，输入分片往往和 HDFS 的块关系很密切。例如，HDFS 的块的大小是 128M，如果我们输入两个文件，大小分别是 27M、129M，那么 27M 的文件会作为一个输入分片（不足 128M 会被当作一个分片），而 129MB 则是两个输入分片（129-128＝1，不足 128M，所以 1M 也会被当作一个输入分片），所以，一般来说，一个文件块会对应一个分片。如图 1-7 所示，Splitting 对应下面的三个数据应该理解为三个分片。 3.Map 阶段：这个阶段的处理逻辑就是编写好的 Map 函数，因为一个分片对应一个 Map 任务，并且是对应一个文件块，所以这里其实是数据本地化的操作，也就是所谓的移动计算而不是移动数据。如图 1-7 所示，这里的操作其实就是把每句话进行分割，然后得到每个单词，再对每个单词进行映射，得到单词和1的键值对。 4.Shuffle 阶段：这是“奇迹”发生的地方，MapReduce 的核心其实就是 Shuffle。那么 Shuffle 的原理呢？Shuffle 就是将 Map 的输出进行整合，然后作为 Reduce 的输入发送给 Reduce。简单理解就是把所有 Map 的输出按照键进行排序，并且把相对键的键值对整合到同一个组中。如上图所示，Bear、Car、Deer、River 是排序的，并且 Bear 这个键有两个键值对。 5.Reduce 阶段：与 Map 类似，这里也是用户编写程序的地方，可以针对分组后的键值对进行处理。如上图所示，针对同一个键 Bear 的所有值进行了一个加法操作，得到 &lt;Bear，2&gt; 这样的键值对。 6.输出：Reduce 的输出直接写入 HDFS 上，同样这个输出文件也是分块的。 用一张图表示上述的运行流程：MapReduce 的本质就是把一组键值对 &lt;K1，V1&gt; 经过 Map 阶段映射成新的键值对 &lt;K2，V2&gt;；接着经过 Shuffle/Sort 阶段进行排序和“洗牌”，把键值对排序，同时把相同的键的值整合；最后经过 Reduce 阶段，把整合后的键值对组进行逻辑处理，输出到新的键值对 &lt;K3，V3&gt;。这样的一个过程，其实就是 MapReduce 的本质。 Hadoop MapReduce 可以根据其使用的资源管理框架不同，而分为 MR v1 和 YARN/MR v2 版本。 在 MR v1 版本中，资源管理主要是 Jobtracker 和 TaskTracker。Jobtracker 主要负责：作业控制（作业分解和状态监控），主要是 MR 任务以及资源管理；而 TaskTracker 主要是调度 Job 的每一个子任务 task；并且接收 JobTracker 的命令。 在 YARN/MR v2 版本中，YARN 把 JobTracker 的工作分为两个部分： ResourceManager 资源管理器全局管理所有应用程序计算资源的分配。 ApplicationMaster 负责相应的调度和协调。 NodeManager 是每一台机器框架的代理，是执行应用程序的容器，监控应用程序的资源（CPU、内存、硬盘、网络）使用情况，并且向调度器汇报。 4.3 Hadoop资源管理–YARN 当 MapReduce 发展到 2.x 时就不使用 JobTracker 来作为自己的资源管理框架，而选择使用 YARN。这里需要说明的是，如果使用 JobTracker 来作为 Hadoop 集群的资源管理框架的话，那么除了 MapReduce 任务以外，不能够运行其他任务。也就是说，如果我们集群的 MapReduce 任务并没有那么饱满的话，集群资源等于是白白浪费的。所以提出了另外的一个资源管理架构 YARN（Yet Another Resource Manager）。这里需要注意，YARN 不是 JobTracker 的简单升级，而是“大换血”。同时 Hadoop 2.X 也包含了此架构。Apache Hadoop 2.X 项目包含以下模块。 Hadoop Common：为 Hadoop 其他模块提供支持的基础模块。 HDFS：Hadoop：分布式文件系统。 YARN：任务分配和集群资源管理框架。 MapReduce：并行和可扩展的用于处理大数据的模式。 YARN 资源管理框架包括 ResourceManager（资源管理器）、ApplicationMaster、NodeManager（节点管理器）。各个组件描述如下。 ResourceManager 是一个全局的资源管理器，负责整个系统的资源管理和分配。它主要由两个组件构成：调度器（Scheduler）和应用程序管理器（ApplicationManager，AM）。 Scheduler 负责分配最少但满足 Application 运行所需的资源量给 Application。Scheduler 只是基于资源的使用情况进行调度，并不负责监视/跟踪 Application 的状态，当然也不会处理失败的 Task。 ApplicationManager 负责处理客户端提交的 Job 以及协商第一个 Container 以供 ApplicationMaster 运行，并且在 ApplicationMaster 失败的时候会重新启动 ApplicationMaster（YARN 中使用 Resource Container 概念来管理集群的资源，Resource Container 是资源的抽象，每个 Container 包括一定的内存、IO、网络等资源）。 ApplicatonMaster 是一个框架特殊的库，每个 Application 有一个 ApplicationMaster，主要管理和监控部署在 YARN 集群上的各种应用。 NodeManager主要负责启动 ResourceManager 分配给 ApplicationMaster 的 Container，并且会监视 Container 的运行情况。在启动 Container 的时候，NodeManager 会设置一些必要的环境变量以及相关文件；当所有准备工作做好后，才会启动该 Container。启动后，NodeManager 会周期性地监视该 Container 运行占用的资源情况，若是超过了该 Container 所声明的资源量，则会 kill 掉该 Container 所代表的进程。 如图 1-11 所示，该集群上有两个任务（对应 Node2、Node6 上面的 AM），并且 Node2 上面的任务运行有 4 个 Container 来执行任务；而 Node6 上面的任务则有 2 个 Container 来执行任务。 5.Hadoop生态 Hadoop 的生态圈其实就是一群动物在狂欢。我们来看看一些主要的框架。 Hbase HBase（Hadoop Database）是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用 HBase 技术可在廉价 PC Server 上搭建起大规模结构化存储集群。 Hive Hive 是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。 Pig Pig 是一个基于 Hadoop 的大规模数据分析平台，它提供的 SQL-LIKE 语言叫作 Pig Latin。该语言的编译器会把类 SQL 的数据分析请求转换为一系列经过优化处理的 Map-Reduce 运算。 Sqoop Sqoop 是一款开源的工具，主要用于在 Hadoop（Hive）与传统的数据库（MySQL、post-gresql等）间进行数据的传递，可以将一个关系型数据库中的数据导入 Hadoop 的 HDFS 中，也可以将 HDFS 的数据导入关系型数据库中，如下图所示。 Flume Flume 是 Cloudera 提供的一个高可用、高可靠、分布式的海量日志采集、聚合和传输的系统，Flume 支持在日志系统中定制各类数据发送方，用于收集数据。同时，Flume 提供对数据进行简单处理并写到各种数据接受方（可定制）的能力，如下图。 Oozie Oozie 是基于 Hadoop 的调度器，以 XML 的形式写调度流程，可以调度 Mr、Pig、Hive、shell、jar 任务等。 主要的功能如下。 Workflow：顺序执行流程节点，支持 fork（分支多个节点）、join（将多个节点合并为一个）。 Coordinator：定时触发 Workflow。 Bundle Job：绑定多个 Coordinator。 Chukwa Chukwa 是一个开源的、用于监控大型分布式系统的数据收集系统。它构建在 Hadoop 的 HDFS 和 MapReduce 框架上，继承了 Hadoop 的可伸缩性和鲁棒性。Chukwa 还包含了一个强大和灵活的工具集，可用于展示、监控和分析已收集的数据。 ZooKeeper ZooKeeper 是一个开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件，如图 1-15 所示。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 二、Hadoop实际操作 未完待续…","@type":"BlogPosting","url":"https://uzzz.org/2019/07/31/792464.html","headline":"Hadoop基础学习","dateModified":"2019-07-31T00:00:00+08:00","datePublished":"2019-07-31T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/07/31/792464.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Hadoop基础学习</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> 
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path> 
  </svg> 
  <p></p>
  <div class="toc">
   <h3>文章目录</h3>
   <ul>
    <li><a href="#_2" rel="nofollow" data-token="a0f9d37b73411f4b891d81fcb11d1237">一、理论知识</a></li>
    <ul>
     <li><a href="#1Hadoop_4" rel="nofollow" data-token="208f565939df648c15e2b8835f8ab965">1.Hadoop的整体印象</a></li>
     <li><a href="#2Hadoop_10" rel="nofollow" data-token="146406c9dfb689e3995df1b3732be786">2.Hadoop的优势</a></li>
     <li><a href="#3Hadoop_16" rel="nofollow" data-token="e6840601a4edb2167d05fed88aba17ba">3.Hadoop可以做什么</a></li>
     <li><a href="#4Hadoop_33" rel="nofollow" data-token="da6b5a89c3a945b69ab9257790fb46f8">4.Hadoop结构</a></li>
     <ul>
      <li><a href="#41_HadoopHDFS_35" rel="nofollow" data-token="180e883341cf2e8e9a7a3b59bad71fe0">4.1 Hadoop存储--HDFS</a></li>
      <li><a href="#42_HadoopMapReduce_69" rel="nofollow" data-token="a8379dcc3ae23f1219ab00864ccf9bab">4.2 Hadoop计算--MapReduce</a></li>
      <li><a href="#43_HadoopYARN_96" rel="nofollow" data-token="f48e243bb1bbc8e838e359e4ec04d388">4.3 Hadoop资源管理--YARN</a></li>
     </ul>
     <li><a href="#5Hadoop_115" rel="nofollow" data-token="599787fa73b14e1c1f1aa78e5f9251c3">5.Hadoop生态</a></li>
    </ul>
    <li><a href="#Hadoop_147" rel="nofollow" data-token="2c5fb0a2856321970f3a7fc696d441e9">二、Hadoop实际操作</a></li>
   </ul>
  </div>
  <br> 
  <b><font color="#D2691E" size="4" face="黑体">本文内容诸多借鉴，在借鉴处会表示出处，可在出处查看详情.</font></b>
  <p></p> 
  <h1><a id="_2"></a>一、理论知识</h1> 
  <p>参考<a href="https://blog.csdn.net/qq_32649581/article/details/82892861" rel="nofollow" data-token="d97224aa7640430da0290cdeb48499ca">Hadoop是什么，能干什么，怎么使用</a></p> 
  <h2><a id="1Hadoop_4"></a>1.Hadoop的整体印象</h2> 
  <p>一句话概括：<strong>Hadoop就是存储海量数据和分析海量数据的工具。</strong></p> 
  <ul> 
   <li>Hadoop是由java语言编写的，在分布式服务器集群上存储海量数据并运行分布式分析应用的开源框架，其核心部件是<strong>HDFS与MapReduce</strong>。</li> 
   <li>HDFS是一个分布式文件系统：引入存放文件元数据信息的服务器<strong>Namenode</strong>和实际存放数据的服务器<strong>Datanode</strong>，对数据进行分布式储存和读取。</li> 
   <li><strong>MapReduce是一个计算框架</strong>：MapReduce的核心思想是把计算任务分配给集群内的服务器里执行。通过对计算任务的拆分（Map计算/Reduce计算）再根据任务调度器（JobTracker）对任务进行分布式计算。</li> 
  </ul> 
  <h2><a id="2Hadoop_10"></a>2.Hadoop的优势</h2> 
  <ul> 
   <li>高可靠性 ： Hadoop 按位存储和处理数据的能力值得人们信赖。</li> 
   <li>高扩展性 ： Hadoop 是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以干计的节点中。</li> 
   <li>高效性 ： Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。</li> 
   <li>高容错性 ： Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分。</li> 
   <li>低成本 ： 与一体机、商用数据仓库以及 QlikView、 Yonghong Z- Suites 等数据集市相比，Hadoop 是开源的，项目的软件成本因此会大大降低。Hadoop 带有用 Java 语言编写的框架，因此运行在 linux 生产平台上是非常理想的， Hadoop 上的应用程序也可以使用其他语言编写，比如 C++。</li> 
  </ul> 
  <h2><a id="3Hadoop_16"></a>3.Hadoop可以做什么</h2> 
  <ul> 
   <li>可以大数据存储：分布式存储</li> 
   <li>日志处理：擅长日志分析</li> 
   <li>ETL:数据抽取到oracle、mysql、DB2、mongdb及主流数据库</li> 
   <li>机器学习: 比如Apache Mahout项目</li> 
   <li>搜索引擎:Hadoop + lucene实现</li> 
   <li>数据挖掘：<strong>目前比较流行的广告推荐，个性化广告推荐</strong></li> 
  </ul> 
  <p>Hadoop是专为离线和大规模数据分析而设计的，并不适合那种对几个记录随机读写的在线事务处理模式。</p> 
  <hr> 
  <p><b><font color="#D2691E" size="4" face="黑体">实际应用：</font></b></p> 
  <p>Flume+Logstash+Kafka+Spark Streaming进行实时日志处理分析<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731105300667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 酷狗音乐的大数据平台<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731105327261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <h2><a id="4Hadoop_33"></a>4.Hadoop结构</h2> 
  <p>参考<a href="https://www.cnblogs.com/binarylei/p/8903601.html" rel="nofollow" data-token="f3466d88ca0e7e2d8a9fc5c823008c03">Hadoop 系列（一）基本概念</a></p> 
  <h3><a id="41_HadoopHDFS_35"></a>4.1 Hadoop存储–HDFS</h3> 
  <p>Hadoop 的存储系统是 HDFS(Hadoop Distributed File System)分布式文件系统，对外部客户端而言，HDFS 就像一个传统的分级文件系统，可以进行<strong>创建、删除、移动或重命名文件或文件夹等操作</strong>，与 Linux 文件系统类似。<br> Hadoop HDFS 的架构是基于一组特定的<strong>节点</strong>构建的(见图s)，这些节<strong>名称节点</strong>(NameNode，仅一个)，它在 HDFS 内部提供元数据服务；<strong>第二名称节点</strong>(Secondary NameNode)，名称节点的帮助节点，主要是为了整合元数据操作(注意不是名称节点的备份)；<strong>数据节点(DataNode)</strong>，它为 HDFS 提供存储块。由于仅有一个 NameNode，因此这是 HDFS 的一个缺点(单点失败，在 Hadoop2.x 后有较大改善)。<strong>存储在 HDFS 中的文件被分成块，然后这些块被复制到多个数据节点中(DataNode)，这与传统的 RAID 架构大不相同。块的大小(通常为 128M)和复制的块数量在创建文件时由客户机决定。名称节点可以控制所有文件操作。HDFS 内部的所有通信都基于标准的 TCP/IP 协议。</strong></p> 
  <p><b><font color="#D2691E" size="3" face="黑体">（1）名称节点（NameNode）</font></b><br> 它是一个通常在HDFS架构中单独机器上运行的组件，<strong>负责管理文件系统名称空间和控制外部客户机的访问</strong>。NameNode决定是否将文件映射到DataNode上的复制块上。<strong>对于最常见的3个复制块，第一个复制块存储在同一机架的不同节点上，最后一个复制块存储在不同机架的某个节点上。</strong></p> 
  <p><b><font color="#D2691E" size="3" face="黑体">（2）数据节点（DataNode）</font></b><br> 数据节点也是一个通常在HDFS架构中的单独机器上运行的组件。<strong>Hadoop集群包含一个NameNode和大量DataNode。数据节点通常以机架的形式组织，机架通过一个交换机将所有系统连接起来。</strong></p> 
  <p><strong>数据节点响应来自HDFS客户机的读写请求。它们还响应来自NameNode的创建、删除和复制块的命令。名称节点依赖来自每个数据节点的定期心跳（heartbeat）消息。每条消息都包含一个块报告，名称节点可以根据这个报告验证块映射和其他文件系统元数据</strong>。如果数据节点不能发送心跳消息，名称节点将采取修复措施，重新复制在该节点上丢失的块。</p> 
  <p><b><font color="#D2691E" size="3" face="黑体">（3）第二名称节点（Secondary NameNode）</font></b><br> 第二名称节点的作用在于为HDFS中的名称节点提供一个Checkpoint，它只是名称节点的一个助手节点，这也是它在社区内被认为是Checkpoint Node的原因。</p> 
  <p>如下图所示，<strong>fsimage 是 NameNode 启动时对整个文件系统的快照；edits 是在 NameNode 启动后对文件系统的改动序列。</strong><br> 只有在NameNode重启时，edits才会合并到fsimage文件中，从而得到一个文件系统的最新快照。但是在生产环境集群中的NameNode是很少重启的，这意味着当NameNode运行很长时间后，edits文件会变得很大。而当NameNode宕机时，edits就会丢失很多改动。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731112000346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 如图 1-4 所示，Secondary NameNode 会定时到 NameNode 去获取名称节点的 edits，并及时更新到自己 fsimage 上。这样，如果 NameNode 宕机，我们也可以使用 Secondary-NameNode 的信息来恢复 NameNode。并且，如果 Secondary NameNode 新的 fsimage 文件达到一定阈值，它就会将其拷贝回名称节点上，这样 NameNode 在下次重启时会使用这个新的 fsimage 文件，从而减少重启的时间。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731112723138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 举个数据上传的例子来深入理解下HDFS内部是怎么做的。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731112813701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 文件在客户端时会被分块，这里可以看到文件被分为 5 个块，分别是：A、B、C、D、E。同时为了负载均衡，所以每个节点有 3 个块。下面来看看具体步骤：</p> 
  <ul> 
   <li>1.客户端将要上传的文件按 128M 的大小分块。</li> 
   <li>2.客户端向名称节点发送写数据请求。</li> 
   <li>3.名称节点记录各个 DataNode 信息，并返回可用的 DataNode 列表。</li> 
   <li>4.客户端直接向 DataNode 发送分割后的文件块，发送过程以流式写入。</li> 
   <li>5.写入完成后，DataNode 向 NameNode 发送消息，更新元数据。</li> 
  </ul> 
  <p><strong>这里需要注意：</strong></p> 
  <ul> 
   <li>1.写 1T 文件，需要 3T 的存储，3T 的网络流量。</li> 
   <li>2.在执行读或写的过程中，NameNode 和 DataNode 通过 HeartBeat 进行保存通信，确定 DataNode 活着。如果发现 DataNode 死掉了，就将死掉的 DataNode 上的数据，放到其他节点去，读取时，读其他节点。</li> 
   <li>3.宕掉一个节点没关系，还有其他节点可以备份；甚至，宕掉某一个机架也没关系；其他机架上也有备份。</li> 
  </ul> 
  <h3><a id="42_HadoopMapReduce_69"></a>4.2 Hadoop计算–MapReduce</h3> 
  <p>MapReduce用于大规模数据集（大于1TB）的并行运算。概念**“Map（映射）”<strong>和</strong>“Reduce（归纳）”**以及它们的主要思想，都是从函数式编程语言借来的，还有从矢量编程语言借来的特性。</p> 
  <p>当前的软件实现是指定一个 <strong>Map（映射）函数：用来把一组键值对映射成一组新的键值对</strong>。指定并发的 <strong>Reduce（归纳）函数，用来保证所有映射的键值对中的每一个共享相同的键组</strong>，如下图所示。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731113421579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 下面将以 Hadoop 的“Hello World”例程—单词计数来分析MapReduce的逻辑，如下图 所示。一般的 MapReduce 程序会经过以下几个过程：<strong>输入（Input）、输入分片（Splitting）、Map阶段、Shuffle阶段、Reduce阶段、输出（Final result）</strong>。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731113603277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <ul> 
   <li> <p>1.输入就不用说了，数据一般放在 HDFS 上面就可以了，而且文件是被分块的。关于文件块和文件分片的关系，在输入分片中说明。</p> </li> 
   <li> <p>2.输入分片：在进行 Map 阶段之前，MapReduce 框架会<strong>根据输入文件计算输入分片（split），每个输入分片会对应一个 Map 任务，输入分片往往和 HDFS 的块关系很密切</strong>。例如，HDFS 的块的大小是 128M，如果我们输入两个文件，大小分别是 27M、129M，那么 27M 的文件会作为一个输入分片（不足 128M 会被当作一个分片），而 129MB 则是两个输入分片（129-128＝1，不足 128M，所以 1M 也会被当作一个输入分片），所以，一般来说，一个文件块会对应一个分片。如图 1-7 所示，Splitting 对应下面的三个数据应该理解为三个分片。</p> </li> 
   <li> <p>3.Map 阶段：这个阶段的处理逻辑就是编写好的 <strong>Map 函数，因为一个分片对应一个 Map 任务，并且是对应一个文件块，所以这里其实是数据本地化的操作，也就是所谓的移动计算而不是移动数据</strong>。如图 1-7 所示，这里的操作其实就是把每句话进行分割，然后得到每个单词，再对每个单词进行映射，得到单词和1的键值对。</p> </li> 
   <li> <p>4.Shuffle 阶段：这是“奇迹”发生的地方，MapReduce 的核心其实就是 Shuffle。那么 Shuffle 的原理呢？<strong>Shuffle 就是将 Map 的输出进行整合，然后作为 Reduce 的输入发送给 Reduce。简单理解就是把所有 Map 的输出按照键进行排序，并且把相对键的键值对整合到同一个组中</strong>。如上图所示，Bear、Car、Deer、River 是排序的，并且 Bear 这个键有两个键值对。</p> </li> 
   <li> <p>5.Reduce 阶段：与 Map 类似，<strong>这里也是用户编写程序的地方，可以针对分组后的键值对进行处理</strong>。如上图所示，针对同一个键 Bear 的所有值进行了一个加法操作，得到 &lt;Bear，2&gt; 这样的键值对。</p> </li> 
   <li> <p>6.输出：Reduce 的输出直接写入 HDFS 上，<strong>同样这个输出文件也是分块的</strong>。</p> </li> 
  </ul> 
  <p>用一张图表示上述的运行流程：MapReduce 的本质就是把一组键值对 &lt;K1，V1&gt; 经过 <strong>Map 阶段映射</strong>成新的键值对 &lt;K2，V2&gt;；接着经过 <strong>Shuffle/Sort 阶段进行排序和“洗牌”，把键值对排序，同时把相同的键的值整合</strong>；最后经过 Reduce 阶段，<strong>把整合后的键值对组进行逻辑处理，输出到新的键值对 &lt;K3，V3&gt;</strong>。这样的一个过程，其实就是 MapReduce 的本质。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731114226324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> Hadoop MapReduce 可以根据其使用的资源管理框架不同，而分为 MR v1 和 YARN/MR v2 版本。<br> 在 <strong>MR v1 版本中，资源管理主要是 Jobtracker 和 TaskTracker</strong>。Jobtracker 主要负责：作业控制（作业分解和状态监控），主要是 MR 任务以及资源管理；而 TaskTracker 主要是调度 Job 的每一个子任务 task；并且接收 JobTracker 的命令。</p> 
  <p>在 <strong>YARN/MR v2 版本中，YARN 把 JobTracker 的工作分为两个部分</strong>：</p> 
  <ul> 
   <li><strong>ResourceManager 资源管理器</strong>全局管理所有应用程序计算资源的分配。</li> 
   <li><strong>ApplicationMaster 负责相应的调度和协调</strong>。<br> NodeManager 是每一台机器框架的代理，是执行应用程序的容器，监控应用程序的资源（CPU、内存、硬盘、网络）使用情况，并且向调度器汇报。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731114447657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li> 
  </ul> 
  <h3><a id="43_HadoopYARN_96"></a>4.3 Hadoop资源管理–YARN</h3> 
  <p>当 MapReduce 发展到 2.x 时就不使用 JobTracker 来作为自己的资源管理框架，而选择使用 YARN。这里需要说明的是，如果使用 JobTracker 来作为 Hadoop 集群的资源管理框架的话，<strong>那么除了 MapReduce 任务以外，不能够运行其他任务</strong>。也就是说，如果我们集群的 MapReduce 任务并没有那么饱满的话，集群资源等于是白白浪费的。所以提出了另外的一个资源管理架构 YARN（Yet Another Resource Manager）。这里需要注意，YARN 不是 JobTracker 的简单升级，而是“大换血”。同时 Hadoop 2.X 也包含了此架构。Apache Hadoop 2.X 项目包含以下模块。</p> 
  <ul> 
   <li>Hadoop Common：为 Hadoop 其他模块提供支持的基础模块。</li> 
   <li>HDFS：Hadoop：分布式文件系统。</li> 
   <li>YARN：任务分配和集群资源管理框架。</li> 
   <li>MapReduce：并行和可扩展的用于处理大数据的模式。<br> YARN 资源管理框架包括 ResourceManager（资源管理器）、ApplicationMaster、NodeManager（节点管理器）。各个组件描述如下。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731134424233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li> 
  </ul> 
  <p><strong>ResourceManager</strong> 是一个<strong>全局的资源管理器</strong>，负责整个系统的资源管理和分配。它主要由两个组件构成：<strong>调度器（Scheduler）和应用程序管理器（ApplicationManager，AM）</strong>。</p> 
  <ul> 
   <li>Scheduler 负责分配最少但满足 Application 运行所需的资源量给 Application。Scheduler 只是基于资源的使用情况进行调度，并不负责监视/跟踪 Application 的状态，当然也不会处理失败的 Task。</li> 
   <li>ApplicationManager <strong>负责处理客户端提交的 Job 以及协商第一个 Container 以供 ApplicationMaster 运行</strong>，并且在 ApplicationMaster 失败的时候会重新启动 ApplicationMaster（YARN 中使用 Resource Container 概念来管理集群的资源，<strong>Resource Container 是资源的抽象</strong>，每个 Container 包括一定的内存、IO、网络等资源）。</li> 
  </ul> 
  <p><strong>ApplicatonMaster</strong> 是一个框架特殊的库，每个 Application 有一个 ApplicationMaster，主要管理和监控部署在 YARN 集群上的各种应用。</p> 
  <p><strong>NodeManager主要负责启动 ResourceManager 分配给 ApplicationMaster 的 Container</strong>，并且会监视 Container 的运行情况。在启动 Container 的时候，NodeManager 会设置一些必要的环境变量以及相关文件；当所有准备工作做好后，才会启动该 Container。启动后，NodeManager 会周期性地监视该 Container 运行占用的资源情况，若是超过了该 Container 所声明的资源量，则会 kill 掉该 Container 所代表的进程。</p> 
  <p>如图 1-11 所示，该集群上有两个任务（对应 Node2、Node6 上面的 AM），并且 Node2 上面的任务运行有 4 个 Container 来执行任务；而 Node6 上面的任务则有 2 个 Container 来执行任务。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/201907311353161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <h2><a id="5Hadoop_115"></a>5.Hadoop生态</h2> 
  <p>Hadoop 的生态圈其实就是一群动物在狂欢。我们来看看一些主要的框架。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731135610659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <b><font color="#D2691E" size="5" face="黑体">Hbase</font></b><br> HBase（Hadoop Database）是一个<strong>高可靠性、高性能、面向列、可伸缩的分布式存储系统</strong>，利用 HBase 技术可在廉价 PC Server 上搭建起大规模结构化存储集群。</p> 
  <p><b><font color="#D2691E" size="5" face="黑体">Hive</font></b><br> Hive 是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行<strong>数据提取转化加载（ETL）</strong>，这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。</p> 
  <p><b><font color="#D2691E" size="5" face="黑体">Pig</font></b><br> Pig 是一个基于 Hadoop 的大规模数据分析平台，它提供的 SQL-LIKE 语言叫作 Pig Latin。该语言的编译器会把<strong>类 SQL 的数据分析请求转换为一系列经过优化处理的 Map-Reduce 运算</strong>。</p> 
  <p><b><font color="#D2691E" size="5" face="黑体">Sqoop</font></b><br> Sqoop 是一款开源的工具，主要用于在 <strong>Hadoop（Hive）与传统的数据库（MySQL、post-gresql等）间进行数据的传递</strong>，可以将一个关系型数据库中的数据导入 Hadoop 的 HDFS 中，也可以将 HDFS 的数据导入关系型数据库中，如下图所示。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731140208927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <p><b><font color="#D2691E" size="5" face="黑体">Flume</font></b><br> Flume 是 Cloudera 提供的一个高可用、高可靠、分布式的海量日志采集、聚合和传输的系统，Flume 支持在日志系统中定制各类数据发送方，用于收集数据。同时，Flume 提供对数据进行简单处理并写到各种数据接受方（可定制）的能力，如下图。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731140035932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU0ODEzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <b><font color="#D2691E" size="5" face="黑体">Oozie</font></b><br> Oozie 是基于 Hadoop 的调度器，以 XML 的形式写调度流程，可以调度 Mr、Pig、Hive、shell、jar 任务等。<br> 主要的功能如下。</p> 
  <ul> 
   <li>Workflow：顺序执行流程节点，支持 fork（分支多个节点）、join（将多个节点合并为一个）。</li> 
   <li>Coordinator：定时触发 Workflow。</li> 
   <li>Bundle Job：绑定多个 Coordinator。</li> 
  </ul> 
  <p><b><font color="#D2691E" size="5" face="黑体">Chukwa</font></b><br> Chukwa 是一个开源的、用于监控大型分布式系统的数据收集系统。它构建在 Hadoop 的 HDFS 和 MapReduce 框架上，继承了 Hadoop 的可伸缩性和鲁棒性。Chukwa 还包含了一个强大和灵活的工具集，可用于展示、监控和分析已收集的数据。<br> <b><font color="#D2691E" size="5" face="黑体">ZooKeeper</font></b><br> ZooKeeper 是一个开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件，如图 1-15 所示。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p> 
  <h1><a id="Hadoop_147"></a>二、Hadoop实际操作</h1> 
  <p>未完待续…</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e44c3c0e64.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
