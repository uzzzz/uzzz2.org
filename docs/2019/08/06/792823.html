<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Docker：慕课网–第一个docker化的java应用 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Docker：慕课网–第一个docker化的java应用" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Docker简介： Docker是一个使用Go语言开发的开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。Docker的发展速度和火爆程度着实令人惊叹，一发不可收拾，形成了席卷整个IT界的新浪潮。学完本课程你将了解到什么是docker，docker的思想以及诸如镜像，仓库，容器等核心概念。你将学会怎样运行一个容器，如何搭建私有仓库，怎么写dockerfile以及怎样把自己的应用放到容器中运行。docker将会是你的IT路上一笔不小的财富。 什么是 Docker Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于&nbsp;2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在&nbsp;GitHub&nbsp;上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动&nbsp;开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其&nbsp;GitHub 项目&nbsp;已经超过 5 万 2 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的&nbsp;Go 语言&nbsp;进行开发实现，基于 Linux 内核的&nbsp;cgroup，namespace，以及AUFS&nbsp;类的&nbsp;Union FS&nbsp;等技术，对进程进行封装隔离，属于&nbsp;操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于&nbsp;LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的&nbsp;libcontainer，从 1.11 开始，则进一步演进为使用&nbsp;runC&nbsp;和&nbsp;containerd。 Docker 架构 &nbsp; runc&nbsp;是一个 Linux 命令行工具，用于根据&nbsp;OCI容器运行时规范&nbsp;创建和运行容器。 containerd&nbsp;是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 下面的图片比较了 Docker 和传统虚拟化方式的不同之处。 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 &nbsp; 传统虚拟化 &nbsp; &nbsp; Docker &nbsp; 第1章 课程介绍 对docker有个简单的印象，了解课程的安排。 Docker 是一个开源的应用容器引擎,主要利用 linux 内核 namespace 实现沙盒隔离,用cgroup 实现资源限制。 Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker的基础是Linux的容器技术(LXC)。 而Docker,正是在容器的基础上进行了进一步的封装,让用户不需要去关心容器的管理,使得操作更为简便。用户操作Docker的容器就像操作一个快速轻量级的虚拟机一样简单。 VM是在硬件层面实现虚拟化 Docker几乎没有使用虚拟化的东西，直接复用了host主机的os，是内核级的虚拟化 docker优势: (1)Docker容器的启动可以在秒级实现,这相比传统的虚拟机方式要快得多。 (2)其次,Docker对系统资源的利用率很高,一台主机上可以同时运行数千个Docker容器。而且容器除了运行其中应用外,基本不消耗额外的系统资源,使得应用的性能很高,同时系统的开销尽量小。 &nbsp; 第2章 了解docker 用形象的类比说明docker的集装箱、标准化、隔离的思想。在用几个工作学习中碰到的问题说明docker解决了哪些问题。 Docker解决的问题 解决了运行环境不一致所带来的问题（它会将运行程序的相关配置，要求统一管理） 解决耗内存问题，Docker会一开始就为每个程序指定内存分配 让快速扩展，弹性伸缩变得简单 第3章 走进docker 结合上面的类比引出docker的核心技术：镜像、仓库和容器的概念，并分别深入讲解技术、原理。 一句话概括核心技术就是：去仓库把镜像拉到本地，然后用一条命令把镜像运行起来，把镜像变成容器。 Build：构建镜像 Ship：运输镜像 Run：运行镜像 Docker包括三个基本概念 镜像(Image)&nbsp;&nbsp;镜像就是一个只读的模板 容器(Container)&nbsp; 运行应用 仓库(Repository)&nbsp;&nbsp;集中存放镜像文件的场所,分为公有仓库和私有仓库2种形式 1.Docker镜像(集装箱) 构建镜像的目的：可以运行在其他环境中 镜像就是一系列的文件，它可以包括我们应用程序的文件，也可以包括应用环境的文件。 Docker会把这些文件保存到本地，存储方式采用Linux中的联合文件系统的分层概念方式。 镜像可以用来创建Docker容器的。 一个镜像可以包含一个完整的操作系统环境和用户需要的其它应用程序。 在docker hub 里面有大量现成的镜像提供下载。 docker的镜像是只可读的，一个镜像可以创建多个容器,每个容器之间相互不干扰。 &nbsp;示例存储方式见下图，由下往上分别是： 操作系统的引导 具体的Linux操作系统 相关软件：tomcat、jdk等 应用代码 顶层为可写层（属于容器） 2.Docker容器（运行程序之地） 容器的本质是一个进程，可以类同于虚拟机 Docker利用容器来开发、运行应用 容器是镜像创建的实例。它可以被启动、开始、停止、删除。每个容器都是 相互隔离的、保证安全的平台。 容器在运行过程中，如果要写一个镜像里面的文件：就需要将镜像里的文件拷贝到最上层，再进行修改；修改后，当我们应用读一个文件时，从上层开始读，上层没有才往下读； 3. Docker 仓库（超级码头） 仓库是集中存放镜像文件的场所。 每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 最大的公开仓库是DockerHub(https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。 国内：&nbsp;Docker - 国内镜像的配置及使用；https://c.163yun.com/hub#/m/library/ 当然，用户也可以在本地网络内创建一个私有仓库 第4章 docker安装 分别在三种平台上讲解docker的安装。同学可以选择自己的平台观看。 在centos和redhat上安装docker 1.前置条件 64-bit 系统 kernel 3.10+1.检查内核版本，返回的值大于3.10即可。 $ uname -r 2.使用 sudo 或 root 权限的用户登入终端。 3.卸载旧版本(如果安装过旧版本的话) $ yum remove docker \ docker-common \ docker-selinux \ docker-engine 4.安装需要的软件包 #yum-util提供yum-config-manager功能 #另外两个是devicemapper驱动依赖的 $ yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 5.设置yum源 $ yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 6.安装docker 6.1. 安装最新版本 $ yum install -y docker-ce 6.2. 安装指定版本 #查询版本列表 $ yum list docker-ce --showduplicates | sort -r 已加载插件：fastestmirror, langpacks 已安装的软件包 可安装的软件包 * updates: mirrors.163.com Loading mirror speeds from cached hostfile * extras: mirrors.163.com docker-ce.x86_64 17.09.1.ce-1.el7.centos docker-ce-stable docker-ce.x86_64 17.09.0.ce-1.el7.centos docker-ce-stable ... #指定版本安装(这里的例子是安装上面列表中的第二个) $ yum install -y docker-ce-17.09.0.ce 如果遇到，Docker安装指定版本异常：Error: Package: docker-ce-17.03.1.ce-1.el7.centos.x86_64 (docker-ce-stable) 请参考：https://blog.csdn.net/fly910905/article/details/97622433 7.启动docker $ systemctl start docker.service 7.验证安装是否成功(有client和service两部分表示docker安装启动都成功了) $ docker version Client: Version: 17.09.0-ce API version: 1.32 Go version: go1.8.3 Git commit: afdb6d4 Built: Tue Sep 26 22:41:23 2017 OS/Arch: linux/amd64 Server: Version: 17.09.0-ce API version: 1.32 (minimum version 1.12) Go version: go1.8.3 Git commit: afdb6d4 Built: Tue Sep 26 22:42:49 2017 OS/Arch: linux/amd64 Experimental: false &nbsp; 第5章 docker初体验 &nbsp; 第一个实例：用helloworld镜像带入，熟悉docker最基本的两个命令，拉取镜像和运行容器，并讲解背后运行逻辑。 第一个docker镜像 docker pull [OPTIONS] NAME[:TAG] 解释：拉取镜像，也就是从docker远程仓库拉去一个镜像到本地， 其中:TAG是可选的（指定版本），OPTIONS为拉取时的一些参数。 docker images [OPTIONS] [REPOSITOR[:TAG]] 解释：查看本机镜像，也可以验证上面的pull是否成功。 REPOSITOR表示镜像名称，:TAG表示版本。 第一个docker容器 docker run [OPTIONS] IMAGE[:TAG][COMMAND][ARG…] 解释：运行镜像，OPTIONS、:TAG同上， COMMAND表示这个IMAGE镜像运行起来后要执行的命令，ARG表示要执行的命令所依赖的参数。 &nbsp; 上图共分为三部分，从左至右分别为 Client、Host、Registry。前两个属于本机，Registry在hello-world例子中相当于远程仓库，整个流程为： docker pull 过程 &nbsp; 先向 docker daemon（在Host中）发送拉取镜像请求 daemon先在本机查找是否由符合版本要求的镜像，如果有，则不会做其他操作； 没有的话，daemon就去 Registry中查找，Registry返回相应镜像到本地。 docker run 过程 &nbsp; 先向 docker daemon发送请求，镜像不存在则再执行一次 docker pull过程。 然后通过一定方式把镜象变成容器 第6章 docker运行nginx静态网站 第二个实例：从运行nginx镜像引出docker网络概念和docker的端口映射，最后运行nginx容器。 &nbsp;&nbsp;实践前奏 ngnix为持久运行的容器（不同于 hello-world） 前台挂起&amp;后台运行（前台运行的话，ctrl+c 即可结束进程，所以最好后台） 进入容器内部，观察容器特征 1. 拉取nginx镜像 docker pull hub.c.163.com/library/nginx:latest 终端执行docker images,可以看到nginx镜像拉取成功 &nbsp;2 运行nginx镜像 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前端运行nginx镜像+关闭镜像方法 执行 docker run hub.c.163.com/library/nginx:latest&nbsp;&nbsp;语句，会发现没有任何响应。 另开一个窗口 执行 docker ps语句，该语句会显示正在运行的镜像 &nbsp; 因为nginx 此时是在前端运行，所以会出现docker run，没有任何响应。 执行 docker kill 779ab2962a80关闭前端运行nginx镜像这个进程。（779ab2962a80*为上图中的容器ID，也可以用 容器名替代） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 后台运行nginx镜像+进入容器内部 执行 docker run -d hub.c.163.com/library/nginx ，在后台运行该镜像，返回的值为容器的ID。 进入容器内部的命令为 docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 解释： 在一个正在运行的容器中执行一条命令。 OPTIONS为执行的参数（可以通过执行 docker exec --help查看） CONTAINER 为容器名， COMMAND [ARG…]为命令名以及参数 执行 docker exec -it f4&nbsp;bash 解释：-it为上图的 -i、-t的缩写，f4为容器ID的简写（因为现在在本机上的容器很少，通过23f就足以查找容器），bash为终端命令 上图表明已经进入了 nginx 所在的linux终端，就可以执行相关的Linux命令了。 执行完相关 Linux命令后，执行exit退出容器 3 Docker网络 网络类型 Bridge（默认） bridge模式是Docker默认的网络设置，此模式会为每一个容器 分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。 Bridge模式：首先创建一个docker0网桥，这个网桥和主机的eth0网卡相连；在启动容器时，容器这边则会产生一个虚拟网卡，也和网桥相连。这种模式下，容器会有自己独立的IP和端口。 &nbsp; (1) 利用 veth pair 技术,在宿主机上创建两个虚拟网络接口设备,假设为veth0 和 veth1。而 veth pair 技术的特性可以保证无论哪一个 veth 接收到网络报文,都会将报文传输给另一方 (2) 将 veth0 附加到docker0 网桥上。保证宿主机的网络报文可以发往 veth0 (3) 将 veth1 添加到容器所属的 namespace 下,并被改名为 eth0。 如此一来,保证宿主机的网络报文若发往 veth0,则立即会被 eth0 接收,实现宿主机到容器网络的联通性;同时,也保证 容器单独使用 eth0,实现容器网络环境的隔离性。 缺点：和宿主机以外的网络通信比较困难 &nbsp; Host 不会创建独立的network namespace。Docker容器中的进程处于宿主机的网络环境中，相当于Docker容器和宿主机共同用一个network namespace，使用宿主机的网卡、IP和端口等信息。 但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。 缺点：容器不再拥有隔离、独立的网络栈，会和宿主机发生资源抢夺 Host模式：容器直接连接主机的网卡eth0，两者使用同一网卡，看到的网络环境一样。 None 没有网络，Docker不会和外界进行通讯。Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。 &nbsp; Container Container模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。 新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。 同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。 (1) 查找其他容器(即需要被共享网络环境的容器)的网络 (2) 将新创建的容器(也是需要共享其他网络的容器)的namespace,使用其他容器的namespace。 可以用来更好的服务于容器间的通信。可以通过 localhost 来访问 namespace 下的其他容器,传输效率较高。虽然多个容器共享网络环境,但是多个容器形成的整体依然与宿主机以及其他容器形成网络隔离。另外,这种模式还节约了一定数量的网络资源。 缺点：它并没有改善容器与宿主机以外世界通信的情况。 端口映射 使容器的端口在主机上访问到，采用端口映射，Docker可以将容器里面的端口与主机的端口进行映射，这样就可以通过访问主机端口去访问容器端口。 执行 docker run -d -p 8080:80 hub.c.163.com/library/nginx 运行Nginx镜像，如下图 解释：-d表示后台运行，-p为端口设置，8080为本机端口，80为Nginx容器开放的端口，hub.c.163.com/library/nginx为容器名。 注意：完成上面步骤后，浏览器访问 localhost：32768，会发现访问不到，我们需要 找到Window系统下的Linux环境的地址 docker-machine ip default，找到Window系统下的Linux环境的地址 另记：上面语句中的-p替代为-P，Docker 会随机映射一个&nbsp; 的端口到内部容器开放的网络端口。然后使用docker ps 可以查看映射的端口号。 第7章 第一个java web应用 最后一个实例：创建自己的镜像，引出dockerfile，讲解基本的dockerfile语法。然后讲解私有仓库的搭建。最后分别在两台机器上演示docker的跨平台运行我们的java web项目。 Docker运行MySql 执行&nbsp;docker pull hub.c.163.com/library/mysql:latest，拉取mysql镜像，然后执行docker images查看本地镜像 终端执行docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=000000 -e MYSQL_DATABASE=jpress hub.c.163.com/library/mysql:latest，运行mysql镜像并创建数据库jpress 命令解释详见：library /mysql 完整步骤 1、下载mysql镜像 &nbsp; 下载mysql镜像，找到镜像，之后执行 docker pull hub.c.163.com/library/mysql:latest ，之后我们重命名下这个镜像，不然名字太长了，执行 docker tag hub.c.163.com/library/mysql:latest mysql:5.7 ，之后执行 docker images ，应该可以看到变化了。 2、运行镜像 &nbsp; &nbsp; &nbsp;执行 docker &nbsp;run &nbsp;-d --name &nbsp;mysql5.7container &nbsp;-p &nbsp;3306:3306 &nbsp;-e &nbsp;MYSQL_ROOT_PASSWORD=123 &nbsp;mysql:5.7 ，注意：123是root用户的密码。之后执行 docker ps -a ，就会看到全部的容器了，可以看到一个名为mysql5.7container的容器。 3、远程连接 &nbsp; &nbsp; 之后用navicat进行远程连接，ip地址填宿主主机(即运行者docker的linux)的ip地址，用户名是root，密码是123. 拉取tomcat镜像 docker pull hub.c.163.com/library/tomcat:latest拉取tomcat镜像（tomcat镜像会包括jdk镜像）,然后docker images查看本机镜像，tomcat镜像名为hub.c.163.com/library/tomcat&nbsp; 编写Dockerfile文件 输入from hub.c.163.com/library/tomcat，这句话表明我要制作的镜像以tomcat的镜像为起点，其中hub.c.163.com/library/tomcat为tomcat的镜像名。 MAINTAINER&nbsp;为自己的一些信息（可以不写）。 输入COPY jpress-web-newest.war /usr/local/tomcat/webapps，将web应用拷贝到tomcat的webapps下，其中/usr/local/tomcat来tomcat的安装目录，jpress-web-newest.war是需要部署的javaWeb程序 执行Docker Build命令 docker build -t jpress:latest . 注意最后面有“.”，表示当前目录 解释：&nbsp;-t表示为创建镜像的参数 ，jpress为镜像名称，latest为镜像版本。 运行镜像 docker run -d -p 8888:8080 jpress,运行容器，其中，本机端口号为8888，jpress开放的端口号为8080 注意：怎么查看tomcat中应用程序的名字？ 进入到 jpress镜像内部，docker exec -it 60 bash，其中，60为运行镜像时返回的ID，会发现直接跳转到了 Dockerfile文件中配置的 tomcat目录下 cd webapps下，然后输入ls展示所有文件，这里就可以看到应用程序的名字了 &nbsp; 参考链接：https://www.imooc.com/learn/824 参考链接：https://www.imooc.com/article/16448 &nbsp;" />
<meta property="og:description" content="Docker简介： Docker是一个使用Go语言开发的开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。Docker的发展速度和火爆程度着实令人惊叹，一发不可收拾，形成了席卷整个IT界的新浪潮。学完本课程你将了解到什么是docker，docker的思想以及诸如镜像，仓库，容器等核心概念。你将学会怎样运行一个容器，如何搭建私有仓库，怎么写dockerfile以及怎样把自己的应用放到容器中运行。docker将会是你的IT路上一笔不小的财富。 什么是 Docker Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于&nbsp;2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在&nbsp;GitHub&nbsp;上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动&nbsp;开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其&nbsp;GitHub 项目&nbsp;已经超过 5 万 2 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的&nbsp;Go 语言&nbsp;进行开发实现，基于 Linux 内核的&nbsp;cgroup，namespace，以及AUFS&nbsp;类的&nbsp;Union FS&nbsp;等技术，对进程进行封装隔离，属于&nbsp;操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于&nbsp;LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的&nbsp;libcontainer，从 1.11 开始，则进一步演进为使用&nbsp;runC&nbsp;和&nbsp;containerd。 Docker 架构 &nbsp; runc&nbsp;是一个 Linux 命令行工具，用于根据&nbsp;OCI容器运行时规范&nbsp;创建和运行容器。 containerd&nbsp;是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 下面的图片比较了 Docker 和传统虚拟化方式的不同之处。 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 &nbsp; 传统虚拟化 &nbsp; &nbsp; Docker &nbsp; 第1章 课程介绍 对docker有个简单的印象，了解课程的安排。 Docker 是一个开源的应用容器引擎,主要利用 linux 内核 namespace 实现沙盒隔离,用cgroup 实现资源限制。 Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker的基础是Linux的容器技术(LXC)。 而Docker,正是在容器的基础上进行了进一步的封装,让用户不需要去关心容器的管理,使得操作更为简便。用户操作Docker的容器就像操作一个快速轻量级的虚拟机一样简单。 VM是在硬件层面实现虚拟化 Docker几乎没有使用虚拟化的东西，直接复用了host主机的os，是内核级的虚拟化 docker优势: (1)Docker容器的启动可以在秒级实现,这相比传统的虚拟机方式要快得多。 (2)其次,Docker对系统资源的利用率很高,一台主机上可以同时运行数千个Docker容器。而且容器除了运行其中应用外,基本不消耗额外的系统资源,使得应用的性能很高,同时系统的开销尽量小。 &nbsp; 第2章 了解docker 用形象的类比说明docker的集装箱、标准化、隔离的思想。在用几个工作学习中碰到的问题说明docker解决了哪些问题。 Docker解决的问题 解决了运行环境不一致所带来的问题（它会将运行程序的相关配置，要求统一管理） 解决耗内存问题，Docker会一开始就为每个程序指定内存分配 让快速扩展，弹性伸缩变得简单 第3章 走进docker 结合上面的类比引出docker的核心技术：镜像、仓库和容器的概念，并分别深入讲解技术、原理。 一句话概括核心技术就是：去仓库把镜像拉到本地，然后用一条命令把镜像运行起来，把镜像变成容器。 Build：构建镜像 Ship：运输镜像 Run：运行镜像 Docker包括三个基本概念 镜像(Image)&nbsp;&nbsp;镜像就是一个只读的模板 容器(Container)&nbsp; 运行应用 仓库(Repository)&nbsp;&nbsp;集中存放镜像文件的场所,分为公有仓库和私有仓库2种形式 1.Docker镜像(集装箱) 构建镜像的目的：可以运行在其他环境中 镜像就是一系列的文件，它可以包括我们应用程序的文件，也可以包括应用环境的文件。 Docker会把这些文件保存到本地，存储方式采用Linux中的联合文件系统的分层概念方式。 镜像可以用来创建Docker容器的。 一个镜像可以包含一个完整的操作系统环境和用户需要的其它应用程序。 在docker hub 里面有大量现成的镜像提供下载。 docker的镜像是只可读的，一个镜像可以创建多个容器,每个容器之间相互不干扰。 &nbsp;示例存储方式见下图，由下往上分别是： 操作系统的引导 具体的Linux操作系统 相关软件：tomcat、jdk等 应用代码 顶层为可写层（属于容器） 2.Docker容器（运行程序之地） 容器的本质是一个进程，可以类同于虚拟机 Docker利用容器来开发、运行应用 容器是镜像创建的实例。它可以被启动、开始、停止、删除。每个容器都是 相互隔离的、保证安全的平台。 容器在运行过程中，如果要写一个镜像里面的文件：就需要将镜像里的文件拷贝到最上层，再进行修改；修改后，当我们应用读一个文件时，从上层开始读，上层没有才往下读； 3. Docker 仓库（超级码头） 仓库是集中存放镜像文件的场所。 每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 最大的公开仓库是DockerHub(https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。 国内：&nbsp;Docker - 国内镜像的配置及使用；https://c.163yun.com/hub#/m/library/ 当然，用户也可以在本地网络内创建一个私有仓库 第4章 docker安装 分别在三种平台上讲解docker的安装。同学可以选择自己的平台观看。 在centos和redhat上安装docker 1.前置条件 64-bit 系统 kernel 3.10+1.检查内核版本，返回的值大于3.10即可。 $ uname -r 2.使用 sudo 或 root 权限的用户登入终端。 3.卸载旧版本(如果安装过旧版本的话) $ yum remove docker \ docker-common \ docker-selinux \ docker-engine 4.安装需要的软件包 #yum-util提供yum-config-manager功能 #另外两个是devicemapper驱动依赖的 $ yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 5.设置yum源 $ yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 6.安装docker 6.1. 安装最新版本 $ yum install -y docker-ce 6.2. 安装指定版本 #查询版本列表 $ yum list docker-ce --showduplicates | sort -r 已加载插件：fastestmirror, langpacks 已安装的软件包 可安装的软件包 * updates: mirrors.163.com Loading mirror speeds from cached hostfile * extras: mirrors.163.com docker-ce.x86_64 17.09.1.ce-1.el7.centos docker-ce-stable docker-ce.x86_64 17.09.0.ce-1.el7.centos docker-ce-stable ... #指定版本安装(这里的例子是安装上面列表中的第二个) $ yum install -y docker-ce-17.09.0.ce 如果遇到，Docker安装指定版本异常：Error: Package: docker-ce-17.03.1.ce-1.el7.centos.x86_64 (docker-ce-stable) 请参考：https://blog.csdn.net/fly910905/article/details/97622433 7.启动docker $ systemctl start docker.service 7.验证安装是否成功(有client和service两部分表示docker安装启动都成功了) $ docker version Client: Version: 17.09.0-ce API version: 1.32 Go version: go1.8.3 Git commit: afdb6d4 Built: Tue Sep 26 22:41:23 2017 OS/Arch: linux/amd64 Server: Version: 17.09.0-ce API version: 1.32 (minimum version 1.12) Go version: go1.8.3 Git commit: afdb6d4 Built: Tue Sep 26 22:42:49 2017 OS/Arch: linux/amd64 Experimental: false &nbsp; 第5章 docker初体验 &nbsp; 第一个实例：用helloworld镜像带入，熟悉docker最基本的两个命令，拉取镜像和运行容器，并讲解背后运行逻辑。 第一个docker镜像 docker pull [OPTIONS] NAME[:TAG] 解释：拉取镜像，也就是从docker远程仓库拉去一个镜像到本地， 其中:TAG是可选的（指定版本），OPTIONS为拉取时的一些参数。 docker images [OPTIONS] [REPOSITOR[:TAG]] 解释：查看本机镜像，也可以验证上面的pull是否成功。 REPOSITOR表示镜像名称，:TAG表示版本。 第一个docker容器 docker run [OPTIONS] IMAGE[:TAG][COMMAND][ARG…] 解释：运行镜像，OPTIONS、:TAG同上， COMMAND表示这个IMAGE镜像运行起来后要执行的命令，ARG表示要执行的命令所依赖的参数。 &nbsp; 上图共分为三部分，从左至右分别为 Client、Host、Registry。前两个属于本机，Registry在hello-world例子中相当于远程仓库，整个流程为： docker pull 过程 &nbsp; 先向 docker daemon（在Host中）发送拉取镜像请求 daemon先在本机查找是否由符合版本要求的镜像，如果有，则不会做其他操作； 没有的话，daemon就去 Registry中查找，Registry返回相应镜像到本地。 docker run 过程 &nbsp; 先向 docker daemon发送请求，镜像不存在则再执行一次 docker pull过程。 然后通过一定方式把镜象变成容器 第6章 docker运行nginx静态网站 第二个实例：从运行nginx镜像引出docker网络概念和docker的端口映射，最后运行nginx容器。 &nbsp;&nbsp;实践前奏 ngnix为持久运行的容器（不同于 hello-world） 前台挂起&amp;后台运行（前台运行的话，ctrl+c 即可结束进程，所以最好后台） 进入容器内部，观察容器特征 1. 拉取nginx镜像 docker pull hub.c.163.com/library/nginx:latest 终端执行docker images,可以看到nginx镜像拉取成功 &nbsp;2 运行nginx镜像 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前端运行nginx镜像+关闭镜像方法 执行 docker run hub.c.163.com/library/nginx:latest&nbsp;&nbsp;语句，会发现没有任何响应。 另开一个窗口 执行 docker ps语句，该语句会显示正在运行的镜像 &nbsp; 因为nginx 此时是在前端运行，所以会出现docker run，没有任何响应。 执行 docker kill 779ab2962a80关闭前端运行nginx镜像这个进程。（779ab2962a80*为上图中的容器ID，也可以用 容器名替代） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 后台运行nginx镜像+进入容器内部 执行 docker run -d hub.c.163.com/library/nginx ，在后台运行该镜像，返回的值为容器的ID。 进入容器内部的命令为 docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 解释： 在一个正在运行的容器中执行一条命令。 OPTIONS为执行的参数（可以通过执行 docker exec --help查看） CONTAINER 为容器名， COMMAND [ARG…]为命令名以及参数 执行 docker exec -it f4&nbsp;bash 解释：-it为上图的 -i、-t的缩写，f4为容器ID的简写（因为现在在本机上的容器很少，通过23f就足以查找容器），bash为终端命令 上图表明已经进入了 nginx 所在的linux终端，就可以执行相关的Linux命令了。 执行完相关 Linux命令后，执行exit退出容器 3 Docker网络 网络类型 Bridge（默认） bridge模式是Docker默认的网络设置，此模式会为每一个容器 分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。 Bridge模式：首先创建一个docker0网桥，这个网桥和主机的eth0网卡相连；在启动容器时，容器这边则会产生一个虚拟网卡，也和网桥相连。这种模式下，容器会有自己独立的IP和端口。 &nbsp; (1) 利用 veth pair 技术,在宿主机上创建两个虚拟网络接口设备,假设为veth0 和 veth1。而 veth pair 技术的特性可以保证无论哪一个 veth 接收到网络报文,都会将报文传输给另一方 (2) 将 veth0 附加到docker0 网桥上。保证宿主机的网络报文可以发往 veth0 (3) 将 veth1 添加到容器所属的 namespace 下,并被改名为 eth0。 如此一来,保证宿主机的网络报文若发往 veth0,则立即会被 eth0 接收,实现宿主机到容器网络的联通性;同时,也保证 容器单独使用 eth0,实现容器网络环境的隔离性。 缺点：和宿主机以外的网络通信比较困难 &nbsp; Host 不会创建独立的network namespace。Docker容器中的进程处于宿主机的网络环境中，相当于Docker容器和宿主机共同用一个network namespace，使用宿主机的网卡、IP和端口等信息。 但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。 缺点：容器不再拥有隔离、独立的网络栈，会和宿主机发生资源抢夺 Host模式：容器直接连接主机的网卡eth0，两者使用同一网卡，看到的网络环境一样。 None 没有网络，Docker不会和外界进行通讯。Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。 &nbsp; Container Container模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。 新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。 同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。 (1) 查找其他容器(即需要被共享网络环境的容器)的网络 (2) 将新创建的容器(也是需要共享其他网络的容器)的namespace,使用其他容器的namespace。 可以用来更好的服务于容器间的通信。可以通过 localhost 来访问 namespace 下的其他容器,传输效率较高。虽然多个容器共享网络环境,但是多个容器形成的整体依然与宿主机以及其他容器形成网络隔离。另外,这种模式还节约了一定数量的网络资源。 缺点：它并没有改善容器与宿主机以外世界通信的情况。 端口映射 使容器的端口在主机上访问到，采用端口映射，Docker可以将容器里面的端口与主机的端口进行映射，这样就可以通过访问主机端口去访问容器端口。 执行 docker run -d -p 8080:80 hub.c.163.com/library/nginx 运行Nginx镜像，如下图 解释：-d表示后台运行，-p为端口设置，8080为本机端口，80为Nginx容器开放的端口，hub.c.163.com/library/nginx为容器名。 注意：完成上面步骤后，浏览器访问 localhost：32768，会发现访问不到，我们需要 找到Window系统下的Linux环境的地址 docker-machine ip default，找到Window系统下的Linux环境的地址 另记：上面语句中的-p替代为-P，Docker 会随机映射一个&nbsp; 的端口到内部容器开放的网络端口。然后使用docker ps 可以查看映射的端口号。 第7章 第一个java web应用 最后一个实例：创建自己的镜像，引出dockerfile，讲解基本的dockerfile语法。然后讲解私有仓库的搭建。最后分别在两台机器上演示docker的跨平台运行我们的java web项目。 Docker运行MySql 执行&nbsp;docker pull hub.c.163.com/library/mysql:latest，拉取mysql镜像，然后执行docker images查看本地镜像 终端执行docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=000000 -e MYSQL_DATABASE=jpress hub.c.163.com/library/mysql:latest，运行mysql镜像并创建数据库jpress 命令解释详见：library /mysql 完整步骤 1、下载mysql镜像 &nbsp; 下载mysql镜像，找到镜像，之后执行 docker pull hub.c.163.com/library/mysql:latest ，之后我们重命名下这个镜像，不然名字太长了，执行 docker tag hub.c.163.com/library/mysql:latest mysql:5.7 ，之后执行 docker images ，应该可以看到变化了。 2、运行镜像 &nbsp; &nbsp; &nbsp;执行 docker &nbsp;run &nbsp;-d --name &nbsp;mysql5.7container &nbsp;-p &nbsp;3306:3306 &nbsp;-e &nbsp;MYSQL_ROOT_PASSWORD=123 &nbsp;mysql:5.7 ，注意：123是root用户的密码。之后执行 docker ps -a ，就会看到全部的容器了，可以看到一个名为mysql5.7container的容器。 3、远程连接 &nbsp; &nbsp; 之后用navicat进行远程连接，ip地址填宿主主机(即运行者docker的linux)的ip地址，用户名是root，密码是123. 拉取tomcat镜像 docker pull hub.c.163.com/library/tomcat:latest拉取tomcat镜像（tomcat镜像会包括jdk镜像）,然后docker images查看本机镜像，tomcat镜像名为hub.c.163.com/library/tomcat&nbsp; 编写Dockerfile文件 输入from hub.c.163.com/library/tomcat，这句话表明我要制作的镜像以tomcat的镜像为起点，其中hub.c.163.com/library/tomcat为tomcat的镜像名。 MAINTAINER&nbsp;为自己的一些信息（可以不写）。 输入COPY jpress-web-newest.war /usr/local/tomcat/webapps，将web应用拷贝到tomcat的webapps下，其中/usr/local/tomcat来tomcat的安装目录，jpress-web-newest.war是需要部署的javaWeb程序 执行Docker Build命令 docker build -t jpress:latest . 注意最后面有“.”，表示当前目录 解释：&nbsp;-t表示为创建镜像的参数 ，jpress为镜像名称，latest为镜像版本。 运行镜像 docker run -d -p 8888:8080 jpress,运行容器，其中，本机端口号为8888，jpress开放的端口号为8080 注意：怎么查看tomcat中应用程序的名字？ 进入到 jpress镜像内部，docker exec -it 60 bash，其中，60为运行镜像时返回的ID，会发现直接跳转到了 Dockerfile文件中配置的 tomcat目录下 cd webapps下，然后输入ls展示所有文件，这里就可以看到应用程序的名字了 &nbsp; 参考链接：https://www.imooc.com/learn/824 参考链接：https://www.imooc.com/article/16448 &nbsp;" />
<link rel="canonical" href="https://uzzz.org/2019/08/06/792823.html" />
<meta property="og:url" content="https://uzzz.org/2019/08/06/792823.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Docker简介： Docker是一个使用Go语言开发的开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。Docker的发展速度和火爆程度着实令人惊叹，一发不可收拾，形成了席卷整个IT界的新浪潮。学完本课程你将了解到什么是docker，docker的思想以及诸如镜像，仓库，容器等核心概念。你将学会怎样运行一个容器，如何搭建私有仓库，怎么写dockerfile以及怎样把自己的应用放到容器中运行。docker将会是你的IT路上一笔不小的财富。 什么是 Docker Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于&nbsp;2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在&nbsp;GitHub&nbsp;上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动&nbsp;开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其&nbsp;GitHub 项目&nbsp;已经超过 5 万 2 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的&nbsp;Go 语言&nbsp;进行开发实现，基于 Linux 内核的&nbsp;cgroup，namespace，以及AUFS&nbsp;类的&nbsp;Union FS&nbsp;等技术，对进程进行封装隔离，属于&nbsp;操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于&nbsp;LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的&nbsp;libcontainer，从 1.11 开始，则进一步演进为使用&nbsp;runC&nbsp;和&nbsp;containerd。 Docker 架构 &nbsp; runc&nbsp;是一个 Linux 命令行工具，用于根据&nbsp;OCI容器运行时规范&nbsp;创建和运行容器。 containerd&nbsp;是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 下面的图片比较了 Docker 和传统虚拟化方式的不同之处。 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 &nbsp; 传统虚拟化 &nbsp; &nbsp; Docker &nbsp; 第1章 课程介绍 对docker有个简单的印象，了解课程的安排。 Docker 是一个开源的应用容器引擎,主要利用 linux 内核 namespace 实现沙盒隔离,用cgroup 实现资源限制。 Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker的基础是Linux的容器技术(LXC)。 而Docker,正是在容器的基础上进行了进一步的封装,让用户不需要去关心容器的管理,使得操作更为简便。用户操作Docker的容器就像操作一个快速轻量级的虚拟机一样简单。 VM是在硬件层面实现虚拟化 Docker几乎没有使用虚拟化的东西，直接复用了host主机的os，是内核级的虚拟化 docker优势: (1)Docker容器的启动可以在秒级实现,这相比传统的虚拟机方式要快得多。 (2)其次,Docker对系统资源的利用率很高,一台主机上可以同时运行数千个Docker容器。而且容器除了运行其中应用外,基本不消耗额外的系统资源,使得应用的性能很高,同时系统的开销尽量小。 &nbsp; 第2章 了解docker 用形象的类比说明docker的集装箱、标准化、隔离的思想。在用几个工作学习中碰到的问题说明docker解决了哪些问题。 Docker解决的问题 解决了运行环境不一致所带来的问题（它会将运行程序的相关配置，要求统一管理） 解决耗内存问题，Docker会一开始就为每个程序指定内存分配 让快速扩展，弹性伸缩变得简单 第3章 走进docker 结合上面的类比引出docker的核心技术：镜像、仓库和容器的概念，并分别深入讲解技术、原理。 一句话概括核心技术就是：去仓库把镜像拉到本地，然后用一条命令把镜像运行起来，把镜像变成容器。 Build：构建镜像 Ship：运输镜像 Run：运行镜像 Docker包括三个基本概念 镜像(Image)&nbsp;&nbsp;镜像就是一个只读的模板 容器(Container)&nbsp; 运行应用 仓库(Repository)&nbsp;&nbsp;集中存放镜像文件的场所,分为公有仓库和私有仓库2种形式 1.Docker镜像(集装箱) 构建镜像的目的：可以运行在其他环境中 镜像就是一系列的文件，它可以包括我们应用程序的文件，也可以包括应用环境的文件。 Docker会把这些文件保存到本地，存储方式采用Linux中的联合文件系统的分层概念方式。 镜像可以用来创建Docker容器的。 一个镜像可以包含一个完整的操作系统环境和用户需要的其它应用程序。 在docker hub 里面有大量现成的镜像提供下载。 docker的镜像是只可读的，一个镜像可以创建多个容器,每个容器之间相互不干扰。 &nbsp;示例存储方式见下图，由下往上分别是： 操作系统的引导 具体的Linux操作系统 相关软件：tomcat、jdk等 应用代码 顶层为可写层（属于容器） 2.Docker容器（运行程序之地） 容器的本质是一个进程，可以类同于虚拟机 Docker利用容器来开发、运行应用 容器是镜像创建的实例。它可以被启动、开始、停止、删除。每个容器都是 相互隔离的、保证安全的平台。 容器在运行过程中，如果要写一个镜像里面的文件：就需要将镜像里的文件拷贝到最上层，再进行修改；修改后，当我们应用读一个文件时，从上层开始读，上层没有才往下读； 3. Docker 仓库（超级码头） 仓库是集中存放镜像文件的场所。 每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 最大的公开仓库是DockerHub(https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。 国内：&nbsp;Docker - 国内镜像的配置及使用；https://c.163yun.com/hub#/m/library/ 当然，用户也可以在本地网络内创建一个私有仓库 第4章 docker安装 分别在三种平台上讲解docker的安装。同学可以选择自己的平台观看。 在centos和redhat上安装docker 1.前置条件 64-bit 系统 kernel 3.10+1.检查内核版本，返回的值大于3.10即可。 $ uname -r 2.使用 sudo 或 root 权限的用户登入终端。 3.卸载旧版本(如果安装过旧版本的话) $ yum remove docker \\ docker-common \\ docker-selinux \\ docker-engine 4.安装需要的软件包 #yum-util提供yum-config-manager功能 #另外两个是devicemapper驱动依赖的 $ yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 5.设置yum源 $ yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 6.安装docker 6.1. 安装最新版本 $ yum install -y docker-ce 6.2. 安装指定版本 #查询版本列表 $ yum list docker-ce --showduplicates | sort -r 已加载插件：fastestmirror, langpacks 已安装的软件包 可安装的软件包 * updates: mirrors.163.com Loading mirror speeds from cached hostfile * extras: mirrors.163.com docker-ce.x86_64 17.09.1.ce-1.el7.centos docker-ce-stable docker-ce.x86_64 17.09.0.ce-1.el7.centos docker-ce-stable ... #指定版本安装(这里的例子是安装上面列表中的第二个) $ yum install -y docker-ce-17.09.0.ce 如果遇到，Docker安装指定版本异常：Error: Package: docker-ce-17.03.1.ce-1.el7.centos.x86_64 (docker-ce-stable) 请参考：https://blog.csdn.net/fly910905/article/details/97622433 7.启动docker $ systemctl start docker.service 7.验证安装是否成功(有client和service两部分表示docker安装启动都成功了) $ docker version Client: Version: 17.09.0-ce API version: 1.32 Go version: go1.8.3 Git commit: afdb6d4 Built: Tue Sep 26 22:41:23 2017 OS/Arch: linux/amd64 Server: Version: 17.09.0-ce API version: 1.32 (minimum version 1.12) Go version: go1.8.3 Git commit: afdb6d4 Built: Tue Sep 26 22:42:49 2017 OS/Arch: linux/amd64 Experimental: false &nbsp; 第5章 docker初体验 &nbsp; 第一个实例：用helloworld镜像带入，熟悉docker最基本的两个命令，拉取镜像和运行容器，并讲解背后运行逻辑。 第一个docker镜像 docker pull [OPTIONS] NAME[:TAG] 解释：拉取镜像，也就是从docker远程仓库拉去一个镜像到本地， 其中:TAG是可选的（指定版本），OPTIONS为拉取时的一些参数。 docker images [OPTIONS] [REPOSITOR[:TAG]] 解释：查看本机镜像，也可以验证上面的pull是否成功。 REPOSITOR表示镜像名称，:TAG表示版本。 第一个docker容器 docker run [OPTIONS] IMAGE[:TAG][COMMAND][ARG…] 解释：运行镜像，OPTIONS、:TAG同上， COMMAND表示这个IMAGE镜像运行起来后要执行的命令，ARG表示要执行的命令所依赖的参数。 &nbsp; 上图共分为三部分，从左至右分别为 Client、Host、Registry。前两个属于本机，Registry在hello-world例子中相当于远程仓库，整个流程为： docker pull 过程 &nbsp; 先向 docker daemon（在Host中）发送拉取镜像请求 daemon先在本机查找是否由符合版本要求的镜像，如果有，则不会做其他操作； 没有的话，daemon就去 Registry中查找，Registry返回相应镜像到本地。 docker run 过程 &nbsp; 先向 docker daemon发送请求，镜像不存在则再执行一次 docker pull过程。 然后通过一定方式把镜象变成容器 第6章 docker运行nginx静态网站 第二个实例：从运行nginx镜像引出docker网络概念和docker的端口映射，最后运行nginx容器。 &nbsp;&nbsp;实践前奏 ngnix为持久运行的容器（不同于 hello-world） 前台挂起&amp;后台运行（前台运行的话，ctrl+c 即可结束进程，所以最好后台） 进入容器内部，观察容器特征 1. 拉取nginx镜像 docker pull hub.c.163.com/library/nginx:latest 终端执行docker images,可以看到nginx镜像拉取成功 &nbsp;2 运行nginx镜像 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前端运行nginx镜像+关闭镜像方法 执行 docker run hub.c.163.com/library/nginx:latest&nbsp;&nbsp;语句，会发现没有任何响应。 另开一个窗口 执行 docker ps语句，该语句会显示正在运行的镜像 &nbsp; 因为nginx 此时是在前端运行，所以会出现docker run，没有任何响应。 执行 docker kill 779ab2962a80关闭前端运行nginx镜像这个进程。（779ab2962a80*为上图中的容器ID，也可以用 容器名替代） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 后台运行nginx镜像+进入容器内部 执行 docker run -d hub.c.163.com/library/nginx ，在后台运行该镜像，返回的值为容器的ID。 进入容器内部的命令为 docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 解释： 在一个正在运行的容器中执行一条命令。 OPTIONS为执行的参数（可以通过执行 docker exec --help查看） CONTAINER 为容器名， COMMAND [ARG…]为命令名以及参数 执行 docker exec -it f4&nbsp;bash 解释：-it为上图的 -i、-t的缩写，f4为容器ID的简写（因为现在在本机上的容器很少，通过23f就足以查找容器），bash为终端命令 上图表明已经进入了 nginx 所在的linux终端，就可以执行相关的Linux命令了。 执行完相关 Linux命令后，执行exit退出容器 3 Docker网络 网络类型 Bridge（默认） bridge模式是Docker默认的网络设置，此模式会为每一个容器 分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。 Bridge模式：首先创建一个docker0网桥，这个网桥和主机的eth0网卡相连；在启动容器时，容器这边则会产生一个虚拟网卡，也和网桥相连。这种模式下，容器会有自己独立的IP和端口。 &nbsp; (1) 利用 veth pair 技术,在宿主机上创建两个虚拟网络接口设备,假设为veth0 和 veth1。而 veth pair 技术的特性可以保证无论哪一个 veth 接收到网络报文,都会将报文传输给另一方 (2) 将 veth0 附加到docker0 网桥上。保证宿主机的网络报文可以发往 veth0 (3) 将 veth1 添加到容器所属的 namespace 下,并被改名为 eth0。 如此一来,保证宿主机的网络报文若发往 veth0,则立即会被 eth0 接收,实现宿主机到容器网络的联通性;同时,也保证 容器单独使用 eth0,实现容器网络环境的隔离性。 缺点：和宿主机以外的网络通信比较困难 &nbsp; Host 不会创建独立的network namespace。Docker容器中的进程处于宿主机的网络环境中，相当于Docker容器和宿主机共同用一个network namespace，使用宿主机的网卡、IP和端口等信息。 但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。 缺点：容器不再拥有隔离、独立的网络栈，会和宿主机发生资源抢夺 Host模式：容器直接连接主机的网卡eth0，两者使用同一网卡，看到的网络环境一样。 None 没有网络，Docker不会和外界进行通讯。Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。 &nbsp; Container Container模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。 新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。 同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。 (1) 查找其他容器(即需要被共享网络环境的容器)的网络 (2) 将新创建的容器(也是需要共享其他网络的容器)的namespace,使用其他容器的namespace。 可以用来更好的服务于容器间的通信。可以通过 localhost 来访问 namespace 下的其他容器,传输效率较高。虽然多个容器共享网络环境,但是多个容器形成的整体依然与宿主机以及其他容器形成网络隔离。另外,这种模式还节约了一定数量的网络资源。 缺点：它并没有改善容器与宿主机以外世界通信的情况。 端口映射 使容器的端口在主机上访问到，采用端口映射，Docker可以将容器里面的端口与主机的端口进行映射，这样就可以通过访问主机端口去访问容器端口。 执行 docker run -d -p 8080:80 hub.c.163.com/library/nginx 运行Nginx镜像，如下图 解释：-d表示后台运行，-p为端口设置，8080为本机端口，80为Nginx容器开放的端口，hub.c.163.com/library/nginx为容器名。 注意：完成上面步骤后，浏览器访问 localhost：32768，会发现访问不到，我们需要 找到Window系统下的Linux环境的地址 docker-machine ip default，找到Window系统下的Linux环境的地址 另记：上面语句中的-p替代为-P，Docker 会随机映射一个&nbsp; 的端口到内部容器开放的网络端口。然后使用docker ps 可以查看映射的端口号。 第7章 第一个java web应用 最后一个实例：创建自己的镜像，引出dockerfile，讲解基本的dockerfile语法。然后讲解私有仓库的搭建。最后分别在两台机器上演示docker的跨平台运行我们的java web项目。 Docker运行MySql 执行&nbsp;docker pull hub.c.163.com/library/mysql:latest，拉取mysql镜像，然后执行docker images查看本地镜像 终端执行docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=000000 -e MYSQL_DATABASE=jpress hub.c.163.com/library/mysql:latest，运行mysql镜像并创建数据库jpress 命令解释详见：library /mysql 完整步骤 1、下载mysql镜像 &nbsp; 下载mysql镜像，找到镜像，之后执行 docker pull hub.c.163.com/library/mysql:latest ，之后我们重命名下这个镜像，不然名字太长了，执行 docker tag hub.c.163.com/library/mysql:latest mysql:5.7 ，之后执行 docker images ，应该可以看到变化了。 2、运行镜像 &nbsp; &nbsp; &nbsp;执行 docker &nbsp;run &nbsp;-d --name &nbsp;mysql5.7container &nbsp;-p &nbsp;3306:3306 &nbsp;-e &nbsp;MYSQL_ROOT_PASSWORD=123 &nbsp;mysql:5.7 ，注意：123是root用户的密码。之后执行 docker ps -a ，就会看到全部的容器了，可以看到一个名为mysql5.7container的容器。 3、远程连接 &nbsp; &nbsp; 之后用navicat进行远程连接，ip地址填宿主主机(即运行者docker的linux)的ip地址，用户名是root，密码是123. 拉取tomcat镜像 docker pull hub.c.163.com/library/tomcat:latest拉取tomcat镜像（tomcat镜像会包括jdk镜像）,然后docker images查看本机镜像，tomcat镜像名为hub.c.163.com/library/tomcat&nbsp; 编写Dockerfile文件 输入from hub.c.163.com/library/tomcat，这句话表明我要制作的镜像以tomcat的镜像为起点，其中hub.c.163.com/library/tomcat为tomcat的镜像名。 MAINTAINER&nbsp;为自己的一些信息（可以不写）。 输入COPY jpress-web-newest.war /usr/local/tomcat/webapps，将web应用拷贝到tomcat的webapps下，其中/usr/local/tomcat来tomcat的安装目录，jpress-web-newest.war是需要部署的javaWeb程序 执行Docker Build命令 docker build -t jpress:latest . 注意最后面有“.”，表示当前目录 解释：&nbsp;-t表示为创建镜像的参数 ，jpress为镜像名称，latest为镜像版本。 运行镜像 docker run -d -p 8888:8080 jpress,运行容器，其中，本机端口号为8888，jpress开放的端口号为8080 注意：怎么查看tomcat中应用程序的名字？ 进入到 jpress镜像内部，docker exec -it 60 bash，其中，60为运行镜像时返回的ID，会发现直接跳转到了 Dockerfile文件中配置的 tomcat目录下 cd webapps下，然后输入ls展示所有文件，这里就可以看到应用程序的名字了 &nbsp; 参考链接：https://www.imooc.com/learn/824 参考链接：https://www.imooc.com/article/16448 &nbsp;","@type":"BlogPosting","url":"https://uzzz.org/2019/08/06/792823.html","headline":"Docker：慕课网–第一个docker化的java应用","dateModified":"2019-08-06T00:00:00+08:00","datePublished":"2019-08-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/08/06/792823.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Docker：慕课网--第一个docker化的java应用</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1>Docker简介：</h1> 
  <blockquote> 
   <p>Docker是一个使用Go语言开发的开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。Docker的发展速度和火爆程度着实令人惊叹，一发不可收拾，形成了席卷整个IT界的新浪潮。学完本课程你将了解到<strong>什么是docker，docker的思想以及诸如镜像，仓库，容器等核心概念</strong>。你将学会<strong>怎样运行一个容器，如何搭建私有仓库，怎么写dockerfile以及怎样把自己的应用放到容器中运行</strong>。docker将会是你的IT路上一笔不小的财富。</p> 
  </blockquote> 
  <h2 id="什么是-docker">什么是 Docker</h2> 
  <p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于&nbsp;<a href="https://en.wikipedia.org/wiki/Docker_(software)" rel="nofollow" data-token="c2e470bc2c33ce66edfadb61c3801cb4">2013 年 3 月以 Apache 2.0 授权协议开源</a>，主要项目代码在&nbsp;<a href="https://github.com/moby/moby" rel="nofollow" data-token="c5254b22f59b548da9e65b747944818b">GitHub</a>&nbsp;上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动&nbsp;<a href="https://www.opencontainers.org/" rel="nofollow" data-token="02c1778aa1cb5bda757f3340a0130dc6">开放容器联盟（OCI）</a>。</p> 
  <p>Docker 自开源后受到广泛的关注和讨论，至今其&nbsp;<a href="https://github.com/moby/moby" rel="nofollow" data-token="c5254b22f59b548da9e65b747944818b">GitHub 项目</a>&nbsp;已经超过 5 万 2 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，<a href="https://blog.docker.com/2013/10/dotcloud-is-becoming-docker-inc/" rel="nofollow" data-token="89a31e101ce3ef6dc270fbed9e6a9ca8">dotCloud 公司决定改名为 Docker</a>。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</p> 
  <p>Docker 使用 Google 公司推出的&nbsp;<a href="https://golang.org/" rel="nofollow" data-token="0b8df3a7930864a39ee966edc6125bf0">Go 语言</a>&nbsp;进行开发实现，基于 Linux 内核的&nbsp;<a href="https://zh.wikipedia.org/wiki/Cgroups" rel="nofollow" data-token="6e049014c7c7357d4590fa2fd626b0d3">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" rel="nofollow" data-token="514633f441d82c57ac329b0abbb6250d">namespace</a>，以及<a href="https://en.wikipedia.org/wiki/Aufs" rel="nofollow" data-token="8012f6d4c01f352540a88c4930fd64fc">AUFS</a>&nbsp;类的&nbsp;<a href="https://en.wikipedia.org/wiki/Union_mount" rel="nofollow" data-token="7d5f52ac3eef7664dfe8093888639246">Union FS</a>&nbsp;等技术，对进程进行封装隔离，属于&nbsp;<a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" rel="nofollow" data-token="2a9f1781c8cffe4706b909f06c76b241">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于&nbsp;<a href="https://linuxcontainers.org/lxc/introduction/" rel="nofollow" data-token="6f1746f6298ecbf7f5288bec6bdde94e">LXC</a>，从 0.7 版本以后开始去除 LXC，转而使用自行开发的&nbsp;<a href="https://github.com/docker/libcontainer" rel="nofollow" data-token="1a05b212e2d9ac81d5cf515fd3f50511">libcontainer</a>，<strong><span style="color:#f33b45;">从 1.11 开始，则进一步演进为使用&nbsp;</span><a href="https://github.com/opencontainers/runc" rel="nofollow"><span style="color:#f33b45;">runC</span></a><span style="color:#f33b45;">&nbsp;和&nbsp;</span><a href="https://github.com/containerd/containerd" rel="nofollow"><span style="color:#f33b45;">containerd</span></a><span style="color:#f33b45;">。</span></strong></p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="" height="546" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190727094241103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="800">
    <figcaption>
     Docker 架构
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp;</p> 
  <blockquote> 
   <p><code>runc</code>&nbsp;是一个 Linux 命令行工具，用于根据&nbsp;<a href="https://github.com/opencontainers/runtime-spec" rel="nofollow" data-token="f92ceca1c643ee7735978579ff12ba57">OCI容器运行时规范</a>&nbsp;创建和运行容器。</p> 
   <p><code>containerd</code>&nbsp;是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。</p> 
  </blockquote> 
  <p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p> 
  <p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。</p> 
  <blockquote> 
   <ul>
    <li><strong>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统</strong>，在该系统上再运行所需应用进程；</li> 
    <li>而<strong>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便。</li> 
   </ul>
  </blockquote> 
  <p>&nbsp;</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="" height="261" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190727094419379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="692">
    <figcaption>
     传统虚拟化
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="" height="195" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190727094437378.png" width="689">
    <figcaption>
     Docker
    </figcaption>
   </figure>
  </div> 
  <h1>&nbsp;</h1> 
  <h1>第1章 课程介绍</h1> 
  <p>对docker有个简单的印象，了解课程的安排。</p> 
  <p style="text-align:center;"><img alt="" class="has" height="426" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723090351648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="800"></p> 
  <ul>
   <li>Docker 是一个开源的应用容器引擎,主要<strong>利用 linux 内核 namespace 实现沙盒隔离,用cgroup 实现资源限制</strong>。</li> 
   <li>Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。</li> 
   <li>Docker的基础是Linux的容器技术(LXC)。</li> 
   <li>而Docker,正是在容器的基础上进行了进一步的封装,让用户不需要去关心容器的管理,使得操作更为简便。用户操作Docker的容器就像操作一个快速轻量级的虚拟机一样简单。</li> 
  </ul>
  <blockquote> 
   <p>VM是在硬件层面实现虚拟化</p> 
   <p>Docker几乎没有使用虚拟化的东西，直接复用了host主机的os，是内核级的虚拟化</p> 
  </blockquote> 
  <h2>docker优势:</h2> 
  <blockquote> 
   <p>(1)Docker容器的<strong>启动</strong>可以在秒级实现,这相比传统的虚拟机方式要<strong>快</strong>得多。</p> 
   <p>(2)其次,<span style="color:#f33b45;"><strong>Docker对系统资源的利用率很高</strong></span>,一台主机上可以同时运行数千个Docker容器。而且容器除了运行其中应用外,基本不消耗额外的系统资源,使得应用的性能很高,同时系统的开销尽量小。</p> 
  </blockquote> 
  <p>&nbsp;</p> 
  <h1>第2章 了解docker</h1> 
  <p>用形象的类比说明docker的集装箱、标准化、隔离的思想。在用几个工作学习中碰到的问题说明docker解决了哪些问题。</p> 
  <p style="text-align:center;"><img alt="" class="has" height="461" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019072309090756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="752"></p> 
  <h2>Docker解决的问题</h2> 
  <p style="text-align:center;"><img alt="" class="has" height="423" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019072309172388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="742"></p> 
  <blockquote> 
   <ul>
    <li>解决了运行环境不一致所带来的问题（它会将运行程序的相关配置，要求统一管理）</li> 
    <li>解决耗内存问题，Docker会一开始就为每个程序指定内存分配</li> 
    <li>让快速扩展，弹性伸缩变得简单</li> 
   </ul>
  </blockquote> 
  <h1>第3章 走进docker</h1> 
  <ul>
   <li>结合上面的类比引出docker的核心技术：镜像、仓库和容器的概念，并分别深入讲解技术、原理。</li> 
  </ul>
  <p style="text-align:center;"><img alt="" class="has" height="463" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723092243217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="725"></p> 
  <blockquote> 
   <p>一句话概括核心技术就是：<span style="color:#f33b45;"><strong>去仓库把镜像拉到本地，然后用一条命令把镜像运行起来，把镜像变成容器。</strong></span></p> 
   <ul>
    <li>Build：构建镜像</li> 
    <li>Ship：运输镜像</li> 
    <li>Run：运行镜像</li> 
   </ul>
  </blockquote> 
  <h2>Docker包括三个基本概念</h2> 
  <blockquote> 
   <p><strong>镜像(Image)&nbsp;&nbsp;</strong>镜像就是一个只读的模板</p> 
   <p><strong>容器(Container)</strong>&nbsp; 运行应用</p> 
   <p><strong>仓库(Repository)&nbsp;&nbsp;</strong>集中存放镜像文件的场所,分为公有仓库和私有仓库2种形式</p> 
  </blockquote> 
  <h2>1.Docker镜像(集装箱)</h2> 
  <ul>
   <li> <p><strong>构建镜像的目的</strong>：可以运行在其他环境中</p> </li> 
  </ul>
  <blockquote> 
   <p><span style="color:#f33b45;"><strong>镜像就是一系列的文件，它可以包括我们应用程序的文件，也可以包括应用环境的文件。</strong></span></p> 
   <p>Docker会把这些文件保存到本地，存储方式采用<strong>Linux中的联合文件系统的分层概念方式</strong>。</p> 
   <p><strong>镜像可以用来创建Docker容器的。</strong></p> 
   <ul>
    <li>一个镜像可以包含一个完整的操作系统环境和用户需要的其它应用程序。</li> 
    <li>在docker hub 里面有大量现成的镜像提供下载。</li> 
    <li>docker的镜像是只可读的，一个镜像可以创建多个容器,每个容器之间相互不干扰。</li> 
   </ul>
   <p>&nbsp;示例存储方式见下图，<strong>由下往上</strong>分别是：</p> 
   <ul>
    <li>操作系统的引导</li> 
    <li>具体的Linux操作系统</li> 
    <li>相关软件：tomcat、jdk等</li> 
    <li>应用代码</li> 
    <li>顶层为可写层（属于容器）</li> 
   </ul>
  </blockquote> 
  <p style="text-align:center;"><img alt="" class="has" height="463" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723092811800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="766"></p> 
  <h2>2.Docker容器（运行程序之地）</h2> 
  <ul>
   <li><span style="color:#f33b45;">容器的本质是一个进程，可以<strong>类同于</strong>虚拟机</span></li> 
  </ul>
  <p style="text-align:center;"><img alt="" class="has" height="558" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723173507439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="748"></p> 
  <blockquote> 
   <p>Docker利用容器来开发、运行应用</p> 
   <p><br><strong>容器是镜像创建的实例</strong>。它可以被启动、开始、停止、删除。每个容器都是 相互隔离的、保证安全的平台。</p> 
   <p>容器在运行过程中，如果要写一个镜像里面的文件：就需要将镜像里的文件拷贝到最上层，再进行修改；修改后，当我们应用读一个文件时，从上层开始读，上层没有才往下读；</p> 
  </blockquote> 
  <h2>3. Docker 仓库（超级码头）</h2> 
  <p style="text-align:center;"><img alt="" class="has" height="410" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723153012846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="644"></p> 
  <blockquote> 
   <p><strong>仓库是集中存放镜像文件的场所。</strong></p> 
   <p>每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p> 
   <ul>
    <li>最大的公开仓库是<a href="https://hub.docker.com/" rel="nofollow" data-token="3f809b77d0230ecec602dd7ce6e36b35">DockerHub</a>(<a href="https://hub.docker.com/" rel="nofollow" data-token="3f809b77d0230ecec602dd7ce6e36b35">https://hub.docker.com/</a>)，存放了数量庞大的镜像供用户下载。</li> 
    <li>国内：<a href="https://www.cnblogs.com/anliven/p/6218741.html" rel="nofollow" data-token="3c62ba98c6ecc01659c5644259270bc5">&nbsp;Docker - 国内镜像的配置及使用</a>；<a href="https://c.163yun.com/hub#/m/library/" rel="nofollow" data-token="b93394da64ce16af0e821bd037d508c5">https://c.163yun.com/hub#/m/library/</a></li> 
    <li>当然，用户也可以在本地网络内创建一个私有仓库</li> 
   </ul>
  </blockquote> 
  <p style="text-align:center;"><img alt="" class="has" height="371" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723154403865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="800"></p> 
  <h1>第4章 docker安装</h1> 
  <p>分别在三种平台上讲解docker的安装。同学可以选择自己的平台观看。</p> 
  <h2>在centos和redhat上安装docker</h2> 
  <h3><strong>1.前置条件</strong></h3> 
  <ul>
   <li>64-bit 系统</li> 
   <li>kernel 3.10+<br><strong>1.检查内核版本，返回的值大于3.10即可。</strong></li> 
  </ul>
  <pre class="has">
<code>$ uname -r
</code></pre> 
  <h3><strong>2.使用 sudo 或 root 权限的用户登入终端。</strong></h3> 
  <h3><strong>3.卸载旧版本(如果安装过旧版本的话)</strong></h3> 
  <pre class="has">
<code>$ yum remove docker \
      docker-common \
      docker-selinux \
      docker-engine
</code></pre> 
  <h3><strong>4.安装需要的软件包</strong></h3> 
  <pre class="has">
<code>#yum-util提供yum-config-manager功能
#另外两个是devicemapper驱动依赖的
$ yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2
</code></pre> 
  <h3><strong>5.设置yum源</strong></h3> 
  <pre class="has">
<code>$ yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
</code></pre> 
  <h3><strong>6.安装docker</strong></h3> 
  <ul>
   <li><em><strong>6.1. 安装最新版本</strong></em></li> 
  </ul>
  <pre class="has">
<code>$ yum install -y docker-ce
</code></pre> 
  <ul>
   <li><em><strong>6.2. 安装指定版本</strong></em></li> 
  </ul>
  <pre class="has">
<code>#查询版本列表
$ yum list docker-ce --showduplicates | sort -r
已加载插件：fastestmirror, langpacks
已安装的软件包
可安装的软件包
 * updates: mirrors.163.com
Loading mirror speeds from cached hostfile
 * extras: mirrors.163.com
docker-ce.x86_64            17.09.1.ce-1.el7.centos            docker-ce-stable
docker-ce.x86_64            17.09.0.ce-1.el7.centos            docker-ce-stable
...
#指定版本安装(这里的例子是安装上面列表中的第二个)
$ yum install -y docker-ce-17.09.0.ce
</code></pre> 
  <ul>
   <li><span style="color:#f33b45;"><strong>如果遇到，Docker安装指定版本异常：Error: Package: docker-ce-17.03.1.ce-1.el7.centos.x86_64 (docker-ce-stable)</strong></span></li> 
  </ul>
  <blockquote> 
   <p>请参考：<a href="https://blog.csdn.net/fly910905/article/details/97622433" rel="nofollow" data-token="93a153fe83ebc6893c1cf1a0e472178e">https://blog.csdn.net/fly910905/article/details/97622433</a></p> 
  </blockquote> 
  <ul>
   <li><strong>7.启动docker</strong></li> 
  </ul>
  <pre class="has">
<code>$ systemctl start docker.service
</code></pre> 
  <h3><strong>7.验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</strong></h3> 
  <pre class="has">
<code>$ docker version
Client:
 Version:      17.09.0-ce
 API version:  1.32
 Go version:   go1.8.3
 Git commit:   afdb6d4
 Built:        Tue Sep 26 22:41:23 2017
 OS/Arch:      linux/amd64

Server:
 Version:      17.09.0-ce
 API version:  1.32 (minimum version 1.12)
 Go version:   go1.8.3
 Git commit:   afdb6d4
 Built:        Tue Sep 26 22:42:49 2017
 OS/Arch:      linux/amd64
 Experimental: false</code></pre> 
  <p>&nbsp;</p> 
  <h1>第5章 docker初体验</h1> 
  <p>&nbsp;</p> 
  <blockquote> 
   <p>第一个实例：用helloworld镜像带入，熟悉docker最基本的两个命令，拉取镜像和运行容器，并讲解背后运行逻辑。</p> 
  </blockquote> 
  <h2>第一个docker镜像</h2> 
  <h2><br> docker pull [OPTIONS] NAME[:TAG]</h2> 
  <blockquote> 
   <p>解释：<strong>拉取镜像</strong>，也就是从docker远程仓库拉去一个镜像到本地，</p> 
   <p>其中:TAG是可选的（指定版本），OPTIONS为拉取时的一些参数。</p> 
  </blockquote> 
  <h3>docker images [OPTIONS] [REPOSITOR[:TAG]]</h3> 
  <blockquote> 
   <p>解释：<strong>查看本机镜像</strong>，也可以验证上面的pull是否成功。</p> 
   <p>REPOSITOR表示镜像名称，:TAG表示版本。</p> 
  </blockquote> 
  <h2>第一个docker容器</h2> 
  <h3>docker run [OPTIONS] IMAGE[:TAG][COMMAND][ARG…]</h3> 
  <blockquote> 
   <p>解释：运行镜像，<code>OPTIONS</code>、<code>:TAG</code>同上，</p> 
   <p><code>COMMAND</code>表示这个IMAGE镜像运行起来后要执行的命令，<code>ARG</code>表示要执行的命令所依赖的参数。</p> 
  </blockquote> 
  <p>&nbsp;</p> 
  <p style="text-align:center;"><img alt="" class="has" height="465" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/201907231422163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="800"></p> 
  <p>上图共分为三部分，从左至右分别为 Client、Host、Registry。前两个属于本机，<strong>Registry在hello-world例子中相当于远程仓库</strong>，整个流程为：</p> 
  <h3>docker pull 过程</h3> 
  <p>&nbsp;</p> 
  <blockquote> 
   <ul>
    <li>先向<strong> docker daemon</strong>（在Host中）发送拉取镜像请求</li> 
    <li>daemon先在本机查找是否由符合版本要求的镜像，如果有，则不会做其他操作；</li> 
    <li>没有的话，daemon就去 Registry中查找，Registry返回相应镜像到本地。</li> 
   </ul>
  </blockquote> 
  <h3>docker run 过程</h3> 
  <p>&nbsp;</p> 
  <blockquote> 
   <ul>
    <li>先向 docker daemon发送请求，镜像不存在则再执行一次 docker pull过程。</li> 
    <li>然后通过一定方式把镜象变成容器</li> 
   </ul>
  </blockquote> 
  <h1>第6章 docker运行nginx静态网站</h1> 
  <blockquote> 
   <p>第二个实例：从运行nginx镜像引出docker网络概念和docker的端口映射，最后运行nginx容器。</p> 
  </blockquote> 
  <h2>&nbsp;&nbsp;实践前奏</h2> 
  <blockquote> 
   <ul>
    <li>ngnix为持久运行的容器（不同于 hello-world）</li> 
    <li>前台挂起&amp;后台运行（前台运行的话，ctrl+c 即可结束进程，所以最好后台）</li> 
    <li>进入容器内部，观察容器特征</li> 
   </ul>
  </blockquote> 
  <h2>1. 拉取nginx镜像</h2> 
  <blockquote> 
   <p>docker pull hub.c.163.com/library/nginx:latest</p> 
  </blockquote> 
  <ul>
   <li>终端执行<code>docker images</code>,可以看到nginx镜像拉取成功</li> 
  </ul>
  <h2>&nbsp;2 运行nginx镜像<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</h2> 
  <h3>前端运行nginx镜像+关闭镜像方法</h3> 
  <blockquote> 
   <p>执行 <strong>docker run hub.c.163.com/library/nginx:latest&nbsp;&nbsp;</strong>语句，会发现没有任何响应。</p> 
   <p><br> 另开一个窗口 执行 <strong>docker ps</strong>语句，该语句会显示正在运行的镜像</p> 
   <p>&nbsp;</p> 
  </blockquote> 
  <ul>
   <li>因为nginx 此时是在前端运行，所以会出现<strong>docker run，</strong>没有任何响应。</li> 
   <li>执行<strong> docker kill 779ab2962a80</strong>关闭前端运行nginx镜像这个进程。（779ab2962a80*为上图中的容器ID，也可以用 容器名替代）</li> 
  </ul>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> 
  <h3>后台运行nginx镜像+进入容器内部</h3> 
  <p><br> 执行<strong> docker run -d hub.c.163.com/library/nginx </strong>，在后台运行该镜像，返回的值为容器的ID。</p> 
  <p>进入容器内部的命令为<span style="color:#f33b45;"><strong> docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</strong></span></p> 
  <p style="text-align:center;"><img alt="" class="has" height="240" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723163828220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="800"></p> 
  <blockquote> 
   <p>解释： 在一个正在运行的容器中执行一条命令。<br> OPTIONS为执行的参数（可以通过执行 docker exec --help查看）<br> CONTAINER 为容器名， COMMAND [ARG…]为命令名以及参数</p> 
  </blockquote> 
  <p>执行<span style="color:#f33b45;"> <strong>docker exec -it f4&nbsp;bash</strong></span></p> 
  <blockquote> 
   <p><img alt="" class="has" height="117" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019072316410048.png" width="741"><br> 解释：-it为上图的 -i、-t的缩写，f4为容器ID的简写（因为现在在本机上的容器很少，通过23f就足以查找容器），bash为终端命令</p> 
  </blockquote> 
  <ul>
   <li>上图表明已经进入了 nginx 所在的linux终端，就可以执行相关的Linux命令了。</li> 
   <li>执行完相关 Linux命令后，执行exit退出容器</li> 
  </ul>
  <h2>3 Docker网络</h2> 
  <h3><br> 网络类型</h3> 
  <p style="text-align:center;"><img alt="" class="has" height="484" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723164235177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="800"></p> 
  <p><br><strong>Bridge（默认）</strong></p> 
  <blockquote> 
   <p>bridge模式是Docker默认的网络设置，此模式<strong>会为每一个容器 分配Network Namespace、设置IP</strong>等，并将一个主机上的Docker容器连接到一个虚拟网桥上。</p> 
  </blockquote> 
  <ul>
   <li>Bridge模式：首先创建一个docker0网桥，这个网桥和主机的eth0网卡相连；在启动容器时，容器这边则会产生一个虚拟网卡，也和网桥相连。<strong>这种模式下，容器会有自己独立的IP和端口。</strong></li> 
  </ul>
  <blockquote> 
   <p>&nbsp;</p> 
   <p>(1) 利用 veth pair 技术,在宿主机上创建两个虚拟网络接口设备,假设为veth0 和 veth1。而 veth pair 技术的特性可以保证无论哪一个 veth 接收到网络报文,都会将报文传输给另一方</p> 
   <p>(2) 将 veth0 附加到docker0 网桥上。保证宿主机的网络报文可以发往 veth0</p> 
   <p>(3) 将 veth1 添加到容器所属的 namespace 下,并被改名为 eth0。</p> 
   <p>如此一来,保证宿主机的网络报文若发往 veth0,则立即会被 eth0 接收,实现宿主机到容器网络的联通性;同时,也保证 容器单独使用 eth0,实现容器网络环境的隔离性。</p> 
   <p><strong>缺点：和宿主机以外的网络通信比较困难</strong></p> 
  </blockquote> 
  <p>&nbsp;</p> 
  <p><strong>Host</strong></p> 
  <blockquote> 
   <p>不会创建独立的network namespace。Docker容器中的进程处于宿主机的网络环境中，相当于Docker容器和宿主机共同用一个network namespace，使用宿主机的网卡、IP和端口等信息。</p> 
   <p>但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p> 
   <p><strong>缺点：容器不再拥有隔离、独立的网络栈，会和宿主机发生资源抢夺</strong></p> 
  </blockquote> 
  <ul>
   <li>Host模式：容器直接连接主机的网卡eth0，两者使用同一网卡，看到的网络环境一样。</li> 
  </ul>
  <p><strong>None</strong></p> 
  <blockquote> 
   <p><strong>没有网络，Docker不会和外界进行通讯。</strong>Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p> 
  </blockquote> 
  <p>&nbsp;</p> 
  <p><strong>Container</strong></p> 
  <blockquote> 
   <p>Container模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。</p> 
   <p>新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。</p> 
   <p>同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p> 
  </blockquote> 
  <blockquote> 
   <p>(1) 查找其他容器(即需要被共享网络环境的容器)的网络</p> 
   <p>(2) 将新创建的容器(也是需要共享其他网络的容器)的namespace,使用其他容器的namespace。</p> 
   <p>可以用来更好的服务于容器间的通信。可以通过 localhost 来访问 namespace 下的其他容器,传输效率较高。虽然多个容器共享网络环境,但是多个容器形成的整体依然与宿主机以及其他容器形成网络隔离。另外,这种模式还节约了一定数量的网络资源。</p> 
   <p><strong>缺点：它并没有改善容器与宿主机以外世界通信的情况。</strong></p> 
  </blockquote> 
  <h3><br> 端口映射</h3> 
  <blockquote> 
   <p><strong>使容器的端口在主机上访问到，采用端口映射</strong>，Docker可以将容器里面的端口与主机的端口进行映射，这样就可以通过访问主机端口去访问容器端口。</p> 
  </blockquote> 
  <p>执行<span style="color:#f33b45;"><strong> docker run -d -p 8080:80 hub.c.163.com/library/nginx </strong></span>运行Nginx镜像，如下图</p> 
  <blockquote> 
   <p>解释：-d表示后台运行，-p为端口设置，8080为本机端口，80为Nginx容器开放的端口，hub.c.163.com/library/nginx为容器名。</p> 
  </blockquote> 
  <p><strong>注意：</strong>完成上面步骤后，浏览器访问 localhost：32768，会发现访问不到，我们需要 找到Window系统下的Linux环境的地址</p> 
  <blockquote> 
   <p><span style="color:#f33b45;"><strong><code>docker-machine ip default</code></strong></span>，找到Window系统下的Linux环境的地址</p> 
  </blockquote> 
  <p><strong>另记</strong>：上面语句中的<span style="color:#f33b45;"><strong><code>-p</code>替代为<code>-P</code></strong></span>，Docker 会随机映射一个&nbsp; 的端口到内部容器开放的网络端口。然后使用docker ps 可以查看映射的端口号。</p> 
  <h1><br> 第7章 第一个java web应用</h1> 
  <blockquote> 
   <p>最后一个实例：创建自己的镜像，引出dockerfile，讲解基本的dockerfile语法。然后讲解私有仓库的搭建。最后分别在两台机器上演示docker的跨平台运行我们的java web项目。</p> 
  </blockquote> 
  <h2>Docker运行MySql</h2> 
  <blockquote> 
   <p>执行&nbsp;<strong><code>docker pull hub.c.163.com/library/mysql:latest</code></strong>，拉取mysql镜像，然后执行<code>docker images</code>查看本地镜像</p> 
   <p>终端执行<span style="color:#f33b45;"><strong>docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=000000 -e MYSQL_DATABASE=jpress hub.c.163.com/library/mysql:latest</strong></span>，运行mysql镜像并创建数据库jpress</p> 
  </blockquote> 
  <p>命令解释详见：<a href="https://c.163yun.com/hub#/m/repository/?repoId=2955" rel="nofollow" data-token="9646482c18bc60ff763b8415a6e85fae">library /mysql</a></p> 
  <h3>完整步骤</h3> 
  <blockquote> 
   <p><strong>1、下载mysql镜像</strong></p> 
   <p>&nbsp;</p> 
   <p>下载mysql镜像，找到镜像，之后执行</p> 
   <pre class="has">
<code class="language-html">docker pull hub.c.163.com/library/mysql:latest</code></pre> 
   <p>，之后我们重命名下这个镜像，不然名字太长了，执行</p> 
   <pre class="has">
<code class="language-html"> docker tag hub.c.163.com/library/mysql:latest mysql:5.7</code></pre> 
   <p>，之后执行</p> 
   <pre class="has">
<code class="language-html">docker images</code></pre> 
   <p>，应该可以看到变化了。</p> 
   <p><strong>2、运行镜像</strong></p> 
   <p>&nbsp; &nbsp; &nbsp;执行</p> 
   <pre class="has">
<code class="language-html">docker &nbsp;run &nbsp;-d --name &nbsp;mysql5.7container &nbsp;-p &nbsp;3306:3306 &nbsp;-e &nbsp;MYSQL_ROOT_PASSWORD=123 &nbsp;mysql:5.7</code></pre> 
   <p>，注意：123是root用户的密码。之后执行</p> 
   <pre class="has">
<code class="language-html">docker ps -a</code></pre> 
   <p>，就会看到全部的容器了，可以看到一个名为mysql5.7container的容器。</p> 
   <p><strong>3、远程连接</strong></p> 
   <p>&nbsp; &nbsp; 之后用navicat进行远程连接，ip地址填宿主主机(即运行者docker的linux)的ip地址，用户名是root，密码是123.</p> 
  </blockquote> 
  <h2><a href="https://c.163yun.com/hub#/m/repository/?repoId=3105" rel="nofollow" data-token="2e7b5020a30086f4548a8649fbfd2c34">拉取tomcat镜像</a></h2> 
  <blockquote> 
   <p><strong><code>docker pull hub.c.163.com/library/tomcat:latest</code></strong>拉取tomcat镜像（tomcat镜像会包括jdk镜像）,然后<code>docker images</code>查看本机镜像，tomcat镜像名为<code>hub.c.163.com/library/tomcat</code>&nbsp;</p> 
  </blockquote> 
  <p style="text-align:center;"><img alt="" class="has" height="335" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723175314732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="800"></p> 
  <h2>编写Dockerfile文件</h2> 
  <ol>
   <li>输入<strong>from hub.c.163.com/library/tomcat</strong>，这句话表明我要制作的镜像以tomcat的镜像为起点，其中hub.c.163.com/library/tomcat为tomcat的镜像名。</li> 
   <li><strong>MAINTAINER&nbsp;</strong>为自己的一些信息（可以不写）。</li> 
   <li>输入<strong>COPY jpress-web-newest.war /usr/local/tomcat/webapps</strong>，将web应用拷贝到tomcat的webapps下，其中/usr/local/tomcat来tomcat的安装目录，jpress-web-newest.war是需要部署的javaWeb程序</li> 
  </ol>
  <p style="text-align:center;"><img alt="" class="has" height="156" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723174013825.png" width="692"></p> 
  <h2>执行Docker Build命令</h2> 
  <blockquote> 
   <p><code>docker build -t jpress:latest .</code></p> 
  </blockquote> 
  <ul>
   <li>注意最后面有“.”，表示当前目录</li> 
   <li><strong>解释</strong>：&nbsp;<code>-t</code>表示为创建镜像的参数 ，<code>jpress</code>为镜像名称，<code>latest</code>为镜像版本。</li> 
  </ul>
  <p style="text-align:center;"><img alt="" class="has" height="234" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723174232714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" width="770"></p> 
  <h1>运行镜像</h1> 
  <blockquote> 
   <p><code>docker run -d -p 8888:8080 jpress</code>,运行容器，其中，本机端口号为<code>8888</code>，jpress开放的端口号为<code>8080</code></p> 
  </blockquote> 
  <ul>
   <li><span style="color:#f33b45;"><code>注意：</code>怎么查看tomcat中应用程序的名字？</span></li> 
  </ul>
  <blockquote> 
   <ul>
    <li>进入到 jpress镜像内部，<code>docker exec -it 60 bash</code>，其中，<code>60</code>为运行镜像时返回的ID，会发现直接跳转到了 Dockerfile文件中配置的 tomcat目录下</li> 
    <li><code>cd webapps</code>下，然后输入<code>ls</code>展示所有文件，这里就可以看到应用程序的名字了</li> 
   </ul>
  </blockquote> 
  <h3>&nbsp;</h3> 
  <p>参考链接：<a href="https://www.imooc.com/learn/824" rel="nofollow" data-token="36ae2ea5c5df0541373fc6a205641862">https://www.imooc.com/learn/824</a></p> 
  <p>参考链接：https://www.imooc.com/article/16448</p> 
  <p>&nbsp;</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
