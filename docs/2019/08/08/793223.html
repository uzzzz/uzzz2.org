<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>卷积神经网络概述 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="卷积神经网络概述" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="目录 人类视觉原理 1整体描述 2基本理论 2.1卷积（convolution） 2.2步长（stride） 2.3填充（padding） Valid卷积 Same卷积 2.4三维卷积 2.5 1x1卷积 2.6偏置（bias） 2.7池化（pooling） 2.8全局池化 (Global Pooling) 2.9激活函数 3特性 3.1局部感知 3.2参数共享 3.3分层提取 3.4感受野（Receptive field） 3.5多核卷积 4局部卷积 5卷积层和池化层的实现 5.1卷积实现 5.2池化实现 6可视化 7神经网络的本质 参考文章 人类视觉原理 &nbsp; &nbsp; &nbsp; &nbsp; 深度学习的许多研究成果，离不开对大脑认知原理的研究，尤其是视觉原理的研究。 &nbsp; &nbsp; &nbsp; &nbsp; 1981 年的诺贝尔医学奖，颁发给了 David Hubel（出生于加拿大的美国神经生物学家） 和TorstenWiesel，以及 Roger Sperry。前两位的主要贡献，是“发现了视觉系统的信息处理”，可视皮层是分级的。 &nbsp; &nbsp; &nbsp; &nbsp; 人类的视觉原理如下：从原始信号摄入开始（瞳孔摄入像素 Pixels），接着做初步处理（大脑皮层某些细胞发现边缘和方向），然后抽象（大脑判定，眼前的物体的形状，是圆形的），然后进一步抽象（大脑进一步判定该物体是只气球）。下面是人脑进行人脸识别的一个示例： 图&nbsp;人类视觉原理 &nbsp; &nbsp; &nbsp; &nbsp; 我们可以看到，在最底层特征基本上是类似的，就是各种边缘，越往上，越能提取出此类物体的一些特征（轮子、眼睛、躯干等），到最上层，不同的高级特征最终组合成相应的图像，从而能够让人类准确的区分不同的物体。那么我们可以很自然的想到：可以不可以模仿人类大脑的这个特点，构造多层的神经网络，让计算机来逐层提取图像中的特征，最终在顶层做出分类呢？答案是肯定的，这也是卷积神经网络的灵感来源。 1整体描述 &nbsp; &nbsp; &nbsp; &nbsp; 卷积神经网络（Convolutional Neural Networks, CNN）是一类包含卷积运算且具有深度结构的前馈神经网络（Feedforward Neural Networks）。相比早期的BP神经网络，卷积神经网络最重要的特性在于“局部感知”与“参数共享”，自2012年的AlexNet开始，卷积神经网络就多次成为ImageNet大规模视觉识别竞赛（ImageNet Large Scale Visual Recognition Challenge, ILSVRC）的优胜算法，至此，卷积神经网络开始大放异彩，成为了众多科学领域的研究重点之一。 &nbsp; &nbsp; &nbsp; &nbsp; 如图1所示，一个完整的卷积神经网络可包含卷积层、池化层、全连接层等。其中卷积层用来进行特征提取，池化层用于降低维数，全连接层可用于结果预测（也可使用全卷积网络进行预测）。 图1.1 卷积神经网络示例（手写数字识别） 注：卷积运算也属于一种线性运算，故需要进行非线性处理，即添加激活函数（示例中为修正线性单元的函数，即 Relu 激活函数）。 &nbsp; &nbsp; &nbsp; &nbsp; 对于卷积层，其详细描述如图1.2所示 图1.2&nbsp;卷积层描述 其运算过程主要由以下4步组成： 原图像（尺寸为&nbsp;）分别与&nbsp;&nbsp;个&nbsp;&nbsp;的卷积核（又名滤波器，fliter）进行卷积运算，得到&nbsp;&nbsp;个&nbsp;&nbsp;的特征图（feature map） 每个特征图分别添加不同的偏置（bias），具体为特征图中的每个元素&nbsp; 对每个特征图添加激活函数&nbsp;，进行非线性运算 将这&nbsp;&nbsp;个特征图依次叠加，得到最终的特征图（尺寸为&nbsp;） 注：对于某一个卷积层，其不同特征图所使用的激活函数相同，但不同卷积层所使用的激活函数可以不同，该步骤在整体描述中为突出与神经网络的相似性而单独提出，但实际上其仍属于卷积层的一部分。 &nbsp; &nbsp; &nbsp; &nbsp; 对于池化层，其详细描述如图1.3所示： 图1.3&nbsp;池化层描述 &nbsp; &nbsp; &nbsp; &nbsp; 承接上例，对于&nbsp;&nbsp;的特征图，其池化过程仅需通过池化核对该特征图进行池化运算即可得到输出。 &nbsp; &nbsp; &nbsp; &nbsp; 然后将得到的特征图经过全连接层进行处理并由softmax算法进行回归即可得到最终的输出结果。 注：全连接层即为机器学习中常见的由神经元构成的神经网络。 （关于神经网络及softmax回归可参考：神经网络的前向及反向传播、深度学习笔记） 2基本理论 &nbsp; 2.1卷积（convolution） &nbsp; &nbsp; &nbsp; &nbsp; 卷积神经网络中的核心即为卷积运算，其相当于图像处理中的“滤波器运算”。 &nbsp; &nbsp; &nbsp; &nbsp; 对于一个&nbsp;&nbsp;大小的卷积核&nbsp;，其对某一原图像&nbsp;&nbsp;进行卷积运算的过程为：卷积核&nbsp;&nbsp;中的每一个权值&nbsp;&nbsp;分别和覆盖的原图像&nbsp;&nbsp;中所对应的像素&nbsp;&nbsp;相乘，然后再求和。计算公式为： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如图2.1所示，对一幅图像的一个完整的卷积运算过程为：卷积核以一定的间隔滑动，并对所覆盖的区域进行卷积运算得到值&nbsp;，直至遍历完整幅图像。 图2.1 卷积运算 &nbsp; &nbsp; &nbsp; &nbsp; 一个标准的卷积运算以图2.2为例，其卷积核每次覆盖原图像的9个像素，共滑动4次，得到了一个&nbsp;&nbsp;的二维数据。对于一个大小为&nbsp;&nbsp;的原图像，经过大小为&nbsp;&nbsp;的卷积运算后，其输出图像的尺寸为&nbsp;。 图2.2&nbsp;标准的二维卷积运算 2.2步长（stride） &nbsp; &nbsp; &nbsp; &nbsp; 滑动一定的间距，但这个间距该如何定义呢? 这个概念就是卷积的 “步长”（stride），设置卷积的步长可使卷积过程跳过原图像中的某些像素。结合步长&nbsp;&nbsp;操作后，其输出图像的尺寸为&nbsp;。stride =&nbsp;1 表示卷积核滑过每一个相距是 1 的像素，是最基本的单步滑动，作为标准卷积模式。Stride 是 2 表示卷积核的移动步长是 2，跳过相邻像素，输出图像缩小为原来的 1/2。Stride 是 3 表示卷积核的移动步长是 3，跳过 2 个相邻像素，图像缩小为原来的 1/3，以此类推。 图2.3&nbsp;一个步长为2的卷积运算 2.3填充（padding） &nbsp; &nbsp; &nbsp; &nbsp; 在标准的卷积过程中，存在两个问题： 每次卷积运算后，图像就会缩小，在经历多次运算后，图像终会失去其形状，变为&nbsp;&nbsp;的 “柱状”。 对于图像边缘的像素，其只被一个输出所触碰或者使用，但对于图像中间的像素，则会有多个卷积核与之重叠。所以那些在角落或者边缘区域的像素点在输出中采用较少，意味着卷积过程丢掉了图像边缘位置的许多信息。 &nbsp; &nbsp; &nbsp; &nbsp; 对于这个问题，可以采用额外的 “假”&nbsp;像素（通常值为 0， 因此经常使用的术语 ”零填充“ ）填充边缘。这样，在滑动时的卷积核可以允许原始边缘像素位于其中心，同时延伸到边缘之外的假像素。假设填充的像素大小为&nbsp;&nbsp;，则&nbsp;&nbsp;就变成了&nbsp;&nbsp;，故其输出图像的尺寸为&nbsp;。 &nbsp; &nbsp; &nbsp; &nbsp; 至于选择填充多少像素，通常有两个选择，分别叫做 Valid 卷积和 Same 卷积。 Valid卷积 &nbsp; &nbsp; &nbsp; &nbsp; Valid 卷积意味着不填充，如之前所述，图像会经历卷积运算后逐渐缩小，输出的图像尺寸即为上述公式：。 Same卷积 &nbsp; &nbsp; &nbsp; &nbsp; Same卷积意味填充后，输出图像的尺寸与输入图像的尺寸相同，根据上述公式，令&nbsp;，可得到。当&nbsp;&nbsp;时，。 注：一般卷积核&nbsp;&nbsp;的大小会选择一个奇数，如 3 \ 5 \ 7 等。主要因为： 如果&nbsp; 是一个偶数，那么只能使用一些不对称填充。只有当&nbsp; 是奇数时，Same 卷积才会有自然的填充，即可以选择同样的数量填充四周。 当卷积核&nbsp;&nbsp;是奇数时，其只有一个中心点，在具体的程序实现过程中会便于指出卷积核的位置。 2.4三维卷积 &nbsp; &nbsp; &nbsp; &nbsp; 此处可分为两种，一种是常见的多通道图像（如RGB彩色图像）的三维卷积（也是实际中最常用的卷积方式），与之前所举的二维卷积例子原理相似只是通道数不为1，具体如下图所示： 图2.4&nbsp;三维卷积 &nbsp; &nbsp; &nbsp; &nbsp; 在该卷积过程中，卷积核n（包含3个小卷积核） 中的每个小卷积核分别与原图像中所对应的图层进行卷积运算（如卷积核1中左边的小卷积核与原图像中左边的红色图层进行卷积运算，得到红色的单通道特征图；卷积核1中中间的小卷积核则与原图像中间的绿色图层进行卷积运算，得到绿色的单通道特征图，以此类推），分别生成3个单通道特征图，然后将这3个特征图按元素对应相加，即可得到卷积核n 生成的单通道特征图，最后将 n 个特征图相叠加即可得到最终的 n通道特征图。 注：该类卷积方式也是图像识别与检测中最常见的运算方式。其维度计算如下。 对于第&nbsp;&nbsp;层卷积，定义符号如下： &nbsp;卷积核尺寸（filter） &nbsp;填充尺寸（padding） &nbsp;步长（stride） &nbsp;图像的高度（height） &nbsp;图像的宽度（width） &nbsp;通道数（channel&nbsp;number） 定义输入图像（第&nbsp;&nbsp;层图像）的尺寸为： 定义共有&nbsp;&nbsp;个&nbsp;&nbsp;卷积核（程序中定义尺寸为 ）对输入图像进行卷积（卷积核的通道数与输入图像一致） &nbsp; &nbsp; &nbsp; &nbsp; 则输出图像（第&nbsp;&nbsp;层图像）的高度&nbsp;，宽度，通道数为卷积核的个数&nbsp;。即输出图像尺寸为：。 注：通过卷积网络中的权重所指的就是卷积核的参数，也就是也就是所有卷积核的集合再乘以卷积核的总数量，即，此处关于高度，宽度和通道的顺序并没有完全统一的标准。 &nbsp; &nbsp; &nbsp; &nbsp; 第二种三维卷积优点类似于卷积的局部连接，但该类卷积运算的卷积核并非只与原图像中的某几层相连接（在一个固定平面内滑动），而是以空间滑动的方式与原图像的所有像素进行卷积。 图2.5&nbsp;三维卷积 &nbsp; &nbsp; &nbsp; &nbsp; 以上图为例，&nbsp;的卷积核在&nbsp;&nbsp;原图像上以步长为1的方式在空间上滑动遍历所有像素进行卷积，最终生成一个&nbsp;&nbsp;的特征图。该类卷积常用于视频的事件检测、三维医学影像等领域。 2.5 1x1卷积 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;卷积也称作 “Network in Network”，其本质上相当于全连接层，以一个&nbsp;&nbsp;的输入图像为例，卷积（通道数与输入图像一致，即尺寸为&nbsp;）所实现的功能就是依次遍历这28个单元格作乘积再求和，增加偏置后应用激活函数（输出图像的高和宽不变，通道数为卷积核的数量）。这时，输入图像的28个不同通道的数据可看作是神经网络的输入向量&nbsp;，而卷积核则可看作是权重&nbsp;，而多个卷积核即构成了神经网络中的隐藏层。 &nbsp; &nbsp; &nbsp; &nbsp; 其主要有2个功能： 降维/升维，即改变图像的通道数，本质上就是通道间信息的线性组合变化。 增加非线性，卷积核，可以在保持图像尺度不变的（即不损失分辨率）的前提下增加非线性特性（利用后接的非线性激活函数）。 2.6偏置（bias） &nbsp; &nbsp; &nbsp; &nbsp; 参考图1.2，每个卷积核都有一个偏置参数&nbsp;，它是一个实数。偏差包含了这些变量，它是该维度上的一个向量，其在代码中表示为一个&nbsp;&nbsp;&nbsp;的四维向量或四维张量。如图2.6所示，三维卷积中，偏置中的每一个单元分别作用于特征图中的每一个图层。 图2.6.1 添加偏置 &nbsp; &nbsp; &nbsp; &nbsp; 其具体计算过程如图2.7所示（以二维卷积为例，也可理解为图2.6中的某一个偏置单元与特征图中对应图层的计算过程）。 图2.6.2 偏置计算 注：神经网络为什么需要添加偏置&nbsp;&nbsp;？，在机器学习中，以一个单变量的线性回归为例，若其假设函数&nbsp;，用其对如下数据进行拟合： 图2.6.3 没有偏置的线性回归 图2.6.4 带有偏置的线性回归 &nbsp; &nbsp; &nbsp; &nbsp; 从图2.6可以看出，在仅含有权重参数&nbsp;&nbsp;的情况下，假设函数必须经过原点，但这将使其无论如何也无法回归出一条完美拟合的直线，而当添加偏置&nbsp;&nbsp;后，假设函数变为&nbsp;&nbsp;，直线将可以通过任意点，进而对数据进行拟合，这个原理可引申到深度学习的前向传播算法中（&nbsp;），即给网络增加了平移的能力（激活函数则可以改变网络拟合的形状），无论在回归还是分类问题中，都可以使网络更好的拟合数据。 2.7池化（pooling） &nbsp; &nbsp; &nbsp; &nbsp; 在通过卷积获得了特征 (features) 之后，下一步我们希望利用这些特征去做分类。理论上讲，人们可以用所有提取得到的特征去训练分类器，但这样做会面临巨大计算量的挑战。并且容易出现过拟合 (over-fitting)。 &nbsp; &nbsp; &nbsp; &nbsp; 为了解决这个问题，首先回忆一下，我们之所以决定使用卷积后的特征是因为图像具有一种“静态性”的属性，这也就意味着在一个图像区域有用的特征极有可能在另一个区域同样适用。因此，为了描述大的图像，一个很自然的想法就是对不同位置的特征进行聚合统计，例如，人们可以计算图像一个区域上的特征的最大值 (或平均值)。这些统计到的特征不仅具有低得多的维度 (相比使用所有提取得到的特征)，同时还会改善结果(不容易过拟合)。这种聚合的操作就叫做池化 (pooling)。 &nbsp; &nbsp; &nbsp; &nbsp; 除了最大值池化（Max Pooling）之外，还有平均值池化（Average pooling）等。相对于Max池化是从目标区域中取出最大值，Average池化则是计算目标区域的平均值。如图2.6.1所示的即为Max池化的运算过程，Average池化依此类推。 图2.7.1 池化 池化有4个重要特性： 不同于卷积，池化没有需要学习的参数。 池化运算后图像的高度和宽度被压缩，但通过数不会改变。 降低了数据特征，扩大了卷积核的感受野。 微小的位置变化具有鲁棒性，在输入数据发生微小偏差时，池化仍会返回相同的结果。如图2.6.2为例，输入数据在宽度方向上只偏离1个元素时，输出仍为相同的结果（根据数据的不同，有时结果也不相同）。 图2.7.2&nbsp;池化的鲁棒性 注：在图像识别领域，主要使用Max池化。所以通常所说的“池化层”，指的就是Max池化。 2.8全局池化 (Global Pooling) &nbsp; &nbsp; &nbsp; &nbsp; “global pooling”在滑窗内的具体池化方法可以是任意的，所以就会被细分为“global average pooling”、“global max pooling”等。在 Network in Network 的工作中，作者使用GAP（Global average pooling）来取代了传统方式最后的全连接层，直接实现了降维，更重要的是极大地减少了网络的参数(CNN网络中占比最大的参数其实后面的全连接层)。GAP的结构如下图所示: 图2.8 Global average pooling &nbsp; &nbsp; &nbsp; &nbsp; 虽然说GAP就是把池化的窗口大小设置成输入图像的大小，但这并不是GAP内涵的全部。GAP的意义是对整个网络从结构上做正则化防止过拟合。既降低参数避免了全连接带来的过拟合风险，又达到了全连接一样的转换功能。 2.9激活函数（activation functions） &nbsp; &nbsp; &nbsp; &nbsp; 为什么神经网络需要非线性激活函数？事实证明：为了使神经网络能够拟合出各种复杂的函数，必须使用非线性激活函数。在神经网络的正向传播过程中（，&nbsp;），如果我们去掉激活函数&nbsp;&nbsp;，则&nbsp;，这个有时被叫做线性激活函数（更学术点的名字是恒等激励函数，因为它们就是把输入值输出），具体公式如下： 第一层： 第二层： &nbsp; &nbsp; &nbsp; &nbsp; 将&nbsp;&nbsp;带入可得第二层：，令&nbsp;，，则第二层变为： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 依此类推，网络的输出仅仅只是输入特征的线性组合。实际上，无论网络有多少层，整体完全可以仅使用1层表示。同理，引入其他线性函数&nbsp;（如）仍然起不到任何作用，因为线性函数的组合本身仍是线性函数。 注：某些特殊情况可能会用到线性激活函数，如机器学习中回归问题的输出层（不在隐藏层）或是压缩问题（可以在隐藏层）。 &nbsp; &nbsp; &nbsp; &nbsp; 常用的激活函数主要有： （1）sigmoid函数&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;（2）tanh 函数 图2.9.1&nbsp;sigmoid函数 图2.9.2&nbsp;tanh函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; 注：tanh函数的效果总是优于 sigmoid 函数。因为函数值域在-1 和+1的激活函数，其均值是更接近零均值的。在训练一个算法模型时，如果使用 tanh 函数代替sigmoid 函数中心化数据，会使得数据的平均值更接近 0 而不是 0.5。 注：sigmoid 函数和 tanh 函数两者共同的缺点是，在&nbsp;&nbsp;特别大或者特别小的情况下，导数的梯度或者函数的斜率会变得特别小，最后就会接近于 0，导致降低梯度下降的速度。 （3）修正线性单元的函数（ReLu）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;（4）Leaky Relu函数 图2.9.3&nbsp;relu函数 图2.9.4&nbsp;leaky relu函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;，一般&nbsp; 注：Relu 进入负半区的时候，梯度为 0，神经元此时不会训练，产生所谓的稀疏性，而 Leaky ReLu 不会有这问题。 3特性 3.1局部感知 &nbsp; &nbsp; &nbsp; &nbsp; 一般认为，人对外界的认知是从局部到全局的，而对于图像来说，空间联系也是局部的像素联系较为紧密，而距离较远的像素相关性则较弱。因而，每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。网络部分连通的思想，也是受启发于生物学里面的视觉系统结构。视觉皮层的神经元就是局部接受信息的（即这些神经元只响应某些特定区域的刺激）。 &nbsp; &nbsp; &nbsp; &nbsp; 在全连接神经网络中（如图3.1所示），相邻层的神经元全部连接在一起，由于其输入数据是一维结构，故图像需先转换为一维向量，而这个过程，也导致图像完全丢失了“形状”，即像素间的空间信息，从理论上来讲，神经网络几乎能解决所有深度学习问题，但是在处理复杂问题时，往往难以达到理想的效果。 图3.1&nbsp;全连接与局部连接 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;该类网络不仅参数量巨大，且学习速度较慢，即使是一个简单的问题，一般也需要几百次甚至上千次的学习才能收敛，而且易产生过拟合问题，泛化能力较弱。 &nbsp; &nbsp; &nbsp; &nbsp; 而卷积层则可以保持形状不变。当输入图像时，卷积层会以3维数据的形式接收输入数据，并同样以3维数据的形式输出至下一层。因此，在CNN中，可以正确理解图像等具有形状的数据，而且由于局部连接，大大降低了参数量，节省了内存。 3.2参数共享 &nbsp; &nbsp; &nbsp; &nbsp; 也可理解为“平移不变性”。卷积神经网络在图像的某一区域学到某个模式之后，它就可以在图像的任何地方识别这个模式。 图3.2&nbsp;参数共享 &nbsp; &nbsp; &nbsp; &nbsp; 如图3.2所示，假设使用某一特征过滤器（检测器）提取 “手写5” 的特征，那么图片的右下角区域，以及旁边的各个区域都可以使用这个过滤器。每个特征检测器以及输出都可以在输入图片的不同区域中使用同样的参数，以便提取特征 “5”。而对于全连接网络来说，如果模式出现在新的位置，它只能重新学习这个模式。这使得卷积神经网络在处理图像时可以高效利用数据（因为视觉世界从根本上具有平移不变性），只需要更少的训练样本就可以学到具有泛化能力的数据表示。 3.3分层提取 &nbsp; &nbsp; &nbsp; &nbsp; 卷积神经网络可以学到模式的空间层次结构（spatial hierarchies of patterns）。 图3.3&nbsp;分层提取 &nbsp; &nbsp; &nbsp; &nbsp; 如图3.3。第一个卷积层将学习较小的局部模式（比如边缘），第二个卷积层将学习由第一层特征组成的更大的模式，以此类推，层数越高，学到的特征就越全局化。这使得卷积神经网络可以有效地学习越来越复杂、越来越抽象的视觉概念（视觉世界从根本上具有空间层次结构）。 3.4感受野（Receptive field） &nbsp; &nbsp; &nbsp; &nbsp; 感受野用来表示网络内部的不同神经元对原图像的感受范围的大小，换句话说，即为每一层输出的特征图(feature map)上的像素点在原始图像上映射的区域大小。其中神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节，因此感受野的值可以用来大致判断每一层的抽象层次。 图3.4 感受野 &nbsp; &nbsp; &nbsp; &nbsp; 对于卷积核 Conv1 来说，其每个元素在原图像上所能看到的范围是&nbsp;（感受野值为 3），又因为卷积核Conv1的大小为3，步长为2，且卷积核 Conv2的大小为2，步长为1，结合可知，Conv2中的每一个元素可包含 Conv1 中大小为2的元素，而2个 Conv1 所能覆盖原始图像的范围为&nbsp;，故Conv2的感受野值为 5。 3.5多核卷积 &nbsp; &nbsp; &nbsp; &nbsp; 一个卷积核只能提取某一种特征，而计算机对于一幅图像的 “理解” 过程中，往往需要对其多个特征进行学习，其每个卷积核都是一种特征提取方式，就像一个筛子，将图像中符合条件（激活值越大越符合条件）的部分筛选出来。 &nbsp; &nbsp; &nbsp; &nbsp; 如图3.3，我们人类对于猫的理解会包括猫的耳朵、鼻子和眼睛，故其可采取图示的三种卷积核来进行提取，而更底层的特征，如不同形状的曲线、图案等则由其他不同种类的卷积核来进行提取。 4局部卷积 &nbsp; &nbsp; &nbsp; &nbsp; 以LeNet网络举例，其结构如下图所示： 图4.1&nbsp;LeNet &nbsp; &nbsp; &nbsp; &nbsp; 原始图像进来以后，先进入一个卷积层C1，由6个 5x5 的卷积核组成，卷积出28x28的图像，然后下采样到14x14（S2）。接下来，再进一个卷积层C3，由16个5x5的卷积核组成，之后再下采样到5x5（S4）。注意，这里S2与C3的连接方式并不是全连接，而是部分连接，如下图所示： 图4.2&nbsp;卷积的部分连接 &nbsp; &nbsp; &nbsp; &nbsp; 其中行代表S2层的某个节点，列代表C3层的某个节点。我们可以看出，C3的 0 和S2的 0、1、2 连接，C3的 1 和S2的 1、2、3 连接，不过从C3的6~13变为了每次连接4个节点，C3的14变为了5个节点，C3的15与S2的节点全部连接。 &nbsp; &nbsp; &nbsp; &nbsp; 即用不同底层特征的组合，可以得到进一步的高级特征，例如：/ + \ =&nbsp;，再比如，以图3.3为例，第一层的9个卷积核与输入图像 “猫” 是全部连接，从 “猫” 中得到了9种不同的底层特征图（各类底层曲线及图案），而第二层的卷积核1（将用于提取 “猫眼睛”）则只与第一层的特征图1~5相连接（即仅与特征图1~5进行卷积运算），同理，第二层的卷积核3（“猫耳朵”）则只与第一层的特征图7~9相连接。 注：此处所说的 “全部连接” 与BP神经网络中的 “全连接” 有着本质的不同，BP神经网络中的全连接表示网络中的每一个神经元都与上一层的所有神经元相连接，而卷积网络中的 “全部连接” 只是表示该层的卷积核与上一层特征图的所有通道进行卷积，但卷积运算的过程仍是 “局部连接”。 图4.3&nbsp;卷积的“全部连接”与“部分连接” &nbsp; &nbsp; &nbsp; &nbsp; 结合图3.3，以图4.3为例，第一层中卷积核1~9的通道数都与原图像的相同（值都为3），故此处属于卷积的 “全部连接”，也是卷积运算默认的连接方式，而第二层中卷积核1的通道数为5，卷积核3的通道数为3，而上层特征图的通道数为9，故此处属于卷积的 “局部连接”。 注：在此处，卷积核1与卷积核3分别仅与第1~5层特征图、7~9层特征图进行卷积运算，即分别仅在其所处的立体空间中的一个面内移动，分别输出的是一个二维的图像（通道数为1），其与处理视频序列的三维卷积概念不同。 5卷积层和池化层的实现 &nbsp; &nbsp; &nbsp; &nbsp; 如果以传统思维使用for循环来实现的话，则在巨大数据量的情况下，for循环进行计算和切换内存的时间消耗会非常大。而采用向量化的并行计算方式则可以大幅缩短计算时间。 5.1卷积实现 &nbsp; &nbsp; &nbsp; &nbsp; 如图5.1所示，首先对于输入数据，将应用滤波器的区域（3维方块）横向展开为1列以匹配卷积核（权重），然后将卷积核依次展开为1列，计算两者的矩阵乘积，最后将得到的2维数据reshape至4维。 注：为了便于观察，将步幅设置得很大，以使滤波器的应用区域不重叠。而在实际的卷积运算中，滤波器的应用区域几乎都是重叠的。在滤波器的应用区域重叠的情况下，展开后的元素个数会多于原方块的元素个数。因此该方法比普通的实现会消耗更多的内存。 注：在程序中，因为包含批处理数量（N幅图像同时处理），故输入数据是4维，卷积核也是所有共同展开，故也是4维。其中：N——批处理的图像数量（样本数）；FN——滤波器数量；C——通道数；H——高度；W——宽度 图5.1&nbsp;卷积实现 注：im2col 是一个展开函数，名称是“image to column”的缩写，即 “从图像到矩阵” 的意思。Caffe、Chainer等深度学习框架中有名为im2col 的函数，并且在卷积层的实现中，都使用了 im2col。 5.2池化实现 &nbsp; &nbsp; &nbsp; &nbsp; 池化层的实现和卷积层相同，都对输入数据进行展开。不过，池化的情况下，在通道方向上是独立的。如图5.2所示，池化的应用区域按通道单独展开。如图5.2所示，对于输入数据的每一层的池化区域分别展开为2维向量，然后对每一行求最大值得到一个1维向量，最后将该向量reshape为合适的维数。 图5.2&nbsp;池化实现 6可视化 &nbsp; &nbsp; &nbsp; &nbsp; 学习前的卷积核是随机进行初始化的，所以在黑白的浓淡上没有规律可循，但学习后的滤波器变成了有规律的图像。可以发现，通过学习，滤波器被更新成了有规律的滤波器，比如从白到黑渐变的滤波器、含有块状区域（称为blob）的滤波器等。 图6.1&nbsp;可视化 &nbsp; &nbsp; &nbsp; &nbsp; 以图6.1为例，不同卷积核经过学习改变了自身对不同特征的响应程度，如边缘（颜色变化的分界线）和斑块（局部的块状区域）等，其中第2个卷积核对垂直边缘响应，第5个卷积核对水平边缘响应，第9个对倾斜边缘响应，第13个对中心斑块响应。 &nbsp; &nbsp; &nbsp; &nbsp; 上面的结果是针对第1层的卷积层得出的。第1层的卷积层中提取了边缘或斑块等“低级”信息，而在堆叠了多层的CNN中，随着层次加深，提取的信息（准确说，是响应强烈的神经元））也越来越抽象。如图6.2所示，第1层的神经元对边缘或斑块有响应，第3层对纹理有响应，第5层对物体部件有响应，最后的全连接层对物体的类别（狗或车）有响应。 图6.2&nbsp;分层可视化 &nbsp; &nbsp; &nbsp; &nbsp; 也就是说，随着层次加深，神经元从简单的形状向“高级”信息变化。换句话说，就像我们理解东西的“含义”一样，响应的对象在逐渐变化。 7神经网络的本质 &nbsp; &nbsp; &nbsp; &nbsp; 神经网络由大量的节点（或称“神经元”，卷积神经网络中为“特征图”）相互连接构成，每个节点代表一种特定的函数，称为激励函数（Activation Function）。节点之间的连接具有特定的权重，信号经过会进行加权，代表神经网络的记忆。网络的输出则依网络的连接方式、权重值和激励函数的不同而不同。网络本身则代表对自然界某种算法或者函数的逼近，也可以是一种逻辑策略的表达。 &nbsp; 参考文章 《吴恩达深度学习》 《深度学习入门：基于Python的理论与实现》 《Python深度学习》 《行人检测：理论与实践》 深度学习简介(一)——卷积神经网络 Receptive field(感受野) Intuitively Understanding Convolutions for Deep Learning 一文读懂卷积神经网络中的1x1卷积核 Global average pooling (GAP) 深度学习笔记：三维图片分类与三维卷积神经网络" />
<meta property="og:description" content="目录 人类视觉原理 1整体描述 2基本理论 2.1卷积（convolution） 2.2步长（stride） 2.3填充（padding） Valid卷积 Same卷积 2.4三维卷积 2.5 1x1卷积 2.6偏置（bias） 2.7池化（pooling） 2.8全局池化 (Global Pooling) 2.9激活函数 3特性 3.1局部感知 3.2参数共享 3.3分层提取 3.4感受野（Receptive field） 3.5多核卷积 4局部卷积 5卷积层和池化层的实现 5.1卷积实现 5.2池化实现 6可视化 7神经网络的本质 参考文章 人类视觉原理 &nbsp; &nbsp; &nbsp; &nbsp; 深度学习的许多研究成果，离不开对大脑认知原理的研究，尤其是视觉原理的研究。 &nbsp; &nbsp; &nbsp; &nbsp; 1981 年的诺贝尔医学奖，颁发给了 David Hubel（出生于加拿大的美国神经生物学家） 和TorstenWiesel，以及 Roger Sperry。前两位的主要贡献，是“发现了视觉系统的信息处理”，可视皮层是分级的。 &nbsp; &nbsp; &nbsp; &nbsp; 人类的视觉原理如下：从原始信号摄入开始（瞳孔摄入像素 Pixels），接着做初步处理（大脑皮层某些细胞发现边缘和方向），然后抽象（大脑判定，眼前的物体的形状，是圆形的），然后进一步抽象（大脑进一步判定该物体是只气球）。下面是人脑进行人脸识别的一个示例： 图&nbsp;人类视觉原理 &nbsp; &nbsp; &nbsp; &nbsp; 我们可以看到，在最底层特征基本上是类似的，就是各种边缘，越往上，越能提取出此类物体的一些特征（轮子、眼睛、躯干等），到最上层，不同的高级特征最终组合成相应的图像，从而能够让人类准确的区分不同的物体。那么我们可以很自然的想到：可以不可以模仿人类大脑的这个特点，构造多层的神经网络，让计算机来逐层提取图像中的特征，最终在顶层做出分类呢？答案是肯定的，这也是卷积神经网络的灵感来源。 1整体描述 &nbsp; &nbsp; &nbsp; &nbsp; 卷积神经网络（Convolutional Neural Networks, CNN）是一类包含卷积运算且具有深度结构的前馈神经网络（Feedforward Neural Networks）。相比早期的BP神经网络，卷积神经网络最重要的特性在于“局部感知”与“参数共享”，自2012年的AlexNet开始，卷积神经网络就多次成为ImageNet大规模视觉识别竞赛（ImageNet Large Scale Visual Recognition Challenge, ILSVRC）的优胜算法，至此，卷积神经网络开始大放异彩，成为了众多科学领域的研究重点之一。 &nbsp; &nbsp; &nbsp; &nbsp; 如图1所示，一个完整的卷积神经网络可包含卷积层、池化层、全连接层等。其中卷积层用来进行特征提取，池化层用于降低维数，全连接层可用于结果预测（也可使用全卷积网络进行预测）。 图1.1 卷积神经网络示例（手写数字识别） 注：卷积运算也属于一种线性运算，故需要进行非线性处理，即添加激活函数（示例中为修正线性单元的函数，即 Relu 激活函数）。 &nbsp; &nbsp; &nbsp; &nbsp; 对于卷积层，其详细描述如图1.2所示 图1.2&nbsp;卷积层描述 其运算过程主要由以下4步组成： 原图像（尺寸为&nbsp;）分别与&nbsp;&nbsp;个&nbsp;&nbsp;的卷积核（又名滤波器，fliter）进行卷积运算，得到&nbsp;&nbsp;个&nbsp;&nbsp;的特征图（feature map） 每个特征图分别添加不同的偏置（bias），具体为特征图中的每个元素&nbsp; 对每个特征图添加激活函数&nbsp;，进行非线性运算 将这&nbsp;&nbsp;个特征图依次叠加，得到最终的特征图（尺寸为&nbsp;） 注：对于某一个卷积层，其不同特征图所使用的激活函数相同，但不同卷积层所使用的激活函数可以不同，该步骤在整体描述中为突出与神经网络的相似性而单独提出，但实际上其仍属于卷积层的一部分。 &nbsp; &nbsp; &nbsp; &nbsp; 对于池化层，其详细描述如图1.3所示： 图1.3&nbsp;池化层描述 &nbsp; &nbsp; &nbsp; &nbsp; 承接上例，对于&nbsp;&nbsp;的特征图，其池化过程仅需通过池化核对该特征图进行池化运算即可得到输出。 &nbsp; &nbsp; &nbsp; &nbsp; 然后将得到的特征图经过全连接层进行处理并由softmax算法进行回归即可得到最终的输出结果。 注：全连接层即为机器学习中常见的由神经元构成的神经网络。 （关于神经网络及softmax回归可参考：神经网络的前向及反向传播、深度学习笔记） 2基本理论 &nbsp; 2.1卷积（convolution） &nbsp; &nbsp; &nbsp; &nbsp; 卷积神经网络中的核心即为卷积运算，其相当于图像处理中的“滤波器运算”。 &nbsp; &nbsp; &nbsp; &nbsp; 对于一个&nbsp;&nbsp;大小的卷积核&nbsp;，其对某一原图像&nbsp;&nbsp;进行卷积运算的过程为：卷积核&nbsp;&nbsp;中的每一个权值&nbsp;&nbsp;分别和覆盖的原图像&nbsp;&nbsp;中所对应的像素&nbsp;&nbsp;相乘，然后再求和。计算公式为： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如图2.1所示，对一幅图像的一个完整的卷积运算过程为：卷积核以一定的间隔滑动，并对所覆盖的区域进行卷积运算得到值&nbsp;，直至遍历完整幅图像。 图2.1 卷积运算 &nbsp; &nbsp; &nbsp; &nbsp; 一个标准的卷积运算以图2.2为例，其卷积核每次覆盖原图像的9个像素，共滑动4次，得到了一个&nbsp;&nbsp;的二维数据。对于一个大小为&nbsp;&nbsp;的原图像，经过大小为&nbsp;&nbsp;的卷积运算后，其输出图像的尺寸为&nbsp;。 图2.2&nbsp;标准的二维卷积运算 2.2步长（stride） &nbsp; &nbsp; &nbsp; &nbsp; 滑动一定的间距，但这个间距该如何定义呢? 这个概念就是卷积的 “步长”（stride），设置卷积的步长可使卷积过程跳过原图像中的某些像素。结合步长&nbsp;&nbsp;操作后，其输出图像的尺寸为&nbsp;。stride =&nbsp;1 表示卷积核滑过每一个相距是 1 的像素，是最基本的单步滑动，作为标准卷积模式。Stride 是 2 表示卷积核的移动步长是 2，跳过相邻像素，输出图像缩小为原来的 1/2。Stride 是 3 表示卷积核的移动步长是 3，跳过 2 个相邻像素，图像缩小为原来的 1/3，以此类推。 图2.3&nbsp;一个步长为2的卷积运算 2.3填充（padding） &nbsp; &nbsp; &nbsp; &nbsp; 在标准的卷积过程中，存在两个问题： 每次卷积运算后，图像就会缩小，在经历多次运算后，图像终会失去其形状，变为&nbsp;&nbsp;的 “柱状”。 对于图像边缘的像素，其只被一个输出所触碰或者使用，但对于图像中间的像素，则会有多个卷积核与之重叠。所以那些在角落或者边缘区域的像素点在输出中采用较少，意味着卷积过程丢掉了图像边缘位置的许多信息。 &nbsp; &nbsp; &nbsp; &nbsp; 对于这个问题，可以采用额外的 “假”&nbsp;像素（通常值为 0， 因此经常使用的术语 ”零填充“ ）填充边缘。这样，在滑动时的卷积核可以允许原始边缘像素位于其中心，同时延伸到边缘之外的假像素。假设填充的像素大小为&nbsp;&nbsp;，则&nbsp;&nbsp;就变成了&nbsp;&nbsp;，故其输出图像的尺寸为&nbsp;。 &nbsp; &nbsp; &nbsp; &nbsp; 至于选择填充多少像素，通常有两个选择，分别叫做 Valid 卷积和 Same 卷积。 Valid卷积 &nbsp; &nbsp; &nbsp; &nbsp; Valid 卷积意味着不填充，如之前所述，图像会经历卷积运算后逐渐缩小，输出的图像尺寸即为上述公式：。 Same卷积 &nbsp; &nbsp; &nbsp; &nbsp; Same卷积意味填充后，输出图像的尺寸与输入图像的尺寸相同，根据上述公式，令&nbsp;，可得到。当&nbsp;&nbsp;时，。 注：一般卷积核&nbsp;&nbsp;的大小会选择一个奇数，如 3 \ 5 \ 7 等。主要因为： 如果&nbsp; 是一个偶数，那么只能使用一些不对称填充。只有当&nbsp; 是奇数时，Same 卷积才会有自然的填充，即可以选择同样的数量填充四周。 当卷积核&nbsp;&nbsp;是奇数时，其只有一个中心点，在具体的程序实现过程中会便于指出卷积核的位置。 2.4三维卷积 &nbsp; &nbsp; &nbsp; &nbsp; 此处可分为两种，一种是常见的多通道图像（如RGB彩色图像）的三维卷积（也是实际中最常用的卷积方式），与之前所举的二维卷积例子原理相似只是通道数不为1，具体如下图所示： 图2.4&nbsp;三维卷积 &nbsp; &nbsp; &nbsp; &nbsp; 在该卷积过程中，卷积核n（包含3个小卷积核） 中的每个小卷积核分别与原图像中所对应的图层进行卷积运算（如卷积核1中左边的小卷积核与原图像中左边的红色图层进行卷积运算，得到红色的单通道特征图；卷积核1中中间的小卷积核则与原图像中间的绿色图层进行卷积运算，得到绿色的单通道特征图，以此类推），分别生成3个单通道特征图，然后将这3个特征图按元素对应相加，即可得到卷积核n 生成的单通道特征图，最后将 n 个特征图相叠加即可得到最终的 n通道特征图。 注：该类卷积方式也是图像识别与检测中最常见的运算方式。其维度计算如下。 对于第&nbsp;&nbsp;层卷积，定义符号如下： &nbsp;卷积核尺寸（filter） &nbsp;填充尺寸（padding） &nbsp;步长（stride） &nbsp;图像的高度（height） &nbsp;图像的宽度（width） &nbsp;通道数（channel&nbsp;number） 定义输入图像（第&nbsp;&nbsp;层图像）的尺寸为： 定义共有&nbsp;&nbsp;个&nbsp;&nbsp;卷积核（程序中定义尺寸为 ）对输入图像进行卷积（卷积核的通道数与输入图像一致） &nbsp; &nbsp; &nbsp; &nbsp; 则输出图像（第&nbsp;&nbsp;层图像）的高度&nbsp;，宽度，通道数为卷积核的个数&nbsp;。即输出图像尺寸为：。 注：通过卷积网络中的权重所指的就是卷积核的参数，也就是也就是所有卷积核的集合再乘以卷积核的总数量，即，此处关于高度，宽度和通道的顺序并没有完全统一的标准。 &nbsp; &nbsp; &nbsp; &nbsp; 第二种三维卷积优点类似于卷积的局部连接，但该类卷积运算的卷积核并非只与原图像中的某几层相连接（在一个固定平面内滑动），而是以空间滑动的方式与原图像的所有像素进行卷积。 图2.5&nbsp;三维卷积 &nbsp; &nbsp; &nbsp; &nbsp; 以上图为例，&nbsp;的卷积核在&nbsp;&nbsp;原图像上以步长为1的方式在空间上滑动遍历所有像素进行卷积，最终生成一个&nbsp;&nbsp;的特征图。该类卷积常用于视频的事件检测、三维医学影像等领域。 2.5 1x1卷积 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;卷积也称作 “Network in Network”，其本质上相当于全连接层，以一个&nbsp;&nbsp;的输入图像为例，卷积（通道数与输入图像一致，即尺寸为&nbsp;）所实现的功能就是依次遍历这28个单元格作乘积再求和，增加偏置后应用激活函数（输出图像的高和宽不变，通道数为卷积核的数量）。这时，输入图像的28个不同通道的数据可看作是神经网络的输入向量&nbsp;，而卷积核则可看作是权重&nbsp;，而多个卷积核即构成了神经网络中的隐藏层。 &nbsp; &nbsp; &nbsp; &nbsp; 其主要有2个功能： 降维/升维，即改变图像的通道数，本质上就是通道间信息的线性组合变化。 增加非线性，卷积核，可以在保持图像尺度不变的（即不损失分辨率）的前提下增加非线性特性（利用后接的非线性激活函数）。 2.6偏置（bias） &nbsp; &nbsp; &nbsp; &nbsp; 参考图1.2，每个卷积核都有一个偏置参数&nbsp;，它是一个实数。偏差包含了这些变量，它是该维度上的一个向量，其在代码中表示为一个&nbsp;&nbsp;&nbsp;的四维向量或四维张量。如图2.6所示，三维卷积中，偏置中的每一个单元分别作用于特征图中的每一个图层。 图2.6.1 添加偏置 &nbsp; &nbsp; &nbsp; &nbsp; 其具体计算过程如图2.7所示（以二维卷积为例，也可理解为图2.6中的某一个偏置单元与特征图中对应图层的计算过程）。 图2.6.2 偏置计算 注：神经网络为什么需要添加偏置&nbsp;&nbsp;？，在机器学习中，以一个单变量的线性回归为例，若其假设函数&nbsp;，用其对如下数据进行拟合： 图2.6.3 没有偏置的线性回归 图2.6.4 带有偏置的线性回归 &nbsp; &nbsp; &nbsp; &nbsp; 从图2.6可以看出，在仅含有权重参数&nbsp;&nbsp;的情况下，假设函数必须经过原点，但这将使其无论如何也无法回归出一条完美拟合的直线，而当添加偏置&nbsp;&nbsp;后，假设函数变为&nbsp;&nbsp;，直线将可以通过任意点，进而对数据进行拟合，这个原理可引申到深度学习的前向传播算法中（&nbsp;），即给网络增加了平移的能力（激活函数则可以改变网络拟合的形状），无论在回归还是分类问题中，都可以使网络更好的拟合数据。 2.7池化（pooling） &nbsp; &nbsp; &nbsp; &nbsp; 在通过卷积获得了特征 (features) 之后，下一步我们希望利用这些特征去做分类。理论上讲，人们可以用所有提取得到的特征去训练分类器，但这样做会面临巨大计算量的挑战。并且容易出现过拟合 (over-fitting)。 &nbsp; &nbsp; &nbsp; &nbsp; 为了解决这个问题，首先回忆一下，我们之所以决定使用卷积后的特征是因为图像具有一种“静态性”的属性，这也就意味着在一个图像区域有用的特征极有可能在另一个区域同样适用。因此，为了描述大的图像，一个很自然的想法就是对不同位置的特征进行聚合统计，例如，人们可以计算图像一个区域上的特征的最大值 (或平均值)。这些统计到的特征不仅具有低得多的维度 (相比使用所有提取得到的特征)，同时还会改善结果(不容易过拟合)。这种聚合的操作就叫做池化 (pooling)。 &nbsp; &nbsp; &nbsp; &nbsp; 除了最大值池化（Max Pooling）之外，还有平均值池化（Average pooling）等。相对于Max池化是从目标区域中取出最大值，Average池化则是计算目标区域的平均值。如图2.6.1所示的即为Max池化的运算过程，Average池化依此类推。 图2.7.1 池化 池化有4个重要特性： 不同于卷积，池化没有需要学习的参数。 池化运算后图像的高度和宽度被压缩，但通过数不会改变。 降低了数据特征，扩大了卷积核的感受野。 微小的位置变化具有鲁棒性，在输入数据发生微小偏差时，池化仍会返回相同的结果。如图2.6.2为例，输入数据在宽度方向上只偏离1个元素时，输出仍为相同的结果（根据数据的不同，有时结果也不相同）。 图2.7.2&nbsp;池化的鲁棒性 注：在图像识别领域，主要使用Max池化。所以通常所说的“池化层”，指的就是Max池化。 2.8全局池化 (Global Pooling) &nbsp; &nbsp; &nbsp; &nbsp; “global pooling”在滑窗内的具体池化方法可以是任意的，所以就会被细分为“global average pooling”、“global max pooling”等。在 Network in Network 的工作中，作者使用GAP（Global average pooling）来取代了传统方式最后的全连接层，直接实现了降维，更重要的是极大地减少了网络的参数(CNN网络中占比最大的参数其实后面的全连接层)。GAP的结构如下图所示: 图2.8 Global average pooling &nbsp; &nbsp; &nbsp; &nbsp; 虽然说GAP就是把池化的窗口大小设置成输入图像的大小，但这并不是GAP内涵的全部。GAP的意义是对整个网络从结构上做正则化防止过拟合。既降低参数避免了全连接带来的过拟合风险，又达到了全连接一样的转换功能。 2.9激活函数（activation functions） &nbsp; &nbsp; &nbsp; &nbsp; 为什么神经网络需要非线性激活函数？事实证明：为了使神经网络能够拟合出各种复杂的函数，必须使用非线性激活函数。在神经网络的正向传播过程中（，&nbsp;），如果我们去掉激活函数&nbsp;&nbsp;，则&nbsp;，这个有时被叫做线性激活函数（更学术点的名字是恒等激励函数，因为它们就是把输入值输出），具体公式如下： 第一层： 第二层： &nbsp; &nbsp; &nbsp; &nbsp; 将&nbsp;&nbsp;带入可得第二层：，令&nbsp;，，则第二层变为： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 依此类推，网络的输出仅仅只是输入特征的线性组合。实际上，无论网络有多少层，整体完全可以仅使用1层表示。同理，引入其他线性函数&nbsp;（如）仍然起不到任何作用，因为线性函数的组合本身仍是线性函数。 注：某些特殊情况可能会用到线性激活函数，如机器学习中回归问题的输出层（不在隐藏层）或是压缩问题（可以在隐藏层）。 &nbsp; &nbsp; &nbsp; &nbsp; 常用的激活函数主要有： （1）sigmoid函数&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;（2）tanh 函数 图2.9.1&nbsp;sigmoid函数 图2.9.2&nbsp;tanh函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; 注：tanh函数的效果总是优于 sigmoid 函数。因为函数值域在-1 和+1的激活函数，其均值是更接近零均值的。在训练一个算法模型时，如果使用 tanh 函数代替sigmoid 函数中心化数据，会使得数据的平均值更接近 0 而不是 0.5。 注：sigmoid 函数和 tanh 函数两者共同的缺点是，在&nbsp;&nbsp;特别大或者特别小的情况下，导数的梯度或者函数的斜率会变得特别小，最后就会接近于 0，导致降低梯度下降的速度。 （3）修正线性单元的函数（ReLu）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;（4）Leaky Relu函数 图2.9.3&nbsp;relu函数 图2.9.4&nbsp;leaky relu函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;，一般&nbsp; 注：Relu 进入负半区的时候，梯度为 0，神经元此时不会训练，产生所谓的稀疏性，而 Leaky ReLu 不会有这问题。 3特性 3.1局部感知 &nbsp; &nbsp; &nbsp; &nbsp; 一般认为，人对外界的认知是从局部到全局的，而对于图像来说，空间联系也是局部的像素联系较为紧密，而距离较远的像素相关性则较弱。因而，每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。网络部分连通的思想，也是受启发于生物学里面的视觉系统结构。视觉皮层的神经元就是局部接受信息的（即这些神经元只响应某些特定区域的刺激）。 &nbsp; &nbsp; &nbsp; &nbsp; 在全连接神经网络中（如图3.1所示），相邻层的神经元全部连接在一起，由于其输入数据是一维结构，故图像需先转换为一维向量，而这个过程，也导致图像完全丢失了“形状”，即像素间的空间信息，从理论上来讲，神经网络几乎能解决所有深度学习问题，但是在处理复杂问题时，往往难以达到理想的效果。 图3.1&nbsp;全连接与局部连接 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;该类网络不仅参数量巨大，且学习速度较慢，即使是一个简单的问题，一般也需要几百次甚至上千次的学习才能收敛，而且易产生过拟合问题，泛化能力较弱。 &nbsp; &nbsp; &nbsp; &nbsp; 而卷积层则可以保持形状不变。当输入图像时，卷积层会以3维数据的形式接收输入数据，并同样以3维数据的形式输出至下一层。因此，在CNN中，可以正确理解图像等具有形状的数据，而且由于局部连接，大大降低了参数量，节省了内存。 3.2参数共享 &nbsp; &nbsp; &nbsp; &nbsp; 也可理解为“平移不变性”。卷积神经网络在图像的某一区域学到某个模式之后，它就可以在图像的任何地方识别这个模式。 图3.2&nbsp;参数共享 &nbsp; &nbsp; &nbsp; &nbsp; 如图3.2所示，假设使用某一特征过滤器（检测器）提取 “手写5” 的特征，那么图片的右下角区域，以及旁边的各个区域都可以使用这个过滤器。每个特征检测器以及输出都可以在输入图片的不同区域中使用同样的参数，以便提取特征 “5”。而对于全连接网络来说，如果模式出现在新的位置，它只能重新学习这个模式。这使得卷积神经网络在处理图像时可以高效利用数据（因为视觉世界从根本上具有平移不变性），只需要更少的训练样本就可以学到具有泛化能力的数据表示。 3.3分层提取 &nbsp; &nbsp; &nbsp; &nbsp; 卷积神经网络可以学到模式的空间层次结构（spatial hierarchies of patterns）。 图3.3&nbsp;分层提取 &nbsp; &nbsp; &nbsp; &nbsp; 如图3.3。第一个卷积层将学习较小的局部模式（比如边缘），第二个卷积层将学习由第一层特征组成的更大的模式，以此类推，层数越高，学到的特征就越全局化。这使得卷积神经网络可以有效地学习越来越复杂、越来越抽象的视觉概念（视觉世界从根本上具有空间层次结构）。 3.4感受野（Receptive field） &nbsp; &nbsp; &nbsp; &nbsp; 感受野用来表示网络内部的不同神经元对原图像的感受范围的大小，换句话说，即为每一层输出的特征图(feature map)上的像素点在原始图像上映射的区域大小。其中神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节，因此感受野的值可以用来大致判断每一层的抽象层次。 图3.4 感受野 &nbsp; &nbsp; &nbsp; &nbsp; 对于卷积核 Conv1 来说，其每个元素在原图像上所能看到的范围是&nbsp;（感受野值为 3），又因为卷积核Conv1的大小为3，步长为2，且卷积核 Conv2的大小为2，步长为1，结合可知，Conv2中的每一个元素可包含 Conv1 中大小为2的元素，而2个 Conv1 所能覆盖原始图像的范围为&nbsp;，故Conv2的感受野值为 5。 3.5多核卷积 &nbsp; &nbsp; &nbsp; &nbsp; 一个卷积核只能提取某一种特征，而计算机对于一幅图像的 “理解” 过程中，往往需要对其多个特征进行学习，其每个卷积核都是一种特征提取方式，就像一个筛子，将图像中符合条件（激活值越大越符合条件）的部分筛选出来。 &nbsp; &nbsp; &nbsp; &nbsp; 如图3.3，我们人类对于猫的理解会包括猫的耳朵、鼻子和眼睛，故其可采取图示的三种卷积核来进行提取，而更底层的特征，如不同形状的曲线、图案等则由其他不同种类的卷积核来进行提取。 4局部卷积 &nbsp; &nbsp; &nbsp; &nbsp; 以LeNet网络举例，其结构如下图所示： 图4.1&nbsp;LeNet &nbsp; &nbsp; &nbsp; &nbsp; 原始图像进来以后，先进入一个卷积层C1，由6个 5x5 的卷积核组成，卷积出28x28的图像，然后下采样到14x14（S2）。接下来，再进一个卷积层C3，由16个5x5的卷积核组成，之后再下采样到5x5（S4）。注意，这里S2与C3的连接方式并不是全连接，而是部分连接，如下图所示： 图4.2&nbsp;卷积的部分连接 &nbsp; &nbsp; &nbsp; &nbsp; 其中行代表S2层的某个节点，列代表C3层的某个节点。我们可以看出，C3的 0 和S2的 0、1、2 连接，C3的 1 和S2的 1、2、3 连接，不过从C3的6~13变为了每次连接4个节点，C3的14变为了5个节点，C3的15与S2的节点全部连接。 &nbsp; &nbsp; &nbsp; &nbsp; 即用不同底层特征的组合，可以得到进一步的高级特征，例如：/ + \ =&nbsp;，再比如，以图3.3为例，第一层的9个卷积核与输入图像 “猫” 是全部连接，从 “猫” 中得到了9种不同的底层特征图（各类底层曲线及图案），而第二层的卷积核1（将用于提取 “猫眼睛”）则只与第一层的特征图1~5相连接（即仅与特征图1~5进行卷积运算），同理，第二层的卷积核3（“猫耳朵”）则只与第一层的特征图7~9相连接。 注：此处所说的 “全部连接” 与BP神经网络中的 “全连接” 有着本质的不同，BP神经网络中的全连接表示网络中的每一个神经元都与上一层的所有神经元相连接，而卷积网络中的 “全部连接” 只是表示该层的卷积核与上一层特征图的所有通道进行卷积，但卷积运算的过程仍是 “局部连接”。 图4.3&nbsp;卷积的“全部连接”与“部分连接” &nbsp; &nbsp; &nbsp; &nbsp; 结合图3.3，以图4.3为例，第一层中卷积核1~9的通道数都与原图像的相同（值都为3），故此处属于卷积的 “全部连接”，也是卷积运算默认的连接方式，而第二层中卷积核1的通道数为5，卷积核3的通道数为3，而上层特征图的通道数为9，故此处属于卷积的 “局部连接”。 注：在此处，卷积核1与卷积核3分别仅与第1~5层特征图、7~9层特征图进行卷积运算，即分别仅在其所处的立体空间中的一个面内移动，分别输出的是一个二维的图像（通道数为1），其与处理视频序列的三维卷积概念不同。 5卷积层和池化层的实现 &nbsp; &nbsp; &nbsp; &nbsp; 如果以传统思维使用for循环来实现的话，则在巨大数据量的情况下，for循环进行计算和切换内存的时间消耗会非常大。而采用向量化的并行计算方式则可以大幅缩短计算时间。 5.1卷积实现 &nbsp; &nbsp; &nbsp; &nbsp; 如图5.1所示，首先对于输入数据，将应用滤波器的区域（3维方块）横向展开为1列以匹配卷积核（权重），然后将卷积核依次展开为1列，计算两者的矩阵乘积，最后将得到的2维数据reshape至4维。 注：为了便于观察，将步幅设置得很大，以使滤波器的应用区域不重叠。而在实际的卷积运算中，滤波器的应用区域几乎都是重叠的。在滤波器的应用区域重叠的情况下，展开后的元素个数会多于原方块的元素个数。因此该方法比普通的实现会消耗更多的内存。 注：在程序中，因为包含批处理数量（N幅图像同时处理），故输入数据是4维，卷积核也是所有共同展开，故也是4维。其中：N——批处理的图像数量（样本数）；FN——滤波器数量；C——通道数；H——高度；W——宽度 图5.1&nbsp;卷积实现 注：im2col 是一个展开函数，名称是“image to column”的缩写，即 “从图像到矩阵” 的意思。Caffe、Chainer等深度学习框架中有名为im2col 的函数，并且在卷积层的实现中，都使用了 im2col。 5.2池化实现 &nbsp; &nbsp; &nbsp; &nbsp; 池化层的实现和卷积层相同，都对输入数据进行展开。不过，池化的情况下，在通道方向上是独立的。如图5.2所示，池化的应用区域按通道单独展开。如图5.2所示，对于输入数据的每一层的池化区域分别展开为2维向量，然后对每一行求最大值得到一个1维向量，最后将该向量reshape为合适的维数。 图5.2&nbsp;池化实现 6可视化 &nbsp; &nbsp; &nbsp; &nbsp; 学习前的卷积核是随机进行初始化的，所以在黑白的浓淡上没有规律可循，但学习后的滤波器变成了有规律的图像。可以发现，通过学习，滤波器被更新成了有规律的滤波器，比如从白到黑渐变的滤波器、含有块状区域（称为blob）的滤波器等。 图6.1&nbsp;可视化 &nbsp; &nbsp; &nbsp; &nbsp; 以图6.1为例，不同卷积核经过学习改变了自身对不同特征的响应程度，如边缘（颜色变化的分界线）和斑块（局部的块状区域）等，其中第2个卷积核对垂直边缘响应，第5个卷积核对水平边缘响应，第9个对倾斜边缘响应，第13个对中心斑块响应。 &nbsp; &nbsp; &nbsp; &nbsp; 上面的结果是针对第1层的卷积层得出的。第1层的卷积层中提取了边缘或斑块等“低级”信息，而在堆叠了多层的CNN中，随着层次加深，提取的信息（准确说，是响应强烈的神经元））也越来越抽象。如图6.2所示，第1层的神经元对边缘或斑块有响应，第3层对纹理有响应，第5层对物体部件有响应，最后的全连接层对物体的类别（狗或车）有响应。 图6.2&nbsp;分层可视化 &nbsp; &nbsp; &nbsp; &nbsp; 也就是说，随着层次加深，神经元从简单的形状向“高级”信息变化。换句话说，就像我们理解东西的“含义”一样，响应的对象在逐渐变化。 7神经网络的本质 &nbsp; &nbsp; &nbsp; &nbsp; 神经网络由大量的节点（或称“神经元”，卷积神经网络中为“特征图”）相互连接构成，每个节点代表一种特定的函数，称为激励函数（Activation Function）。节点之间的连接具有特定的权重，信号经过会进行加权，代表神经网络的记忆。网络的输出则依网络的连接方式、权重值和激励函数的不同而不同。网络本身则代表对自然界某种算法或者函数的逼近，也可以是一种逻辑策略的表达。 &nbsp; 参考文章 《吴恩达深度学习》 《深度学习入门：基于Python的理论与实现》 《Python深度学习》 《行人检测：理论与实践》 深度学习简介(一)——卷积神经网络 Receptive field(感受野) Intuitively Understanding Convolutions for Deep Learning 一文读懂卷积神经网络中的1x1卷积核 Global average pooling (GAP) 深度学习笔记：三维图片分类与三维卷积神经网络" />
<link rel="canonical" href="https://uzzz.org/2019/08/08/793223.html" />
<meta property="og:url" content="https://uzzz.org/2019/08/08/793223.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-08T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"目录 人类视觉原理 1整体描述 2基本理论 2.1卷积（convolution） 2.2步长（stride） 2.3填充（padding） Valid卷积 Same卷积 2.4三维卷积 2.5 1x1卷积 2.6偏置（bias） 2.7池化（pooling） 2.8全局池化 (Global Pooling) 2.9激活函数 3特性 3.1局部感知 3.2参数共享 3.3分层提取 3.4感受野（Receptive field） 3.5多核卷积 4局部卷积 5卷积层和池化层的实现 5.1卷积实现 5.2池化实现 6可视化 7神经网络的本质 参考文章 人类视觉原理 &nbsp; &nbsp; &nbsp; &nbsp; 深度学习的许多研究成果，离不开对大脑认知原理的研究，尤其是视觉原理的研究。 &nbsp; &nbsp; &nbsp; &nbsp; 1981 年的诺贝尔医学奖，颁发给了 David Hubel（出生于加拿大的美国神经生物学家） 和TorstenWiesel，以及 Roger Sperry。前两位的主要贡献，是“发现了视觉系统的信息处理”，可视皮层是分级的。 &nbsp; &nbsp; &nbsp; &nbsp; 人类的视觉原理如下：从原始信号摄入开始（瞳孔摄入像素 Pixels），接着做初步处理（大脑皮层某些细胞发现边缘和方向），然后抽象（大脑判定，眼前的物体的形状，是圆形的），然后进一步抽象（大脑进一步判定该物体是只气球）。下面是人脑进行人脸识别的一个示例： 图&nbsp;人类视觉原理 &nbsp; &nbsp; &nbsp; &nbsp; 我们可以看到，在最底层特征基本上是类似的，就是各种边缘，越往上，越能提取出此类物体的一些特征（轮子、眼睛、躯干等），到最上层，不同的高级特征最终组合成相应的图像，从而能够让人类准确的区分不同的物体。那么我们可以很自然的想到：可以不可以模仿人类大脑的这个特点，构造多层的神经网络，让计算机来逐层提取图像中的特征，最终在顶层做出分类呢？答案是肯定的，这也是卷积神经网络的灵感来源。 1整体描述 &nbsp; &nbsp; &nbsp; &nbsp; 卷积神经网络（Convolutional Neural Networks, CNN）是一类包含卷积运算且具有深度结构的前馈神经网络（Feedforward Neural Networks）。相比早期的BP神经网络，卷积神经网络最重要的特性在于“局部感知”与“参数共享”，自2012年的AlexNet开始，卷积神经网络就多次成为ImageNet大规模视觉识别竞赛（ImageNet Large Scale Visual Recognition Challenge, ILSVRC）的优胜算法，至此，卷积神经网络开始大放异彩，成为了众多科学领域的研究重点之一。 &nbsp; &nbsp; &nbsp; &nbsp; 如图1所示，一个完整的卷积神经网络可包含卷积层、池化层、全连接层等。其中卷积层用来进行特征提取，池化层用于降低维数，全连接层可用于结果预测（也可使用全卷积网络进行预测）。 图1.1 卷积神经网络示例（手写数字识别） 注：卷积运算也属于一种线性运算，故需要进行非线性处理，即添加激活函数（示例中为修正线性单元的函数，即 Relu 激活函数）。 &nbsp; &nbsp; &nbsp; &nbsp; 对于卷积层，其详细描述如图1.2所示 图1.2&nbsp;卷积层描述 其运算过程主要由以下4步组成： 原图像（尺寸为&nbsp;）分别与&nbsp;&nbsp;个&nbsp;&nbsp;的卷积核（又名滤波器，fliter）进行卷积运算，得到&nbsp;&nbsp;个&nbsp;&nbsp;的特征图（feature map） 每个特征图分别添加不同的偏置（bias），具体为特征图中的每个元素&nbsp; 对每个特征图添加激活函数&nbsp;，进行非线性运算 将这&nbsp;&nbsp;个特征图依次叠加，得到最终的特征图（尺寸为&nbsp;） 注：对于某一个卷积层，其不同特征图所使用的激活函数相同，但不同卷积层所使用的激活函数可以不同，该步骤在整体描述中为突出与神经网络的相似性而单独提出，但实际上其仍属于卷积层的一部分。 &nbsp; &nbsp; &nbsp; &nbsp; 对于池化层，其详细描述如图1.3所示： 图1.3&nbsp;池化层描述 &nbsp; &nbsp; &nbsp; &nbsp; 承接上例，对于&nbsp;&nbsp;的特征图，其池化过程仅需通过池化核对该特征图进行池化运算即可得到输出。 &nbsp; &nbsp; &nbsp; &nbsp; 然后将得到的特征图经过全连接层进行处理并由softmax算法进行回归即可得到最终的输出结果。 注：全连接层即为机器学习中常见的由神经元构成的神经网络。 （关于神经网络及softmax回归可参考：神经网络的前向及反向传播、深度学习笔记） 2基本理论 &nbsp; 2.1卷积（convolution） &nbsp; &nbsp; &nbsp; &nbsp; 卷积神经网络中的核心即为卷积运算，其相当于图像处理中的“滤波器运算”。 &nbsp; &nbsp; &nbsp; &nbsp; 对于一个&nbsp;&nbsp;大小的卷积核&nbsp;，其对某一原图像&nbsp;&nbsp;进行卷积运算的过程为：卷积核&nbsp;&nbsp;中的每一个权值&nbsp;&nbsp;分别和覆盖的原图像&nbsp;&nbsp;中所对应的像素&nbsp;&nbsp;相乘，然后再求和。计算公式为： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如图2.1所示，对一幅图像的一个完整的卷积运算过程为：卷积核以一定的间隔滑动，并对所覆盖的区域进行卷积运算得到值&nbsp;，直至遍历完整幅图像。 图2.1 卷积运算 &nbsp; &nbsp; &nbsp; &nbsp; 一个标准的卷积运算以图2.2为例，其卷积核每次覆盖原图像的9个像素，共滑动4次，得到了一个&nbsp;&nbsp;的二维数据。对于一个大小为&nbsp;&nbsp;的原图像，经过大小为&nbsp;&nbsp;的卷积运算后，其输出图像的尺寸为&nbsp;。 图2.2&nbsp;标准的二维卷积运算 2.2步长（stride） &nbsp; &nbsp; &nbsp; &nbsp; 滑动一定的间距，但这个间距该如何定义呢? 这个概念就是卷积的 “步长”（stride），设置卷积的步长可使卷积过程跳过原图像中的某些像素。结合步长&nbsp;&nbsp;操作后，其输出图像的尺寸为&nbsp;。stride =&nbsp;1 表示卷积核滑过每一个相距是 1 的像素，是最基本的单步滑动，作为标准卷积模式。Stride 是 2 表示卷积核的移动步长是 2，跳过相邻像素，输出图像缩小为原来的 1/2。Stride 是 3 表示卷积核的移动步长是 3，跳过 2 个相邻像素，图像缩小为原来的 1/3，以此类推。 图2.3&nbsp;一个步长为2的卷积运算 2.3填充（padding） &nbsp; &nbsp; &nbsp; &nbsp; 在标准的卷积过程中，存在两个问题： 每次卷积运算后，图像就会缩小，在经历多次运算后，图像终会失去其形状，变为&nbsp;&nbsp;的 “柱状”。 对于图像边缘的像素，其只被一个输出所触碰或者使用，但对于图像中间的像素，则会有多个卷积核与之重叠。所以那些在角落或者边缘区域的像素点在输出中采用较少，意味着卷积过程丢掉了图像边缘位置的许多信息。 &nbsp; &nbsp; &nbsp; &nbsp; 对于这个问题，可以采用额外的 “假”&nbsp;像素（通常值为 0， 因此经常使用的术语 ”零填充“ ）填充边缘。这样，在滑动时的卷积核可以允许原始边缘像素位于其中心，同时延伸到边缘之外的假像素。假设填充的像素大小为&nbsp;&nbsp;，则&nbsp;&nbsp;就变成了&nbsp;&nbsp;，故其输出图像的尺寸为&nbsp;。 &nbsp; &nbsp; &nbsp; &nbsp; 至于选择填充多少像素，通常有两个选择，分别叫做 Valid 卷积和 Same 卷积。 Valid卷积 &nbsp; &nbsp; &nbsp; &nbsp; Valid 卷积意味着不填充，如之前所述，图像会经历卷积运算后逐渐缩小，输出的图像尺寸即为上述公式：。 Same卷积 &nbsp; &nbsp; &nbsp; &nbsp; Same卷积意味填充后，输出图像的尺寸与输入图像的尺寸相同，根据上述公式，令&nbsp;，可得到。当&nbsp;&nbsp;时，。 注：一般卷积核&nbsp;&nbsp;的大小会选择一个奇数，如 3 \\ 5 \\ 7 等。主要因为： 如果&nbsp; 是一个偶数，那么只能使用一些不对称填充。只有当&nbsp; 是奇数时，Same 卷积才会有自然的填充，即可以选择同样的数量填充四周。 当卷积核&nbsp;&nbsp;是奇数时，其只有一个中心点，在具体的程序实现过程中会便于指出卷积核的位置。 2.4三维卷积 &nbsp; &nbsp; &nbsp; &nbsp; 此处可分为两种，一种是常见的多通道图像（如RGB彩色图像）的三维卷积（也是实际中最常用的卷积方式），与之前所举的二维卷积例子原理相似只是通道数不为1，具体如下图所示： 图2.4&nbsp;三维卷积 &nbsp; &nbsp; &nbsp; &nbsp; 在该卷积过程中，卷积核n（包含3个小卷积核） 中的每个小卷积核分别与原图像中所对应的图层进行卷积运算（如卷积核1中左边的小卷积核与原图像中左边的红色图层进行卷积运算，得到红色的单通道特征图；卷积核1中中间的小卷积核则与原图像中间的绿色图层进行卷积运算，得到绿色的单通道特征图，以此类推），分别生成3个单通道特征图，然后将这3个特征图按元素对应相加，即可得到卷积核n 生成的单通道特征图，最后将 n 个特征图相叠加即可得到最终的 n通道特征图。 注：该类卷积方式也是图像识别与检测中最常见的运算方式。其维度计算如下。 对于第&nbsp;&nbsp;层卷积，定义符号如下： &nbsp;卷积核尺寸（filter） &nbsp;填充尺寸（padding） &nbsp;步长（stride） &nbsp;图像的高度（height） &nbsp;图像的宽度（width） &nbsp;通道数（channel&nbsp;number） 定义输入图像（第&nbsp;&nbsp;层图像）的尺寸为： 定义共有&nbsp;&nbsp;个&nbsp;&nbsp;卷积核（程序中定义尺寸为 ）对输入图像进行卷积（卷积核的通道数与输入图像一致） &nbsp; &nbsp; &nbsp; &nbsp; 则输出图像（第&nbsp;&nbsp;层图像）的高度&nbsp;，宽度，通道数为卷积核的个数&nbsp;。即输出图像尺寸为：。 注：通过卷积网络中的权重所指的就是卷积核的参数，也就是也就是所有卷积核的集合再乘以卷积核的总数量，即，此处关于高度，宽度和通道的顺序并没有完全统一的标准。 &nbsp; &nbsp; &nbsp; &nbsp; 第二种三维卷积优点类似于卷积的局部连接，但该类卷积运算的卷积核并非只与原图像中的某几层相连接（在一个固定平面内滑动），而是以空间滑动的方式与原图像的所有像素进行卷积。 图2.5&nbsp;三维卷积 &nbsp; &nbsp; &nbsp; &nbsp; 以上图为例，&nbsp;的卷积核在&nbsp;&nbsp;原图像上以步长为1的方式在空间上滑动遍历所有像素进行卷积，最终生成一个&nbsp;&nbsp;的特征图。该类卷积常用于视频的事件检测、三维医学影像等领域。 2.5 1x1卷积 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;卷积也称作 “Network in Network”，其本质上相当于全连接层，以一个&nbsp;&nbsp;的输入图像为例，卷积（通道数与输入图像一致，即尺寸为&nbsp;）所实现的功能就是依次遍历这28个单元格作乘积再求和，增加偏置后应用激活函数（输出图像的高和宽不变，通道数为卷积核的数量）。这时，输入图像的28个不同通道的数据可看作是神经网络的输入向量&nbsp;，而卷积核则可看作是权重&nbsp;，而多个卷积核即构成了神经网络中的隐藏层。 &nbsp; &nbsp; &nbsp; &nbsp; 其主要有2个功能： 降维/升维，即改变图像的通道数，本质上就是通道间信息的线性组合变化。 增加非线性，卷积核，可以在保持图像尺度不变的（即不损失分辨率）的前提下增加非线性特性（利用后接的非线性激活函数）。 2.6偏置（bias） &nbsp; &nbsp; &nbsp; &nbsp; 参考图1.2，每个卷积核都有一个偏置参数&nbsp;，它是一个实数。偏差包含了这些变量，它是该维度上的一个向量，其在代码中表示为一个&nbsp;&nbsp;&nbsp;的四维向量或四维张量。如图2.6所示，三维卷积中，偏置中的每一个单元分别作用于特征图中的每一个图层。 图2.6.1 添加偏置 &nbsp; &nbsp; &nbsp; &nbsp; 其具体计算过程如图2.7所示（以二维卷积为例，也可理解为图2.6中的某一个偏置单元与特征图中对应图层的计算过程）。 图2.6.2 偏置计算 注：神经网络为什么需要添加偏置&nbsp;&nbsp;？，在机器学习中，以一个单变量的线性回归为例，若其假设函数&nbsp;，用其对如下数据进行拟合： 图2.6.3 没有偏置的线性回归 图2.6.4 带有偏置的线性回归 &nbsp; &nbsp; &nbsp; &nbsp; 从图2.6可以看出，在仅含有权重参数&nbsp;&nbsp;的情况下，假设函数必须经过原点，但这将使其无论如何也无法回归出一条完美拟合的直线，而当添加偏置&nbsp;&nbsp;后，假设函数变为&nbsp;&nbsp;，直线将可以通过任意点，进而对数据进行拟合，这个原理可引申到深度学习的前向传播算法中（&nbsp;），即给网络增加了平移的能力（激活函数则可以改变网络拟合的形状），无论在回归还是分类问题中，都可以使网络更好的拟合数据。 2.7池化（pooling） &nbsp; &nbsp; &nbsp; &nbsp; 在通过卷积获得了特征 (features) 之后，下一步我们希望利用这些特征去做分类。理论上讲，人们可以用所有提取得到的特征去训练分类器，但这样做会面临巨大计算量的挑战。并且容易出现过拟合 (over-fitting)。 &nbsp; &nbsp; &nbsp; &nbsp; 为了解决这个问题，首先回忆一下，我们之所以决定使用卷积后的特征是因为图像具有一种“静态性”的属性，这也就意味着在一个图像区域有用的特征极有可能在另一个区域同样适用。因此，为了描述大的图像，一个很自然的想法就是对不同位置的特征进行聚合统计，例如，人们可以计算图像一个区域上的特征的最大值 (或平均值)。这些统计到的特征不仅具有低得多的维度 (相比使用所有提取得到的特征)，同时还会改善结果(不容易过拟合)。这种聚合的操作就叫做池化 (pooling)。 &nbsp; &nbsp; &nbsp; &nbsp; 除了最大值池化（Max Pooling）之外，还有平均值池化（Average pooling）等。相对于Max池化是从目标区域中取出最大值，Average池化则是计算目标区域的平均值。如图2.6.1所示的即为Max池化的运算过程，Average池化依此类推。 图2.7.1 池化 池化有4个重要特性： 不同于卷积，池化没有需要学习的参数。 池化运算后图像的高度和宽度被压缩，但通过数不会改变。 降低了数据特征，扩大了卷积核的感受野。 微小的位置变化具有鲁棒性，在输入数据发生微小偏差时，池化仍会返回相同的结果。如图2.6.2为例，输入数据在宽度方向上只偏离1个元素时，输出仍为相同的结果（根据数据的不同，有时结果也不相同）。 图2.7.2&nbsp;池化的鲁棒性 注：在图像识别领域，主要使用Max池化。所以通常所说的“池化层”，指的就是Max池化。 2.8全局池化 (Global Pooling) &nbsp; &nbsp; &nbsp; &nbsp; “global pooling”在滑窗内的具体池化方法可以是任意的，所以就会被细分为“global average pooling”、“global max pooling”等。在 Network in Network 的工作中，作者使用GAP（Global average pooling）来取代了传统方式最后的全连接层，直接实现了降维，更重要的是极大地减少了网络的参数(CNN网络中占比最大的参数其实后面的全连接层)。GAP的结构如下图所示: 图2.8 Global average pooling &nbsp; &nbsp; &nbsp; &nbsp; 虽然说GAP就是把池化的窗口大小设置成输入图像的大小，但这并不是GAP内涵的全部。GAP的意义是对整个网络从结构上做正则化防止过拟合。既降低参数避免了全连接带来的过拟合风险，又达到了全连接一样的转换功能。 2.9激活函数（activation functions） &nbsp; &nbsp; &nbsp; &nbsp; 为什么神经网络需要非线性激活函数？事实证明：为了使神经网络能够拟合出各种复杂的函数，必须使用非线性激活函数。在神经网络的正向传播过程中（，&nbsp;），如果我们去掉激活函数&nbsp;&nbsp;，则&nbsp;，这个有时被叫做线性激活函数（更学术点的名字是恒等激励函数，因为它们就是把输入值输出），具体公式如下： 第一层： 第二层： &nbsp; &nbsp; &nbsp; &nbsp; 将&nbsp;&nbsp;带入可得第二层：，令&nbsp;，，则第二层变为： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 依此类推，网络的输出仅仅只是输入特征的线性组合。实际上，无论网络有多少层，整体完全可以仅使用1层表示。同理，引入其他线性函数&nbsp;（如）仍然起不到任何作用，因为线性函数的组合本身仍是线性函数。 注：某些特殊情况可能会用到线性激活函数，如机器学习中回归问题的输出层（不在隐藏层）或是压缩问题（可以在隐藏层）。 &nbsp; &nbsp; &nbsp; &nbsp; 常用的激活函数主要有： （1）sigmoid函数&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;（2）tanh 函数 图2.9.1&nbsp;sigmoid函数 图2.9.2&nbsp;tanh函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; 注：tanh函数的效果总是优于 sigmoid 函数。因为函数值域在-1 和+1的激活函数，其均值是更接近零均值的。在训练一个算法模型时，如果使用 tanh 函数代替sigmoid 函数中心化数据，会使得数据的平均值更接近 0 而不是 0.5。 注：sigmoid 函数和 tanh 函数两者共同的缺点是，在&nbsp;&nbsp;特别大或者特别小的情况下，导数的梯度或者函数的斜率会变得特别小，最后就会接近于 0，导致降低梯度下降的速度。 （3）修正线性单元的函数（ReLu）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;（4）Leaky Relu函数 图2.9.3&nbsp;relu函数 图2.9.4&nbsp;leaky relu函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;，一般&nbsp; 注：Relu 进入负半区的时候，梯度为 0，神经元此时不会训练，产生所谓的稀疏性，而 Leaky ReLu 不会有这问题。 3特性 3.1局部感知 &nbsp; &nbsp; &nbsp; &nbsp; 一般认为，人对外界的认知是从局部到全局的，而对于图像来说，空间联系也是局部的像素联系较为紧密，而距离较远的像素相关性则较弱。因而，每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。网络部分连通的思想，也是受启发于生物学里面的视觉系统结构。视觉皮层的神经元就是局部接受信息的（即这些神经元只响应某些特定区域的刺激）。 &nbsp; &nbsp; &nbsp; &nbsp; 在全连接神经网络中（如图3.1所示），相邻层的神经元全部连接在一起，由于其输入数据是一维结构，故图像需先转换为一维向量，而这个过程，也导致图像完全丢失了“形状”，即像素间的空间信息，从理论上来讲，神经网络几乎能解决所有深度学习问题，但是在处理复杂问题时，往往难以达到理想的效果。 图3.1&nbsp;全连接与局部连接 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;该类网络不仅参数量巨大，且学习速度较慢，即使是一个简单的问题，一般也需要几百次甚至上千次的学习才能收敛，而且易产生过拟合问题，泛化能力较弱。 &nbsp; &nbsp; &nbsp; &nbsp; 而卷积层则可以保持形状不变。当输入图像时，卷积层会以3维数据的形式接收输入数据，并同样以3维数据的形式输出至下一层。因此，在CNN中，可以正确理解图像等具有形状的数据，而且由于局部连接，大大降低了参数量，节省了内存。 3.2参数共享 &nbsp; &nbsp; &nbsp; &nbsp; 也可理解为“平移不变性”。卷积神经网络在图像的某一区域学到某个模式之后，它就可以在图像的任何地方识别这个模式。 图3.2&nbsp;参数共享 &nbsp; &nbsp; &nbsp; &nbsp; 如图3.2所示，假设使用某一特征过滤器（检测器）提取 “手写5” 的特征，那么图片的右下角区域，以及旁边的各个区域都可以使用这个过滤器。每个特征检测器以及输出都可以在输入图片的不同区域中使用同样的参数，以便提取特征 “5”。而对于全连接网络来说，如果模式出现在新的位置，它只能重新学习这个模式。这使得卷积神经网络在处理图像时可以高效利用数据（因为视觉世界从根本上具有平移不变性），只需要更少的训练样本就可以学到具有泛化能力的数据表示。 3.3分层提取 &nbsp; &nbsp; &nbsp; &nbsp; 卷积神经网络可以学到模式的空间层次结构（spatial hierarchies of patterns）。 图3.3&nbsp;分层提取 &nbsp; &nbsp; &nbsp; &nbsp; 如图3.3。第一个卷积层将学习较小的局部模式（比如边缘），第二个卷积层将学习由第一层特征组成的更大的模式，以此类推，层数越高，学到的特征就越全局化。这使得卷积神经网络可以有效地学习越来越复杂、越来越抽象的视觉概念（视觉世界从根本上具有空间层次结构）。 3.4感受野（Receptive field） &nbsp; &nbsp; &nbsp; &nbsp; 感受野用来表示网络内部的不同神经元对原图像的感受范围的大小，换句话说，即为每一层输出的特征图(feature map)上的像素点在原始图像上映射的区域大小。其中神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节，因此感受野的值可以用来大致判断每一层的抽象层次。 图3.4 感受野 &nbsp; &nbsp; &nbsp; &nbsp; 对于卷积核 Conv1 来说，其每个元素在原图像上所能看到的范围是&nbsp;（感受野值为 3），又因为卷积核Conv1的大小为3，步长为2，且卷积核 Conv2的大小为2，步长为1，结合可知，Conv2中的每一个元素可包含 Conv1 中大小为2的元素，而2个 Conv1 所能覆盖原始图像的范围为&nbsp;，故Conv2的感受野值为 5。 3.5多核卷积 &nbsp; &nbsp; &nbsp; &nbsp; 一个卷积核只能提取某一种特征，而计算机对于一幅图像的 “理解” 过程中，往往需要对其多个特征进行学习，其每个卷积核都是一种特征提取方式，就像一个筛子，将图像中符合条件（激活值越大越符合条件）的部分筛选出来。 &nbsp; &nbsp; &nbsp; &nbsp; 如图3.3，我们人类对于猫的理解会包括猫的耳朵、鼻子和眼睛，故其可采取图示的三种卷积核来进行提取，而更底层的特征，如不同形状的曲线、图案等则由其他不同种类的卷积核来进行提取。 4局部卷积 &nbsp; &nbsp; &nbsp; &nbsp; 以LeNet网络举例，其结构如下图所示： 图4.1&nbsp;LeNet &nbsp; &nbsp; &nbsp; &nbsp; 原始图像进来以后，先进入一个卷积层C1，由6个 5x5 的卷积核组成，卷积出28x28的图像，然后下采样到14x14（S2）。接下来，再进一个卷积层C3，由16个5x5的卷积核组成，之后再下采样到5x5（S4）。注意，这里S2与C3的连接方式并不是全连接，而是部分连接，如下图所示： 图4.2&nbsp;卷积的部分连接 &nbsp; &nbsp; &nbsp; &nbsp; 其中行代表S2层的某个节点，列代表C3层的某个节点。我们可以看出，C3的 0 和S2的 0、1、2 连接，C3的 1 和S2的 1、2、3 连接，不过从C3的6~13变为了每次连接4个节点，C3的14变为了5个节点，C3的15与S2的节点全部连接。 &nbsp; &nbsp; &nbsp; &nbsp; 即用不同底层特征的组合，可以得到进一步的高级特征，例如：/ + \\ =&nbsp;，再比如，以图3.3为例，第一层的9个卷积核与输入图像 “猫” 是全部连接，从 “猫” 中得到了9种不同的底层特征图（各类底层曲线及图案），而第二层的卷积核1（将用于提取 “猫眼睛”）则只与第一层的特征图1~5相连接（即仅与特征图1~5进行卷积运算），同理，第二层的卷积核3（“猫耳朵”）则只与第一层的特征图7~9相连接。 注：此处所说的 “全部连接” 与BP神经网络中的 “全连接” 有着本质的不同，BP神经网络中的全连接表示网络中的每一个神经元都与上一层的所有神经元相连接，而卷积网络中的 “全部连接” 只是表示该层的卷积核与上一层特征图的所有通道进行卷积，但卷积运算的过程仍是 “局部连接”。 图4.3&nbsp;卷积的“全部连接”与“部分连接” &nbsp; &nbsp; &nbsp; &nbsp; 结合图3.3，以图4.3为例，第一层中卷积核1~9的通道数都与原图像的相同（值都为3），故此处属于卷积的 “全部连接”，也是卷积运算默认的连接方式，而第二层中卷积核1的通道数为5，卷积核3的通道数为3，而上层特征图的通道数为9，故此处属于卷积的 “局部连接”。 注：在此处，卷积核1与卷积核3分别仅与第1~5层特征图、7~9层特征图进行卷积运算，即分别仅在其所处的立体空间中的一个面内移动，分别输出的是一个二维的图像（通道数为1），其与处理视频序列的三维卷积概念不同。 5卷积层和池化层的实现 &nbsp; &nbsp; &nbsp; &nbsp; 如果以传统思维使用for循环来实现的话，则在巨大数据量的情况下，for循环进行计算和切换内存的时间消耗会非常大。而采用向量化的并行计算方式则可以大幅缩短计算时间。 5.1卷积实现 &nbsp; &nbsp; &nbsp; &nbsp; 如图5.1所示，首先对于输入数据，将应用滤波器的区域（3维方块）横向展开为1列以匹配卷积核（权重），然后将卷积核依次展开为1列，计算两者的矩阵乘积，最后将得到的2维数据reshape至4维。 注：为了便于观察，将步幅设置得很大，以使滤波器的应用区域不重叠。而在实际的卷积运算中，滤波器的应用区域几乎都是重叠的。在滤波器的应用区域重叠的情况下，展开后的元素个数会多于原方块的元素个数。因此该方法比普通的实现会消耗更多的内存。 注：在程序中，因为包含批处理数量（N幅图像同时处理），故输入数据是4维，卷积核也是所有共同展开，故也是4维。其中：N——批处理的图像数量（样本数）；FN——滤波器数量；C——通道数；H——高度；W——宽度 图5.1&nbsp;卷积实现 注：im2col 是一个展开函数，名称是“image to column”的缩写，即 “从图像到矩阵” 的意思。Caffe、Chainer等深度学习框架中有名为im2col 的函数，并且在卷积层的实现中，都使用了 im2col。 5.2池化实现 &nbsp; &nbsp; &nbsp; &nbsp; 池化层的实现和卷积层相同，都对输入数据进行展开。不过，池化的情况下，在通道方向上是独立的。如图5.2所示，池化的应用区域按通道单独展开。如图5.2所示，对于输入数据的每一层的池化区域分别展开为2维向量，然后对每一行求最大值得到一个1维向量，最后将该向量reshape为合适的维数。 图5.2&nbsp;池化实现 6可视化 &nbsp; &nbsp; &nbsp; &nbsp; 学习前的卷积核是随机进行初始化的，所以在黑白的浓淡上没有规律可循，但学习后的滤波器变成了有规律的图像。可以发现，通过学习，滤波器被更新成了有规律的滤波器，比如从白到黑渐变的滤波器、含有块状区域（称为blob）的滤波器等。 图6.1&nbsp;可视化 &nbsp; &nbsp; &nbsp; &nbsp; 以图6.1为例，不同卷积核经过学习改变了自身对不同特征的响应程度，如边缘（颜色变化的分界线）和斑块（局部的块状区域）等，其中第2个卷积核对垂直边缘响应，第5个卷积核对水平边缘响应，第9个对倾斜边缘响应，第13个对中心斑块响应。 &nbsp; &nbsp; &nbsp; &nbsp; 上面的结果是针对第1层的卷积层得出的。第1层的卷积层中提取了边缘或斑块等“低级”信息，而在堆叠了多层的CNN中，随着层次加深，提取的信息（准确说，是响应强烈的神经元））也越来越抽象。如图6.2所示，第1层的神经元对边缘或斑块有响应，第3层对纹理有响应，第5层对物体部件有响应，最后的全连接层对物体的类别（狗或车）有响应。 图6.2&nbsp;分层可视化 &nbsp; &nbsp; &nbsp; &nbsp; 也就是说，随着层次加深，神经元从简单的形状向“高级”信息变化。换句话说，就像我们理解东西的“含义”一样，响应的对象在逐渐变化。 7神经网络的本质 &nbsp; &nbsp; &nbsp; &nbsp; 神经网络由大量的节点（或称“神经元”，卷积神经网络中为“特征图”）相互连接构成，每个节点代表一种特定的函数，称为激励函数（Activation Function）。节点之间的连接具有特定的权重，信号经过会进行加权，代表神经网络的记忆。网络的输出则依网络的连接方式、权重值和激励函数的不同而不同。网络本身则代表对自然界某种算法或者函数的逼近，也可以是一种逻辑策略的表达。 &nbsp; 参考文章 《吴恩达深度学习》 《深度学习入门：基于Python的理论与实现》 《Python深度学习》 《行人检测：理论与实践》 深度学习简介(一)——卷积神经网络 Receptive field(感受野) Intuitively Understanding Convolutions for Deep Learning 一文读懂卷积神经网络中的1x1卷积核 Global average pooling (GAP) 深度学习笔记：三维图片分类与三维卷积神经网络","@type":"BlogPosting","url":"https://uzzz.org/2019/08/08/793223.html","headline":"卷积神经网络概述","dateModified":"2019-08-08T00:00:00+08:00","datePublished":"2019-08-08T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/08/08/793223.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>卷积神经网络概述</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p id="main-toc"><strong>目录</strong></p> 
  <p id="%E4%BA%BA%E7%B1%BB%E8%A7%86%E8%A7%89%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%BA%BA%E7%B1%BB%E8%A7%86%E8%A7%89%E5%8E%9F%E7%90%86" rel="nofollow" data-token="a890aeb445ef2dc449132f78a36201c8">人类视觉原理</a></p> 
  <p id="1%E6%95%B4%E4%BD%93%E6%8F%8F%E8%BF%B0-toc" style="margin-left:0px;"><a href="#1%E6%95%B4%E4%BD%93%E6%8F%8F%E8%BF%B0" rel="nofollow" data-token="620df42dbc3005ad410e305e4901ebea">1整体描述</a></p> 
  <p id="2%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA-toc" style="margin-left:0px;"><a href="#2%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA" rel="nofollow" data-token="8ea000da352a00c97ca58b69e58623f4">2基本理论</a></p> 
  <p id="2.1%E5%8D%B7%E7%A7%AF%EF%BC%88convolution%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.1%E5%8D%B7%E7%A7%AF%EF%BC%88convolution%EF%BC%89" rel="nofollow" data-token="adaa31e53da1711dfaa549704c5df38d">2.1卷积（convolution）</a></p> 
  <p id="2.2%E6%AD%A5%E9%95%BF%EF%BC%88stride%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.2%E6%AD%A5%E9%95%BF%EF%BC%88stride%EF%BC%89" rel="nofollow" data-token="5ab7271a132586052c362847f092e0ae">2.2步长（stride）</a></p> 
  <p id="2.3%E5%A1%AB%E5%85%85%EF%BC%88padding%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.3%E5%A1%AB%E5%85%85%EF%BC%88padding%EF%BC%89" rel="nofollow" data-token="7f26dd9b75dd35a22ef9ba61ec3986d4">2.3填充（padding）</a></p> 
  <p id="Valid%E5%8D%B7%E7%A7%AF-toc" style="margin-left:80px;"><a href="#Valid%E5%8D%B7%E7%A7%AF" rel="nofollow" data-token="7a9424cdbb149c2fa2f9658e85855d85">Valid卷积</a></p> 
  <p id="Same%E5%8D%B7%E7%A7%AF-toc" style="margin-left:80px;"><a href="#Same%E5%8D%B7%E7%A7%AF" rel="nofollow" data-token="8b55490c266c299590492446ed5814ee">Same卷积</a></p> 
  <p id="2.4%E4%B8%89%E7%BB%B4%E5%8D%B7%E7%A7%AF-toc" style="margin-left:40px;"><a href="#2.4%E4%B8%89%E7%BB%B4%E5%8D%B7%E7%A7%AF" rel="nofollow" data-token="da8a8cb5e771befc5bc80b8546d2ba3b">2.4三维卷积</a></p> 
  <p id="2.5%C2%A0%E5%8D%B7%E7%A7%AF-toc" style="margin-left:40px;"><a href="#2.5%C2%A0%E5%8D%B7%E7%A7%AF" rel="nofollow" data-token="d9ddc6da36f979bd8950c87d9527a5f3">2.5 1x1卷积</a></p> 
  <p id="2.6%E5%81%8F%E7%BD%AE%EF%BC%88bias%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.6%E5%81%8F%E7%BD%AE%EF%BC%88bias%EF%BC%89" rel="nofollow" data-token="373c8e9452bf951d7d9d780b3888491a">2.6偏置（bias）</a></p> 
  <p id="2.6%E6%B1%A0%E5%8C%96%EF%BC%88pooling%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.6%E6%B1%A0%E5%8C%96%EF%BC%88pooling%EF%BC%89" rel="nofollow" data-token="f402d37c5e7c0cbda29ac3afa2af02e9">2.7池化（pooling）</a></p> 
  <p id="%E5%85%A8%E5%B1%80%E6%B1%A0%E5%8C%96%20(Global%20Pooling)-toc" style="margin-left:40px;"><a href="#%E5%85%A8%E5%B1%80%E6%B1%A0%E5%8C%96%20(Global%20Pooling)" rel="nofollow" data-token="c34d284c6583ba45af730aaaafc938b5">2.8全局池化 (Global Pooling)</a></p> 
  <p id="2.8%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.8%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0" rel="nofollow" data-token="e92dd121153f8cdc8b6e150606ae0de9">2.9激活函数</a></p> 
  <p id="3%E7%89%B9%E6%80%A7-toc" style="margin-left:0px;"><a href="#3%E7%89%B9%E6%80%A7" rel="nofollow" data-token="516c5c90a94aeebed50d52a080daa985">3特性</a></p> 
  <p id="3.1%E5%B1%80%E9%83%A8%E6%84%9F%E7%9F%A5-toc" style="margin-left:40px;"><a href="#3.1%E5%B1%80%E9%83%A8%E6%84%9F%E7%9F%A5" rel="nofollow" data-token="6fe6b30b9c99a31aa34ca64a424f0570">3.1局部感知</a></p> 
  <p id="3.2%E5%8F%82%E6%95%B0%E5%85%B1%E4%BA%AB-toc" style="margin-left:40px;"><a href="#3.2%E5%8F%82%E6%95%B0%E5%85%B1%E4%BA%AB" rel="nofollow" data-token="9305f2972b2a76c1fb8c82534061ff13">3.2参数共享</a></p> 
  <p id="3.3%E5%88%86%E5%B1%82%E6%8F%90%E5%8F%96-toc" style="margin-left:40px;"><a href="#3.3%E5%88%86%E5%B1%82%E6%8F%90%E5%8F%96" rel="nofollow" data-token="ab20f5741b1a9323d03994e96c853882">3.3分层提取</a></p> 
  <p id="3.4%E6%84%9F%E5%8F%97%E9%87%8E%EF%BC%88Receptive%20field%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.4%E6%84%9F%E5%8F%97%E9%87%8E%EF%BC%88Receptive%20field%EF%BC%89" rel="nofollow" data-token="f9f789c3ed7bda19a4f0124564dada01">3.4感受野（Receptive field）</a></p> 
  <p id="3.5%E5%A4%9A%E6%A0%B8%E5%8D%B7%E7%A7%AF-toc" style="margin-left:40px;"><a href="#3.5%E5%A4%9A%E6%A0%B8%E5%8D%B7%E7%A7%AF" rel="nofollow" data-token="20ae685fd4a7585ee4f8a3db6bf9ce56">3.5多核卷积</a></p> 
  <p id="4%E5%B1%80%E9%83%A8%E5%8D%B7%E7%A7%AF-toc" style="margin-left:0px;"><a href="#4%E5%B1%80%E9%83%A8%E5%8D%B7%E7%A7%AF" rel="nofollow" data-token="369fe4a0d5445704dbb28d88b2bfccbd">4局部卷积</a></p> 
  <p id="5%E5%8D%B7%E7%A7%AF%E5%B1%82%E5%92%8C%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#5%E5%8D%B7%E7%A7%AF%E5%B1%82%E5%92%8C%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow" data-token="016f70756cb08e1a81f995879856c28d">5卷积层和池化层的实现</a></p> 
  <p id="5.1%E5%8D%B7%E7%A7%AF%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#5.1%E5%8D%B7%E7%A7%AF%E5%AE%9E%E7%8E%B0" rel="nofollow" data-token="1c0b1ec4e3aed9e4350df228d4996b6b">5.1卷积实现</a></p> 
  <p id="5.2%E6%B1%A0%E5%8C%96%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#5.2%E6%B1%A0%E5%8C%96%E5%AE%9E%E7%8E%B0" rel="nofollow" data-token="0099cc578f1d3dbfe492c9d690c41f44">5.2池化实现</a></p> 
  <p id="6%E5%8F%AF%E8%A7%86%E5%8C%96-toc" style="margin-left:0px;"><a href="#6%E5%8F%AF%E8%A7%86%E5%8C%96" rel="nofollow" data-token="df941b15d8ee945637dff30033c71139">6可视化</a></p> 
  <p id="7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%9C%AC%E8%B4%A8-toc" style="margin-left:0px;"><a href="#7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%9C%AC%E8%B4%A8" rel="nofollow" data-token="948d9a8b2b00c5f0f9a4594706c26da3">7神经网络的本质</a></p> 
  <p id="%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0-toc" style="margin-left:0px;"><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0" rel="nofollow" data-token="1aebfddabaa245d92f8e685c9df5a723">参考文章</a></p> 
  <hr id="hr-toc">
  <h1 id="%E4%BA%BA%E7%B1%BB%E8%A7%86%E8%A7%89%E5%8E%9F%E7%90%86">人类视觉原理</h1> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 深度学习的许多研究成果，离不开对大脑认知原理的研究，尤其是视觉原理的研究。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 1981 年的诺贝尔医学奖，颁发给了 David Hubel（出生于加拿大的美国神经生物学家） 和TorstenWiesel，以及 Roger Sperry。前两位的主要贡献，是“发现了视觉系统的信息处理”，可视皮层是分级的。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 人类的视觉原理如下：从原始信号摄入开始（瞳孔摄入像素 Pixels），接着做初步处理（大脑皮层某些细胞发现边缘和方向），然后抽象（大脑判定，眼前的物体的形状，是圆形的），然后进一步抽象（大脑进一步判定该物体是只气球）。下面是人脑进行人脸识别的一个示例：</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="人类视觉原理" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190720162632858.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图&nbsp;人类视觉原理
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 我们可以看到，在最底层特征基本上是类似的，就是各种边缘，越往上，越能提取出此类物体的一些特征（轮子、眼睛、躯干等），到最上层，不同的高级特征最终组合成相应的图像，从而能够让人类准确的区分不同的物体。那么我们可以很自然的想到：可以不可以模仿人类大脑的这个特点，构造多层的神经网络，让计算机来逐层提取图像中的特征，最终在顶层做出分类呢？答案是肯定的，这也是卷积神经网络的灵感来源。</p> 
  <h1 id="1%E6%95%B4%E4%BD%93%E6%8F%8F%E8%BF%B0">1整体描述</h1> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 卷积神经网络（Convolutional Neural Networks, CNN）是一类包含卷积运算且具有深度结构的前馈神经网络（Feedforward Neural Networks）。相比早期的BP神经网络，卷积神经网络最重要的特性在于“<strong><span style="color:#f33b45;">局部感知</span></strong>”与“<strong><span style="color:#f33b45;">参数共享</span></strong>”，自2012年的AlexNet开始，卷积神经网络就多次成为ImageNet大规模视觉识别竞赛（ImageNet Large Scale Visual Recognition Challenge, ILSVRC）的优胜算法，至此，卷积神经网络开始大放异彩，成为了众多科学领域的研究重点之一。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 如图1所示，一个完整的卷积神经网络可包含卷积层、池化层、全连接层等。其中卷积层用来进行特征提取，池化层用于降低维数，全连接层可用于结果预测（也可使用全卷积网络进行预测）。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="卷积神经网络示例" height="172" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190719175355915.PNG" width="886">
    <figcaption>
     图1.1 卷积神经网络示例（手写数字识别）
    </figcaption>
   </figure>
  </div> 
  <blockquote> 
   <p><strong><span style="color:#f33b45;">注：</span></strong>卷积运算也属于一种线性运算，故需要进行非线性处理，即添加激活函数（示例中为修正线性单元的函数，即 Relu 激活函数）。</p> 
  </blockquote> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 对于卷积层，其详细描述如图1.2所示</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="卷积层描述" height="417" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190719162821979.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70" width="719">
    <figcaption>
     图1.2&nbsp;卷积层描述
    </figcaption>
   </figure>
  </div> 
  <p>其运算过程主要由以下4步组成：</p> 
  <ul>
   <li>原图像（尺寸为&nbsp;<img alt="32\times 32 \times 3" class="mathcode" src="https://private.codecogs.com/gif.latex?32%5Ctimes%2032%20%5Ctimes%203">）分别与&nbsp;<img alt="n" class="mathcode" src="https://private.codecogs.com/gif.latex?n">&nbsp;个&nbsp;<img alt="5\times 5 \times 3" class="mathcode" src="https://private.codecogs.com/gif.latex?5%5Ctimes%205%20%5Ctimes%203">&nbsp;的卷积核（又名滤波器，fliter）进行卷积运算，得到&nbsp;<img alt="n" class="mathcode" src="https://private.codecogs.com/gif.latex?n">&nbsp;个&nbsp;<img alt="28\times 28 \times 1" class="mathcode" src="https://private.codecogs.com/gif.latex?28%5Ctimes%2028%20%5Ctimes%201">&nbsp;的特征图（feature map）</li> 
   <li>每个特征图分别添加不同的偏置（bias），具体为特征图中的每个元素&nbsp;<img alt="+\ b_n" class="mathcode" src="https://private.codecogs.com/gif.latex?&amp;plus;%5C%20b_n"></li> 
   <li>对每个特征图添加激活函数&nbsp;<img alt="g(x)" class="mathcode" src="https://private.codecogs.com/gif.latex?g%28x%29">，进行非线性运算</li> 
   <li>将这&nbsp;<img alt="n" class="mathcode" src="https://private.codecogs.com/gif.latex?n">&nbsp;个特征图依次叠加，得到最终的特征图（尺寸为&nbsp;<img alt="28\times 28 \times n" class="mathcode" src="https://private.codecogs.com/gif.latex?28%5Ctimes%2028%20%5Ctimes%20n">）</li> 
  </ul>
  <blockquote> 
   <p><strong><span style="color:#f33b45;">注：</span></strong>对于某一个卷积层，其不同特征图所使用的激活函数相同，但不同卷积层所使用的激活函数可以不同，该步骤在整体描述中为突出与神经网络的相似性而单独提出，但实际上其仍属于卷积层的一部分。</p> 
  </blockquote> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 对于池化层，其详细描述如图1.3所示：</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="池化层描述" height="201" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190719164325679.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70" width="650">
    <figcaption>
     图1.3&nbsp;池化层描述
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 承接上例，对于&nbsp;<img alt="28\times 28 \times n" class="mathcode" src="https://private.codecogs.com/gif.latex?28%5Ctimes%2028%20%5Ctimes%20n">&nbsp;的特征图，其池化过程仅需通过池化核对该特征图进行池化运算即可得到输出。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 然后将得到的特征图经过全连接层进行处理并由softmax算法进行回归即可得到最终的输出结果。</p> 
  <blockquote> 
   <p><span style="color:#f33b45;"><strong>注：</strong></span>全连接层即为机器学习中常见的由神经元构成的神经网络。</p> 
   <p>（关于神经网络及softmax回归可参考：<a href="https://blog.csdn.net/jack__linux/article/details/89246782" rel="nofollow" data-token="c5b7ba63fbb31fab214ccbb71e1e1fad">神经网络的前向及反向传播</a>、<a href="https://blog.csdn.net/jack__linux/article/details/90345861" rel="nofollow" data-token="07c663165c75f03ca211c2ac820e4b42">深度学习笔记</a>）</p> 
  </blockquote> 
  <h1 id="2%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA">2基本理论</h1> 
  <p>&nbsp;</p> 
  <h2 id="2.1%E5%8D%B7%E7%A7%AF%EF%BC%88convolution%EF%BC%89">2.1卷积（convolution）</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 卷积神经网络中的核心即为卷积运算，其相当于图像处理中的“滤波器运算”。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 对于一个&nbsp;<img alt="m \times n" class="mathcode" src="https://private.codecogs.com/gif.latex?m%20%5Ctimes%20n">&nbsp;大小的卷积核&nbsp;<img alt="W = \begin{bmatrix} w_{11} \ \ w_{12} \ ... \ w_{1n} \\ w_{21} \ \ w_{22} \ ... \ w_{2n} \\ ... ... ... ... \\ w_{m1}\ w_{m2} \ ... \ w_{mn} \end{bmatrix}_{(m\times n)}" class="mathcode" src="https://private.codecogs.com/gif.latex?W%20%3D%20%5Cbegin%7Bbmatrix%7D%20w_%7B11%7D%20%5C%20%5C%20w_%7B12%7D%20%5C%20...%20%5C%20w_%7B1n%7D%20%5C%5C%20w_%7B21%7D%20%5C%20%5C%20w_%7B22%7D%20%5C%20...%20%5C%20w_%7B2n%7D%20%5C%5C%20...%20...%20...%20...%20%5C%5C%20w_%7Bm1%7D%5C%20w_%7Bm2%7D%20%5C%20...%20%5C%20w_%7Bmn%7D%20%5Cend%7Bbmatrix%7D_%7B%28m%5Ctimes%20n%29%7D">，其对某一原图像&nbsp;<img alt="X" class="mathcode" src="https://private.codecogs.com/gif.latex?X">&nbsp;进行卷积运算的过程为：卷积核&nbsp;<img alt="W" class="mathcode" src="https://private.codecogs.com/gif.latex?W">&nbsp;中的每一个权值&nbsp;<img alt="w" class="mathcode" src="https://private.codecogs.com/gif.latex?w">&nbsp;分别和覆盖的原图像&nbsp;<img alt="X" class="mathcode" src="https://private.codecogs.com/gif.latex?X">&nbsp;中所对应的像素&nbsp;<img alt="x" class="mathcode" src="https://private.codecogs.com/gif.latex?x">&nbsp;相乘，然后再求和。计算公式为：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="z=w_1x_1+w_2x_2+...+w_{mn}x_{mn}=\sum_{k=1}^{mn}w_kx_k=W^TX" class="mathcode" src="https://private.codecogs.com/gif.latex?z%3Dw_1x_1&amp;plus;w_2x_2&amp;plus;...&amp;plus;w_%7Bmn%7Dx_%7Bmn%7D%3D%5Csum_%7Bk%3D1%7D%5E%7Bmn%7Dw_kx_k%3DW%5ETX"></p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 如图2.1所示，对一幅图像的一个完整的卷积运算过程为：卷积核以一定的间隔滑动，并对所覆盖的区域进行卷积运算得到值&nbsp;<img alt="z" class="mathcode" src="https://private.codecogs.com/gif.latex?z">，直至遍历完整幅图像。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="卷积运算" height="363" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190720180736192.gif" width="500">
    <figcaption>
     图2.1 卷积运算
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 一个标准的卷积运算以图2.2为例，其卷积核每次覆盖原图像的9个像素，共滑动4次，得到了一个&nbsp;<img alt="2\times 2" class="mathcode" src="https://private.codecogs.com/gif.latex?2%5Ctimes%202">&nbsp;的二维数据。对于一个大小为&nbsp;<img alt="n" class="mathcode" src="https://private.codecogs.com/gif.latex?n">&nbsp;的原图像，经过大小为&nbsp;<img alt="f" class="mathcode" src="https://private.codecogs.com/gif.latex?f">&nbsp;的卷积运算后，其输出图像的尺寸为&nbsp;<img alt="n-f+1" class="mathcode" src="https://private.codecogs.com/gif.latex?n-f&amp;plus;1">。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="标准的二维卷积运算" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190720181914831.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图2.2&nbsp;标准的二维卷积运算
    </figcaption>
   </figure>
  </div> 
  <h2 id="2.2%E6%AD%A5%E9%95%BF%EF%BC%88stride%EF%BC%89">2.2步长（stride）</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 滑动一定的间距，但这个间距该如何定义呢? 这个概念就是卷积的 “步长”（stride），设置卷积的步长可使卷积过程跳过原图像中的某些像素。结合步长&nbsp;<img alt="s" class="mathcode" src="https://private.codecogs.com/gif.latex?s">&nbsp;操作后，其输出图像的尺寸为&nbsp;<img alt="\left \lfloor \frac{n-f}{s} \right \rfloor +1" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Cleft%20%5Clfloor%20%5Cfrac%7Bn-f%7D%7Bs%7D%20%5Cright%20%5Crfloor%20&amp;plus;1">。stride =&nbsp;1 表示卷积核滑过每一个相距是 1 的像素，是最基本的单步滑动，作为标准卷积模式。Stride 是 2 表示卷积核的移动步长是 2，跳过相邻像素，输出图像缩小为原来的 1/2。Stride 是 3 表示卷积核的移动步长是 3，跳过 2 个相邻像素，图像缩小为原来的 1/3，以此类推。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="一个步长为2的卷积运算" height="329" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190720182452976.gif" width="336">
    <figcaption>
     图2.3&nbsp;一个步长为2的卷积运算
    </figcaption>
   </figure>
  </div> 
  <h2 id="2.3%E5%A1%AB%E5%85%85%EF%BC%88padding%EF%BC%89">2.3填充（padding）</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 在标准的卷积过程中，存在两个问题：</p> 
  <ul>
   <li>每次卷积运算后，图像就会缩小，在经历多次运算后，图像终会失去其形状，变为&nbsp;<img alt="1\times 1" class="mathcode" src="https://private.codecogs.com/gif.latex?1%5Ctimes%201">&nbsp;的 “柱状”。</li> 
   <li>对于图像边缘的像素，其只被一个输出所触碰或者使用，但对于图像中间的像素，则会有多个卷积核与之重叠。所以那些在角落或者边缘区域的像素点在输出中采用较少，意味着卷积过程丢掉了图像边缘位置的许多信息。</li> 
  </ul>
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 对于这个问题，可以采用额外的 “假”&nbsp;像素（通常值为 0， 因此经常使用的术语 ”零填充“ ）填充边缘。这样，在滑动时的卷积核可以允许原始边缘像素位于其中心，同时延伸到边缘之外的假像素。假设填充的像素大小为&nbsp;<img alt="p" class="mathcode" src="https://private.codecogs.com/gif.latex?p">&nbsp;，则&nbsp;<img alt="n" class="mathcode" src="https://private.codecogs.com/gif.latex?n">&nbsp;就变成了&nbsp;<img alt="n+2p" class="mathcode" src="https://private.codecogs.com/gif.latex?n&amp;plus;2p">&nbsp;，故其输出图像的尺寸为&nbsp;<img alt="\left \lfloor \frac{n+2p-f}{s} \right \rfloor +1" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Cleft%20%5Clfloor%20%5Cfrac%7Bn&amp;plus;2p-f%7D%7Bs%7D%20%5Cright%20%5Crfloor%20&amp;plus;1">。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 至于选择填充多少像素，通常有两个选择，分别叫做 Valid 卷积和 Same 卷积。</p> 
  <h3 id="Valid%E5%8D%B7%E7%A7%AF">Valid卷积</h3> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; Valid 卷积意味着<span style="color:#f33b45;"><strong>不填充</strong></span>，如之前所述，图像会经历卷积运算后逐渐缩小，输出的图像尺寸即为上述公式：<img alt="\left \lfloor \frac{n+2p-f}{s} \right \rfloor +1" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Cleft%20%5Clfloor%20%5Cfrac%7Bn&amp;plus;2p-f%7D%7Bs%7D%20%5Cright%20%5Crfloor%20&amp;plus;1">。</p> 
  <h3 id="Same%E5%8D%B7%E7%A7%AF">Same卷积</h3> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; Same卷积意味<span style="color:#f33b45;"><strong>填充后</strong></span>，输出图像的尺寸与输入图像的<span style="color:#f33b45;"><strong>尺寸相同</strong></span>，根据上述公式，令&nbsp;<img alt="\left \lfloor \frac{n+2p-f}{s} \right \rfloor +1=n" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Cleft%20%5Clfloor%20%5Cfrac%7Bn&amp;plus;2p-f%7D%7Bs%7D%20%5Cright%20%5Crfloor%20&amp;plus;1%3Dn">，可得到<img alt="p=\frac{(n-1)s-n+f}{2}" class="mathcode" src="https://private.codecogs.com/gif.latex?p%3D%5Cfrac%7B%28n-1%29s-n&amp;plus;f%7D%7B2%7D">。当&nbsp;<img alt="s=1" class="mathcode" src="https://private.codecogs.com/gif.latex?s%3D1">&nbsp;时，<img alt="p=\frac{f-1}{2}" class="mathcode" src="https://private.codecogs.com/gif.latex?p%3D%5Cfrac%7Bf-1%7D%7B2%7D">。</p> 
  <blockquote> 
   <p><strong><span style="color:#f33b45;">注：</span></strong>一般卷积核&nbsp;<img alt="f" class="mathcode" src="https://private.codecogs.com/gif.latex?f">&nbsp;的大小会选择一个奇数，如 3 \ 5 \ 7 等。主要因为：</p> 
   <ul>
    <li>如果&nbsp;<img alt="f" class="mathcode" src="https://private.codecogs.com/gif.latex?f"> 是一个偶数，那么只能使用一些不对称填充。只有当&nbsp;<img alt="f" class="mathcode" src="https://private.codecogs.com/gif.latex?f"> 是奇数时，Same 卷积才会有自然的填充，即可以选择同样的数量填充四周。</li> 
    <li>当卷积核&nbsp;<img alt="f" class="mathcode" src="https://private.codecogs.com/gif.latex?f">&nbsp;是奇数时，其只有一个中心点，在具体的程序实现过程中会便于指出卷积核的位置。</li> 
   </ul>
  </blockquote> 
  <h2 id="2.4%E4%B8%89%E7%BB%B4%E5%8D%B7%E7%A7%AF">2.4三维卷积</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 此处可分为两种，一种是常见的多通道图像（如RGB彩色图像）的三维卷积（也是实际中最常用的卷积方式），与之前所举的二维卷积例子原理相似只是通道数不为1，具体如下图所示：</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="三维卷积1" height="458" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190720230236845.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70" width="722">
    <figcaption>
     图2.4&nbsp;三维卷积
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 在该卷积过程中，卷积核n（包含3个小卷积核） 中的每个小卷积核分别与原图像中所对应的图层进行卷积运算（如卷积核1中左边的小卷积核与原图像中左边的红色图层进行卷积运算，得到红色的单通道特征图；卷积核1中中间的小卷积核则与原图像中间的绿色图层进行卷积运算，得到绿色的单通道特征图，以此类推），分别生成3个单通道特征图，然后将这3个特征图按元素对应相加，即可得到卷积核n 生成的单通道特征图，最后将 n 个特征图相叠加即可得到最终的 n通道特征图。</p> 
  <blockquote> 
   <p><strong><span style="color:#f33b45;">注：</span></strong>该类卷积方式也是图像识别与检测中最常见的运算方式。其维度计算如下。</p> 
   <p>对于第&nbsp;<img alt="l" class="mathcode" src="https://private.codecogs.com/gif.latex?l">&nbsp;层卷积，定义符号如下：</p> 
   <p><img alt="f^{[l]}=" class="mathcode" src="https://private.codecogs.com/gif.latex?f%5E%7B%5Bl%5D%7D%3D">&nbsp;卷积核尺寸（filter）</p> 
   <p><img alt="p^{[l]}=" class="mathcode" src="https://private.codecogs.com/gif.latex?p%5E%7B%5Bl%5D%7D%3D">&nbsp;填充尺寸（padding）</p> 
   <p><img alt="s^{[l]}=" class="mathcode" src="https://private.codecogs.com/gif.latex?s%5E%7B%5Bl%5D%7D%3D">&nbsp;步长（stride）</p> 
   <p><img alt="n_h^{[l]}=" class="mathcode" src="https://private.codecogs.com/gif.latex?n_h%5E%7B%5Bl%5D%7D%3D">&nbsp;图像的高度（height）</p> 
   <p><img alt="n_w^{[l]}=" class="mathcode" src="https://private.codecogs.com/gif.latex?n_w%5E%7B%5Bl%5D%7D%3D">&nbsp;图像的宽度（width）</p> 
   <p><img alt="n_c^{[l]}=" class="mathcode" src="https://private.codecogs.com/gif.latex?n_c%5E%7B%5Bl%5D%7D%3D">&nbsp;通道数（channel&nbsp;number）</p> 
   <p>定义<span style="color:#3399ea;">输入图像（第&nbsp;<img alt="{\color{Blue} l-1}" class="mathcode" src="https://private.codecogs.com/gif.latex?%7B%5Ccolor%7BBlue%7D%20l-1%7D">&nbsp;层图像）</span>的尺寸为：<img alt="{\color{Blue} n_h^{[l-1]}\times n_w^{[l-1]}\times n_c^{[l-1]}}" class="mathcode" src="https://private.codecogs.com/gif.latex?%7B%5Ccolor%7BBlue%7D%20n_h%5E%7B%5Bl-1%5D%7D%5Ctimes%20n_w%5E%7B%5Bl-1%5D%7D%5Ctimes%20n_c%5E%7B%5Bl-1%5D%7D%7D"></p> 
   <p>定义共有&nbsp;<img alt="n_c^{[l]}" class="mathcode" src="https://private.codecogs.com/gif.latex?n_c%5E%7B%5Bl%5D%7D">&nbsp;个&nbsp;<img alt="f^{[l]}\times f^{[l]}\times n_c^{[l-1]}" class="mathcode" src="https://private.codecogs.com/gif.latex?f%5E%7B%5Bl%5D%7D%5Ctimes%20f%5E%7B%5Bl%5D%7D%5Ctimes%20n_c%5E%7B%5Bl-1%5D%7D">&nbsp;卷积核（程序中定义尺寸为 <img alt="{\color{Blue} f^{[l]}\times f^{[l]}\times n_c^{[l-1]} \times n_c^{[l]}}" class="mathcode" src="https://private.codecogs.com/gif.latex?%7B%5Ccolor%7BBlue%7D%20f%5E%7B%5Bl%5D%7D%5Ctimes%20f%5E%7B%5Bl%5D%7D%5Ctimes%20n_c%5E%7B%5Bl-1%5D%7D%20%5Ctimes%20n_c%5E%7B%5Bl%5D%7D%7D">）对输入图像进行卷积（<span style="color:#f33b45;"><strong>卷积核的通道数与输入图像一致</strong></span>）</p> 
   <p>&nbsp; &nbsp; &nbsp; &nbsp; 则<span style="color:#3399ea;">输出图像（第&nbsp;<img alt="{\color{Blue} l}" class="mathcode" src="https://private.codecogs.com/gif.latex?%7B%5Ccolor%7BBlue%7D%20l%7D">&nbsp;层图像）</span>的高度&nbsp;<img alt="n_h^{[l]}=\left \lfloor \frac{n_h^{[l-1]}+2p^{[l]}-f^{[l]} }{s^{[l]} } \right \rfloor +1" class="mathcode" src="https://private.codecogs.com/gif.latex?n_h%5E%7B%5Bl%5D%7D%3D%5Cleft%20%5Clfloor%20%5Cfrac%7Bn_h%5E%7B%5Bl-1%5D%7D&amp;plus;2p%5E%7B%5Bl%5D%7D-f%5E%7B%5Bl%5D%7D%20%7D%7Bs%5E%7B%5Bl%5D%7D%20%7D%20%5Cright%20%5Crfloor%20&amp;plus;1">，宽度<img alt="n_w^{[l]}=\left \lfloor \frac{n_w^{[l-1]}+2p^{[l]}-f^{[l]} }{s^{[l]} } \right \rfloor +1" class="mathcode" src="https://private.codecogs.com/gif.latex?n_w%5E%7B%5Bl%5D%7D%3D%5Cleft%20%5Clfloor%20%5Cfrac%7Bn_w%5E%7B%5Bl-1%5D%7D&amp;plus;2p%5E%7B%5Bl%5D%7D-f%5E%7B%5Bl%5D%7D%20%7D%7Bs%5E%7B%5Bl%5D%7D%20%7D%20%5Cright%20%5Crfloor%20&amp;plus;1">，通道数为卷积核的个数&nbsp;<img alt="n_c^{[l]}" class="mathcode" src="https://private.codecogs.com/gif.latex?n_c%5E%7B%5Bl%5D%7D">。即输出图像尺寸为：<span style="color:#7c79e5;"><img alt="{\color{Blue} n_h^{[l]}\times n_w^{[l]} \times n_c^{[l]}}" class="mathcode" src="https://private.codecogs.com/gif.latex?%7B%5Ccolor%7BBlue%7D%20n_h%5E%7B%5Bl%5D%7D%5Ctimes%20n_w%5E%7B%5Bl%5D%7D%20%5Ctimes%20n_c%5E%7B%5Bl%5D%7D%7D"></span>。</p> 
   <p><span style="color:#f33b45;"><strong>注：</strong></span>通过卷积网络中的权重所指的就是卷积核的参数，也就是也就是所有卷积核的集合再乘以卷积核的总数量，即<img alt="f^{[l]}\times f^{[l]}\times n_c^{[l-1]} \times n_c^{[l]}" class="mathcode" src="https://private.codecogs.com/gif.latex?f%5E%7B%5Bl%5D%7D%5Ctimes%20f%5E%7B%5Bl%5D%7D%5Ctimes%20n_c%5E%7B%5Bl-1%5D%7D%20%5Ctimes%20n_c%5E%7B%5Bl%5D%7D">，此处关于高度，宽度和通道的顺序并没有完全统一的标准。</p> 
  </blockquote> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 第二种三维卷积优点类似于卷积的局部连接，但该类卷积运算的卷积核并非只与原图像中的某几层相连接（在一个固定平面内滑动），而是以空间滑动的方式与原图像的所有像素进行卷积。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="三维卷积" height="220" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190720214149789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70" width="411">
    <figcaption>
     图2.5&nbsp;三维卷积
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 以上图为例，<img alt="3\times 3 \times3" class="mathcode" src="https://private.codecogs.com/gif.latex?3%5Ctimes%203%20%5Ctimes3">&nbsp;的卷积核在&nbsp;<img alt="10\times 10 \times 10" class="mathcode" src="https://private.codecogs.com/gif.latex?10%5Ctimes%2010%20%5Ctimes%2010">&nbsp;原图像上以步长为1的方式在空间上滑动遍历所有像素进行卷积，最终生成一个&nbsp;<img alt="7\times 7 \times7" class="mathcode" src="https://private.codecogs.com/gif.latex?7%5Ctimes%207%20%5Ctimes7">&nbsp;的特征图。该类卷积常用于<strong>视频的事件检测</strong>、<strong>三维医学影像</strong>等领域。</p> 
  <h2 id="2.5%C2%A0%E5%8D%B7%E7%A7%AF">2.5 1x1卷积</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="1\times 1" class="mathcode" src="https://private.codecogs.com/gif.latex?1%5Ctimes%201">卷积也称作 “Network in Network”，其本质上相当于全连接层，以一个&nbsp;<img alt="4 \times 4\times 28" class="mathcode" src="https://private.codecogs.com/gif.latex?4%20%5Ctimes%204%5Ctimes%2028">&nbsp;的输入图像为例，<img alt="1\times 1" class="mathcode" src="https://private.codecogs.com/gif.latex?1%5Ctimes%201">卷积（通道数与输入图像一致，即尺寸为&nbsp;<img alt="1\times 1 \times28" class="mathcode" src="https://private.codecogs.com/gif.latex?1%5Ctimes%201%20%5Ctimes28">）所实现的功能就是依次遍历这28个单元格作乘积再求和，增加偏置后应用激活函数（输出图像的高和宽不变，通道数为卷积核的数量）。这时，输入图像的28个不同通道的数据可看作是神经网络的输入向量&nbsp;<img alt="X" class="mathcode" src="https://private.codecogs.com/gif.latex?X">，而卷积核则可看作是权重&nbsp;<img alt="W" class="mathcode" src="https://private.codecogs.com/gif.latex?W">，而多个卷积核即构成了神经网络中的隐藏层。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 其主要有2个功能：</p> 
  <ul>
   <li>降维/升维，即改变图像的通道数，本质上就是通道间信息的线性组合变化。</li> 
   <li>增加非线性，<img alt="1\times 1" class="mathcode" src="https://private.codecogs.com/gif.latex?1%5Ctimes%201">卷积核，可以在保持图像尺度不变的（即不损失分辨率）的前提下增加非线性特性（利用后接的非线性激活函数）。</li> 
  </ul>
  <h2 id="2.6%E5%81%8F%E7%BD%AE%EF%BC%88bias%EF%BC%89">2.6偏置（bias）</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 参考图1.2，每个卷积核都有一个偏置参数&nbsp;<img alt="b" class="mathcode" src="https://private.codecogs.com/gif.latex?b">，它是一个实数。偏差包含了这些变量，它是该维度上的一个向量，其在代码中表示为一个&nbsp;&nbsp;<img alt="1 \times 1\times 1\times n_c^{[l]}" class="mathcode" src="https://private.codecogs.com/gif.latex?1%20%5Ctimes%201%5Ctimes%201%5Ctimes%20n_c%5E%7B%5Bl%5D%7D">&nbsp;的四维向量或四维张量。如图2.6所示，三维卷积中，偏置中的每一个单元分别作用于特征图中的每一个图层。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="添加偏置" height="200" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190721220901901.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70" width="571">
    <figcaption>
     图2.6.1 添加偏置
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 其具体计算过程如图2.7所示（以二维卷积为例，也可理解为图2.6中的某一个偏置单元与特征图中对应图层的计算过程）。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="偏置计算" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190721221413585.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图2.6.2 偏置计算
    </figcaption>
   </figure>
  </div> 
  <blockquote> 
   <p><span style="color:#f33b45;"><strong>注：</strong></span>神经网络为什么需要添加偏置&nbsp;<img alt="b" class="mathcode" src="https://private.codecogs.com/gif.latex?b">&nbsp;？，在机器学习中，以一个单变量的线性回归为例，若其假设函数&nbsp;<img alt="h(x)=wx" class="mathcode" src="https://private.codecogs.com/gif.latex?h%28x%29%3Dwx">，用其对如下数据进行拟合：</p> 
   <figure class="image">
    <img alt="单变量线性回归1" height="182" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190721210228993.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70" width="321">
    <figcaption>
     图2.6.3 没有偏置的线性回归
    </figcaption>
   </figure>
   <figure class="image">
    <img alt="带有偏置的线性回归" height="166" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190721213723360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70" width="323">
    <figcaption>
     图2.6.4 带有偏置的线性回归
    </figcaption>
   </figure>
   <p>&nbsp; &nbsp; &nbsp; &nbsp; 从图2.6可以看出，在仅含有权重参数&nbsp;<img alt="w" class="mathcode" src="https://private.codecogs.com/gif.latex?w">&nbsp;的情况下，假设函数必须经过原点，但这将使其无论如何也无法回归出一条完美拟合的直线，而当添加偏置&nbsp;<img alt="b" class="mathcode" src="https://private.codecogs.com/gif.latex?b">&nbsp;后，假设函数变为&nbsp;<img alt="h(x)=wx+b" class="mathcode" src="https://private.codecogs.com/gif.latex?h%28x%29%3Dwx&amp;plus;b">&nbsp;，直线将可以通过任意点，进而对数据进行拟合，这个原理可引申到深度学习的前向传播算法中（&nbsp;<img alt="Z=W^{T}A+b" class="mathcode" src="https://private.codecogs.com/gif.latex?Z%3DW%5E%7BT%7DA&amp;plus;b">），即<span style="color:#f33b45;"><strong>给网络增加了平移的能力（激活函数则可以改变网络拟合的形状），无论在回归还是分类问题中，都可以使网络更好的拟合数据</strong></span>。</p> 
  </blockquote> 
  <h2 id="2.6%E6%B1%A0%E5%8C%96%EF%BC%88pooling%EF%BC%89">2.7池化（<strong>pooling）</strong></h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 在通过卷积获得了特征 (features) 之后，下一步我们希望利用这些特征去做分类。理论上讲，人们可以用所有提取得到的特征去训练分类器，但这样做会面临<span style="color:#f33b45;"><strong>巨大计算量</strong></span>的挑战。并且容易出现<span style="color:#f33b45;"><strong>过拟合</strong></span> (over-fitting)。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 为了解决这个问题，首先回忆一下，我们之所以决定使用卷积后的特征是因为图像具有一种“静态性”的属性，这也就意味着在一个图像区域有用的特征极有可能在另一个区域同样适用。因此，为了描述大的图像，一个很自然的想法就是对不同位置的特征进行聚合统计，例如，人们可以计算图像一个区域上的特征的最大值 (或平均值)。这些统计到的特征不仅具有低得多的维度 (相比使用所有提取得到的特征)，同时还会改善结果(不容易过拟合)。这种聚合的操作就叫做<strong>池化 (pooling)</strong>。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 除了最大值池化（Max Pooling）之外，还有平均值池化（Average pooling）等。相对于Max池化是从目标区域中取出最大值，Average池化则是计算目标区域的平均值。如图2.6.1所示的即为Max池化的运算过程，Average池化依此类推。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="池化" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190721225413179.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图2.7.1 池化
    </figcaption>
   </figure>
  </div> 
  <p>池化有4个重要特性：</p> 
  <ul>
   <li>不同于卷积，池化没有需要学习的参数。</li> 
   <li>池化运算后图像的高度和宽度被压缩，但通过数不会改变。</li> 
   <li>降低了数据特征，扩大了卷积核的感受野。</li> 
   <li>微小的位置变化具有鲁棒性，在输入数据发生微小偏差时，池化仍会返回相同的结果。如图2.6.2为例，输入数据在宽度方向上只偏离1个元素时，输出仍为相同的结果（根据数据的不同，有时结果也不相同）。</li> 
  </ul>
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="池化的鲁棒性" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190721230417919.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图2.7.2&nbsp;池化的鲁棒性
    </figcaption>
   </figure>
  </div> 
  <blockquote> 
   <p><span style="color:#f33b45;"><strong>注：</strong></span>在图像识别领域，主要使用Max池化。所以通常所说的“池化层”，指的就是Max池化。</p> 
  </blockquote> 
  <h2 id="%E5%85%A8%E5%B1%80%E6%B1%A0%E5%8C%96%20(Global%20Pooling)">2.8全局池化 (Global Pooling)</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; “global pooling”在滑窗内的具体池化方法可以是任意的，所以就会被细分为“global average pooling”、“global max pooling”等。在 Network in Network 的工作中，作者使用GAP（Global average pooling）来取代了传统方式最后的全连接层，直接实现了降维，更重要的是极大地减少了网络的参数(CNN网络中占比最大的参数其实后面的全连接层)。GAP的结构如下图所示:</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="GAP" height="291" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190721232124372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70" width="708">
    <figcaption>
     图2.8 Global average pooling
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 虽然说GAP就是把池化的窗口大小设置成输入图像的大小，但这并不是GAP内涵的全部。<strong>GAP的意义是对整个网络从结构上做正则化防止过拟合</strong>。既降低参数避免了全连接带来的过拟合风险，又达到了全连接一样的转换功能。</p> 
  <h2 id="2.8%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0">2.9激活函数（activation functions）</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 为什么神经网络需要非线性激活函数？事实证明：为了使神经网络能够拟合出各种复杂的函数，必须使用非线性激活函数。在神经网络的正向传播过程中（<img alt="Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}" class="mathcode" src="https://private.codecogs.com/gif.latex?Z%5E%7B%5Bl%5D%7D%3DW%5E%7B%5Bl%5D%7DA%5E%7B%5Bl-1%5D%7D&amp;plus;b%5E%7B%5Bl%5D%7D">，&nbsp;<img alt="A^{[l]}=g(Z^{[l]})" class="mathcode" src="https://private.codecogs.com/gif.latex?A%5E%7B%5Bl%5D%7D%3Dg%28Z%5E%7B%5Bl%5D%7D%29">），如果我们去掉激活函数&nbsp;<img alt="g" class="mathcode" src="https://private.codecogs.com/gif.latex?g">&nbsp;，则&nbsp;<img alt="A^{[l]}=Z^{[l]}" class="mathcode" src="https://private.codecogs.com/gif.latex?A%5E%7B%5Bl%5D%7D%3DZ%5E%7B%5Bl%5D%7D">，这个有时被叫做线性激活函数（更学术点的名字是恒等激励函数，因为它们就是把输入值输出），具体公式如下：</p> 
  <p>第一层：<img alt="A^{[1]}=Z^{[1]}=W^{[1]}X+b^{[1]}" class="mathcode" src="https://private.codecogs.com/gif.latex?A%5E%7B%5B1%5D%7D%3DZ%5E%7B%5B1%5D%7D%3DW%5E%7B%5B1%5D%7DX&amp;plus;b%5E%7B%5B1%5D%7D"></p> 
  <p>第二层：<img alt="A^{[2]}=Z^{[2]}=W^{[2]}A^{[1]}+b^{[2]}" class="mathcode" src="https://private.codecogs.com/gif.latex?A%5E%7B%5B2%5D%7D%3DZ%5E%7B%5B2%5D%7D%3DW%5E%7B%5B2%5D%7DA%5E%7B%5B1%5D%7D&amp;plus;b%5E%7B%5B2%5D%7D"></p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 将&nbsp;<img alt="A^{[1]}" class="mathcode" src="https://private.codecogs.com/gif.latex?A%5E%7B%5B1%5D%7D">&nbsp;带入可得第二层：<img alt="A^{[2]}=Z^{[2]}=W^{[2]}(W^{[1]}X+b^{[1]})+b^{[2]}=W^{[2]}W^{[1]}X+W^{[2]}b^{[1]}+b^{[2]}" class="mathcode" src="https://private.codecogs.com/gif.latex?A%5E%7B%5B2%5D%7D%3DZ%5E%7B%5B2%5D%7D%3DW%5E%7B%5B2%5D%7D%28W%5E%7B%5B1%5D%7DX&amp;plus;b%5E%7B%5B1%5D%7D%29&amp;plus;b%5E%7B%5B2%5D%7D%3DW%5E%7B%5B2%5D%7DW%5E%7B%5B1%5D%7DX&amp;plus;W%5E%7B%5B2%5D%7Db%5E%7B%5B1%5D%7D&amp;plus;b%5E%7B%5B2%5D%7D">，令&nbsp;<img alt="W^{[2]}W^{[1]}=W^{'}" class="mathcode" src="https://private.codecogs.com/gif.latex?W%5E%7B%5B2%5D%7DW%5E%7B%5B1%5D%7D%3DW%5E%7B%27%7D">，<img alt="W^{[2]}b^{[1]}+b^{[2]}=b^{'}" class="mathcode" src="https://private.codecogs.com/gif.latex?W%5E%7B%5B2%5D%7Db%5E%7B%5B1%5D%7D&amp;plus;b%5E%7B%5B2%5D%7D%3Db%5E%7B%27%7D">，则第二层变为：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="A^{[2]}=Z^{[2]}=W^{'}X+b^{'}" class="mathcode" src="https://private.codecogs.com/gif.latex?A%5E%7B%5B2%5D%7D%3DZ%5E%7B%5B2%5D%7D%3DW%5E%7B%27%7DX&amp;plus;b%5E%7B%27%7D"></p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 依此类推，网络的输出仅仅只是<strong>输入特征的线性组合</strong>。实际上，无论网络有多少层，整体完全可以仅使用1层表示。同理，引入其他线性函数&nbsp;（如<img alt="g^{'}=2x" class="mathcode" src="https://private.codecogs.com/gif.latex?g%5E%7B%27%7D%3D2x">）仍然起不到任何作用，因为线性函数的组合本身仍是线性函数。</p> 
  <blockquote> 
   <p><span style="color:#f33b45;"><strong>注：</strong></span>某些特殊情况可能会用到线性激活函数，如机器学习中回归问题的输出层（不在隐藏层）或是压缩问题（可以在隐藏层）。</p> 
  </blockquote> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 常用的激活函数主要有：</p> 
  <p>（1）sigmoid函数&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;（2）tanh 函数</p> 
  <figure class="image">
   <img alt="sigmoid函数" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019072212325621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
   <figcaption>
    图2.9.1&nbsp;sigmoid函数
   </figcaption>
  </figure>
  <figure class="image">
   <img alt="tanh函数" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019072212335374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
   <figcaption>
    图2.9.2&nbsp;tanh函数
   </figcaption>
  </figure>
  <p>&nbsp;</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="g(z)=\frac{1}{1+e^{-z}}" class="mathcode" src="https://private.codecogs.com/gif.latex?g%28z%29%3D%5Cfrac%7B1%7D%7B1&amp;plus;e%5E%7B-z%7D%7D">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;<img alt="g(z)=\tanh (z)=\frac{e^{z}-e^{-z}}{e^{z}+e^{-z}}" class="mathcode" src="https://private.codecogs.com/gif.latex?g%28z%29%3D%5Ctanh%20%28z%29%3D%5Cfrac%7Be%5E%7Bz%7D-e%5E%7B-z%7D%7D%7Be%5E%7Bz%7D&amp;plus;e%5E%7B-z%7D%7D"></p> 
  <blockquote> 
   <p><span style="color:#f33b45;"><strong>注：</strong></span>tanh函数的效果总是优于 sigmoid 函数。因为函数值域在-1 和+1的激活函数，其均值是更接近零均值的。在训练一个算法模型时，如果使用 tanh 函数代替sigmoid 函数中心化数据，会使得数据的平均值更接近 0 而不是 0.5。</p> 
   <p><span style="color:#f33b45;"><strong>注：</strong></span>sigmoid 函数和 tanh 函数两者共同的缺点是，在&nbsp;<img alt="z" class="mathcode" src="https://private.codecogs.com/gif.latex?z">&nbsp;特别大或者特别小的情况下，导数的梯度或者函数的斜率会变得特别小，最后就会接近于 0，导致降低梯度下降的速度。</p> 
  </blockquote> 
  <p>（3）修正线性单元的函数（ReLu）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;（4）Leaky Relu函数</p> 
  <figure class="image">
   <img alt="relu函数" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722152700598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
   <figcaption>
    图2.9.3&nbsp;relu函数
   </figcaption>
  </figure>
  <figure class="image">
   <img alt="leaky relu函数" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722152812109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
   <figcaption>
    图2.9.4&nbsp;leaky relu函数
   </figcaption>
  </figure>
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <img alt="g(z)=max(0,z)" class="mathcode" src="https://private.codecogs.com/gif.latex?g%28z%29%3Dmax%280%2Cz%29">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;<img alt="g(z)=max(\alpha z,z)" class="mathcode" src="https://private.codecogs.com/gif.latex?g%28z%29%3Dmax%28%5Calpha%20z%2Cz%29">，一般&nbsp;<img alt="\alpha =0.01" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Calpha%20%3D0.01"></p> 
  <blockquote> 
   <p><span style="color:#f33b45;"><strong>注：</strong></span>Relu 进入负半区的时候，梯度为 0，神经元此时不会训练，产生所谓的稀疏性，而 Leaky ReLu 不会有这问题。</p> 
  </blockquote> 
  <h1 id="3%E7%89%B9%E6%80%A7">3特性</h1> 
  <h2 id="3.1%E5%B1%80%E9%83%A8%E6%84%9F%E7%9F%A5">3.1局部感知</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 一般认为，人对外界的认知是从局部到全局的，而对于图像来说，空间联系也是局部的像素联系较为紧密，而距离较远的像素相关性则较弱。因而，每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。网络部分连通的思想，也是受启发于生物学里面的视觉系统结构。视觉皮层的神经元就是局部接受信息的（即这些神经元只响应某些特定区域的刺激）。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 在全连接神经网络中（如图3.1所示），相邻层的神经元全部连接在一起，由于其输入数据是一维结构，故图像需先转换为一维向量，而这个过程，也导致图像完全丢失了“形状”，即像素间的空间信息，从理论上来讲，神经网络几乎能解决所有深度学习问题，但是在处理复杂问题时，往往难以达到理想的效果。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="全连接与局部连接" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190719205050450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图3.1&nbsp;全连接与局部连接
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;该类网络不仅参数量巨大，且学习速度较慢，即使是一个简单的问题，一般也需要几百次甚至上千次的学习才能收敛，而且易产生过拟合问题，泛化能力较弱。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 而卷积层则可以保持形状不变。当输入图像时，卷积层会以3维数据的形式接收输入数据，并同样以3维数据的形式输出至下一层。因此，在CNN中，可以正确理解图像等具有形状的数据，而且由于局部连接，大大降低了参数量，节省了内存。</p> 
  <h2 id="3.2%E5%8F%82%E6%95%B0%E5%85%B1%E4%BA%AB">3.2参数共享</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 也可理解为“平移不变性”。卷积神经网络在图像的某一区域学到某个模式之后，它就可以在图像的任何地方识别这个模式。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="参数共享" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190719215014431.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图3.2&nbsp;参数共享
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 如图3.2所示，假设使用某一特征过滤器（检测器）提取 “手写5” 的特征，那么图片的右下角区域，以及旁边的各个区域都可以使用这个过滤器。每个特征检测器以及输出都可以在输入图片的不同区域中使用同样的参数，以便提取特征 “5”。而对于全连接网络来说，如果模式出现在新的位置，它只能重新学习这个模式。这使得卷积神经网络在处理图像时可以高效利用数据（因为视觉世界从根本上具有平移不变性），只需要更少的训练样本就可以学到具有泛化能力的数据表示。</p> 
  <h2 id="3.3%E5%88%86%E5%B1%82%E6%8F%90%E5%8F%96">3.3分层提取</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 卷积神经网络可以学到<strong>模式的空间层次结构</strong>（spatial hierarchies of patterns）。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="分层提取" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190719224502463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图3.3&nbsp;分层提取
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 如图3.3。第一个卷积层将学习较小的局部模式（比如边缘），第二个卷积层将学习由第一层特征组成的更大的模式，以此类推，层数越高，学到的特征就越全局化。这使得卷积神经网络可以有效地学习越来越复杂、越来越抽象的视觉概念（视觉世界从根本上具有空间层次结构）。</p> 
  <h2 id="3.4%E6%84%9F%E5%8F%97%E9%87%8E%EF%BC%88Receptive%20field%EF%BC%89">3.4感受野（Receptive field）</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 感受野用来表示网络内部的不同神经元对原图像的感受范围的大小，换句话说，即为每一层输出的特征图(feature map)上的像素点在原始图像上映射的区域大小。其中神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节，因此感受野的值可以用来大致判断每一层的抽象层次。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="感受野" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190719233227268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图3.4 感受野
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 对于卷积核 Conv1 来说，其每个元素在原图像上所能看到的范围是&nbsp;<img alt="3\times 3" class="mathcode" src="https://private.codecogs.com/gif.latex?3%5Ctimes%203">（感受野值为 3），又因为卷积核Conv1的大小为3，步长为2，且卷积核 Conv2的大小为2，步长为1，结合可知，Conv2中的每一个元素可包含 Conv1 中大小为2的元素，而2个 Conv1 所能覆盖原始图像的范围为&nbsp;<img alt="5\times 5" class="mathcode" src="https://private.codecogs.com/gif.latex?5%5Ctimes%205">，故Conv2的感受野值为 5。</p> 
  <h2 id="3.5%E5%A4%9A%E6%A0%B8%E5%8D%B7%E7%A7%AF">3.5多核卷积</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 一个卷积核只能提取某一种特征，而计算机对于一幅图像的 “理解” 过程中，往往需要对其多个特征进行学习，其每个卷积核都是一种特征提取方式，就像一个筛子，将图像中符合条件（激活值越大越符合条件）的部分筛选出来。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 如图3.3，我们人类对于猫的理解会包括猫的耳朵、鼻子和眼睛，故其可采取图示的三种卷积核来进行提取，而更底层的特征，如不同形状的曲线、图案等则由其他不同种类的卷积核来进行提取。</p> 
  <h1 id="4%E5%B1%80%E9%83%A8%E5%8D%B7%E7%A7%AF">4局部卷积</h1> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 以LeNet网络举例，其结构如下图所示：</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="LeNet" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190720105936591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图4.1&nbsp;LeNet
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 原始图像进来以后，先进入一个卷积层C1，由6个 5x5 的卷积核组成，卷积出28x28的图像，然后下采样到14x14（S2）。接下来，再进一个卷积层C3，由16个5x5的卷积核组成，之后再下采样到5x5（S4）。注意，这里S2与C3的连接方式并不是全连接，而是部分连接，如下图所示：</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="卷积的部分连接" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190720111052512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图4.2&nbsp;卷积的部分连接
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 其中行代表S2层的某个节点，列代表C3层的某个节点。我们可以看出，C3的 0 和S2的 0、1、2 连接，C3的 1 和S2的 1、2、3 连接，不过从C3的6~13变为了每次连接4个节点，C3的14变为了5个节点，C3的15与S2的节点全部连接。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 即用不同底层特征的组合，可以得到进一步的高级特征，例如：/ + \ =&nbsp;<img alt="\wedge" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Cwedge">，再比如，以图3.3为例，第一层的9个卷积核与输入图像 “猫” 是全部连接，从 “猫” 中得到了9种不同的底层特征图（各类底层曲线及图案），而第二层的卷积核1（将用于提取 “猫眼睛”）则只与第一层的特征图1~5相连接（即仅与特征图1~5进行卷积运算），同理，第二层的卷积核3（“猫耳朵”）则只与第一层的特征图7~9相连接。</p> 
  <blockquote> 
   <p><span style="color:#f33b45;"><strong>注：</strong></span>此处所说的 “全部连接” 与BP神经网络中的 “全连接” 有着本质的不同，BP神经网络中的全连接表示网络中的每一个神经元都与上一层的所有神经元相连接，而卷积网络中的 “全部连接” 只是表示该层的卷积核与上一层特征图的所有通道进行卷积，但卷积运算的过程仍是 “局部连接”。</p> 
   <div style="text-align:center;"> 
    <figure class="image">
     <img alt="卷积的“全部连接”与“部分连接”" height="432" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190720121918932.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70" width="815">
     <figcaption>
      图4.3&nbsp;卷积的“全部连接”与“部分连接”
     </figcaption>
    </figure>
   </div> 
   <p>&nbsp; &nbsp; &nbsp; &nbsp; 结合图3.3，以图4.3为例，第一层中卷积核1~9的通道数都与原图像的相同（值都为3），故此处属于卷积的 “全部连接”，也是卷积运算默认的连接方式，而第二层中卷积核1的通道数为5，卷积核3的通道数为3，而上层特征图的通道数为9，故此处属于卷积的 “局部连接”。</p> 
   <p><strong><span style="color:#f33b45;">注：</span></strong>在此处，卷积核1与卷积核3分别仅与第1~5层特征图、7~9层特征图进行卷积运算，即分别仅在其所处的立体空间中的一个面内移动，分别输出的是一个二维的图像（通道数为1），<strong><span style="color:#f33b45;">其与处理视频序列的三维卷积概念不同</span></strong>。</p> 
  </blockquote> 
  <h1 id="5%E5%8D%B7%E7%A7%AF%E5%B1%82%E5%92%8C%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0">5卷积层和池化层的实现</h1> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 如果以传统思维使用for循环来实现的话，则在巨大数据量的情况下，for循环进行计算和切换内存的时间消耗会非常大。而采用向量化的并行计算方式则可以大幅缩短计算时间。</p> 
  <h2 id="5.1%E5%8D%B7%E7%A7%AF%E5%AE%9E%E7%8E%B0">5.1卷积实现</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 如图5.1所示，首先对于输入数据，将应用滤波器的区域（3维方块）横向展开为1列以匹配卷积核（权重），然后将卷积核依次展开为1列，计算两者的矩阵乘积，最后将得到的2维数据reshape至4维。</p> 
  <blockquote> 
   <p><span style="color:#f33b45;"><strong>注：</strong></span>为了便于观察，将步幅设置得很大，以使滤波器的应用区域不重叠。而在实际的卷积运算中，滤波器的应用区域几乎都是重叠的。在滤波器的应用区域重叠的情况下，展开后的元素个数会多于原方块的元素个数。因此该方法比普通的实现会消耗更多的内存。</p> 
   <p><span style="color:#f33b45;"><strong>注：</strong></span>在程序中，因为包含批处理数量（N幅图像同时处理），故输入数据是4维，卷积核也是所有共同展开，故也是4维。其中：N——批处理的图像数量（样本数）；FN——滤波器数量；C——通道数；H——高度；W——宽度</p> 
  </blockquote> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="卷积实现" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722105035403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图5.1&nbsp;卷积实现
    </figcaption>
   </figure>
  </div> 
  <blockquote> 
   <p><span style="color:#f33b45;"><strong>注：</strong></span>im2col 是一个展开函数，名称是“image to column”的缩写，即 “从图像到矩阵” 的意思。Caffe、Chainer等深度学习框架中有名为im2col 的函数，并且在卷积层的实现中，都使用了 im2col。</p> 
  </blockquote> 
  <h2 id="5.2%E6%B1%A0%E5%8C%96%E5%AE%9E%E7%8E%B0">5.2池化实现</h2> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 池化层的实现和卷积层相同，都对输入数据进行展开。不过，池化的情况下，在通道方向上是独立的。如图5.2所示，池化的应用区域按通道单独展开。如图5.2所示，对于输入数据的每一层的池化区域分别展开为2维向量，然后对每一行求最大值得到一个1维向量，最后将该向量reshape为合适的维数。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="池化实现" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722110824855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图5.2&nbsp;池化实现
    </figcaption>
   </figure>
  </div> 
  <h1 id="6%E5%8F%AF%E8%A7%86%E5%8C%96">6可视化</h1> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 学习前的卷积核是随机进行初始化的，所以在黑白的浓淡上没有规律可循，但学习后的滤波器变成了有规律的图像。可以发现，通过学习，滤波器被更新成了有规律的滤波器，比如从白到黑渐变的滤波器、含有块状区域（称为blob）的滤波器等。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="可视化" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722160402330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图6.1&nbsp;可视化
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 以图6.1为例，不同卷积核经过学习改变了自身对不同特征的响应程度，如边缘（颜色变化的分界线）和斑块（局部的块状区域）等，其中第2个卷积核对垂直边缘响应，第5个卷积核对水平边缘响应，第9个对倾斜边缘响应，第13个对中心斑块响应。</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 上面的结果是针对第1层的卷积层得出的。第1层的卷积层中提取了边缘或斑块等“低级”信息，而在堆叠了多层的CNN中，随着层次加深，提取的信息（准确说，是响应强烈的神经元））也越来越抽象。如图6.2所示，第1层的神经元对边缘或斑块有响应，第3层对纹理有响应，第5层对物体部件有响应，最后的全连接层对物体的类别（狗或车）有响应。</p> 
  <div style="text-align:center;"> 
   <figure class="image">
    <img alt="分层可视化" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722160542737.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tfX2xpbnV4,size_16,color_FFFFFF,t_70">
    <figcaption>
     图6.2&nbsp;分层可视化
    </figcaption>
   </figure>
  </div> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 也就是说，随着层次加深，神经元从简单的形状向“高级”信息变化。换句话说，就像我们理解东西的“含义”一样，响应的对象在逐渐变化。</p> 
  <h1 id="7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%9C%AC%E8%B4%A8">7神经网络的本质</h1> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 神经网络由大量的节点（或称“神经元”，卷积神经网络中为“特征图”）相互连接构成，每个节点代表一种特定的函数，称为激励函数（Activation Function）。节点之间的连接具有特定的权重，信号经过会进行加权，代表神经网络的记忆。网络的输出则依网络的连接方式、权重值和激励函数的不同而不同。<span style="color:#f33b45;"><strong>网络本身则代表对自然界某种算法或者函数的逼近，也可以是一种逻辑策略的表达</strong></span>。</p> 
  <p>&nbsp;</p> 
  <h1 id="%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">参考文章</h1> 
  <p>《吴恩达深度学习》</p> 
  <p>《深度学习入门：基于Python的理论与实现》</p> 
  <p>《Python深度学习》</p> 
  <p>《行人检测：理论与实践》</p> 
  <p><a href="https://www.cnblogs.com/alexcai/p/5506806.html" rel="nofollow" data-token="fabecc9621e5987a77064feffb5493c7">深度学习简介(一)——卷积神经网络</a></p> 
  <p><a href="https://www.jianshu.com/p/2b968e7a1715" rel="nofollow" data-token="2f8ef92096df33f1d744f80f9abfd746">Receptive field(感受野)</a></p> 
  <p><a href="https://towardsdatascience.com/intuitively-understanding-convolutions-for-deep-learning-1f6f42faee1" rel="nofollow" data-token="2b834da289535d506101b27485c25e95">Intuitively Understanding Convolutions for Deep Learning</a></p> 
  <p><a href="https://blog.csdn.net/amusi1994/article/details/81091145" rel="nofollow" data-token="37c906f5e838b8fd0de99be1e837044e">一文读懂卷积神经网络中的1x1卷积核</a></p> 
  <p><a href="https://www.jianshu.com/p/04f7771f4da2" rel="nofollow" data-token="6f85c7f35e56ee4de5fdf6d66b7239c8">Global average pooling (GAP)</a></p> 
  <p><a href="https://www.jianshu.com/p/eb29e624173e" rel="nofollow" data-token="5e68581cf93401131050cfb9b60e2c25">深度学习笔记：三维图片分类与三维卷积神经网络</a></p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
