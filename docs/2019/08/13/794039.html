<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Kubernets笔记（十六）－－Secrect | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Kubernets笔记（十六）－－Secrect" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Secret 上节课我们学习了ConfigMap的时候，我们说ConfigMap这个资源对象是Kubernetes当中非常重要的一个对象，一般情况下ConfigMap是用来存储一些非安全的配置信息，如果涉及到一些安全相关的数据的话用ConfigMap就非常不妥了，因为ConfigMap是名为存储的，我们说这个时候我们就需要用到另外一个资源对象了：Secret，Secret用来保存敏感信息，例如密码、OAuth 令牌和 ssh key等等，将这些信息放在Secret中比放在Pod的定义中或者docker镜像中来说更加安全和灵活。 Secret有三种类型： Opaque：base64 编码格式的 Secret，用来存储密码、密钥等；但数据也可以通过base64 –decode解码得到原始数据，所有加密性很弱。 kubernetes.io/dockerconfigjson：用来存储私有docker registry的认证信息。 kubernetes.io/service-account-token：用于被serviceaccount引用，serviceaccout 创建时Kubernetes会默认创建对应的secret。Pod如果使用了serviceaccount，对应的secret会自动挂载到Pod目录/run/secrets/kubernetes.io/serviceaccount中。 Opaque Secret 1 从文件中创建Secret 分别创建两个名为username.txt和password.txt的文件： $ echo -n &quot;admin&quot; &gt; ./username.txt $ echo -n &quot;1f2d1e2e67df&quot; &gt; ./password.txt 使用kubectl create secret命令创建secret： $ kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt secret &quot;db-user-pass&quot; created 2 使用描述文件创建Secret Opaque 类型的数据是一个 map 类型，要求value是base64编码格式，比如我们来创建一个用户名为 admin，密码为 admin321 的 Secret 对象，首先我们先把这用户名和密码做 base64 编码， $ echo -n &quot;admin&quot; | base64 YWRtaW4= $ echo -n &quot;admin321&quot; | base64 YWRtaW4zMjE= 然后我们就可以利用上面编码过后的数据来编写一个YAML文件：(secret-demo.yaml) apiVersion: v1 kind: Secret metadata: name: mysecret type: Opaque data: username: YWRtaW4= password: YWRtaW4zMjE= 然后同样的我们就可以使用kubectl命令来创建了： $ kubectl create -f secret-demo.yaml secret &quot;mysecret&quot; created 利用get secret命令查看： $ kubectl get secret NAME TYPE DATA AGE default-token-n9w2d kubernetes.io/service-account-token 3 33d mysecret Opaque 2 40s 其中default-token-cty7pdefault-token-n9w2d为创建集群时默认创建的 secret，被serviceacount/default 引用。 使用describe命令，查看详情： $ kubectl describe secret mysecret Name: mysecret Namespace: default Labels: &lt;none&gt; Annotations: &lt;none&gt; Type: Opaque Data ==== password: 8 bytes username: 5 bytes 我们可以看到利用describe命令查看到的Data没有直接显示出来，如果想看到Data里面的详细信息，同样我们可以输出成YAML文件进行查看： $ kubectl get secret mysecret -o yaml apiVersion: v1 data: password: YWRtaW4zMjE= username: YWRtaW4= kind: Secret metadata: creationTimestamp: 2018-06-19T15:27:06Z name: mysecret namespace: default resourceVersion: &quot;3694084&quot; selfLink: /api/v1/namespaces/default/secrets/mysecret uid: 39c139f5-73d5-11e8-a101-525400db4df7 type: Opaque 创建好Secret对象后，有两种方式来使用它： 以环境变量的形式 以Volume的形式挂载 环境变量 首先我们来测试下环境变量的方式，同样的，我们来使用一个简单的busybox镜像来测试下:(secret1-pod.yaml) apiVersion: v1 kind: Pod metadata: name: secret1-pod spec: containers: - name: secret1 image: busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ] env: - name: USERNAME valueFrom: secretKeyRef: name: mysecret key: username - name: PASSWORD valueFrom: secretKeyRef: name: mysecret key: password 主要上面环境变量中定义的secretKeyRef关键字，和我们上节课的configMapKeyRef是不是比较类似，一个是从Secret对象中获取，一个是从ConfigMap对象中获取，创建上面的Pod： $ kubectl create -f secret1-pod.yaml pod &quot;secret1-pod&quot; created 然后我们查看Pod的日志输出： $ kubectl logs secret1-pod ... USERNAME=admin PASSWORD=admin321 ... 可以看到有 USERNAME 和 PASSWORD 两个环境变量输出出来。 Volume 挂载 同样的我们用一个Pod来验证下Volume挂载，创建一个Pod文件：(secret2-pod.yaml) apiVersion: v1 kind: Pod metadata: name: secret2-pod spec: containers: - name: secret2 image: busybox command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/secrets&quot;] volumeMounts: - name: secrets mountPath: /etc/secrets volumes: - name: secrets secret: secretName: mysecret 创建Pod: $ kubectl create -f secret-pod2.yaml pod &quot;secret2-pod&quot; created 然后我们查看输出日志： $ kubectl logs secret2-pod password username 可以看到secret把两个key挂载成了两个对应的文件。当然如果想要挂载到指定的文件上面，在secretName下面添加items指定 key 和 path即可。也可以只挂载Secret中特定的key： apiVersion: v1 kind: Pod metadata: name: mypod spec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; readOnly: true volumes: - name: foo secret: secretName: mysecret items: - key: username path: my-group/my-username 在这种情况下： username 存储在/etc/foo/my-group/my-username中 password未被挂载 kubernetes.io/dockerconfigjson 除了上面的Opaque这种类型外，我们还可以来创建用户docker registry认证的Secret，直接使用kubectl create命令创建即可，如下： $ kubectl create secret docker-registry myregistry --docker-server=DOCKER_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL secret &quot;myregistry&quot; created 然后查看Secret列表： $ kubectl get secret NAME TYPE DATA AGE default-token-n9w2d kubernetes.io/service-account-token 3 33d myregistry kubernetes.io/dockerconfigjson 1 15s mysecret Opaque 2 34m 注意看上面的TYPE类型，myregistry是不是对应的kubernetes.io/dockerconfigjson，同样的可以使用describe命令来查看详细信息： $ kubectl describe secret myregistry Name: myregistry Namespace: default Labels: &lt;none&gt; Annotations: &lt;none&gt; Type: kubernetes.io/dockerconfigjson Data ==== .dockerconfigjson: 152 bytes 同样的可以看到Data区域没有直接展示出来，如果想查看的话可以使用-o yaml来输出展示出来： $ kubectl get secret myregistry -o yaml apiVersion: v1 data: .dockerconfigjson: eyJhdXRocyI6eyJET0NLRVJfU0VSVkVSIjp7InVzZXJuYW1lIjoiRE9DS0VSX1VTRVIiLCJwYXNzd29yZCI6IkRPQ0tFUl9QQVNTV09SRCIsImVtYWlsIjoiRE9DS0VSX0VNQUlMIiwiYXV0aCI6IlJFOURTMFZTWDFWVFJWSTZSRTlEUzBWU1gxQkJVMU5YVDFKRSJ9fX0= kind: Secret metadata: creationTimestamp: 2018-06-19T16:01:05Z name: myregistry namespace: default resourceVersion: &quot;3696966&quot; selfLink: /api/v1/namespaces/default/secrets/myregistry uid: f91db707-73d9-11e8-a101-525400db4df7 type: kubernetes.io/dockerconfigjson 可以把上面的data.dockerconfigjson下面的数据做一个base64解码，看看里面的数据是怎样的呢？ $ echo eyJhdXRocyI6eyJET0NLRVJfU0VSVkVSIjp7InVzZXJuYW1lIjoiRE9DS0VSX1VTRVIiLCJwYXNzd29yZCI6IkRPQ0tFUl9QQVNTV09SRCIsImVtYWlsIjoiRE9DS0VSX0VNQUlMIiwiYXV0aCI6IlJFOURTMFZTWDFWVFJWSTZSRTlEUzBWU1gxQkJVMU5YVDFKRSJ9fX0= | base64 -d {&quot;auths&quot;:{&quot;DOCKER_SERVER&quot;:{&quot;username&quot;:&quot;DOCKER_USER&quot;,&quot;password&quot;:&quot;DOCKER_PASSWORD&quot;,&quot;email&quot;:&quot;DOCKER_EMAIL&quot;,&quot;auth&quot;:&quot;RE9DS0VSX1VTRVI6RE9DS0VSX1BBU1NXT1JE&quot;}}} 如果我们需要拉取私有仓库中的docker镜像的话就需要使用到上面的myregistry这个Secret： apiVersion: v1 kind: Pod metadata: name: foo spec: containers: - name: foo image: 192.168.1.100:5000/test:v1 imagePullSecrets: - name: myregistrykey 我们需要拉取私有仓库镜像192.168.1.100:5000/test:v1，我们就需要针对该私有仓库来创建一个如上的Secret，然后在Pod的 YAML 文件中指定imagePullSecrets，我们会在后面的私有仓库搭建的课程中跟大家详细说明的。 kubernetes.io/service-account-token 另外一种Secret类型就是kubernetes.io/service-account-token，用于被serviceaccount引用。serviceaccout 创建时 Kubernetes 会默认创建对应的 secret。Pod 如果使用了 serviceaccount，对应的secret会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount目录中。 这里我们使用一个nginx镜像来验证一下，大家想一想为什么不是用busybox镜像来验证？当然也是可以的，但是我们就不能在command里面来验证了，因为token是需要Pod运行起来过后才会被挂载上去的，直接在command命令中去查看肯定是还没有 token 文件的。 $ kubectl run secret-pod3 --image nginx:1.7.9（直接运行即可） deployment.apps &quot;secret-pod3&quot; created $ kubectl get pods NAME READY STATUS RESTARTS AGE ... secret-pod3-78c8c76db8-7zmqm 1/1 Running 0 13s ... $ kubectl exec secret-pod3-78c8c76db8-7zmqm ls /run/secrets/kubernetes.io/serviceaccount ca.crt namespace token $ kubectl exec secret-pod3-78c8c76db8-7zmqm cat /run/secrets/kubernetes.io/serviceaccount/token eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tbjl3MmQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjMzY2FkOWQxLTU5MmYtMTFlOC1hMTAxLTUyNTQwMGRiNGRmNyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.0FpzPD8WO_fwnMjwpGIOphdVu4K9wUINwpXpBOJAQ-Tawd0RTbAUHcgYy3sEHSk9uvgnl1FJRQpbQN3yVR_DWSIlAtbmd4dIPxK4O7ZVdd4UnmC467cNXEBqL1sDWLfS5f03d7D1dw1ljFJ_pJw2P65Fjd13reKJvvTQnpu5U0SDcfxj675-Z3z-iOO3XSalZmkFIw2MfYMzf_WpxW0yMFCVkUZ8tBSTegA9-NJZededceA_VCOdKcUjDPrDo-CNti3wZqax5WPw95Ou8RJDMAIS5EcVym7M2_zjGiqHEL3VTvcwXbdFKxsNX-1VW6nr_KKuMGKOyx-5vgxebl71QQ Secret 与 ConfigMap 对比 最后我们来对比下Secret和ConfigMap这两种资源对象的异同点： 相同点： key/value的形式 属于某个特定的namespace 可以导出到环境变量 可以通过目录/文件形式挂载 通过 volume 挂载的配置信息均可热更新 不同点： Secret 可以被 ServerAccount 关联 Secret 可以存储 docker register 的鉴权信息，用在 ImagePullSecret 参数中，用于拉取私有仓库的镜像 Secret 支持 Base64 加密 Secret 分为 kubernetes.io/service-account-token、kubernetes.io/dockerconfigjson、Opaque 三种类型，而 Configmap 不区分类型" />
<meta property="og:description" content="Secret 上节课我们学习了ConfigMap的时候，我们说ConfigMap这个资源对象是Kubernetes当中非常重要的一个对象，一般情况下ConfigMap是用来存储一些非安全的配置信息，如果涉及到一些安全相关的数据的话用ConfigMap就非常不妥了，因为ConfigMap是名为存储的，我们说这个时候我们就需要用到另外一个资源对象了：Secret，Secret用来保存敏感信息，例如密码、OAuth 令牌和 ssh key等等，将这些信息放在Secret中比放在Pod的定义中或者docker镜像中来说更加安全和灵活。 Secret有三种类型： Opaque：base64 编码格式的 Secret，用来存储密码、密钥等；但数据也可以通过base64 –decode解码得到原始数据，所有加密性很弱。 kubernetes.io/dockerconfigjson：用来存储私有docker registry的认证信息。 kubernetes.io/service-account-token：用于被serviceaccount引用，serviceaccout 创建时Kubernetes会默认创建对应的secret。Pod如果使用了serviceaccount，对应的secret会自动挂载到Pod目录/run/secrets/kubernetes.io/serviceaccount中。 Opaque Secret 1 从文件中创建Secret 分别创建两个名为username.txt和password.txt的文件： $ echo -n &quot;admin&quot; &gt; ./username.txt $ echo -n &quot;1f2d1e2e67df&quot; &gt; ./password.txt 使用kubectl create secret命令创建secret： $ kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt secret &quot;db-user-pass&quot; created 2 使用描述文件创建Secret Opaque 类型的数据是一个 map 类型，要求value是base64编码格式，比如我们来创建一个用户名为 admin，密码为 admin321 的 Secret 对象，首先我们先把这用户名和密码做 base64 编码， $ echo -n &quot;admin&quot; | base64 YWRtaW4= $ echo -n &quot;admin321&quot; | base64 YWRtaW4zMjE= 然后我们就可以利用上面编码过后的数据来编写一个YAML文件：(secret-demo.yaml) apiVersion: v1 kind: Secret metadata: name: mysecret type: Opaque data: username: YWRtaW4= password: YWRtaW4zMjE= 然后同样的我们就可以使用kubectl命令来创建了： $ kubectl create -f secret-demo.yaml secret &quot;mysecret&quot; created 利用get secret命令查看： $ kubectl get secret NAME TYPE DATA AGE default-token-n9w2d kubernetes.io/service-account-token 3 33d mysecret Opaque 2 40s 其中default-token-cty7pdefault-token-n9w2d为创建集群时默认创建的 secret，被serviceacount/default 引用。 使用describe命令，查看详情： $ kubectl describe secret mysecret Name: mysecret Namespace: default Labels: &lt;none&gt; Annotations: &lt;none&gt; Type: Opaque Data ==== password: 8 bytes username: 5 bytes 我们可以看到利用describe命令查看到的Data没有直接显示出来，如果想看到Data里面的详细信息，同样我们可以输出成YAML文件进行查看： $ kubectl get secret mysecret -o yaml apiVersion: v1 data: password: YWRtaW4zMjE= username: YWRtaW4= kind: Secret metadata: creationTimestamp: 2018-06-19T15:27:06Z name: mysecret namespace: default resourceVersion: &quot;3694084&quot; selfLink: /api/v1/namespaces/default/secrets/mysecret uid: 39c139f5-73d5-11e8-a101-525400db4df7 type: Opaque 创建好Secret对象后，有两种方式来使用它： 以环境变量的形式 以Volume的形式挂载 环境变量 首先我们来测试下环境变量的方式，同样的，我们来使用一个简单的busybox镜像来测试下:(secret1-pod.yaml) apiVersion: v1 kind: Pod metadata: name: secret1-pod spec: containers: - name: secret1 image: busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ] env: - name: USERNAME valueFrom: secretKeyRef: name: mysecret key: username - name: PASSWORD valueFrom: secretKeyRef: name: mysecret key: password 主要上面环境变量中定义的secretKeyRef关键字，和我们上节课的configMapKeyRef是不是比较类似，一个是从Secret对象中获取，一个是从ConfigMap对象中获取，创建上面的Pod： $ kubectl create -f secret1-pod.yaml pod &quot;secret1-pod&quot; created 然后我们查看Pod的日志输出： $ kubectl logs secret1-pod ... USERNAME=admin PASSWORD=admin321 ... 可以看到有 USERNAME 和 PASSWORD 两个环境变量输出出来。 Volume 挂载 同样的我们用一个Pod来验证下Volume挂载，创建一个Pod文件：(secret2-pod.yaml) apiVersion: v1 kind: Pod metadata: name: secret2-pod spec: containers: - name: secret2 image: busybox command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/secrets&quot;] volumeMounts: - name: secrets mountPath: /etc/secrets volumes: - name: secrets secret: secretName: mysecret 创建Pod: $ kubectl create -f secret-pod2.yaml pod &quot;secret2-pod&quot; created 然后我们查看输出日志： $ kubectl logs secret2-pod password username 可以看到secret把两个key挂载成了两个对应的文件。当然如果想要挂载到指定的文件上面，在secretName下面添加items指定 key 和 path即可。也可以只挂载Secret中特定的key： apiVersion: v1 kind: Pod metadata: name: mypod spec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; readOnly: true volumes: - name: foo secret: secretName: mysecret items: - key: username path: my-group/my-username 在这种情况下： username 存储在/etc/foo/my-group/my-username中 password未被挂载 kubernetes.io/dockerconfigjson 除了上面的Opaque这种类型外，我们还可以来创建用户docker registry认证的Secret，直接使用kubectl create命令创建即可，如下： $ kubectl create secret docker-registry myregistry --docker-server=DOCKER_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL secret &quot;myregistry&quot; created 然后查看Secret列表： $ kubectl get secret NAME TYPE DATA AGE default-token-n9w2d kubernetes.io/service-account-token 3 33d myregistry kubernetes.io/dockerconfigjson 1 15s mysecret Opaque 2 34m 注意看上面的TYPE类型，myregistry是不是对应的kubernetes.io/dockerconfigjson，同样的可以使用describe命令来查看详细信息： $ kubectl describe secret myregistry Name: myregistry Namespace: default Labels: &lt;none&gt; Annotations: &lt;none&gt; Type: kubernetes.io/dockerconfigjson Data ==== .dockerconfigjson: 152 bytes 同样的可以看到Data区域没有直接展示出来，如果想查看的话可以使用-o yaml来输出展示出来： $ kubectl get secret myregistry -o yaml apiVersion: v1 data: .dockerconfigjson: eyJhdXRocyI6eyJET0NLRVJfU0VSVkVSIjp7InVzZXJuYW1lIjoiRE9DS0VSX1VTRVIiLCJwYXNzd29yZCI6IkRPQ0tFUl9QQVNTV09SRCIsImVtYWlsIjoiRE9DS0VSX0VNQUlMIiwiYXV0aCI6IlJFOURTMFZTWDFWVFJWSTZSRTlEUzBWU1gxQkJVMU5YVDFKRSJ9fX0= kind: Secret metadata: creationTimestamp: 2018-06-19T16:01:05Z name: myregistry namespace: default resourceVersion: &quot;3696966&quot; selfLink: /api/v1/namespaces/default/secrets/myregistry uid: f91db707-73d9-11e8-a101-525400db4df7 type: kubernetes.io/dockerconfigjson 可以把上面的data.dockerconfigjson下面的数据做一个base64解码，看看里面的数据是怎样的呢？ $ echo eyJhdXRocyI6eyJET0NLRVJfU0VSVkVSIjp7InVzZXJuYW1lIjoiRE9DS0VSX1VTRVIiLCJwYXNzd29yZCI6IkRPQ0tFUl9QQVNTV09SRCIsImVtYWlsIjoiRE9DS0VSX0VNQUlMIiwiYXV0aCI6IlJFOURTMFZTWDFWVFJWSTZSRTlEUzBWU1gxQkJVMU5YVDFKRSJ9fX0= | base64 -d {&quot;auths&quot;:{&quot;DOCKER_SERVER&quot;:{&quot;username&quot;:&quot;DOCKER_USER&quot;,&quot;password&quot;:&quot;DOCKER_PASSWORD&quot;,&quot;email&quot;:&quot;DOCKER_EMAIL&quot;,&quot;auth&quot;:&quot;RE9DS0VSX1VTRVI6RE9DS0VSX1BBU1NXT1JE&quot;}}} 如果我们需要拉取私有仓库中的docker镜像的话就需要使用到上面的myregistry这个Secret： apiVersion: v1 kind: Pod metadata: name: foo spec: containers: - name: foo image: 192.168.1.100:5000/test:v1 imagePullSecrets: - name: myregistrykey 我们需要拉取私有仓库镜像192.168.1.100:5000/test:v1，我们就需要针对该私有仓库来创建一个如上的Secret，然后在Pod的 YAML 文件中指定imagePullSecrets，我们会在后面的私有仓库搭建的课程中跟大家详细说明的。 kubernetes.io/service-account-token 另外一种Secret类型就是kubernetes.io/service-account-token，用于被serviceaccount引用。serviceaccout 创建时 Kubernetes 会默认创建对应的 secret。Pod 如果使用了 serviceaccount，对应的secret会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount目录中。 这里我们使用一个nginx镜像来验证一下，大家想一想为什么不是用busybox镜像来验证？当然也是可以的，但是我们就不能在command里面来验证了，因为token是需要Pod运行起来过后才会被挂载上去的，直接在command命令中去查看肯定是还没有 token 文件的。 $ kubectl run secret-pod3 --image nginx:1.7.9（直接运行即可） deployment.apps &quot;secret-pod3&quot; created $ kubectl get pods NAME READY STATUS RESTARTS AGE ... secret-pod3-78c8c76db8-7zmqm 1/1 Running 0 13s ... $ kubectl exec secret-pod3-78c8c76db8-7zmqm ls /run/secrets/kubernetes.io/serviceaccount ca.crt namespace token $ kubectl exec secret-pod3-78c8c76db8-7zmqm cat /run/secrets/kubernetes.io/serviceaccount/token eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tbjl3MmQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjMzY2FkOWQxLTU5MmYtMTFlOC1hMTAxLTUyNTQwMGRiNGRmNyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.0FpzPD8WO_fwnMjwpGIOphdVu4K9wUINwpXpBOJAQ-Tawd0RTbAUHcgYy3sEHSk9uvgnl1FJRQpbQN3yVR_DWSIlAtbmd4dIPxK4O7ZVdd4UnmC467cNXEBqL1sDWLfS5f03d7D1dw1ljFJ_pJw2P65Fjd13reKJvvTQnpu5U0SDcfxj675-Z3z-iOO3XSalZmkFIw2MfYMzf_WpxW0yMFCVkUZ8tBSTegA9-NJZededceA_VCOdKcUjDPrDo-CNti3wZqax5WPw95Ou8RJDMAIS5EcVym7M2_zjGiqHEL3VTvcwXbdFKxsNX-1VW6nr_KKuMGKOyx-5vgxebl71QQ Secret 与 ConfigMap 对比 最后我们来对比下Secret和ConfigMap这两种资源对象的异同点： 相同点： key/value的形式 属于某个特定的namespace 可以导出到环境变量 可以通过目录/文件形式挂载 通过 volume 挂载的配置信息均可热更新 不同点： Secret 可以被 ServerAccount 关联 Secret 可以存储 docker register 的鉴权信息，用在 ImagePullSecret 参数中，用于拉取私有仓库的镜像 Secret 支持 Base64 加密 Secret 分为 kubernetes.io/service-account-token、kubernetes.io/dockerconfigjson、Opaque 三种类型，而 Configmap 不区分类型" />
<link rel="canonical" href="https://uzzz.org/2019/08/13/794039.html" />
<meta property="og:url" content="https://uzzz.org/2019/08/13/794039.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Secret 上节课我们学习了ConfigMap的时候，我们说ConfigMap这个资源对象是Kubernetes当中非常重要的一个对象，一般情况下ConfigMap是用来存储一些非安全的配置信息，如果涉及到一些安全相关的数据的话用ConfigMap就非常不妥了，因为ConfigMap是名为存储的，我们说这个时候我们就需要用到另外一个资源对象了：Secret，Secret用来保存敏感信息，例如密码、OAuth 令牌和 ssh key等等，将这些信息放在Secret中比放在Pod的定义中或者docker镜像中来说更加安全和灵活。 Secret有三种类型： Opaque：base64 编码格式的 Secret，用来存储密码、密钥等；但数据也可以通过base64 –decode解码得到原始数据，所有加密性很弱。 kubernetes.io/dockerconfigjson：用来存储私有docker registry的认证信息。 kubernetes.io/service-account-token：用于被serviceaccount引用，serviceaccout 创建时Kubernetes会默认创建对应的secret。Pod如果使用了serviceaccount，对应的secret会自动挂载到Pod目录/run/secrets/kubernetes.io/serviceaccount中。 Opaque Secret 1 从文件中创建Secret 分别创建两个名为username.txt和password.txt的文件： $ echo -n &quot;admin&quot; &gt; ./username.txt $ echo -n &quot;1f2d1e2e67df&quot; &gt; ./password.txt 使用kubectl create secret命令创建secret： $ kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt secret &quot;db-user-pass&quot; created 2 使用描述文件创建Secret Opaque 类型的数据是一个 map 类型，要求value是base64编码格式，比如我们来创建一个用户名为 admin，密码为 admin321 的 Secret 对象，首先我们先把这用户名和密码做 base64 编码， $ echo -n &quot;admin&quot; | base64 YWRtaW4= $ echo -n &quot;admin321&quot; | base64 YWRtaW4zMjE= 然后我们就可以利用上面编码过后的数据来编写一个YAML文件：(secret-demo.yaml) apiVersion: v1 kind: Secret metadata: name: mysecret type: Opaque data: username: YWRtaW4= password: YWRtaW4zMjE= 然后同样的我们就可以使用kubectl命令来创建了： $ kubectl create -f secret-demo.yaml secret &quot;mysecret&quot; created 利用get secret命令查看： $ kubectl get secret NAME TYPE DATA AGE default-token-n9w2d kubernetes.io/service-account-token 3 33d mysecret Opaque 2 40s 其中default-token-cty7pdefault-token-n9w2d为创建集群时默认创建的 secret，被serviceacount/default 引用。 使用describe命令，查看详情： $ kubectl describe secret mysecret Name: mysecret Namespace: default Labels: &lt;none&gt; Annotations: &lt;none&gt; Type: Opaque Data ==== password: 8 bytes username: 5 bytes 我们可以看到利用describe命令查看到的Data没有直接显示出来，如果想看到Data里面的详细信息，同样我们可以输出成YAML文件进行查看： $ kubectl get secret mysecret -o yaml apiVersion: v1 data: password: YWRtaW4zMjE= username: YWRtaW4= kind: Secret metadata: creationTimestamp: 2018-06-19T15:27:06Z name: mysecret namespace: default resourceVersion: &quot;3694084&quot; selfLink: /api/v1/namespaces/default/secrets/mysecret uid: 39c139f5-73d5-11e8-a101-525400db4df7 type: Opaque 创建好Secret对象后，有两种方式来使用它： 以环境变量的形式 以Volume的形式挂载 环境变量 首先我们来测试下环境变量的方式，同样的，我们来使用一个简单的busybox镜像来测试下:(secret1-pod.yaml) apiVersion: v1 kind: Pod metadata: name: secret1-pod spec: containers: - name: secret1 image: busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ] env: - name: USERNAME valueFrom: secretKeyRef: name: mysecret key: username - name: PASSWORD valueFrom: secretKeyRef: name: mysecret key: password 主要上面环境变量中定义的secretKeyRef关键字，和我们上节课的configMapKeyRef是不是比较类似，一个是从Secret对象中获取，一个是从ConfigMap对象中获取，创建上面的Pod： $ kubectl create -f secret1-pod.yaml pod &quot;secret1-pod&quot; created 然后我们查看Pod的日志输出： $ kubectl logs secret1-pod ... USERNAME=admin PASSWORD=admin321 ... 可以看到有 USERNAME 和 PASSWORD 两个环境变量输出出来。 Volume 挂载 同样的我们用一个Pod来验证下Volume挂载，创建一个Pod文件：(secret2-pod.yaml) apiVersion: v1 kind: Pod metadata: name: secret2-pod spec: containers: - name: secret2 image: busybox command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/secrets&quot;] volumeMounts: - name: secrets mountPath: /etc/secrets volumes: - name: secrets secret: secretName: mysecret 创建Pod: $ kubectl create -f secret-pod2.yaml pod &quot;secret2-pod&quot; created 然后我们查看输出日志： $ kubectl logs secret2-pod password username 可以看到secret把两个key挂载成了两个对应的文件。当然如果想要挂载到指定的文件上面，在secretName下面添加items指定 key 和 path即可。也可以只挂载Secret中特定的key： apiVersion: v1 kind: Pod metadata: name: mypod spec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; readOnly: true volumes: - name: foo secret: secretName: mysecret items: - key: username path: my-group/my-username 在这种情况下： username 存储在/etc/foo/my-group/my-username中 password未被挂载 kubernetes.io/dockerconfigjson 除了上面的Opaque这种类型外，我们还可以来创建用户docker registry认证的Secret，直接使用kubectl create命令创建即可，如下： $ kubectl create secret docker-registry myregistry --docker-server=DOCKER_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL secret &quot;myregistry&quot; created 然后查看Secret列表： $ kubectl get secret NAME TYPE DATA AGE default-token-n9w2d kubernetes.io/service-account-token 3 33d myregistry kubernetes.io/dockerconfigjson 1 15s mysecret Opaque 2 34m 注意看上面的TYPE类型，myregistry是不是对应的kubernetes.io/dockerconfigjson，同样的可以使用describe命令来查看详细信息： $ kubectl describe secret myregistry Name: myregistry Namespace: default Labels: &lt;none&gt; Annotations: &lt;none&gt; Type: kubernetes.io/dockerconfigjson Data ==== .dockerconfigjson: 152 bytes 同样的可以看到Data区域没有直接展示出来，如果想查看的话可以使用-o yaml来输出展示出来： $ kubectl get secret myregistry -o yaml apiVersion: v1 data: .dockerconfigjson: eyJhdXRocyI6eyJET0NLRVJfU0VSVkVSIjp7InVzZXJuYW1lIjoiRE9DS0VSX1VTRVIiLCJwYXNzd29yZCI6IkRPQ0tFUl9QQVNTV09SRCIsImVtYWlsIjoiRE9DS0VSX0VNQUlMIiwiYXV0aCI6IlJFOURTMFZTWDFWVFJWSTZSRTlEUzBWU1gxQkJVMU5YVDFKRSJ9fX0= kind: Secret metadata: creationTimestamp: 2018-06-19T16:01:05Z name: myregistry namespace: default resourceVersion: &quot;3696966&quot; selfLink: /api/v1/namespaces/default/secrets/myregistry uid: f91db707-73d9-11e8-a101-525400db4df7 type: kubernetes.io/dockerconfigjson 可以把上面的data.dockerconfigjson下面的数据做一个base64解码，看看里面的数据是怎样的呢？ $ echo eyJhdXRocyI6eyJET0NLRVJfU0VSVkVSIjp7InVzZXJuYW1lIjoiRE9DS0VSX1VTRVIiLCJwYXNzd29yZCI6IkRPQ0tFUl9QQVNTV09SRCIsImVtYWlsIjoiRE9DS0VSX0VNQUlMIiwiYXV0aCI6IlJFOURTMFZTWDFWVFJWSTZSRTlEUzBWU1gxQkJVMU5YVDFKRSJ9fX0= | base64 -d {&quot;auths&quot;:{&quot;DOCKER_SERVER&quot;:{&quot;username&quot;:&quot;DOCKER_USER&quot;,&quot;password&quot;:&quot;DOCKER_PASSWORD&quot;,&quot;email&quot;:&quot;DOCKER_EMAIL&quot;,&quot;auth&quot;:&quot;RE9DS0VSX1VTRVI6RE9DS0VSX1BBU1NXT1JE&quot;}}} 如果我们需要拉取私有仓库中的docker镜像的话就需要使用到上面的myregistry这个Secret： apiVersion: v1 kind: Pod metadata: name: foo spec: containers: - name: foo image: 192.168.1.100:5000/test:v1 imagePullSecrets: - name: myregistrykey 我们需要拉取私有仓库镜像192.168.1.100:5000/test:v1，我们就需要针对该私有仓库来创建一个如上的Secret，然后在Pod的 YAML 文件中指定imagePullSecrets，我们会在后面的私有仓库搭建的课程中跟大家详细说明的。 kubernetes.io/service-account-token 另外一种Secret类型就是kubernetes.io/service-account-token，用于被serviceaccount引用。serviceaccout 创建时 Kubernetes 会默认创建对应的 secret。Pod 如果使用了 serviceaccount，对应的secret会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount目录中。 这里我们使用一个nginx镜像来验证一下，大家想一想为什么不是用busybox镜像来验证？当然也是可以的，但是我们就不能在command里面来验证了，因为token是需要Pod运行起来过后才会被挂载上去的，直接在command命令中去查看肯定是还没有 token 文件的。 $ kubectl run secret-pod3 --image nginx:1.7.9（直接运行即可） deployment.apps &quot;secret-pod3&quot; created $ kubectl get pods NAME READY STATUS RESTARTS AGE ... secret-pod3-78c8c76db8-7zmqm 1/1 Running 0 13s ... $ kubectl exec secret-pod3-78c8c76db8-7zmqm ls /run/secrets/kubernetes.io/serviceaccount ca.crt namespace token $ kubectl exec secret-pod3-78c8c76db8-7zmqm cat /run/secrets/kubernetes.io/serviceaccount/token eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tbjl3MmQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjMzY2FkOWQxLTU5MmYtMTFlOC1hMTAxLTUyNTQwMGRiNGRmNyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.0FpzPD8WO_fwnMjwpGIOphdVu4K9wUINwpXpBOJAQ-Tawd0RTbAUHcgYy3sEHSk9uvgnl1FJRQpbQN3yVR_DWSIlAtbmd4dIPxK4O7ZVdd4UnmC467cNXEBqL1sDWLfS5f03d7D1dw1ljFJ_pJw2P65Fjd13reKJvvTQnpu5U0SDcfxj675-Z3z-iOO3XSalZmkFIw2MfYMzf_WpxW0yMFCVkUZ8tBSTegA9-NJZededceA_VCOdKcUjDPrDo-CNti3wZqax5WPw95Ou8RJDMAIS5EcVym7M2_zjGiqHEL3VTvcwXbdFKxsNX-1VW6nr_KKuMGKOyx-5vgxebl71QQ Secret 与 ConfigMap 对比 最后我们来对比下Secret和ConfigMap这两种资源对象的异同点： 相同点： key/value的形式 属于某个特定的namespace 可以导出到环境变量 可以通过目录/文件形式挂载 通过 volume 挂载的配置信息均可热更新 不同点： Secret 可以被 ServerAccount 关联 Secret 可以存储 docker register 的鉴权信息，用在 ImagePullSecret 参数中，用于拉取私有仓库的镜像 Secret 支持 Base64 加密 Secret 分为 kubernetes.io/service-account-token、kubernetes.io/dockerconfigjson、Opaque 三种类型，而 Configmap 不区分类型","@type":"BlogPosting","url":"https://uzzz.org/2019/08/13/794039.html","headline":"Kubernets笔记（十六）－－Secrect","dateModified":"2019-08-13T00:00:00+08:00","datePublished":"2019-08-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/08/13/794039.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Kubernets笔记（十六）－－Secrect</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div id="content_views" class="markdown_views prism-tomorrow-night"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> 
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path> 
  </svg> 
  <h3><a id="Secret_0"></a>Secret</h3> 
  <p>上节课我们学习了ConfigMap的时候，我们说ConfigMap这个资源对象是Kubernetes当中非常重要的一个对象，一般情况下ConfigMap是用来存储一些非安全的配置信息，如果涉及到一些安全相关的数据的话用ConfigMap就非常不妥了，因为ConfigMap是名为存储的，我们说这个时候我们就需要用到另外一个资源对象了：Secret，Secret用来保存敏感信息，例如密码、OAuth 令牌和 ssh key等等，将这些信息放在Secret中比放在Pod的定义中或者docker镜像中来说更加安全和灵活。</p> 
  <p>Secret有三种类型：</p> 
  <pre><code>Opaque：base64 编码格式的 Secret，用来存储密码、密钥等；但数据也可以通过base64 –decode解码得到原始数据，所有加密性很弱。
kubernetes.io/dockerconfigjson：用来存储私有docker registry的认证信息。
kubernetes.io/service-account-token：用于被serviceaccount引用，serviceaccout 创建时Kubernetes会默认创建对应的secret。Pod如果使用了serviceaccount，对应的secret会自动挂载到Pod目录/run/secrets/kubernetes.io/serviceaccount中。
</code></pre> 
  <h3><a id="Opaque_Secret_10"></a>Opaque Secret</h3> 
  <h6><a id="1_Secret_11"></a>1 从文件中创建Secret</h6> 
  <p>分别创建两个名为username.txt和password.txt的文件：</p> 
  <pre><code>$ echo -n "admin" &gt; ./username.txt
$ echo -n "1f2d1e2e67df" &gt; ./password.txt
</code></pre> 
  <p>使用kubectl create secret命令创建secret：</p> 
  <pre><code>$ kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt
secret "db-user-pass" created
</code></pre> 
  <h6><a id="2_Secret_22"></a>2 使用描述文件创建Secret</h6> 
  <p>Opaque 类型的数据是一个 map 类型，要求value是base64编码格式，比如我们来创建一个用户名为 admin，密码为 admin321 的 Secret 对象，首先我们先把这用户名和密码做 base64 编码，</p> 
  <pre><code>$ echo -n "admin" | base64
YWRtaW4=
$ echo -n "admin321" | base64
YWRtaW4zMjE=
</code></pre> 
  <p>然后我们就可以利用上面编码过后的数据来编写一个YAML文件：(secret-demo.yaml)</p> 
  <pre><code>apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: YWRtaW4zMjE=
</code></pre> 
  <p>然后同样的我们就可以使用kubectl命令来创建了：</p> 
  <pre><code>$ kubectl create -f secret-demo.yaml
secret "mysecret" created
</code></pre> 
  <p>利用get secret命令查看：</p> 
  <pre><code>$ kubectl get secret
NAME                  TYPE                                  DATA      AGE
default-token-n9w2d   kubernetes.io/service-account-token   3         33d
mysecret              Opaque                                2         40s
</code></pre> 
  <pre><code>其中default-token-cty7pdefault-token-n9w2d为创建集群时默认创建的 secret，被serviceacount/default 引用。
</code></pre> 
  <p>使用describe命令，查看详情：</p> 
  <pre><code>$ kubectl describe secret mysecret
Name:         mysecret
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Type:  Opaque

Data
====
password:  8 bytes
username:  5 bytes
</code></pre> 
  <p>我们可以看到利用describe命令查看到的Data没有直接显示出来，如果想看到Data里面的详细信息，同样我们可以输出成YAML文件进行查看：</p> 
  <pre><code>$ kubectl get secret mysecret -o yaml
apiVersion: v1
data:
  password: YWRtaW4zMjE=
  username: YWRtaW4=
kind: Secret
metadata:
  creationTimestamp: 2018-06-19T15:27:06Z
  name: mysecret
  namespace: default
  resourceVersion: "3694084"
  selfLink: /api/v1/namespaces/default/secrets/mysecret
  uid: 39c139f5-73d5-11e8-a101-525400db4df7
type: Opaque
</code></pre> 
  <p>创建好Secret对象后，有两种方式来使用它：</p> 
  <pre><code>以环境变量的形式
以Volume的形式挂载
</code></pre> 
  <h4><a id="_92"></a>环境变量</h4> 
  <p>首先我们来测试下环境变量的方式，同样的，我们来使用一个简单的busybox镜像来测试下:(secret1-pod.yaml)</p> 
  <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: secret1-pod
spec:
  containers:
  - name: secret1
    image: busybox
    command: [ "/bin/sh", "-c", "env" ]
    env:
    - name: USERNAME
      valueFrom:
        secretKeyRef:
          name: mysecret
          key: username
    - name: PASSWORD
      valueFrom:
        secretKeyRef:
          name: mysecret
          key: password
</code></pre> 
  <p>主要上面环境变量中定义的secretKeyRef关键字，和我们上节课的configMapKeyRef是不是比较类似，一个是从Secret对象中获取，一个是从ConfigMap对象中获取，创建上面的Pod：</p> 
  <pre><code>$ kubectl create -f secret1-pod.yaml
pod "secret1-pod" created
</code></pre> 
  <p>然后我们查看Pod的日志输出：</p> 
  <pre><code>$ kubectl logs secret1-pod
...
USERNAME=admin
PASSWORD=admin321
...
</code></pre> 
  <p>可以看到有 USERNAME 和 PASSWORD 两个环境变量输出出来。</p> 
  <h3><a id="Volume__131"></a>Volume 挂载</h3> 
  <p>同样的我们用一个Pod来验证下Volume挂载，创建一个Pod文件：(secret2-pod.yaml)</p> 
  <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: secret2-pod
spec:
  containers:
  - name: secret2
    image: busybox
    command: ["/bin/sh", "-c", "ls /etc/secrets"]
    volumeMounts:
    - name: secrets
      mountPath: /etc/secrets
  volumes:
  - name: secrets
    secret:
     secretName: mysecret
</code></pre> 
  <p>创建Pod:</p> 
  <pre><code>$ kubectl create -f secret-pod2.yaml
pod "secret2-pod" created
</code></pre> 
  <p>然后我们查看输出日志：</p> 
  <pre><code>$ kubectl logs secret2-pod
password
username
</code></pre> 
  <p>可以看到secret把两个key挂载成了两个对应的文件。当然如果想要挂载到指定的文件上面，在secretName下面添加items指定 key 和 path即可。也可以只挂载Secret中特定的key：</p> 
  <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      items:
      - key: username
        path: my-group/my-username
</code></pre> 
  <p>在这种情况下：<br> username 存储在/etc/foo/my-group/my-username中<br> password未被挂载</p> 
  <h3><a id="kubernetesiodockerconfigjson_188"></a>kubernetes.io/dockerconfigjson</h3> 
  <p>除了上面的Opaque这种类型外，我们还可以来创建用户docker registry认证的Secret，直接使用kubectl create命令创建即可，如下：</p> 
  <pre><code>$ kubectl create secret docker-registry myregistry --docker-server=DOCKER_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL
secret "myregistry" created
</code></pre> 
  <p>然后查看Secret列表：</p> 
  <pre><code>$ kubectl get secret
NAME                  TYPE                                  DATA      AGE
default-token-n9w2d   kubernetes.io/service-account-token   3         33d
myregistry            kubernetes.io/dockerconfigjson        1         15s
mysecret              Opaque                                2         34m
</code></pre> 
  <p>注意看上面的TYPE类型，myregistry是不是对应的kubernetes.io/dockerconfigjson，同样的可以使用describe命令来查看详细信息：</p> 
  <pre><code>$ kubectl describe secret myregistry
Name:         myregistry
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Type:  kubernetes.io/dockerconfigjson

Data
====
.dockerconfigjson:  152 bytes

同样的可以看到Data区域没有直接展示出来，如果想查看的话可以使用-o yaml来输出展示出来：

$ kubectl get secret myregistry -o yaml
apiVersion: v1
data:
  .dockerconfigjson: eyJhdXRocyI6eyJET0NLRVJfU0VSVkVSIjp7InVzZXJuYW1lIjoiRE9DS0VSX1VTRVIiLCJwYXNzd29yZCI6IkRPQ0tFUl9QQVNTV09SRCIsImVtYWlsIjoiRE9DS0VSX0VNQUlMIiwiYXV0aCI6IlJFOURTMFZTWDFWVFJWSTZSRTlEUzBWU1gxQkJVMU5YVDFKRSJ9fX0=
kind: Secret
metadata:
  creationTimestamp: 2018-06-19T16:01:05Z
  name: myregistry
  namespace: default
  resourceVersion: "3696966"
  selfLink: /api/v1/namespaces/default/secrets/myregistry
  uid: f91db707-73d9-11e8-a101-525400db4df7
type: kubernetes.io/dockerconfigjson
</code></pre> 
  <p>可以把上面的data.dockerconfigjson下面的数据做一个base64解码，看看里面的数据是怎样的呢？</p> 
  <pre><code>$ echo eyJhdXRocyI6eyJET0NLRVJfU0VSVkVSIjp7InVzZXJuYW1lIjoiRE9DS0VSX1VTRVIiLCJwYXNzd29yZCI6IkRPQ0tFUl9QQVNTV09SRCIsImVtYWlsIjoiRE9DS0VSX0VNQUlMIiwiYXV0aCI6IlJFOURTMFZTWDFWVFJWSTZSRTlEUzBWU1gxQkJVMU5YVDFKRSJ9fX0= | base64 -d
{"auths":{"DOCKER_SERVER":{"username":"DOCKER_USER","password":"DOCKER_PASSWORD","email":"DOCKER_EMAIL","auth":"RE9DS0VSX1VTRVI6RE9DS0VSX1BBU1NXT1JE"}}}
</code></pre> 
  <p>如果我们需要拉取私有仓库中的docker镜像的话就需要使用到上面的myregistry这个Secret：</p> 
  <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: foo
spec:
  containers:
  - name: foo
    image: 192.168.1.100:5000/test:v1
  imagePullSecrets:
  - name: myregistrykey
</code></pre> 
  <p>我们需要拉取私有仓库镜像192.168.1.100:5000/test:v1，我们就需要针对该私有仓库来创建一个如上的Secret，然后在Pod的 YAML 文件中指定imagePullSecrets，我们会在后面的私有仓库搭建的课程中跟大家详细说明的。</p> 
  <h3><a id="kubernetesioserviceaccounttoken_252"></a>kubernetes.io/service-account-token</h3> 
  <p>另外一种Secret类型就是kubernetes.io/service-account-token，用于被serviceaccount引用。serviceaccout 创建时 Kubernetes 会默认创建对应的 secret。Pod 如果使用了 serviceaccount，对应的secret会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount目录中。</p> 
  <p>这里我们使用一个nginx镜像来验证一下，大家想一想为什么不是用busybox镜像来验证？当然也是可以的，但是我们就不能在command里面来验证了，因为token是需要Pod运行起来过后才会被挂载上去的，直接在command命令中去查看肯定是还没有 token 文件的。</p> 
  <pre><code>$ kubectl run secret-pod3 --image nginx:1.7.9（直接运行即可）
deployment.apps "secret-pod3" created
$ kubectl get pods
NAME                           READY     STATUS    RESTARTS   AGE
...
secret-pod3-78c8c76db8-7zmqm   1/1       Running   0          13s
...
$ kubectl exec secret-pod3-78c8c76db8-7zmqm ls /run/secrets/kubernetes.io/serviceaccount
ca.crt
namespace
token
$ kubectl exec secret-pod3-78c8c76db8-7zmqm cat /run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tbjl3MmQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjMzY2FkOWQxLTU5MmYtMTFlOC1hMTAxLTUyNTQwMGRiNGRmNyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.0FpzPD8WO_fwnMjwpGIOphdVu4K9wUINwpXpBOJAQ-Tawd0RTbAUHcgYy3sEHSk9uvgnl1FJRQpbQN3yVR_DWSIlAtbmd4dIPxK4O7ZVdd4UnmC467cNXEBqL1sDWLfS5f03d7D1dw1ljFJ_pJw2P65Fjd13reKJvvTQnpu5U0SDcfxj675-Z3z-iOO3XSalZmkFIw2MfYMzf_WpxW0yMFCVkUZ8tBSTegA9-NJZededceA_VCOdKcUjDPrDo-CNti3wZqax5WPw95Ou8RJDMAIS5EcVym7M2_zjGiqHEL3VTvcwXbdFKxsNX-1VW6nr_KKuMGKOyx-5vgxebl71QQ
</code></pre> 
  <h3><a id="Secret__ConfigMap__271"></a>Secret 与 ConfigMap 对比</h3> 
  <p>最后我们来对比下Secret和ConfigMap这两种资源对象的异同点：</p> 
  <p>相同点：</p> 
  <pre><code>key/value的形式
属于某个特定的namespace
可以导出到环境变量
可以通过目录/文件形式挂载
通过 volume 挂载的配置信息均可热更新
</code></pre> 
  <p>不同点：</p> 
  <pre><code>Secret 可以被 ServerAccount 关联
Secret 可以存储 docker register 的鉴权信息，用在 ImagePullSecret 参数中，用于拉取私有仓库的镜像
Secret 支持 Base64 加密
Secret 分为 kubernetes.io/service-account-token、kubernetes.io/dockerconfigjson、Opaque 三种类型，而 Configmap 不区分类型
</code></pre> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e44c3c0e64.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
