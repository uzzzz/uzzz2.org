<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Spark-Streaming | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Spark-Streaming" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Spark Streaming流式处理 Spark Streaming 介绍 Spark Streaming 概述 什么是 Spark Streaming 为什么要学习 Spark Streaming SparkStreaming 与 Storm 对比 Spark Streaming 原理 原理 Spark Streaming 计算流程 Spark Streaming 容错性 Spark Streaming 实时性 DStream 什么是 DStream DStream 相关操作 Transformations on DStreams Output Operations on DStreams DStream 操作实战 SparkStreaming 接收 socket 数据，实现单词技术 WordCound 架构图 实现流程 执行查看效果 SparkStreaming 接受 socket 数据，实现单词计数累加 架构图 实现流程 执行查看效果 SparkStreaming开窗函数reduceByKeyAndWindow，实现单词计数 架构图 实现流程 执行查看效果 SparkStreaming开窗函数统计一定时间内的热门词汇 架构图 实现流程 执行查看效果 Spark Streaming整合flume实战 Poll 方式 Push方式 6. Spark Streaming整合kafka实战 KafkaUtils.createDstream方式 KafkaUtils.createDstream实战 KafkaUtils.createDirectStream方式 Spark Streaming 介绍 Spark Streaming 概述 什么是 Spark Streaming &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 类似于 Apache Storm，用于流式数据的处理。根据官方文档介绍，Spark Streaming 有高吞吐量和容错能力强等特点。Spark Streaming 支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ 和简单的 TCP 套接字等等。数据输入后可以用 Spark 的高度抽象操作如：map、reduce、join、window等进行运算。而结果也能保存在很多地方，如 HDFS ， 数据库等。另外 Spark Streaming 也能和 MLlib（机器学习）以及 Graphx 完美融合。 为什么要学习 Spark Streaming 易用 容错 易整合到 Spark 体系 SparkStreaming 与 Storm 对比 SparkStreaming Storm 开发语言：Scala 开发语言：Clojure 编程模型：DStream 编程模型：Spoot/Bolt Spark Streaming 原理 原理 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 是基于 Spark 的流式批处理引擎，其基本原理是把==输入的数据以某一时间间隔批量的处理==，当批处理间隔缩短到==秒级==时，便可以用于处理实时数据流。 Spark Streaming 计算流程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 是将流式计算分解成一系列短小的批处理作业。这里的批处理引擎是 Spark Core，也就是把 Spark Streaming 的输入数据按照 batch size （如1秒）分成一段一段的数据（Discretized Stream），每一段数据都转换成 Spark 中的 RDD （Resilient Distributed Dataset），然后将 Spark Streaming 中对 DStream 的 Transformtion 操作变为针对 Spark 中对 RDD 的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transformation 操作，将 RDD 经过操作编程中间结果保存在内存中，整个流式计算根据业务的需求可以对中间的结果进行缓存或者存储到外部设备。下图为 Spark Streaming 的整个流程： Spark Streaming 容错性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于流失计算来说，容错性至关重要。首先我们要明确一下 Spark 中 RDD 的容错机制。每一个 RDD 都是不可变的分布式可重算的数据集，其记录着确定性操作继承关系（lineage），所以只要输入数据是可容错的，那么任意一个 RDD 的分区（Partition）出错或不可用，都是可以利用原始输入数据通过转换操作而重新算出的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 Spark Streaming 来说，其 RDD 的传承关系如下图所示： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;途中的每一个椭圆表示一个 RDD ，椭圆形中的每个圆形代表一个 RDD 中的一个 Partition ，图中的每一列的多个 RDD 表示一个 DStream（图中有三个 DStream），而每一行最后一个 RDD 则表示每一个 Batch Size 所产生的中间结果 RDD。我们可以看到图中的每一个 RDD 都是通过 lineage 相连接的，由于 Spark Streaming 输入数据可以来自于磁盘，例如 HDFS（多分拷贝）或是来自于网络的数据流（Spark Streaming 会将网络输入数据的每一个数据流拷贝两份到其他机器）都能保证容错性，所以 RDD 中任意的 Partition 出错，都可以并行地在其他机器上将缺失的 Partition 计算出来。这个容错恢复方式比连续计算模型（如 Storm）的效率更高 Spark Streaming 实时性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于实时性的讨论，会牵涉到流式处理框架的应用场景。Spark Streaming 将流式计算分解成多个 Spark Job，对于每一段数据的处理都会经过 Spark DAG 图分解以及 Spark 的任务集的调度过程。对于目前版本的 Spark Streaming 而言，其最小的 Batch Size 的选取在 0.5 ~ 2秒之间（Storm 目前最小的延迟是 100ms左右），所以 Spark Streaming 能满足除对实时性要求非常高（如高频实时交易）之外的所有流式准实时计算场景。 DStream 什么是 DStream &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretized Stream 是 Spark Streaming 的基础抽象，代表连续性的数据流和经过各种 Spark 算子操作后的结果数据流。在内部是线上。DStream 是一系列连续的 RDD 来表示。每个 RDD 含有一段时间间隔内的数据，如下图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对数据的操作也是按照 RDD 为单位来进行的 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 使用数据源产生的数据流创建 DStream，也可以在已有的 DStream 上使用一些操作来创建新的 DStream。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的工作流程像下面的图所示一样，接受到实时数据后，给数据分批次，然后传给 Spark Engine 处理最后生成该批次的结果。 DStream 相关操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DStream 上的操作与 RDD 类似，分为 Transformations （转换）和 Output Operations（输出）两种，此外转换操作中还有一些比较特殊的操作，如：updateStateByKey()、transform()以及各种 Window 相关的操作。 Transformations on DStreams Transformations Meaning map(func) 对DStream中的各个元素进行func函数操作，然后返回一个新的DStream flatMap(func) 与map方法类似，只不过各个输入项可以被输出为零个或多个输出项 filter(func) 过滤出所有函数func返回值为true的DStream元素并返回一个新的DStream repartition(numPartitions) 增加或减少DStream中的分区数，从而改变DStream的并行度 repartition(numPartitions) 增加或减少DStream中的分区数，从而改变DStream的并行度 union(otherStream) 将源DStream和输入参数为otherDStream的元素合并，并返回一个新的DStream. count() 通过对DStream中的各个RDD中的元素进行计数，然后返回只有一个元素的RDD构成的DStream reduce(func) 对源DStream中的各个RDD中的元素利用func进行聚合操作，然后返回只有一个元素的RDD构成的新的DStream. countByValue() 对于元素类型为K的DStream，返回一个元素为（K,Long）键值对形式的新的DStream，Long对应的值为源DStream中各个RDD的key出现的次数 reduceByKey(func, [numTasks]) 利用func函数对源DStream中的key进行聚 合操作，然后返回新的（K，V）对构成的DStream join(otherStream, [numTasks]) 输入为（K,V)、（K,W）类型的DStream，返回一个新的（K，（V，W）类型的DStream cogroup(otherStream, [numTasks]) 输入为（K,V)、（K,W）类型的DStream，返回一个新的 (K, Seq[V], Seq[W]) 元组类型的DStream transform(func) 通过RDD-to-RDD函数作用于DStream中的各个RDD，可以是任意的RDD操作，从而返回一个新的RDD updateStateByKey(func) 根据于key的前置状态和key的新值，对key进行更新，返回一个新状态的DStream 特殊的Transformations UpdateStateByKey Operation UpdateStateByKey用于记录历史记录，保存上次的状态 Window Operations(开窗函数,滑动窗口转换操作:) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 滑动窗口转换操作的计算过程如下图所示，我们可以事先设定一个滑动窗口的长度（也就是窗口的持续时间）， 并且设定滑动窗口的时间间隔（每隔多长时间执行一次计算），然后就可以让窗口按照指定时间间隔在源 DStream 上滑动，每次窗口停放的位置上，都会有一部分 DStream 被框入窗口内，形成一个小段 DStream ，这是，就可以启动对这个小段 DStream 的计算。 红色的矩形就是一个窗口，窗口框住的是一段时间内的数据流。 这里面每一个time都是时间单元，在官方的例子中，每隔window size是3 time unit, 而且每隔2个单位时间，窗口会slide一次。 所以基于窗口的操作，需要指定2个参数： • window length - The duration of the window (3 in the figure) • slide interval - The interval at which the window-based operation is performed (2 in the figure). 窗口大小：一段时间内数据的容器。 滑动间隔：每隔多久计算一次。 Output Operations on DStreams &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output Operations 可以将 DStream 的数据输出到外部的数据库或文件系统，当某个 Output Operations 被调用时（与 RDD 的 Action 相同），spark streaming 程序才会真正的计算过程。 Output Operation Meaning print() 打印到控制台 saveAsTextFiles(prefix, [suffix]) 保存流的内容为文本文件，文件名为&quot;prefix-TIME_IN_MS[.suffix]&quot;. saveAsObjectFiles(prefix, [suffix]) 保存流的内容为SequenceFile，文件名为 “prefix-TIME_IN_MS[.suffix]”. saveAsHadoopFiles(prefix, [suffix]) 保存流的内容为hadoop文件，文件名为&quot;prefix-TIME_IN_MS[.suffix]&quot;. foreachRDD(func) 对Dstream里面的每个RDD执行func DStream 操作实战 SparkStreaming 接收 socket 数据，实现单词技术 WordCound 架构图 实现流程 安装并启动生产者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在 linux 服务器上用 Yum 安装 nc 工具，命令为 netcat 命令的简称，都是用来设置路由器。我们可以利用它像某个端口发送数据。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yun install -y nc 通过 netcat 工具像指定的端口发送数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 编写 Spark Streaming 程序import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreming流式处理接受socket数据，实现单词统计 */ object SparkStreamingTCP { def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreamingTCP&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) //设置日志输出级别 sc.setLogLevel(&quot;WARN&quot;) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc,Seconds(5)) //注册一个监听的IP地址和端口 用来收集数据 val lines: ReceiverInputDStream[String] = scc.socketTextStream(&quot;192.168.200.160&quot;,9999) //切分每一行记录 val words: DStream[String] = lines.flatMap(_.split(&quot; &quot;)) //每个单词记为1 val wordAndOne: DStream[(String, Int)] = words.map((_,1)) //分组聚合 val result: DStream[(String, Int)] = wordAndOne.reduceByKey(_+_) //打印数据 result.print() scc.start() scc.awaitTermination() } } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于使用的是本地模式 local[2] 所以可以在本地运行该程序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：要指定并行度，如在本地运行设置 setMaster(&quot;local[2]&quot;)，相当于启动两个线程，一个给 received，一个给 computer。如果是在集群中运行，必须要求集群中可的 core 数大于1。 执行查看效果 先执行 nc -lk 9999 在执行代码 不断的在 1. 中输入不同的单词，观察 IDEA 控制台的输出 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象：SparkStreaming 每隔 5s 计算一次当前 5s 内的数据，然后将每个批次的数据输出。 SparkStreaming 接受 socket 数据，实现单词计数累加 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在上面的案例中存在这样一个问题：每个批次的单词都被正确的统计出来，但是结果不能累加！如果需要累加需要使用 updateStateByKey（func）来更新状态。 架构图 实现流程 安装并启动生成者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在linux服务器上用YUM安装nc工具，nc命令是netcat命令的简称,都是用来设置路由器。我们可以利用它向某个端口发送数据。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install -y nc 启动一个服务端并监听9999端口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向指定的端口发送数据 编写 SparkStreaming 程序 import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreaming流式处理，接受socket数据，实现单词统计并且每个批次数据结果累加 */ object SparkStreamingTCPTotal { //newValues 表示当前批次汇总成的(word,1)中相同单词的所有的1 //runningCount 历史的所有相同key的value总和 def updateFunction(newValues: Seq[Int], runningCount: Option[Int]): Option[Int] = { val newCount =runningCount.getOrElse(0)+newValues.sum Some(newCount) } def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreamingTCPTotal&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) sc.setLogLevel(&quot;WARN&quot;) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc, Seconds(5)) scc.checkpoint(&quot;./&quot;) //注册一个监听的IP地址和端口 用来收集数据 val lines: ReceiverInputDStream[String] = scc.socketTextStream(&quot;bw01&quot;, 9999) //切分每一行记录 val words: DStream[String] = lines.flatMap(_.split(&quot; &quot;)) //每个单词记为1 val wordAndOne: DStream[(String, Int)] = words.map((_, 1)) //累计统计单词出现的次数 val result: DStream[(String, Int)] = wordAndOne.updateStateByKey(updateFunction) result.print() scc.start() scc.awaitTermination() } } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过函数 updateStateByKey 实现。根据于 key 的前置状态和 key 的新值，对 key 进行更新，返回一个新状态的 DStream。 执行查看效果 执行 nc -lk 9999 然后执行以上代码 不断的在 1. 中输入不同的单词，观察 IDEA 控制台输出 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象：sparkStreaming每隔5s计算一次当前5s内的数据，然后将每个批次的结果数据累加输出。 SparkStreaming开窗函数reduceByKeyAndWindow，实现单词计数 架构图 实现流程 安装并启动生产者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在 linux 服务器上用 YUM 安装 nc 工具，nc 命令是 netcat 命令的简称，都是用来设置路由器。我们可以利用它向某个端口发送数据。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install -y nc 启动一个服务器 并监听 9999 端口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 ，向指定的端口发送数据。 编写 Spark Streaming 程序 import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreming开窗函数---统计一定时间内单词出现的次数 */ object SparkStreamingTCPWindow { def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreamingTCPWindow&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) sc.setLogLevel(&quot;WARN&quot;) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc,Seconds(5)) //注册一个监听的IP地址和端口 用来收集数据 val lines: ReceiverInputDStream[String] = scc.socketTextStream(&quot;192.168.200.160&quot;,9999) //切分每一行记录 val words: DStream[String] = lines.flatMap(_.split(&quot; &quot;)) //每个单词记为1 val wordAndOne: DStream[(String, Int)] = words.map((_,1)) //reduceByKeyAndWindow函数参数意义： // windowDuration:表示window框住的时间长度，如本例5秒切分一次RDD，框10秒，就会保留最近2次切分的RDD //slideDuration: 表示window滑动的时间长度，即每隔多久执行本计算 val result: DStream[(String, Int)] = wordAndOne.reduceByKeyAndWindow((a:Int,b:Int)=&gt;a+b,Seconds(10),Seconds(5)) result.print() scc.start() scc.awaitTermination() } } 执行查看效果 先执行 nc -lk 9999 然后在执行以上代码 断的在（1）中输入不同的单词，观察IDEA控制台输出 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象： Spark Streaming 每个5s 计算一次当前在窗口大小为 10s 内的数据，然后将结果数据输出。 SparkStreaming开窗函数统计一定时间内的热门词汇 架构图 实现流程 安装并启动生产者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在 linux 服务器上用 YUM 安装 nc 工具，nc 命令是 netcat 命令的简称，都是用来设置路由器。我们可以利用它向某个端口发送数据。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install -y nc 启动一个服务器并监听 9999 端口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 编写 Spark Streaming 程序 package cn.test.spark import org.apache.spark.rdd.RDD import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreming开窗函数应用----统计一定时间内的热门词汇 */ object SparkStreamingTCPWindowHotWords { def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreamingTCPWindowHotWords&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) sc.setLogLevel(&quot;WARN&quot;) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc,Seconds(5)) //注册一个监听的IP地址和端口 用来收集数据 val lines: ReceiverInputDStream[String] = scc.socketTextStream(&quot;192.168.200.160&quot;,9999) //切分每一行记录 val words: DStream[String] = lines.flatMap(_.split(&quot; &quot;)) //每个单词记为1 val wordAndOne: DStream[(String, Int)] = words.map((_,1)) //reduceByKeyAndWindow函数参数意义： // windowDuration:表示window框住的时间长度，如本例5秒切分一次RDD，框10秒，就会保留最近2次切分的RDD //slideDuration: 表示window滑动的时间长度，即每隔多久执行本计算 val result: DStream[(String, Int)] = wordAndOne.reduceByKeyAndWindow((a:Int,b:Int)=&gt;a+b,Seconds(5),Seconds(5)) val data=result.transform(rdd=&gt;{ //降序处理后，取前3位 val dataRDD: RDD[(String, Int)] = rdd.sortBy(t=&gt;t._2,false) val sortResult: Array[(String, Int)] = dataRDD.take(3) println(&quot;--------------print top 3 begin--------------&quot;) sortResult.foreach(println) println(&quot;--------------print top 3 end--------------&quot;) dataRDD }) data.print() scc.start() scc.awaitTermination() } } 执行查看效果 先执行 nc -lk 9999 在执行以上代码 不断的在 1. 中输入不同的单词，观察 IDEA 控制台输出 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象：sparkStreaming每隔5s计算一次当前在窗口大小为10s内的数据，然后将单词出现次数最多的前3位进行输出打印。/p&gt; Spark Streaming整合flume实战 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flume作为日志实时采集的框架，可以与SparkStreaming实时处理框进行对接，flume实时产生数据，sparkStreaming做实时处理。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 对接 FlumeNG有两种方式，一种是FlumeNG将消息Push推给Spark Streaming，还有一种是Spark Streaming从flume 中 Poll 拉取数据。 Poll 方式 安装flume1.6以上 下载依赖包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spark-streaming-flume-sink_2.11-2.0.2.jar放入到flume的lib目录下。/p&gt; 写flume的agent，注意既然是拉取的方式，那么flume向自己所在的机器上产数据就行 编写flume-poll.conf配置文件 a1.sources = r1 a1.sinks = k1 a1.channels = c1 #source a1.sources.r1.channels = c1 a1.sources.r1.type = spooldir a1.sources.r1.spoolDir = /root/data a1.sources.r1.fileHeader = true #channel a1.channels.c1.type =memory a1.channels.c1.capacity = 20000 a1.channels.c1.transactionCapacity=5000 #sinks a1.sinks.k1.channel = c1 a1.sinks.k1.type = org.apache.spark.streaming.flume.sink.SparkSink a1.sinks.k1.hostname=hdp-node-01 a1.sinks.k1.port = 8888 a1.sinks.k1.batchSize= 2000 启动flume： flume-ng agent -n a1 -c /opt/bigdata/flume/conf -f /opt/bigdata/flume/conf/flume-poll.conf -Dflume.root.logger=INFO,console &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务器上的 /root/data目录下准备数据文件data.txt 5. 启动 spark-streaming 应用程序，去 flume 所在机器拉取数据 6. 代码实现 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要添加pom依赖 &lt;properties&gt; &lt;scala.version&gt;2.11.8&lt;/scala.version&gt; &lt;hadoop.version&gt;2.7.4&lt;/hadoop.version&gt; &lt;spark.version&gt;2.0.2&lt;/spark.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt; &lt;version&gt;${spark.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入spark-streaming-flume的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-flume_2.10&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 具体代码如下： import java.net.InetSocketAddress import org.apache.spark.storage.StorageLevel import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.flume.{FlumeUtils, SparkFlumeEvent} import org.apache.spark.{SparkConf, SparkContext} import org.apache.spark.streaming.{Seconds, StreamingContext} object FlumeDir { def main(args: Array[String]): Unit = { val conf: SparkConf = new SparkConf().setAppName(&quot;FlumeDir&quot;).setMaster(&quot;local[2]&quot;) val sc = new SparkContext(conf) sc.setLogLevel(&quot;WARN&quot;) val scc = new StreamingContext(sc,Seconds(5)) scc.checkpoint(&quot;./spark_flume_dir&quot;) //设置flume地址 val addresses: Seq[InetSocketAddress] = Seq (new InetSocketAddress(&quot;192.168.44.127&quot;,8888)) val flumeds: ReceiverInputDStream[SparkFlumeEvent] = FlumeUtils.createPollingStream(scc,addresses,StorageLevel.MEMORY_AND_DISK) val lineds: DStream[String] = flumeds.map(x=&gt;new String(x.event.getBody.array())) lineds.flatMap(_.split(&quot; &quot;)).map((_,1)).reduceByKey(_+_).print() scc.start() scc.awaitTermination() } } Push方式 （1）编写flume-push.conf配置文件 #push mode a1.sources = r1 a1.sinks = k1 a1.channels = c1 #source a1.sources.r1.channels = c1 a1.sources.r1.type = spooldir a1.sources.r1.spoolDir = /root/data a1.sources.r1.fileHeader = true #channel a1.channels.c1.type =memory a1.channels.c1.capacity = 20000 a1.channels.c1.transactionCapacity=5000 #sinks a1.sinks.k1.channel = c1 a1.sinks.k1.type = avro a1.sinks.k1.hostname=172.16.43.63 a1.sinks.k1.port = 8888 a1.sinks.k1.batchSize= 2000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意配置文件中指明的hostname和port是spark应用程序所在服务器的ip地址和端口 代码实现如下： package cn.test.spark import java.net.InetSocketAddress import org.apache.spark.storage.StorageLevel import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.flume.{FlumeUtils, SparkFlumeEvent} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreaming整合flume 推模式Push */ object SparkStreaming_Flume_Push { //newValues 表示当前批次汇总成的(word,1)中相同单词的所有的1 //runningCount 历史的所有相同key的value总和 def updateFunction(newValues: Seq[Int], runningCount: Option[Int]): Option[Int] = { val newCount =runningCount.getOrElse(0)+newValues.sum Some(newCount) } def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreaming_Flume_Push&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc, Seconds(5)) //设置日志输出级别 sc.setLogLevel(&quot;WARN&quot;) //设置检查点目录 scc.checkpoint(&quot;./&quot;) //flume推数据过来 // 当前应用程序部署的服务器ip地址，跟flume配置文件保持一致 val flumeStream: ReceiverInputDStream[SparkFlumeEvent] = FlumeUtils.createStream(scc,&quot;172.16.43.63&quot;,8888,StorageLevel.MEMORY_AND_DISK) //获取flume中数据，数据存在event的body中，转化为String val lineStream: DStream[String] = flumeStream.map(x=&gt;new String(x.event.getBody.array())) //实现单词汇总 val result: DStream[(String, Int)] = lineStream.flatMap(_.split(&quot; &quot;)).map((_,1)).updateStateByKey(updateFunction) result.print() scc.start() scc.awaitTermination() } } } 启动执行 先执行spark代码 然后在执行flume配置文件 观察 IDEA 控制台输出 6. Spark Streaming整合kafka实战 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kafka作为一个实时的分布式消息队列，实时的生产和消费消息，这里我们可以利用SparkStreaming实时计算框架实时地读取kafka中的数据然后进行计算。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在spark1.3版本后，kafkaUtils里面提供了两个创建dstream的方法，一种为KafkaUtils.createDstream，另一种为KafkaUtils.createDirectStream。 KafkaUtils.createDstream方式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造函数为KafkaUtils.createDstream(ssc, [zk], [consumer group id], [per-topic,partitions] ) 使用了receivers来接收数据，利用的是Kafka高层次的消费者api，对于所有的receivers接收到的数据将会保存在Spark executors中，然后通过Spark Streaming启动job来处理这些数据，默认会丢失，可启用WAL日志，它同步将接受到数据保存到分布式文件系统上比如HDFS。 所以数据在出错的情况下可以恢复出来 。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190813213050229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个receiver来对kafka进行定时拉取数据，ssc的rdd分区和kafka的topic分区不是一个概念，故如果增加特定主消费的线程数仅仅是增加一个receiver中消费topic的线程数，并不增加spark的并行处理数据数量 。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于不同的group和topic可以使用多个receivers创建不同的DStream 。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果启用了WAL (spark.streaming.receiver.writeAheadLog.enable=true) 同时需要设置存储级别(默认StorageLevel.MEMORY_AND_DISK_SER_2)， 即KafkaUtils.createStream(….,StorageLevel.MEMORY_AND_DISK_SER) 。 KafkaUtils.createDstream实战 添加 kafka 的 pom 依赖 &lt;properties&gt; &lt;scala.version&gt;2.11.8&lt;/scala.version&gt; &lt;hadoop.version&gt;2.7.4&lt;/hadoop.version&gt; &lt;spark.version&gt;2.0.2&lt;/spark.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-kafka-0-8_2.11&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt; &lt;version&gt;${spark.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-hive_2.11&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 启动 zookeeper 集群 zkServer.sh start 启动 kafka 集群 kafka-server-start.sh /export/servers/kafka/config/server.properties 创建 topic kafka-topics.sh --create --zookeeper hdp-node-01:2181 --replication-factor 1 --partitions 3 --topic kafka_spark 向 topic 中生产数据 通过 shell 命令向 topic 发送消息 kafka-console-producer.sh --broker-list hdp-node-01:9092 --topic kafka_spark 编写 Spark Streaming import org.apache.spark.streaming.dstream.DStream import org.apache.spark.streaming.kafka.KafkaUtils import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} import scala.collection.immutable //todo:利用sparkStreaming接受kafka中的数据实现单词计数----采用receivers object SparkStreamingKafka_Receiver_checkpoint { def updateFunc(a:Seq[Int], b:Option[Int]) :Option[Int] ={ Some(a.sum+b.getOrElse(0)) } def main(args: Array[String]): Unit = { val checkpointPath = &quot;./kafka-receiver&quot; val ssc = StreamingContext.getOrCreate(checkpointPath, () =&gt; { createFunc(checkpointPath) }) ssc.start() ssc.awaitTermination() } def createFunc(checkpointPath:String): StreamingContext = { //todo:1、创建sparkConf val sparkConf: SparkConf = new SparkConf() .setAppName(&quot;SparkStreamingKafka_Receiver_checkpoint&quot;) .setMaster(&quot;local[4]&quot;) //todo:开启wal预写日志 .set(&quot;spark.streaming.receiver.writeAheadLog.enable&quot;,&quot;true&quot;) //todo:2、创建sparkContext val sc = new SparkContext(sparkConf) sc.setLogLevel(&quot;WARN&quot;) //todo:3、创建StreamingContext val ssc = new StreamingContext(sc,Seconds(5)) ssc.checkpoint(checkpointPath) //todo:4、指定zkServer val zkServer=&quot;node1:2181,node2:2181,node3:2181&quot; //todo:5、指定groupId val groupId=&quot;spark-kafka-receiver01&quot; //todo:6、指定topics 这个可以利用一个消费者组来消费多个topic, //(topic_name -&gt; numPartitions) 指定topic消费的线程数 val topics=Map(&quot;kafka_spark&quot;-&gt;1) //todo:7、并行运行更多的接收器读取kafak topic中的数据，这里设置3个 val resultDStream: immutable.IndexedSeq[DStream[String]] = (1 to 3).map(x =&gt; { //todo:8、通过使用KafkaUtils的createStream接受kafka topic中的数据，生成DStream val kafkaDataDStream: DStream[String] = KafkaUtils.createStream(ssc, zkServer, groupId, topics).map(x =&gt; x._2) kafkaDataDStream } ) //todo:利用StreamContext将所有的DStream组合在一起 val kafkaDStream: DStream[String] = ssc.union(resultDStream) //todo:8、获取kafka中topic的内容 //todo:9、切分每一行。每个单词记为1 val wordAndOne: DStream[(String, Int)] = kafkaDStream.flatMap(_.split(&quot; &quot;)).map((_,1)) //todo:10、相同单词出现的次数累加 val result: DStream[(String, Int)] = wordAndOne.updateStateByKey(updateFunc) //todo:打印 result.print() ssc } } 运行代码，查看控制台数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这种方式实现，刚开始的时候系统正常运行，没有发现问题，但是如果系统异常重新启动sparkstreaming程序后，发现程序会重复处理已经处理过的数据，这种基于receiver的方式，是使用Kafka的高阶API来在ZooKeeper中保存消费过的offset的。这是消费Kafka数据的传统方式。这种方式配合着WAL机制可以保证数据零丢失的高可靠性，但是却无法保证数据被处理一次且仅一次，可能会处理两次。因为Spark和ZooKeeper之间可能是不同步的。官方现在也已经不推荐这种整合方式，官网相关地址下面我们使用官网推荐的第二种方式kafkaUtils的createDirectStream()方式。 KafkaUtils.createDirectStream方式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同于Receiver接收数据，这种方式定期地从kafka的topic下对应的partition中查询最新的偏移量，再根据偏移量范围在每个batch里面处理数据，Spark通过调用kafka简单的消费者Api读取一定范围的数据。 相比基于Receiver方式有几个优点： 简化并行: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不需要创建多个kafka输入流，然后union它们，sparkStreaming将会创建和kafka分区一种的rdd的分区数，而且会从kafka中并行读取数据，spark中RDD的分区数和kafka中的分区数据是一一对应的关系。 高效: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种实现数据的零丢失是将数据预先保存在WAL中，会复制一遍数据，会导致数据被拷贝两次，第一次是被kafka复制，另一次是写到WAL中。而没有receiver的这种方式消除了这个问题。 恰好一次语义(Exactly-once-semantics): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Receiver读取kafka数据是通过kafka高层次api把偏移量写入zookeeper中，虽然这种方法可以通过数据保存在WAL中保证数据不丢失，但是可能会因为sparkStreaming和ZK中保存的偏移量不一致而导致数据被消费了多次。EOS通过实现kafka低层次api，偏移量仅仅被ssc保存在checkpoint中，消除了zk和ssc偏移量不一致的问题。缺点是无法使用基于zookeeper的kafka监控工具 依赖到上面的案例即可,其余步骤也相同,接下来代码实现： import kafka.serializer.StringDecoder import org.apache.spark.streaming.dstream.InputDStream import org.apache.spark.streaming.kafka.KafkaUtils import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} object KafkaTest2 { def updateFunction(olds:Seq[Int],news:Option[Int]) : Option[Int] = { Some(olds.sum + news.getOrElse(0)) } def main(args: Array[String]): Unit = { val conf: SparkConf = new SparkConf().setAppName(&quot;testkafka2&quot;).setMaster(&quot;local[2]&quot;) val sc = new SparkContext(conf) sc.setLogLevel(&quot;ERROR&quot;) val scc = new StreamingContext(sc,Seconds(5)) scc.checkpoint(&quot;./spark_kafka&quot;) val brokers = &quot;node2:9092,node3:9092,node4:9092&quot; val topicSet = &quot;mdj&quot;.split(&quot;,&quot;).toSet val kafkaParam = Map(&quot;metadata.broker.list&quot;-&gt;brokers) val kafkads: InputDStream[(String, String)] = KafkaUtils.createDirectStream[String,String,StringDecoder,StringDecoder](scc,kafkaParam,topicSet) kafkads.map(_._2).map(_.split(&quot; &quot;)).map((_,1)).updateStateByKey(updateFunction).print() scc.start() scc.awaitTermination() } } 查看效果 向 topic 中添加数据 查看控制台的输出：" />
<meta property="og:description" content="Spark Streaming流式处理 Spark Streaming 介绍 Spark Streaming 概述 什么是 Spark Streaming 为什么要学习 Spark Streaming SparkStreaming 与 Storm 对比 Spark Streaming 原理 原理 Spark Streaming 计算流程 Spark Streaming 容错性 Spark Streaming 实时性 DStream 什么是 DStream DStream 相关操作 Transformations on DStreams Output Operations on DStreams DStream 操作实战 SparkStreaming 接收 socket 数据，实现单词技术 WordCound 架构图 实现流程 执行查看效果 SparkStreaming 接受 socket 数据，实现单词计数累加 架构图 实现流程 执行查看效果 SparkStreaming开窗函数reduceByKeyAndWindow，实现单词计数 架构图 实现流程 执行查看效果 SparkStreaming开窗函数统计一定时间内的热门词汇 架构图 实现流程 执行查看效果 Spark Streaming整合flume实战 Poll 方式 Push方式 6. Spark Streaming整合kafka实战 KafkaUtils.createDstream方式 KafkaUtils.createDstream实战 KafkaUtils.createDirectStream方式 Spark Streaming 介绍 Spark Streaming 概述 什么是 Spark Streaming &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 类似于 Apache Storm，用于流式数据的处理。根据官方文档介绍，Spark Streaming 有高吞吐量和容错能力强等特点。Spark Streaming 支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ 和简单的 TCP 套接字等等。数据输入后可以用 Spark 的高度抽象操作如：map、reduce、join、window等进行运算。而结果也能保存在很多地方，如 HDFS ， 数据库等。另外 Spark Streaming 也能和 MLlib（机器学习）以及 Graphx 完美融合。 为什么要学习 Spark Streaming 易用 容错 易整合到 Spark 体系 SparkStreaming 与 Storm 对比 SparkStreaming Storm 开发语言：Scala 开发语言：Clojure 编程模型：DStream 编程模型：Spoot/Bolt Spark Streaming 原理 原理 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 是基于 Spark 的流式批处理引擎，其基本原理是把==输入的数据以某一时间间隔批量的处理==，当批处理间隔缩短到==秒级==时，便可以用于处理实时数据流。 Spark Streaming 计算流程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 是将流式计算分解成一系列短小的批处理作业。这里的批处理引擎是 Spark Core，也就是把 Spark Streaming 的输入数据按照 batch size （如1秒）分成一段一段的数据（Discretized Stream），每一段数据都转换成 Spark 中的 RDD （Resilient Distributed Dataset），然后将 Spark Streaming 中对 DStream 的 Transformtion 操作变为针对 Spark 中对 RDD 的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transformation 操作，将 RDD 经过操作编程中间结果保存在内存中，整个流式计算根据业务的需求可以对中间的结果进行缓存或者存储到外部设备。下图为 Spark Streaming 的整个流程： Spark Streaming 容错性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于流失计算来说，容错性至关重要。首先我们要明确一下 Spark 中 RDD 的容错机制。每一个 RDD 都是不可变的分布式可重算的数据集，其记录着确定性操作继承关系（lineage），所以只要输入数据是可容错的，那么任意一个 RDD 的分区（Partition）出错或不可用，都是可以利用原始输入数据通过转换操作而重新算出的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 Spark Streaming 来说，其 RDD 的传承关系如下图所示： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;途中的每一个椭圆表示一个 RDD ，椭圆形中的每个圆形代表一个 RDD 中的一个 Partition ，图中的每一列的多个 RDD 表示一个 DStream（图中有三个 DStream），而每一行最后一个 RDD 则表示每一个 Batch Size 所产生的中间结果 RDD。我们可以看到图中的每一个 RDD 都是通过 lineage 相连接的，由于 Spark Streaming 输入数据可以来自于磁盘，例如 HDFS（多分拷贝）或是来自于网络的数据流（Spark Streaming 会将网络输入数据的每一个数据流拷贝两份到其他机器）都能保证容错性，所以 RDD 中任意的 Partition 出错，都可以并行地在其他机器上将缺失的 Partition 计算出来。这个容错恢复方式比连续计算模型（如 Storm）的效率更高 Spark Streaming 实时性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于实时性的讨论，会牵涉到流式处理框架的应用场景。Spark Streaming 将流式计算分解成多个 Spark Job，对于每一段数据的处理都会经过 Spark DAG 图分解以及 Spark 的任务集的调度过程。对于目前版本的 Spark Streaming 而言，其最小的 Batch Size 的选取在 0.5 ~ 2秒之间（Storm 目前最小的延迟是 100ms左右），所以 Spark Streaming 能满足除对实时性要求非常高（如高频实时交易）之外的所有流式准实时计算场景。 DStream 什么是 DStream &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretized Stream 是 Spark Streaming 的基础抽象，代表连续性的数据流和经过各种 Spark 算子操作后的结果数据流。在内部是线上。DStream 是一系列连续的 RDD 来表示。每个 RDD 含有一段时间间隔内的数据，如下图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对数据的操作也是按照 RDD 为单位来进行的 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 使用数据源产生的数据流创建 DStream，也可以在已有的 DStream 上使用一些操作来创建新的 DStream。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的工作流程像下面的图所示一样，接受到实时数据后，给数据分批次，然后传给 Spark Engine 处理最后生成该批次的结果。 DStream 相关操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DStream 上的操作与 RDD 类似，分为 Transformations （转换）和 Output Operations（输出）两种，此外转换操作中还有一些比较特殊的操作，如：updateStateByKey()、transform()以及各种 Window 相关的操作。 Transformations on DStreams Transformations Meaning map(func) 对DStream中的各个元素进行func函数操作，然后返回一个新的DStream flatMap(func) 与map方法类似，只不过各个输入项可以被输出为零个或多个输出项 filter(func) 过滤出所有函数func返回值为true的DStream元素并返回一个新的DStream repartition(numPartitions) 增加或减少DStream中的分区数，从而改变DStream的并行度 repartition(numPartitions) 增加或减少DStream中的分区数，从而改变DStream的并行度 union(otherStream) 将源DStream和输入参数为otherDStream的元素合并，并返回一个新的DStream. count() 通过对DStream中的各个RDD中的元素进行计数，然后返回只有一个元素的RDD构成的DStream reduce(func) 对源DStream中的各个RDD中的元素利用func进行聚合操作，然后返回只有一个元素的RDD构成的新的DStream. countByValue() 对于元素类型为K的DStream，返回一个元素为（K,Long）键值对形式的新的DStream，Long对应的值为源DStream中各个RDD的key出现的次数 reduceByKey(func, [numTasks]) 利用func函数对源DStream中的key进行聚 合操作，然后返回新的（K，V）对构成的DStream join(otherStream, [numTasks]) 输入为（K,V)、（K,W）类型的DStream，返回一个新的（K，（V，W）类型的DStream cogroup(otherStream, [numTasks]) 输入为（K,V)、（K,W）类型的DStream，返回一个新的 (K, Seq[V], Seq[W]) 元组类型的DStream transform(func) 通过RDD-to-RDD函数作用于DStream中的各个RDD，可以是任意的RDD操作，从而返回一个新的RDD updateStateByKey(func) 根据于key的前置状态和key的新值，对key进行更新，返回一个新状态的DStream 特殊的Transformations UpdateStateByKey Operation UpdateStateByKey用于记录历史记录，保存上次的状态 Window Operations(开窗函数,滑动窗口转换操作:) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 滑动窗口转换操作的计算过程如下图所示，我们可以事先设定一个滑动窗口的长度（也就是窗口的持续时间）， 并且设定滑动窗口的时间间隔（每隔多长时间执行一次计算），然后就可以让窗口按照指定时间间隔在源 DStream 上滑动，每次窗口停放的位置上，都会有一部分 DStream 被框入窗口内，形成一个小段 DStream ，这是，就可以启动对这个小段 DStream 的计算。 红色的矩形就是一个窗口，窗口框住的是一段时间内的数据流。 这里面每一个time都是时间单元，在官方的例子中，每隔window size是3 time unit, 而且每隔2个单位时间，窗口会slide一次。 所以基于窗口的操作，需要指定2个参数： • window length - The duration of the window (3 in the figure) • slide interval - The interval at which the window-based operation is performed (2 in the figure). 窗口大小：一段时间内数据的容器。 滑动间隔：每隔多久计算一次。 Output Operations on DStreams &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output Operations 可以将 DStream 的数据输出到外部的数据库或文件系统，当某个 Output Operations 被调用时（与 RDD 的 Action 相同），spark streaming 程序才会真正的计算过程。 Output Operation Meaning print() 打印到控制台 saveAsTextFiles(prefix, [suffix]) 保存流的内容为文本文件，文件名为&quot;prefix-TIME_IN_MS[.suffix]&quot;. saveAsObjectFiles(prefix, [suffix]) 保存流的内容为SequenceFile，文件名为 “prefix-TIME_IN_MS[.suffix]”. saveAsHadoopFiles(prefix, [suffix]) 保存流的内容为hadoop文件，文件名为&quot;prefix-TIME_IN_MS[.suffix]&quot;. foreachRDD(func) 对Dstream里面的每个RDD执行func DStream 操作实战 SparkStreaming 接收 socket 数据，实现单词技术 WordCound 架构图 实现流程 安装并启动生产者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在 linux 服务器上用 Yum 安装 nc 工具，命令为 netcat 命令的简称，都是用来设置路由器。我们可以利用它像某个端口发送数据。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yun install -y nc 通过 netcat 工具像指定的端口发送数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 编写 Spark Streaming 程序import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreming流式处理接受socket数据，实现单词统计 */ object SparkStreamingTCP { def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreamingTCP&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) //设置日志输出级别 sc.setLogLevel(&quot;WARN&quot;) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc,Seconds(5)) //注册一个监听的IP地址和端口 用来收集数据 val lines: ReceiverInputDStream[String] = scc.socketTextStream(&quot;192.168.200.160&quot;,9999) //切分每一行记录 val words: DStream[String] = lines.flatMap(_.split(&quot; &quot;)) //每个单词记为1 val wordAndOne: DStream[(String, Int)] = words.map((_,1)) //分组聚合 val result: DStream[(String, Int)] = wordAndOne.reduceByKey(_+_) //打印数据 result.print() scc.start() scc.awaitTermination() } } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于使用的是本地模式 local[2] 所以可以在本地运行该程序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：要指定并行度，如在本地运行设置 setMaster(&quot;local[2]&quot;)，相当于启动两个线程，一个给 received，一个给 computer。如果是在集群中运行，必须要求集群中可的 core 数大于1。 执行查看效果 先执行 nc -lk 9999 在执行代码 不断的在 1. 中输入不同的单词，观察 IDEA 控制台的输出 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象：SparkStreaming 每隔 5s 计算一次当前 5s 内的数据，然后将每个批次的数据输出。 SparkStreaming 接受 socket 数据，实现单词计数累加 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在上面的案例中存在这样一个问题：每个批次的单词都被正确的统计出来，但是结果不能累加！如果需要累加需要使用 updateStateByKey（func）来更新状态。 架构图 实现流程 安装并启动生成者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在linux服务器上用YUM安装nc工具，nc命令是netcat命令的简称,都是用来设置路由器。我们可以利用它向某个端口发送数据。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install -y nc 启动一个服务端并监听9999端口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向指定的端口发送数据 编写 SparkStreaming 程序 import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreaming流式处理，接受socket数据，实现单词统计并且每个批次数据结果累加 */ object SparkStreamingTCPTotal { //newValues 表示当前批次汇总成的(word,1)中相同单词的所有的1 //runningCount 历史的所有相同key的value总和 def updateFunction(newValues: Seq[Int], runningCount: Option[Int]): Option[Int] = { val newCount =runningCount.getOrElse(0)+newValues.sum Some(newCount) } def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreamingTCPTotal&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) sc.setLogLevel(&quot;WARN&quot;) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc, Seconds(5)) scc.checkpoint(&quot;./&quot;) //注册一个监听的IP地址和端口 用来收集数据 val lines: ReceiverInputDStream[String] = scc.socketTextStream(&quot;bw01&quot;, 9999) //切分每一行记录 val words: DStream[String] = lines.flatMap(_.split(&quot; &quot;)) //每个单词记为1 val wordAndOne: DStream[(String, Int)] = words.map((_, 1)) //累计统计单词出现的次数 val result: DStream[(String, Int)] = wordAndOne.updateStateByKey(updateFunction) result.print() scc.start() scc.awaitTermination() } } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过函数 updateStateByKey 实现。根据于 key 的前置状态和 key 的新值，对 key 进行更新，返回一个新状态的 DStream。 执行查看效果 执行 nc -lk 9999 然后执行以上代码 不断的在 1. 中输入不同的单词，观察 IDEA 控制台输出 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象：sparkStreaming每隔5s计算一次当前5s内的数据，然后将每个批次的结果数据累加输出。 SparkStreaming开窗函数reduceByKeyAndWindow，实现单词计数 架构图 实现流程 安装并启动生产者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在 linux 服务器上用 YUM 安装 nc 工具，nc 命令是 netcat 命令的简称，都是用来设置路由器。我们可以利用它向某个端口发送数据。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install -y nc 启动一个服务器 并监听 9999 端口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 ，向指定的端口发送数据。 编写 Spark Streaming 程序 import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreming开窗函数---统计一定时间内单词出现的次数 */ object SparkStreamingTCPWindow { def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreamingTCPWindow&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) sc.setLogLevel(&quot;WARN&quot;) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc,Seconds(5)) //注册一个监听的IP地址和端口 用来收集数据 val lines: ReceiverInputDStream[String] = scc.socketTextStream(&quot;192.168.200.160&quot;,9999) //切分每一行记录 val words: DStream[String] = lines.flatMap(_.split(&quot; &quot;)) //每个单词记为1 val wordAndOne: DStream[(String, Int)] = words.map((_,1)) //reduceByKeyAndWindow函数参数意义： // windowDuration:表示window框住的时间长度，如本例5秒切分一次RDD，框10秒，就会保留最近2次切分的RDD //slideDuration: 表示window滑动的时间长度，即每隔多久执行本计算 val result: DStream[(String, Int)] = wordAndOne.reduceByKeyAndWindow((a:Int,b:Int)=&gt;a+b,Seconds(10),Seconds(5)) result.print() scc.start() scc.awaitTermination() } } 执行查看效果 先执行 nc -lk 9999 然后在执行以上代码 断的在（1）中输入不同的单词，观察IDEA控制台输出 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象： Spark Streaming 每个5s 计算一次当前在窗口大小为 10s 内的数据，然后将结果数据输出。 SparkStreaming开窗函数统计一定时间内的热门词汇 架构图 实现流程 安装并启动生产者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在 linux 服务器上用 YUM 安装 nc 工具，nc 命令是 netcat 命令的简称，都是用来设置路由器。我们可以利用它向某个端口发送数据。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install -y nc 启动一个服务器并监听 9999 端口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 编写 Spark Streaming 程序 package cn.test.spark import org.apache.spark.rdd.RDD import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreming开窗函数应用----统计一定时间内的热门词汇 */ object SparkStreamingTCPWindowHotWords { def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreamingTCPWindowHotWords&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) sc.setLogLevel(&quot;WARN&quot;) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc,Seconds(5)) //注册一个监听的IP地址和端口 用来收集数据 val lines: ReceiverInputDStream[String] = scc.socketTextStream(&quot;192.168.200.160&quot;,9999) //切分每一行记录 val words: DStream[String] = lines.flatMap(_.split(&quot; &quot;)) //每个单词记为1 val wordAndOne: DStream[(String, Int)] = words.map((_,1)) //reduceByKeyAndWindow函数参数意义： // windowDuration:表示window框住的时间长度，如本例5秒切分一次RDD，框10秒，就会保留最近2次切分的RDD //slideDuration: 表示window滑动的时间长度，即每隔多久执行本计算 val result: DStream[(String, Int)] = wordAndOne.reduceByKeyAndWindow((a:Int,b:Int)=&gt;a+b,Seconds(5),Seconds(5)) val data=result.transform(rdd=&gt;{ //降序处理后，取前3位 val dataRDD: RDD[(String, Int)] = rdd.sortBy(t=&gt;t._2,false) val sortResult: Array[(String, Int)] = dataRDD.take(3) println(&quot;--------------print top 3 begin--------------&quot;) sortResult.foreach(println) println(&quot;--------------print top 3 end--------------&quot;) dataRDD }) data.print() scc.start() scc.awaitTermination() } } 执行查看效果 先执行 nc -lk 9999 在执行以上代码 不断的在 1. 中输入不同的单词，观察 IDEA 控制台输出 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象：sparkStreaming每隔5s计算一次当前在窗口大小为10s内的数据，然后将单词出现次数最多的前3位进行输出打印。/p&gt; Spark Streaming整合flume实战 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flume作为日志实时采集的框架，可以与SparkStreaming实时处理框进行对接，flume实时产生数据，sparkStreaming做实时处理。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 对接 FlumeNG有两种方式，一种是FlumeNG将消息Push推给Spark Streaming，还有一种是Spark Streaming从flume 中 Poll 拉取数据。 Poll 方式 安装flume1.6以上 下载依赖包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spark-streaming-flume-sink_2.11-2.0.2.jar放入到flume的lib目录下。/p&gt; 写flume的agent，注意既然是拉取的方式，那么flume向自己所在的机器上产数据就行 编写flume-poll.conf配置文件 a1.sources = r1 a1.sinks = k1 a1.channels = c1 #source a1.sources.r1.channels = c1 a1.sources.r1.type = spooldir a1.sources.r1.spoolDir = /root/data a1.sources.r1.fileHeader = true #channel a1.channels.c1.type =memory a1.channels.c1.capacity = 20000 a1.channels.c1.transactionCapacity=5000 #sinks a1.sinks.k1.channel = c1 a1.sinks.k1.type = org.apache.spark.streaming.flume.sink.SparkSink a1.sinks.k1.hostname=hdp-node-01 a1.sinks.k1.port = 8888 a1.sinks.k1.batchSize= 2000 启动flume： flume-ng agent -n a1 -c /opt/bigdata/flume/conf -f /opt/bigdata/flume/conf/flume-poll.conf -Dflume.root.logger=INFO,console &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务器上的 /root/data目录下准备数据文件data.txt 5. 启动 spark-streaming 应用程序，去 flume 所在机器拉取数据 6. 代码实现 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要添加pom依赖 &lt;properties&gt; &lt;scala.version&gt;2.11.8&lt;/scala.version&gt; &lt;hadoop.version&gt;2.7.4&lt;/hadoop.version&gt; &lt;spark.version&gt;2.0.2&lt;/spark.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt; &lt;version&gt;${spark.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入spark-streaming-flume的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-flume_2.10&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 具体代码如下： import java.net.InetSocketAddress import org.apache.spark.storage.StorageLevel import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.flume.{FlumeUtils, SparkFlumeEvent} import org.apache.spark.{SparkConf, SparkContext} import org.apache.spark.streaming.{Seconds, StreamingContext} object FlumeDir { def main(args: Array[String]): Unit = { val conf: SparkConf = new SparkConf().setAppName(&quot;FlumeDir&quot;).setMaster(&quot;local[2]&quot;) val sc = new SparkContext(conf) sc.setLogLevel(&quot;WARN&quot;) val scc = new StreamingContext(sc,Seconds(5)) scc.checkpoint(&quot;./spark_flume_dir&quot;) //设置flume地址 val addresses: Seq[InetSocketAddress] = Seq (new InetSocketAddress(&quot;192.168.44.127&quot;,8888)) val flumeds: ReceiverInputDStream[SparkFlumeEvent] = FlumeUtils.createPollingStream(scc,addresses,StorageLevel.MEMORY_AND_DISK) val lineds: DStream[String] = flumeds.map(x=&gt;new String(x.event.getBody.array())) lineds.flatMap(_.split(&quot; &quot;)).map((_,1)).reduceByKey(_+_).print() scc.start() scc.awaitTermination() } } Push方式 （1）编写flume-push.conf配置文件 #push mode a1.sources = r1 a1.sinks = k1 a1.channels = c1 #source a1.sources.r1.channels = c1 a1.sources.r1.type = spooldir a1.sources.r1.spoolDir = /root/data a1.sources.r1.fileHeader = true #channel a1.channels.c1.type =memory a1.channels.c1.capacity = 20000 a1.channels.c1.transactionCapacity=5000 #sinks a1.sinks.k1.channel = c1 a1.sinks.k1.type = avro a1.sinks.k1.hostname=172.16.43.63 a1.sinks.k1.port = 8888 a1.sinks.k1.batchSize= 2000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意配置文件中指明的hostname和port是spark应用程序所在服务器的ip地址和端口 代码实现如下： package cn.test.spark import java.net.InetSocketAddress import org.apache.spark.storage.StorageLevel import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.flume.{FlumeUtils, SparkFlumeEvent} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreaming整合flume 推模式Push */ object SparkStreaming_Flume_Push { //newValues 表示当前批次汇总成的(word,1)中相同单词的所有的1 //runningCount 历史的所有相同key的value总和 def updateFunction(newValues: Seq[Int], runningCount: Option[Int]): Option[Int] = { val newCount =runningCount.getOrElse(0)+newValues.sum Some(newCount) } def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreaming_Flume_Push&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc, Seconds(5)) //设置日志输出级别 sc.setLogLevel(&quot;WARN&quot;) //设置检查点目录 scc.checkpoint(&quot;./&quot;) //flume推数据过来 // 当前应用程序部署的服务器ip地址，跟flume配置文件保持一致 val flumeStream: ReceiverInputDStream[SparkFlumeEvent] = FlumeUtils.createStream(scc,&quot;172.16.43.63&quot;,8888,StorageLevel.MEMORY_AND_DISK) //获取flume中数据，数据存在event的body中，转化为String val lineStream: DStream[String] = flumeStream.map(x=&gt;new String(x.event.getBody.array())) //实现单词汇总 val result: DStream[(String, Int)] = lineStream.flatMap(_.split(&quot; &quot;)).map((_,1)).updateStateByKey(updateFunction) result.print() scc.start() scc.awaitTermination() } } } 启动执行 先执行spark代码 然后在执行flume配置文件 观察 IDEA 控制台输出 6. Spark Streaming整合kafka实战 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kafka作为一个实时的分布式消息队列，实时的生产和消费消息，这里我们可以利用SparkStreaming实时计算框架实时地读取kafka中的数据然后进行计算。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在spark1.3版本后，kafkaUtils里面提供了两个创建dstream的方法，一种为KafkaUtils.createDstream，另一种为KafkaUtils.createDirectStream。 KafkaUtils.createDstream方式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造函数为KafkaUtils.createDstream(ssc, [zk], [consumer group id], [per-topic,partitions] ) 使用了receivers来接收数据，利用的是Kafka高层次的消费者api，对于所有的receivers接收到的数据将会保存在Spark executors中，然后通过Spark Streaming启动job来处理这些数据，默认会丢失，可启用WAL日志，它同步将接受到数据保存到分布式文件系统上比如HDFS。 所以数据在出错的情况下可以恢复出来 。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190813213050229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个receiver来对kafka进行定时拉取数据，ssc的rdd分区和kafka的topic分区不是一个概念，故如果增加特定主消费的线程数仅仅是增加一个receiver中消费topic的线程数，并不增加spark的并行处理数据数量 。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于不同的group和topic可以使用多个receivers创建不同的DStream 。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果启用了WAL (spark.streaming.receiver.writeAheadLog.enable=true) 同时需要设置存储级别(默认StorageLevel.MEMORY_AND_DISK_SER_2)， 即KafkaUtils.createStream(….,StorageLevel.MEMORY_AND_DISK_SER) 。 KafkaUtils.createDstream实战 添加 kafka 的 pom 依赖 &lt;properties&gt; &lt;scala.version&gt;2.11.8&lt;/scala.version&gt; &lt;hadoop.version&gt;2.7.4&lt;/hadoop.version&gt; &lt;spark.version&gt;2.0.2&lt;/spark.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-kafka-0-8_2.11&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt; &lt;version&gt;${spark.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-hive_2.11&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 启动 zookeeper 集群 zkServer.sh start 启动 kafka 集群 kafka-server-start.sh /export/servers/kafka/config/server.properties 创建 topic kafka-topics.sh --create --zookeeper hdp-node-01:2181 --replication-factor 1 --partitions 3 --topic kafka_spark 向 topic 中生产数据 通过 shell 命令向 topic 发送消息 kafka-console-producer.sh --broker-list hdp-node-01:9092 --topic kafka_spark 编写 Spark Streaming import org.apache.spark.streaming.dstream.DStream import org.apache.spark.streaming.kafka.KafkaUtils import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} import scala.collection.immutable //todo:利用sparkStreaming接受kafka中的数据实现单词计数----采用receivers object SparkStreamingKafka_Receiver_checkpoint { def updateFunc(a:Seq[Int], b:Option[Int]) :Option[Int] ={ Some(a.sum+b.getOrElse(0)) } def main(args: Array[String]): Unit = { val checkpointPath = &quot;./kafka-receiver&quot; val ssc = StreamingContext.getOrCreate(checkpointPath, () =&gt; { createFunc(checkpointPath) }) ssc.start() ssc.awaitTermination() } def createFunc(checkpointPath:String): StreamingContext = { //todo:1、创建sparkConf val sparkConf: SparkConf = new SparkConf() .setAppName(&quot;SparkStreamingKafka_Receiver_checkpoint&quot;) .setMaster(&quot;local[4]&quot;) //todo:开启wal预写日志 .set(&quot;spark.streaming.receiver.writeAheadLog.enable&quot;,&quot;true&quot;) //todo:2、创建sparkContext val sc = new SparkContext(sparkConf) sc.setLogLevel(&quot;WARN&quot;) //todo:3、创建StreamingContext val ssc = new StreamingContext(sc,Seconds(5)) ssc.checkpoint(checkpointPath) //todo:4、指定zkServer val zkServer=&quot;node1:2181,node2:2181,node3:2181&quot; //todo:5、指定groupId val groupId=&quot;spark-kafka-receiver01&quot; //todo:6、指定topics 这个可以利用一个消费者组来消费多个topic, //(topic_name -&gt; numPartitions) 指定topic消费的线程数 val topics=Map(&quot;kafka_spark&quot;-&gt;1) //todo:7、并行运行更多的接收器读取kafak topic中的数据，这里设置3个 val resultDStream: immutable.IndexedSeq[DStream[String]] = (1 to 3).map(x =&gt; { //todo:8、通过使用KafkaUtils的createStream接受kafka topic中的数据，生成DStream val kafkaDataDStream: DStream[String] = KafkaUtils.createStream(ssc, zkServer, groupId, topics).map(x =&gt; x._2) kafkaDataDStream } ) //todo:利用StreamContext将所有的DStream组合在一起 val kafkaDStream: DStream[String] = ssc.union(resultDStream) //todo:8、获取kafka中topic的内容 //todo:9、切分每一行。每个单词记为1 val wordAndOne: DStream[(String, Int)] = kafkaDStream.flatMap(_.split(&quot; &quot;)).map((_,1)) //todo:10、相同单词出现的次数累加 val result: DStream[(String, Int)] = wordAndOne.updateStateByKey(updateFunc) //todo:打印 result.print() ssc } } 运行代码，查看控制台数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这种方式实现，刚开始的时候系统正常运行，没有发现问题，但是如果系统异常重新启动sparkstreaming程序后，发现程序会重复处理已经处理过的数据，这种基于receiver的方式，是使用Kafka的高阶API来在ZooKeeper中保存消费过的offset的。这是消费Kafka数据的传统方式。这种方式配合着WAL机制可以保证数据零丢失的高可靠性，但是却无法保证数据被处理一次且仅一次，可能会处理两次。因为Spark和ZooKeeper之间可能是不同步的。官方现在也已经不推荐这种整合方式，官网相关地址下面我们使用官网推荐的第二种方式kafkaUtils的createDirectStream()方式。 KafkaUtils.createDirectStream方式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同于Receiver接收数据，这种方式定期地从kafka的topic下对应的partition中查询最新的偏移量，再根据偏移量范围在每个batch里面处理数据，Spark通过调用kafka简单的消费者Api读取一定范围的数据。 相比基于Receiver方式有几个优点： 简化并行: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不需要创建多个kafka输入流，然后union它们，sparkStreaming将会创建和kafka分区一种的rdd的分区数，而且会从kafka中并行读取数据，spark中RDD的分区数和kafka中的分区数据是一一对应的关系。 高效: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种实现数据的零丢失是将数据预先保存在WAL中，会复制一遍数据，会导致数据被拷贝两次，第一次是被kafka复制，另一次是写到WAL中。而没有receiver的这种方式消除了这个问题。 恰好一次语义(Exactly-once-semantics): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Receiver读取kafka数据是通过kafka高层次api把偏移量写入zookeeper中，虽然这种方法可以通过数据保存在WAL中保证数据不丢失，但是可能会因为sparkStreaming和ZK中保存的偏移量不一致而导致数据被消费了多次。EOS通过实现kafka低层次api，偏移量仅仅被ssc保存在checkpoint中，消除了zk和ssc偏移量不一致的问题。缺点是无法使用基于zookeeper的kafka监控工具 依赖到上面的案例即可,其余步骤也相同,接下来代码实现： import kafka.serializer.StringDecoder import org.apache.spark.streaming.dstream.InputDStream import org.apache.spark.streaming.kafka.KafkaUtils import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} object KafkaTest2 { def updateFunction(olds:Seq[Int],news:Option[Int]) : Option[Int] = { Some(olds.sum + news.getOrElse(0)) } def main(args: Array[String]): Unit = { val conf: SparkConf = new SparkConf().setAppName(&quot;testkafka2&quot;).setMaster(&quot;local[2]&quot;) val sc = new SparkContext(conf) sc.setLogLevel(&quot;ERROR&quot;) val scc = new StreamingContext(sc,Seconds(5)) scc.checkpoint(&quot;./spark_kafka&quot;) val brokers = &quot;node2:9092,node3:9092,node4:9092&quot; val topicSet = &quot;mdj&quot;.split(&quot;,&quot;).toSet val kafkaParam = Map(&quot;metadata.broker.list&quot;-&gt;brokers) val kafkads: InputDStream[(String, String)] = KafkaUtils.createDirectStream[String,String,StringDecoder,StringDecoder](scc,kafkaParam,topicSet) kafkads.map(_._2).map(_.split(&quot; &quot;)).map((_,1)).updateStateByKey(updateFunction).print() scc.start() scc.awaitTermination() } } 查看效果 向 topic 中添加数据 查看控制台的输出：" />
<link rel="canonical" href="https://uzzz.org/2019/08/13/794489.html" />
<meta property="og:url" content="https://uzzz.org/2019/08/13/794489.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Spark Streaming流式处理 Spark Streaming 介绍 Spark Streaming 概述 什么是 Spark Streaming 为什么要学习 Spark Streaming SparkStreaming 与 Storm 对比 Spark Streaming 原理 原理 Spark Streaming 计算流程 Spark Streaming 容错性 Spark Streaming 实时性 DStream 什么是 DStream DStream 相关操作 Transformations on DStreams Output Operations on DStreams DStream 操作实战 SparkStreaming 接收 socket 数据，实现单词技术 WordCound 架构图 实现流程 执行查看效果 SparkStreaming 接受 socket 数据，实现单词计数累加 架构图 实现流程 执行查看效果 SparkStreaming开窗函数reduceByKeyAndWindow，实现单词计数 架构图 实现流程 执行查看效果 SparkStreaming开窗函数统计一定时间内的热门词汇 架构图 实现流程 执行查看效果 Spark Streaming整合flume实战 Poll 方式 Push方式 6. Spark Streaming整合kafka实战 KafkaUtils.createDstream方式 KafkaUtils.createDstream实战 KafkaUtils.createDirectStream方式 Spark Streaming 介绍 Spark Streaming 概述 什么是 Spark Streaming &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 类似于 Apache Storm，用于流式数据的处理。根据官方文档介绍，Spark Streaming 有高吞吐量和容错能力强等特点。Spark Streaming 支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ 和简单的 TCP 套接字等等。数据输入后可以用 Spark 的高度抽象操作如：map、reduce、join、window等进行运算。而结果也能保存在很多地方，如 HDFS ， 数据库等。另外 Spark Streaming 也能和 MLlib（机器学习）以及 Graphx 完美融合。 为什么要学习 Spark Streaming 易用 容错 易整合到 Spark 体系 SparkStreaming 与 Storm 对比 SparkStreaming Storm 开发语言：Scala 开发语言：Clojure 编程模型：DStream 编程模型：Spoot/Bolt Spark Streaming 原理 原理 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 是基于 Spark 的流式批处理引擎，其基本原理是把==输入的数据以某一时间间隔批量的处理==，当批处理间隔缩短到==秒级==时，便可以用于处理实时数据流。 Spark Streaming 计算流程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 是将流式计算分解成一系列短小的批处理作业。这里的批处理引擎是 Spark Core，也就是把 Spark Streaming 的输入数据按照 batch size （如1秒）分成一段一段的数据（Discretized Stream），每一段数据都转换成 Spark 中的 RDD （Resilient Distributed Dataset），然后将 Spark Streaming 中对 DStream 的 Transformtion 操作变为针对 Spark 中对 RDD 的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transformation 操作，将 RDD 经过操作编程中间结果保存在内存中，整个流式计算根据业务的需求可以对中间的结果进行缓存或者存储到外部设备。下图为 Spark Streaming 的整个流程： Spark Streaming 容错性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于流失计算来说，容错性至关重要。首先我们要明确一下 Spark 中 RDD 的容错机制。每一个 RDD 都是不可变的分布式可重算的数据集，其记录着确定性操作继承关系（lineage），所以只要输入数据是可容错的，那么任意一个 RDD 的分区（Partition）出错或不可用，都是可以利用原始输入数据通过转换操作而重新算出的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 Spark Streaming 来说，其 RDD 的传承关系如下图所示： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;途中的每一个椭圆表示一个 RDD ，椭圆形中的每个圆形代表一个 RDD 中的一个 Partition ，图中的每一列的多个 RDD 表示一个 DStream（图中有三个 DStream），而每一行最后一个 RDD 则表示每一个 Batch Size 所产生的中间结果 RDD。我们可以看到图中的每一个 RDD 都是通过 lineage 相连接的，由于 Spark Streaming 输入数据可以来自于磁盘，例如 HDFS（多分拷贝）或是来自于网络的数据流（Spark Streaming 会将网络输入数据的每一个数据流拷贝两份到其他机器）都能保证容错性，所以 RDD 中任意的 Partition 出错，都可以并行地在其他机器上将缺失的 Partition 计算出来。这个容错恢复方式比连续计算模型（如 Storm）的效率更高 Spark Streaming 实时性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于实时性的讨论，会牵涉到流式处理框架的应用场景。Spark Streaming 将流式计算分解成多个 Spark Job，对于每一段数据的处理都会经过 Spark DAG 图分解以及 Spark 的任务集的调度过程。对于目前版本的 Spark Streaming 而言，其最小的 Batch Size 的选取在 0.5 ~ 2秒之间（Storm 目前最小的延迟是 100ms左右），所以 Spark Streaming 能满足除对实时性要求非常高（如高频实时交易）之外的所有流式准实时计算场景。 DStream 什么是 DStream &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretized Stream 是 Spark Streaming 的基础抽象，代表连续性的数据流和经过各种 Spark 算子操作后的结果数据流。在内部是线上。DStream 是一系列连续的 RDD 来表示。每个 RDD 含有一段时间间隔内的数据，如下图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对数据的操作也是按照 RDD 为单位来进行的 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 使用数据源产生的数据流创建 DStream，也可以在已有的 DStream 上使用一些操作来创建新的 DStream。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的工作流程像下面的图所示一样，接受到实时数据后，给数据分批次，然后传给 Spark Engine 处理最后生成该批次的结果。 DStream 相关操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DStream 上的操作与 RDD 类似，分为 Transformations （转换）和 Output Operations（输出）两种，此外转换操作中还有一些比较特殊的操作，如：updateStateByKey()、transform()以及各种 Window 相关的操作。 Transformations on DStreams Transformations Meaning map(func) 对DStream中的各个元素进行func函数操作，然后返回一个新的DStream flatMap(func) 与map方法类似，只不过各个输入项可以被输出为零个或多个输出项 filter(func) 过滤出所有函数func返回值为true的DStream元素并返回一个新的DStream repartition(numPartitions) 增加或减少DStream中的分区数，从而改变DStream的并行度 repartition(numPartitions) 增加或减少DStream中的分区数，从而改变DStream的并行度 union(otherStream) 将源DStream和输入参数为otherDStream的元素合并，并返回一个新的DStream. count() 通过对DStream中的各个RDD中的元素进行计数，然后返回只有一个元素的RDD构成的DStream reduce(func) 对源DStream中的各个RDD中的元素利用func进行聚合操作，然后返回只有一个元素的RDD构成的新的DStream. countByValue() 对于元素类型为K的DStream，返回一个元素为（K,Long）键值对形式的新的DStream，Long对应的值为源DStream中各个RDD的key出现的次数 reduceByKey(func, [numTasks]) 利用func函数对源DStream中的key进行聚 合操作，然后返回新的（K，V）对构成的DStream join(otherStream, [numTasks]) 输入为（K,V)、（K,W）类型的DStream，返回一个新的（K，（V，W）类型的DStream cogroup(otherStream, [numTasks]) 输入为（K,V)、（K,W）类型的DStream，返回一个新的 (K, Seq[V], Seq[W]) 元组类型的DStream transform(func) 通过RDD-to-RDD函数作用于DStream中的各个RDD，可以是任意的RDD操作，从而返回一个新的RDD updateStateByKey(func) 根据于key的前置状态和key的新值，对key进行更新，返回一个新状态的DStream 特殊的Transformations UpdateStateByKey Operation UpdateStateByKey用于记录历史记录，保存上次的状态 Window Operations(开窗函数,滑动窗口转换操作:) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 滑动窗口转换操作的计算过程如下图所示，我们可以事先设定一个滑动窗口的长度（也就是窗口的持续时间）， 并且设定滑动窗口的时间间隔（每隔多长时间执行一次计算），然后就可以让窗口按照指定时间间隔在源 DStream 上滑动，每次窗口停放的位置上，都会有一部分 DStream 被框入窗口内，形成一个小段 DStream ，这是，就可以启动对这个小段 DStream 的计算。 红色的矩形就是一个窗口，窗口框住的是一段时间内的数据流。 这里面每一个time都是时间单元，在官方的例子中，每隔window size是3 time unit, 而且每隔2个单位时间，窗口会slide一次。 所以基于窗口的操作，需要指定2个参数： • window length - The duration of the window (3 in the figure) • slide interval - The interval at which the window-based operation is performed (2 in the figure). 窗口大小：一段时间内数据的容器。 滑动间隔：每隔多久计算一次。 Output Operations on DStreams &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output Operations 可以将 DStream 的数据输出到外部的数据库或文件系统，当某个 Output Operations 被调用时（与 RDD 的 Action 相同），spark streaming 程序才会真正的计算过程。 Output Operation Meaning print() 打印到控制台 saveAsTextFiles(prefix, [suffix]) 保存流的内容为文本文件，文件名为&quot;prefix-TIME_IN_MS[.suffix]&quot;. saveAsObjectFiles(prefix, [suffix]) 保存流的内容为SequenceFile，文件名为 “prefix-TIME_IN_MS[.suffix]”. saveAsHadoopFiles(prefix, [suffix]) 保存流的内容为hadoop文件，文件名为&quot;prefix-TIME_IN_MS[.suffix]&quot;. foreachRDD(func) 对Dstream里面的每个RDD执行func DStream 操作实战 SparkStreaming 接收 socket 数据，实现单词技术 WordCound 架构图 实现流程 安装并启动生产者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在 linux 服务器上用 Yum 安装 nc 工具，命令为 netcat 命令的简称，都是用来设置路由器。我们可以利用它像某个端口发送数据。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yun install -y nc 通过 netcat 工具像指定的端口发送数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 编写 Spark Streaming 程序import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreming流式处理接受socket数据，实现单词统计 */ object SparkStreamingTCP { def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreamingTCP&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) //设置日志输出级别 sc.setLogLevel(&quot;WARN&quot;) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc,Seconds(5)) //注册一个监听的IP地址和端口 用来收集数据 val lines: ReceiverInputDStream[String] = scc.socketTextStream(&quot;192.168.200.160&quot;,9999) //切分每一行记录 val words: DStream[String] = lines.flatMap(_.split(&quot; &quot;)) //每个单词记为1 val wordAndOne: DStream[(String, Int)] = words.map((_,1)) //分组聚合 val result: DStream[(String, Int)] = wordAndOne.reduceByKey(_+_) //打印数据 result.print() scc.start() scc.awaitTermination() } } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于使用的是本地模式 local[2] 所以可以在本地运行该程序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：要指定并行度，如在本地运行设置 setMaster(&quot;local[2]&quot;)，相当于启动两个线程，一个给 received，一个给 computer。如果是在集群中运行，必须要求集群中可的 core 数大于1。 执行查看效果 先执行 nc -lk 9999 在执行代码 不断的在 1. 中输入不同的单词，观察 IDEA 控制台的输出 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象：SparkStreaming 每隔 5s 计算一次当前 5s 内的数据，然后将每个批次的数据输出。 SparkStreaming 接受 socket 数据，实现单词计数累加 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在上面的案例中存在这样一个问题：每个批次的单词都被正确的统计出来，但是结果不能累加！如果需要累加需要使用 updateStateByKey（func）来更新状态。 架构图 实现流程 安装并启动生成者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在linux服务器上用YUM安装nc工具，nc命令是netcat命令的简称,都是用来设置路由器。我们可以利用它向某个端口发送数据。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install -y nc 启动一个服务端并监听9999端口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向指定的端口发送数据 编写 SparkStreaming 程序 import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreaming流式处理，接受socket数据，实现单词统计并且每个批次数据结果累加 */ object SparkStreamingTCPTotal { //newValues 表示当前批次汇总成的(word,1)中相同单词的所有的1 //runningCount 历史的所有相同key的value总和 def updateFunction(newValues: Seq[Int], runningCount: Option[Int]): Option[Int] = { val newCount =runningCount.getOrElse(0)+newValues.sum Some(newCount) } def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreamingTCPTotal&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) sc.setLogLevel(&quot;WARN&quot;) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc, Seconds(5)) scc.checkpoint(&quot;./&quot;) //注册一个监听的IP地址和端口 用来收集数据 val lines: ReceiverInputDStream[String] = scc.socketTextStream(&quot;bw01&quot;, 9999) //切分每一行记录 val words: DStream[String] = lines.flatMap(_.split(&quot; &quot;)) //每个单词记为1 val wordAndOne: DStream[(String, Int)] = words.map((_, 1)) //累计统计单词出现的次数 val result: DStream[(String, Int)] = wordAndOne.updateStateByKey(updateFunction) result.print() scc.start() scc.awaitTermination() } } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过函数 updateStateByKey 实现。根据于 key 的前置状态和 key 的新值，对 key 进行更新，返回一个新状态的 DStream。 执行查看效果 执行 nc -lk 9999 然后执行以上代码 不断的在 1. 中输入不同的单词，观察 IDEA 控制台输出 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象：sparkStreaming每隔5s计算一次当前5s内的数据，然后将每个批次的结果数据累加输出。 SparkStreaming开窗函数reduceByKeyAndWindow，实现单词计数 架构图 实现流程 安装并启动生产者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在 linux 服务器上用 YUM 安装 nc 工具，nc 命令是 netcat 命令的简称，都是用来设置路由器。我们可以利用它向某个端口发送数据。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install -y nc 启动一个服务器 并监听 9999 端口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 ，向指定的端口发送数据。 编写 Spark Streaming 程序 import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreming开窗函数---统计一定时间内单词出现的次数 */ object SparkStreamingTCPWindow { def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreamingTCPWindow&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) sc.setLogLevel(&quot;WARN&quot;) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc,Seconds(5)) //注册一个监听的IP地址和端口 用来收集数据 val lines: ReceiverInputDStream[String] = scc.socketTextStream(&quot;192.168.200.160&quot;,9999) //切分每一行记录 val words: DStream[String] = lines.flatMap(_.split(&quot; &quot;)) //每个单词记为1 val wordAndOne: DStream[(String, Int)] = words.map((_,1)) //reduceByKeyAndWindow函数参数意义： // windowDuration:表示window框住的时间长度，如本例5秒切分一次RDD，框10秒，就会保留最近2次切分的RDD //slideDuration: 表示window滑动的时间长度，即每隔多久执行本计算 val result: DStream[(String, Int)] = wordAndOne.reduceByKeyAndWindow((a:Int,b:Int)=&gt;a+b,Seconds(10),Seconds(5)) result.print() scc.start() scc.awaitTermination() } } 执行查看效果 先执行 nc -lk 9999 然后在执行以上代码 断的在（1）中输入不同的单词，观察IDEA控制台输出 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象： Spark Streaming 每个5s 计算一次当前在窗口大小为 10s 内的数据，然后将结果数据输出。 SparkStreaming开窗函数统计一定时间内的热门词汇 架构图 实现流程 安装并启动生产者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在 linux 服务器上用 YUM 安装 nc 工具，nc 命令是 netcat 命令的简称，都是用来设置路由器。我们可以利用它向某个端口发送数据。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install -y nc 启动一个服务器并监听 9999 端口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 编写 Spark Streaming 程序 package cn.test.spark import org.apache.spark.rdd.RDD import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreming开窗函数应用----统计一定时间内的热门词汇 */ object SparkStreamingTCPWindowHotWords { def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreamingTCPWindowHotWords&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) sc.setLogLevel(&quot;WARN&quot;) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc,Seconds(5)) //注册一个监听的IP地址和端口 用来收集数据 val lines: ReceiverInputDStream[String] = scc.socketTextStream(&quot;192.168.200.160&quot;,9999) //切分每一行记录 val words: DStream[String] = lines.flatMap(_.split(&quot; &quot;)) //每个单词记为1 val wordAndOne: DStream[(String, Int)] = words.map((_,1)) //reduceByKeyAndWindow函数参数意义： // windowDuration:表示window框住的时间长度，如本例5秒切分一次RDD，框10秒，就会保留最近2次切分的RDD //slideDuration: 表示window滑动的时间长度，即每隔多久执行本计算 val result: DStream[(String, Int)] = wordAndOne.reduceByKeyAndWindow((a:Int,b:Int)=&gt;a+b,Seconds(5),Seconds(5)) val data=result.transform(rdd=&gt;{ //降序处理后，取前3位 val dataRDD: RDD[(String, Int)] = rdd.sortBy(t=&gt;t._2,false) val sortResult: Array[(String, Int)] = dataRDD.take(3) println(&quot;--------------print top 3 begin--------------&quot;) sortResult.foreach(println) println(&quot;--------------print top 3 end--------------&quot;) dataRDD }) data.print() scc.start() scc.awaitTermination() } } 执行查看效果 先执行 nc -lk 9999 在执行以上代码 不断的在 1. 中输入不同的单词，观察 IDEA 控制台输出 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象：sparkStreaming每隔5s计算一次当前在窗口大小为10s内的数据，然后将单词出现次数最多的前3位进行输出打印。/p&gt; Spark Streaming整合flume实战 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flume作为日志实时采集的框架，可以与SparkStreaming实时处理框进行对接，flume实时产生数据，sparkStreaming做实时处理。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 对接 FlumeNG有两种方式，一种是FlumeNG将消息Push推给Spark Streaming，还有一种是Spark Streaming从flume 中 Poll 拉取数据。 Poll 方式 安装flume1.6以上 下载依赖包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spark-streaming-flume-sink_2.11-2.0.2.jar放入到flume的lib目录下。/p&gt; 写flume的agent，注意既然是拉取的方式，那么flume向自己所在的机器上产数据就行 编写flume-poll.conf配置文件 a1.sources = r1 a1.sinks = k1 a1.channels = c1 #source a1.sources.r1.channels = c1 a1.sources.r1.type = spooldir a1.sources.r1.spoolDir = /root/data a1.sources.r1.fileHeader = true #channel a1.channels.c1.type =memory a1.channels.c1.capacity = 20000 a1.channels.c1.transactionCapacity=5000 #sinks a1.sinks.k1.channel = c1 a1.sinks.k1.type = org.apache.spark.streaming.flume.sink.SparkSink a1.sinks.k1.hostname=hdp-node-01 a1.sinks.k1.port = 8888 a1.sinks.k1.batchSize= 2000 启动flume： flume-ng agent -n a1 -c /opt/bigdata/flume/conf -f /opt/bigdata/flume/conf/flume-poll.conf -Dflume.root.logger=INFO,console &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务器上的 /root/data目录下准备数据文件data.txt 5. 启动 spark-streaming 应用程序，去 flume 所在机器拉取数据 6. 代码实现 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要添加pom依赖 &lt;properties&gt; &lt;scala.version&gt;2.11.8&lt;/scala.version&gt; &lt;hadoop.version&gt;2.7.4&lt;/hadoop.version&gt; &lt;spark.version&gt;2.0.2&lt;/spark.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt; &lt;version&gt;${spark.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入spark-streaming-flume的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-flume_2.10&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 具体代码如下： import java.net.InetSocketAddress import org.apache.spark.storage.StorageLevel import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.flume.{FlumeUtils, SparkFlumeEvent} import org.apache.spark.{SparkConf, SparkContext} import org.apache.spark.streaming.{Seconds, StreamingContext} object FlumeDir { def main(args: Array[String]): Unit = { val conf: SparkConf = new SparkConf().setAppName(&quot;FlumeDir&quot;).setMaster(&quot;local[2]&quot;) val sc = new SparkContext(conf) sc.setLogLevel(&quot;WARN&quot;) val scc = new StreamingContext(sc,Seconds(5)) scc.checkpoint(&quot;./spark_flume_dir&quot;) //设置flume地址 val addresses: Seq[InetSocketAddress] = Seq (new InetSocketAddress(&quot;192.168.44.127&quot;,8888)) val flumeds: ReceiverInputDStream[SparkFlumeEvent] = FlumeUtils.createPollingStream(scc,addresses,StorageLevel.MEMORY_AND_DISK) val lineds: DStream[String] = flumeds.map(x=&gt;new String(x.event.getBody.array())) lineds.flatMap(_.split(&quot; &quot;)).map((_,1)).reduceByKey(_+_).print() scc.start() scc.awaitTermination() } } Push方式 （1）编写flume-push.conf配置文件 #push mode a1.sources = r1 a1.sinks = k1 a1.channels = c1 #source a1.sources.r1.channels = c1 a1.sources.r1.type = spooldir a1.sources.r1.spoolDir = /root/data a1.sources.r1.fileHeader = true #channel a1.channels.c1.type =memory a1.channels.c1.capacity = 20000 a1.channels.c1.transactionCapacity=5000 #sinks a1.sinks.k1.channel = c1 a1.sinks.k1.type = avro a1.sinks.k1.hostname=172.16.43.63 a1.sinks.k1.port = 8888 a1.sinks.k1.batchSize= 2000 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意配置文件中指明的hostname和port是spark应用程序所在服务器的ip地址和端口 代码实现如下： package cn.test.spark import java.net.InetSocketAddress import org.apache.spark.storage.StorageLevel import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.flume.{FlumeUtils, SparkFlumeEvent} import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * sparkStreaming整合flume 推模式Push */ object SparkStreaming_Flume_Push { //newValues 表示当前批次汇总成的(word,1)中相同单词的所有的1 //runningCount 历史的所有相同key的value总和 def updateFunction(newValues: Seq[Int], runningCount: Option[Int]): Option[Int] = { val newCount =runningCount.getOrElse(0)+newValues.sum Some(newCount) } def main(args: Array[String]): Unit = { //配置sparkConf参数 val sparkConf: SparkConf = new SparkConf().setAppName(&quot;SparkStreaming_Flume_Push&quot;).setMaster(&quot;local[2]&quot;) //构建sparkContext对象 val sc: SparkContext = new SparkContext(sparkConf) //构建StreamingContext对象，每个批处理的时间间隔 val scc: StreamingContext = new StreamingContext(sc, Seconds(5)) //设置日志输出级别 sc.setLogLevel(&quot;WARN&quot;) //设置检查点目录 scc.checkpoint(&quot;./&quot;) //flume推数据过来 // 当前应用程序部署的服务器ip地址，跟flume配置文件保持一致 val flumeStream: ReceiverInputDStream[SparkFlumeEvent] = FlumeUtils.createStream(scc,&quot;172.16.43.63&quot;,8888,StorageLevel.MEMORY_AND_DISK) //获取flume中数据，数据存在event的body中，转化为String val lineStream: DStream[String] = flumeStream.map(x=&gt;new String(x.event.getBody.array())) //实现单词汇总 val result: DStream[(String, Int)] = lineStream.flatMap(_.split(&quot; &quot;)).map((_,1)).updateStateByKey(updateFunction) result.print() scc.start() scc.awaitTermination() } } } 启动执行 先执行spark代码 然后在执行flume配置文件 观察 IDEA 控制台输出 6. Spark Streaming整合kafka实战 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kafka作为一个实时的分布式消息队列，实时的生产和消费消息，这里我们可以利用SparkStreaming实时计算框架实时地读取kafka中的数据然后进行计算。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在spark1.3版本后，kafkaUtils里面提供了两个创建dstream的方法，一种为KafkaUtils.createDstream，另一种为KafkaUtils.createDirectStream。 KafkaUtils.createDstream方式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造函数为KafkaUtils.createDstream(ssc, [zk], [consumer group id], [per-topic,partitions] ) 使用了receivers来接收数据，利用的是Kafka高层次的消费者api，对于所有的receivers接收到的数据将会保存在Spark executors中，然后通过Spark Streaming启动job来处理这些数据，默认会丢失，可启用WAL日志，它同步将接受到数据保存到分布式文件系统上比如HDFS。 所以数据在出错的情况下可以恢复出来 。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190813213050229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个receiver来对kafka进行定时拉取数据，ssc的rdd分区和kafka的topic分区不是一个概念，故如果增加特定主消费的线程数仅仅是增加一个receiver中消费topic的线程数，并不增加spark的并行处理数据数量 。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于不同的group和topic可以使用多个receivers创建不同的DStream 。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果启用了WAL (spark.streaming.receiver.writeAheadLog.enable=true) 同时需要设置存储级别(默认StorageLevel.MEMORY_AND_DISK_SER_2)， 即KafkaUtils.createStream(….,StorageLevel.MEMORY_AND_DISK_SER) 。 KafkaUtils.createDstream实战 添加 kafka 的 pom 依赖 &lt;properties&gt; &lt;scala.version&gt;2.11.8&lt;/scala.version&gt; &lt;hadoop.version&gt;2.7.4&lt;/hadoop.version&gt; &lt;spark.version&gt;2.0.2&lt;/spark.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-kafka-0-8_2.11&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt; &lt;version&gt;${spark.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-hive_2.11&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 启动 zookeeper 集群 zkServer.sh start 启动 kafka 集群 kafka-server-start.sh /export/servers/kafka/config/server.properties 创建 topic kafka-topics.sh --create --zookeeper hdp-node-01:2181 --replication-factor 1 --partitions 3 --topic kafka_spark 向 topic 中生产数据 通过 shell 命令向 topic 发送消息 kafka-console-producer.sh --broker-list hdp-node-01:9092 --topic kafka_spark 编写 Spark Streaming import org.apache.spark.streaming.dstream.DStream import org.apache.spark.streaming.kafka.KafkaUtils import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} import scala.collection.immutable //todo:利用sparkStreaming接受kafka中的数据实现单词计数----采用receivers object SparkStreamingKafka_Receiver_checkpoint { def updateFunc(a:Seq[Int], b:Option[Int]) :Option[Int] ={ Some(a.sum+b.getOrElse(0)) } def main(args: Array[String]): Unit = { val checkpointPath = &quot;./kafka-receiver&quot; val ssc = StreamingContext.getOrCreate(checkpointPath, () =&gt; { createFunc(checkpointPath) }) ssc.start() ssc.awaitTermination() } def createFunc(checkpointPath:String): StreamingContext = { //todo:1、创建sparkConf val sparkConf: SparkConf = new SparkConf() .setAppName(&quot;SparkStreamingKafka_Receiver_checkpoint&quot;) .setMaster(&quot;local[4]&quot;) //todo:开启wal预写日志 .set(&quot;spark.streaming.receiver.writeAheadLog.enable&quot;,&quot;true&quot;) //todo:2、创建sparkContext val sc = new SparkContext(sparkConf) sc.setLogLevel(&quot;WARN&quot;) //todo:3、创建StreamingContext val ssc = new StreamingContext(sc,Seconds(5)) ssc.checkpoint(checkpointPath) //todo:4、指定zkServer val zkServer=&quot;node1:2181,node2:2181,node3:2181&quot; //todo:5、指定groupId val groupId=&quot;spark-kafka-receiver01&quot; //todo:6、指定topics 这个可以利用一个消费者组来消费多个topic, //(topic_name -&gt; numPartitions) 指定topic消费的线程数 val topics=Map(&quot;kafka_spark&quot;-&gt;1) //todo:7、并行运行更多的接收器读取kafak topic中的数据，这里设置3个 val resultDStream: immutable.IndexedSeq[DStream[String]] = (1 to 3).map(x =&gt; { //todo:8、通过使用KafkaUtils的createStream接受kafka topic中的数据，生成DStream val kafkaDataDStream: DStream[String] = KafkaUtils.createStream(ssc, zkServer, groupId, topics).map(x =&gt; x._2) kafkaDataDStream } ) //todo:利用StreamContext将所有的DStream组合在一起 val kafkaDStream: DStream[String] = ssc.union(resultDStream) //todo:8、获取kafka中topic的内容 //todo:9、切分每一行。每个单词记为1 val wordAndOne: DStream[(String, Int)] = kafkaDStream.flatMap(_.split(&quot; &quot;)).map((_,1)) //todo:10、相同单词出现的次数累加 val result: DStream[(String, Int)] = wordAndOne.updateStateByKey(updateFunc) //todo:打印 result.print() ssc } } 运行代码，查看控制台数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这种方式实现，刚开始的时候系统正常运行，没有发现问题，但是如果系统异常重新启动sparkstreaming程序后，发现程序会重复处理已经处理过的数据，这种基于receiver的方式，是使用Kafka的高阶API来在ZooKeeper中保存消费过的offset的。这是消费Kafka数据的传统方式。这种方式配合着WAL机制可以保证数据零丢失的高可靠性，但是却无法保证数据被处理一次且仅一次，可能会处理两次。因为Spark和ZooKeeper之间可能是不同步的。官方现在也已经不推荐这种整合方式，官网相关地址下面我们使用官网推荐的第二种方式kafkaUtils的createDirectStream()方式。 KafkaUtils.createDirectStream方式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同于Receiver接收数据，这种方式定期地从kafka的topic下对应的partition中查询最新的偏移量，再根据偏移量范围在每个batch里面处理数据，Spark通过调用kafka简单的消费者Api读取一定范围的数据。 相比基于Receiver方式有几个优点： 简化并行: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不需要创建多个kafka输入流，然后union它们，sparkStreaming将会创建和kafka分区一种的rdd的分区数，而且会从kafka中并行读取数据，spark中RDD的分区数和kafka中的分区数据是一一对应的关系。 高效: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种实现数据的零丢失是将数据预先保存在WAL中，会复制一遍数据，会导致数据被拷贝两次，第一次是被kafka复制，另一次是写到WAL中。而没有receiver的这种方式消除了这个问题。 恰好一次语义(Exactly-once-semantics): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Receiver读取kafka数据是通过kafka高层次api把偏移量写入zookeeper中，虽然这种方法可以通过数据保存在WAL中保证数据不丢失，但是可能会因为sparkStreaming和ZK中保存的偏移量不一致而导致数据被消费了多次。EOS通过实现kafka低层次api，偏移量仅仅被ssc保存在checkpoint中，消除了zk和ssc偏移量不一致的问题。缺点是无法使用基于zookeeper的kafka监控工具 依赖到上面的案例即可,其余步骤也相同,接下来代码实现： import kafka.serializer.StringDecoder import org.apache.spark.streaming.dstream.InputDStream import org.apache.spark.streaming.kafka.KafkaUtils import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} object KafkaTest2 { def updateFunction(olds:Seq[Int],news:Option[Int]) : Option[Int] = { Some(olds.sum + news.getOrElse(0)) } def main(args: Array[String]): Unit = { val conf: SparkConf = new SparkConf().setAppName(&quot;testkafka2&quot;).setMaster(&quot;local[2]&quot;) val sc = new SparkContext(conf) sc.setLogLevel(&quot;ERROR&quot;) val scc = new StreamingContext(sc,Seconds(5)) scc.checkpoint(&quot;./spark_kafka&quot;) val brokers = &quot;node2:9092,node3:9092,node4:9092&quot; val topicSet = &quot;mdj&quot;.split(&quot;,&quot;).toSet val kafkaParam = Map(&quot;metadata.broker.list&quot;-&gt;brokers) val kafkads: InputDStream[(String, String)] = KafkaUtils.createDirectStream[String,String,StringDecoder,StringDecoder](scc,kafkaParam,topicSet) kafkads.map(_._2).map(_.split(&quot; &quot;)).map((_,1)).updateStateByKey(updateFunction).print() scc.start() scc.awaitTermination() } } 查看效果 向 topic 中添加数据 查看控制台的输出：","@type":"BlogPosting","url":"https://uzzz.org/2019/08/13/794489.html","headline":"Spark-Streaming","dateModified":"2019-08-13T00:00:00+08:00","datePublished":"2019-08-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/08/13/794489.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Spark-Streaming</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> 
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path> 
  </svg> 
  <p></p>
  <div class="toc">
   <h3>Spark Streaming流式处理</h3>
   <ul>
    <li><a href="#Spark_Streaming__1" rel="nofollow" data-token="c709e1b1f7ec875f78ca3801ac8b44a6">Spark Streaming 介绍</a></li>
    <ul>
     <li><a href="#Spark_Streaming__2" rel="nofollow" data-token="57e97465684f9a6bdb0a6eb653bb982f">Spark Streaming 概述</a></li>
     <ul>
      <li><a href="#_Spark_Streaming_3" rel="nofollow" data-token="8fa22143621cbe5253893a7a09b7c4e7">什么是 Spark Streaming</a></li>
      <li><a href="#_Spark_Streaming_8" rel="nofollow" data-token="7af66aafbedb4d646a8d27ebe6555e39">为什么要学习 Spark Streaming</a></li>
      <li><a href="#SparkStreaming__Storm__16" rel="nofollow" data-token="8790a603fe4d318acb16e1cfb3152cd7">SparkStreaming 与 Storm 对比</a></li>
     </ul>
    </ul>
    <li><a href="#Spark_Streaming__23" rel="nofollow" data-token="6c6a9c1f1e1304c2d5e01101b2887e4a">Spark Streaming 原理</a></li>
    <ul>
     <li><a href="#_24" rel="nofollow" data-token="dc27f3b827c98dfb5e75e982963c3c6c">原理</a></li>
     <li><a href="#Spark_Streaming__27" rel="nofollow" data-token="984362bddf11523f452beb0418bf8f15">Spark Streaming 计算流程</a></li>
     <li><a href="#Spark_Streaming__33" rel="nofollow" data-token="24207f1e8057b76cd0520561e1fdd55a">Spark Streaming 容错性</a></li>
     <li><a href="#Spark_Streaming__39" rel="nofollow" data-token="0f38699ac246b9c0b79bb3207cd92432">Spark Streaming 实时性</a></li>
    </ul>
    <li><a href="#DStream_42" rel="nofollow" data-token="9effb0dd0a88100b07f0f89e488986d9">DStream</a></li>
    <ul>
     <li><a href="#_DStream_43" rel="nofollow" data-token="2cc21f21665b7af893a75359845e2cba">什么是 DStream</a></li>
    </ul>
    <li><a href="#DStream__55" rel="nofollow" data-token="60b7038f5a65ad8397c118830ce57797">DStream 相关操作</a></li>
    <ul>
     <li><a href="#Transformations_on_DStreams_58" rel="nofollow" data-token="5a7efe64342990c886b47042cbf7cce6">Transformations on DStreams</a></li>
     <li><a href="#Output_Operations_on_DStreams_95" rel="nofollow" data-token="963349530cf62007858905f9f2be52c5">Output Operations on DStreams</a></li>
    </ul>
    <li><a href="#DStream__107" rel="nofollow" data-token="69feea32955b0eca7c8f8394fd1b5a1f">DStream 操作实战</a></li>
    <ul>
     <li><a href="#SparkStreaming__socket__WordCound_108" rel="nofollow" data-token="8bf6d8e8ab19856208928acbcff1ccb1">SparkStreaming 接收 socket 数据，实现单词技术 WordCound</a></li>
     <ul>
      <li><a href="#_109" rel="nofollow" data-token="a195bb364d149bf98541d56dd332d779">架构图</a></li>
      <li><a href="#_111" rel="nofollow" data-token="47e815d27a27bac77fb2ede251844318">实现流程</a></li>
      <li><a href="#_158" rel="nofollow" data-token="ca133656c7719be56d690891e3e35232">执行查看效果</a></li>
     </ul>
     <li><a href="#SparkStreaming__socket__168" rel="nofollow" data-token="9d3bfbab675b439d168559bff481ec59">SparkStreaming 接受 socket 数据，实现单词计数累加</a></li>
     <ul>
      <li><a href="#_171" rel="nofollow" data-token="cefdbeea07e653885bc6a818698f734d">架构图</a></li>
      <li><a href="#_173" rel="nofollow" data-token="023e993bde626488f5fd2fdb1f11e973">实现流程</a></li>
      <li><a href="#_230" rel="nofollow" data-token="b2de37fd6226cc8237474b22908f42c7">执行查看效果</a></li>
     </ul>
     <li><a href="#SparkStreamingreduceByKeyAndWindow_240" rel="nofollow" data-token="bb3350a028deda81f51a1d7c830fa24c">SparkStreaming开窗函数reduceByKeyAndWindow，实现单词计数</a></li>
     <ul>
      <li><a href="#_241" rel="nofollow" data-token="65c6ad03a7e923f6e2eb209b5b5f3df9">架构图</a></li>
      <li><a href="#_243" rel="nofollow" data-token="3e2f6a0bb78fc29b3396cab2dc7b9cda">实现流程</a></li>
      <li><a href="#_285" rel="nofollow" data-token="47497a452cd694fd8e898a9475b6f087">执行查看效果</a></li>
     </ul>
     <li><a href="#SparkStreaming_296" rel="nofollow" data-token="30fc0f3bf4d763d0f2bab71c00a9d60e">SparkStreaming开窗函数统计一定时间内的热门词汇</a></li>
     <ul>
      <li><a href="#_297" rel="nofollow" data-token="e6349f68ee63373152c998db9de2299d">架构图</a></li>
      <li><a href="#_299" rel="nofollow" data-token="9fd6e88b7b40a833d4ae3eeecc3c8eca">实现流程</a></li>
      <li><a href="#_357" rel="nofollow" data-token="df83393dea829471eaf157236468f2e0">执行查看效果</a></li>
     </ul>
    </ul>
    <li><a href="#Spark_Streamingflume_367" rel="nofollow" data-token="f76b95d2cd11cfe684475f267fe8c829">Spark Streaming整合flume实战</a></li>
    <ul>
     <li><a href="#Poll__372" rel="nofollow" data-token="e42d0e18b003a9554f7b7c1f7ae8ff34">Poll 方式</a></li>
     <li><a href="#Push_467" rel="nofollow" data-token="452e73462879938c008147d620938158">Push方式</a></li>
    </ul>
    <li><a href="#6	Spark_Streamingkafka_554" rel="nofollow" data-token="3ac00fec119066792d3d23a789e47603">6. Spark Streaming整合kafka实战</a></li>
    <ul>
     <li><a href="#KafkaUtilscreateDstream_558" rel="nofollow" data-token="3775ae0327c92ef1a3df3312ec7407fc">KafkaUtils.createDstream方式</a></li>
     <ul>
      <li><a href="#KafkaUtilscreateDstream_569" rel="nofollow" data-token="1e63e8b844ac0902fbe2fbe57197fde3">KafkaUtils.createDstream实战</a></li>
     </ul>
     <li><a href="#KafkaUtilscreateDirectStream_697" rel="nofollow" data-token="5628be3643b9b23f66d2e111292009e5">KafkaUtils.createDirectStream方式</a></li>
    </ul>
   </ul>
  </div>
  <p></p> 
  <h1><a id="Spark_Streaming__1"></a>Spark Streaming 介绍</h1> 
  <h2><a id="Spark_Streaming__2"></a>Spark Streaming 概述</h2> 
  <h3><a id="_Spark_Streaming_3"></a>什么是 Spark Streaming</h3> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722192236348.png" alt="在这里插入图片描述"></p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 类似于 Apache Storm，用于流式数据的处理。根据官方文档介绍，Spark Streaming 有高吞吐量和容错能力强等特点。Spark Streaming 支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ 和简单的 TCP 套接字等等。数据输入后可以用 Spark 的高度抽象操作如：map、reduce、join、window等进行运算。而结果也能保存在很多地方，如 HDFS ， 数据库等。另外 Spark Streaming 也能和 MLlib（机器学习）以及 Graphx 完美融合。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722192822132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <h3><a id="_Spark_Streaming_8"></a>为什么要学习 Spark Streaming</h3> 
  <ol> 
   <li><strong>易用</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722192919663.png" alt="在这里插入图片描述"></li> 
   <li><strong>容错</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722192926848.png" alt="在这里插入图片描述"></li> 
   <li><strong>易整合到 Spark 体系</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722193004560.png" alt="在这里插入图片描述"></li> 
  </ol> 
  <h3><a id="SparkStreaming__Storm__16"></a>SparkStreaming 与 Storm 对比</h3> 
  <table> 
   <thead> 
    <tr> 
     <th>SparkStreaming</th> 
     <th>Storm</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722193059240.png" alt="在这里插入图片描述"></td> 
     <td><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722193105285.png" alt="在这里插入图片描述"></td> 
    </tr> 
    <tr> 
     <td>开发语言：<mark>Scala</mark></td> 
     <td>开发语言：<mark>Clojure</mark></td> 
    </tr> 
    <tr> 
     <td>编程模型：<mark>DStream</mark></td> 
     <td>编程模型：<mark>Spoot/Bolt</mark></td> 
    </tr> 
   </tbody> 
  </table>
  <h1><a id="Spark_Streaming__23"></a>Spark Streaming 原理</h1> 
  <h2><a id="_24"></a>原理</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 是基于 Spark 的流式批处理引擎，其基本原理是把==输入的数据以某一时间间隔批量的处理==，当批处理间隔缩短到==秒级==时，便可以用于处理实时数据流。</p> 
  <h2><a id="Spark_Streaming__27"></a>Spark Streaming 计算流程</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 是将流式计算分解成一系列短小的批处理作业。这里的批处理引擎是 Spark Core，也就是把 Spark Streaming 的输入数据按照 batch size （如1秒）分成一段一段的数据（Discretized Stream），每一段数据都转换成 Spark 中的 RDD （Resilient Distributed Dataset），然后将 Spark Streaming 中对 DStream 的 Transformtion 操作变为针对 Spark 中对 RDD 的。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transformation 操作，将 RDD 经过操作编程中间结果保存在内存中，整个流式计算根据业务的需求可以对中间的结果进行缓存或者存储到外部设备。下图为 Spark Streaming 的整个流程： </p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722194244347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <h2><a id="Spark_Streaming__33"></a>Spark Streaming 容错性</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于流失计算来说，容错性至关重要。首先我们要明确一下 Spark 中 RDD 的容错机制。每一个 RDD 都是不可变的分布式可重算的数据集，其记录着确定性操作继承关系（lineage），所以只要输入数据是可容错的，那么任意一个 RDD 的分区（Partition）出错或不可用，都是可以利用原始输入数据通过转换操作而重新算出的。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 Spark Streaming 来说，其 RDD 的传承关系如下图所示：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722195829526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;途中的每一个椭圆表示一个 RDD ，椭圆形中的每个圆形代表一个 RDD 中的一个 Partition ，图中的每一列的多个 RDD 表示一个 DStream（图中有三个 DStream），而每一行最后一个 RDD 则表示每一个 Batch Size 所产生的中间结果 RDD。我们可以看到图中的每一个 RDD 都是通过 lineage 相连接的，由于 Spark Streaming 输入数据可以来自于磁盘，例如 HDFS（多分拷贝）或是来自于网络的数据流（Spark Streaming 会将网络输入数据的每一个数据流拷贝两份到其他机器）都能保证容错性，所以 RDD 中任意的 Partition 出错，都可以并行地在其他机器上将缺失的 Partition 计算出来。这个容错恢复方式比连续计算模型（如 Storm）的效率更高</p> 
  <h2><a id="Spark_Streaming__39"></a>Spark Streaming 实时性</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于实时性的讨论，会牵涉到流式处理框架的应用场景。Spark Streaming 将流式计算分解成多个 Spark Job，对于每一段数据的处理都会经过 Spark DAG 图分解以及 Spark 的任务集的调度过程。对于目前版本的 Spark Streaming 而言，其最小的 Batch Size 的选取在 0.5 ~ 2秒之间（Storm 目前最小的延迟是 100ms左右），所以 Spark Streaming 能满足除对实时性要求非常高（如高频实时交易）之外的所有流式准实时计算场景。</p> 
  <h1><a id="DStream_42"></a>DStream</h1> 
  <h2><a id="_DStream_43"></a>什么是 DStream</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretized Stream 是 Spark Streaming 的基础抽象，代表连续性的数据流和经过各种 Spark 算子操作后的结果数据流。在内部是线上。DStream 是一系列连续的 RDD 来表示。每个 RDD 含有一段时间间隔内的数据，如下图</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722201017435.png" alt="在这里插入图片描述"></p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对数据的操作也是按照 RDD 为单位来进行的</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722201035905.png" alt="在这里插入图片描述"></p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spark Streaming 使用数据源产生的数据流创建 DStream，也可以在已有的 DStream 上使用一些操作来创建新的 DStream。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的工作流程像下面的图所示一样，接受到实时数据后，给数据分批次，然后传给 Spark Engine 处理最后生成该批次的结果。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722201457514.png" alt="在这里插入图片描述"></p> 
  <h1><a id="DStream__55"></a>DStream 相关操作</h1> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DStream 上的操作与 RDD 类似，分为 Transformations （转换）和 Output Operations（输出）两种，此外转换操作中还有一些比较特殊的操作，如：updateStateByKey()、transform()以及各种 Window 相关的操作。</p> 
  <h2><a id="Transformations_on_DStreams_58"></a>Transformations on DStreams</h2> 
  <table> 
   <thead> 
    <tr> 
     <th>Transformations</th> 
     <th>Meaning</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>map(func)</td> 
     <td>对DStream中的各个元素进行func函数操作，然后返回一个新的DStream</td> 
    </tr> 
    <tr> 
     <td>flatMap(func)</td> 
     <td>与map方法类似，只不过各个输入项可以被输出为零个或多个输出项</td> 
    </tr> 
    <tr> 
     <td>filter(func)</td> 
     <td>过滤出所有函数func返回值为true的DStream元素并返回一个新的DStream</td> 
    </tr> 
    <tr> 
     <td>repartition(numPartitions)</td> 
     <td>增加或减少DStream中的分区数，从而改变DStream的并行度</td> 
    </tr> 
    <tr> 
     <td>repartition(numPartitions)</td> 
     <td>增加或减少DStream中的分区数，从而改变DStream的并行度</td> 
    </tr> 
    <tr> 
     <td>union(otherStream)</td> 
     <td>将源DStream和输入参数为otherDStream的元素合并，并返回一个新的DStream.</td> 
    </tr> 
    <tr> 
     <td>count()</td> 
     <td>通过对DStream中的各个RDD中的元素进行计数，然后返回只有一个元素的RDD构成的DStream</td> 
    </tr> 
    <tr> 
     <td>reduce(func)</td> 
     <td>对源DStream中的各个RDD中的元素利用func进行聚合操作，然后返回只有一个元素的RDD构成的新的DStream.</td> 
    </tr> 
    <tr> 
     <td>countByValue()</td> 
     <td>对于元素类型为K的DStream，返回一个元素为（K,Long）键值对形式的新的DStream，Long对应的值为源DStream中各个RDD的key出现的次数</td> 
    </tr> 
    <tr> 
     <td>reduceByKey(func, [numTasks])</td> 
     <td>利用func函数对源DStream中的key进行聚</td> 
    </tr> 
    <tr> 
     <td>合操作，然后返回新的（K，V）对构成的DStream</td> 
     <td></td> 
    </tr> 
    <tr> 
     <td>join(otherStream, [numTasks])</td> 
     <td>输入为（K,V)、（K,W）类型的DStream，返回一个新的（K，（V，W）类型的DStream</td> 
    </tr> 
    <tr> 
     <td>cogroup(otherStream, [numTasks])</td> 
     <td>输入为（K,V)、（K,W）类型的DStream，返回一个新的 (K, Seq[V], Seq[W]) 元组类型的DStream</td> 
    </tr> 
    <tr> 
     <td>transform(func)</td> 
     <td>通过RDD-to-RDD函数作用于DStream中的各个RDD，可以是任意的RDD操作，从而返回一个新的RDD</td> 
    </tr> 
    <tr> 
     <td>updateStateByKey(func)</td> 
     <td>根据于key的前置状态和key的新值，对key进行更新，返回一个新状态的DStream</td> 
    </tr> 
   </tbody> 
  </table>
  <p><mark>特殊的Transformations</mark></p> 
  <ul> 
   <li> <p>UpdateStateByKey Operation<br> <strong>UpdateStateByKey用于记录历史记录，保存上次的状态</strong></p> </li> 
   <li> <p>Window Operations(开窗函数,滑动窗口转换操作:)</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 滑动窗口转换操作的计算过程如下图所示，我们可以事先设定一个滑动窗口的长度（也就是窗口的持续时间）， 并且设定滑动窗口的时间间隔（每隔多长时间执行一次计算），然后就可以让窗口按照指定时间间隔在源 DStream 上滑动，每次窗口停放的位置上，都会有一部分 DStream 被框入窗口内，形成一个小段 DStream ，这是，就可以启动对这个小段 DStream 的计算。</p> <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722203643738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
    <ol> 
     <li> <p>红色的矩形就是一个窗口，窗口框住的是一段时间内的数据流。</p> </li> 
     <li> <p>这里面每一个time都是时间单元，在官方的例子中，每隔window size是3 time unit, 而且每隔2个单位时间，窗口会slide一次。</p> </li> 
     <li> <p>所以基于窗口的操作，需要指定2个参数：<br> <strong><b>•<b></b></b></strong> window length - The duration of the window (3 in the figure)</p> <p><strong><b>•<b></b></b></strong> slide interval - The interval at which the window-based operation is performed (2 in the figure).<br> 窗口大小：一段时间内数据的容器。<br> 滑动间隔：每隔多久计算一次。</p> </li> 
    </ol> </li> 
  </ul> 
  <h2><a id="Output_Operations_on_DStreams_95"></a>Output Operations on DStreams</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output Operations 可以将 DStream 的数据输出到外部的数据库或文件系统，当某个 Output Operations 被调用时（与 RDD 的 Action 相同），spark streaming 程序才会真正的计算过程。</p> 
  <table> 
   <thead> 
    <tr> 
     <th>Output Operation</th> 
     <th>Meaning</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>print()</td> 
     <td>打印到控制台</td> 
    </tr> 
    <tr> 
     <td>saveAsTextFiles(prefix, [suffix])</td> 
     <td>保存流的内容为文本文件，文件名为"prefix-TIME_IN_MS[.suffix]".</td> 
    </tr> 
    <tr> 
     <td>saveAsObjectFiles(prefix, [suffix])</td> 
     <td>保存流的内容为SequenceFile，文件名为 “prefix-TIME_IN_MS[.suffix]”.</td> 
    </tr> 
    <tr> 
     <td>saveAsHadoopFiles(prefix, [suffix])</td> 
     <td>保存流的内容为hadoop文件，文件名为"prefix-TIME_IN_MS[.suffix]".</td> 
    </tr> 
    <tr> 
     <td>foreachRDD(func)</td> 
     <td>对Dstream里面的每个RDD执行func</td> 
    </tr> 
   </tbody> 
  </table>
  <h1><a id="DStream__107"></a>DStream 操作实战</h1> 
  <h2><a id="SparkStreaming__socket__WordCound_108"></a>SparkStreaming 接收 socket 数据，实现单词技术 WordCound</h2> 
  <h3><a id="_109"></a>架构图</h3> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190722210501185.png" alt="在这里插入图片描述"></p> 
  <h3><a id="_111"></a>实现流程</h3> 
  <ol> 
   <li>安装并启动生产者</li> 
  </ol> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在 linux 服务器上用 Yum 安装 nc 工具，命令为 netcat 命令的简称，都是用来设置路由器。我们可以利用它像某个端口发送数据。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yun install -y nc</p> 
  <ol start="2"> 
   <li>通过 netcat 工具像指定的端口发送数据</li> 
  </ol> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999</p> 
  <ol start="3"> 
   <li>编写 Spark Streaming 程序<pre><code>import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
import org.apache.spark.streaming.{Seconds, StreamingContext}
import org.apache.spark.{SparkConf, SparkContext}

/**
  * sparkStreming流式处理接受socket数据，实现单词统计
  */
object  SparkStreamingTCP {

  def main(args: Array[String]): Unit = {
    //配置sparkConf参数
    val sparkConf: SparkConf = new SparkConf().setAppName("SparkStreamingTCP").setMaster("local[2]")
    //构建sparkContext对象
    val sc: SparkContext = new SparkContext(sparkConf)
    //设置日志输出级别
    sc.setLogLevel("WARN")
    //构建StreamingContext对象，每个批处理的时间间隔
    val scc: StreamingContext = new StreamingContext(sc,Seconds(5))
    //注册一个监听的IP地址和端口  用来收集数据
    val lines: ReceiverInputDStream[String] = scc.socketTextStream("192.168.200.160",9999)
    //切分每一行记录
    val words: DStream[String] = lines.flatMap(_.split(" "))
    //每个单词记为1
    val wordAndOne: DStream[(String, Int)] = words.map((_,1))
    //分组聚合
    val result: DStream[(String, Int)] = wordAndOne.reduceByKey(_+_)
    //打印数据
    result.print()
    scc.start()
    scc.awaitTermination()
  }
}
</code></pre> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于使用的是本地模式 local[2] 所以可以在本地运行该程序。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：要指定并行度，如在本地运行设置 setMaster("local[2]")，相当于启动两个线程，一个给 received，一个给 computer。如果是在集群中运行，必须要求集群中可的 core 数大于1。</p> </li> 
  </ol> 
  <h3><a id="_158"></a>执行查看效果</h3> 
  <ol> 
   <li>先执行 nc -lk 9999<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723142436736.png" alt="在这里插入图片描述"></li> 
   <li>在执行代码<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723142506928.png" alt="在这里插入图片描述"></li> 
   <li>不断的在 1. 中输入不同的单词，观察 IDEA 控制台的输出<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723142545425.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723142549171.png" alt="在这里插入图片描述"></li> 
  </ol> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象：SparkStreaming 每隔 5s 计算一次当前 5s 内的数据，然后将每个批次的数据输出。</p> 
  <h2><a id="SparkStreaming__socket__168"></a>SparkStreaming 接受 socket 数据，实现单词计数累加</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在上面的案例中存在这样一个问题：每个批次的单词都被正确的统计出来，但是结果不能累加！如果需要累加需要使用 updateStateByKey（func）来更新状态。</p> 
  <h3><a id="_171"></a>架构图</h3> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723143352480.png" alt="在这里插入图片描述"></p> 
  <h3><a id="_173"></a>实现流程</h3> 
  <ol> 
   <li>安装并启动生成者</li> 
  </ol> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在linux服务器上用YUM安装nc工具，nc命令是netcat命令的简称,都是用来设置路由器。我们可以利用它向某个端口发送数据。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install -y nc</p> 
  <ol start="2"> 
   <li> <p>启动一个服务端并监听9999端口</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 </p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向指定的端口发送数据 </p> </li> 
   <li> <p>编写 SparkStreaming 程序</p> <pre><code>	import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
import org.apache.spark.streaming.{Seconds, StreamingContext}
import org.apache.spark.{SparkConf, SparkContext}

/**
  * sparkStreaming流式处理，接受socket数据，实现单词统计并且每个批次数据结果累加
  */
object SparkStreamingTCPTotal {

  //newValues 表示当前批次汇总成的(word,1)中相同单词的所有的1
  //runningCount 历史的所有相同key的value总和
  def updateFunction(newValues: Seq[Int], runningCount: Option[Int]): Option[Int] = {
    val newCount =runningCount.getOrElse(0)+newValues.sum
    Some(newCount)
  }


  def main(args: Array[String]): Unit = {

    //配置sparkConf参数
    val sparkConf: SparkConf = new SparkConf().setAppName("SparkStreamingTCPTotal").setMaster("local[2]")
    //构建sparkContext对象
    val sc: SparkContext = new SparkContext(sparkConf)

    sc.setLogLevel("WARN")
    //构建StreamingContext对象，每个批处理的时间间隔
    val scc: StreamingContext = new StreamingContext(sc, Seconds(5))

    scc.checkpoint("./")
    //注册一个监听的IP地址和端口  用来收集数据
    val lines: ReceiverInputDStream[String] = scc.socketTextStream("bw01", 9999)
    //切分每一行记录
    val words: DStream[String] = lines.flatMap(_.split(" "))
    //每个单词记为1
    val wordAndOne: DStream[(String, Int)] = words.map((_, 1))
    //累计统计单词出现的次数
    val result: DStream[(String, Int)] = wordAndOne.updateStateByKey(updateFunction)
    result.print()
    scc.start()
    scc.awaitTermination()
  }
}

</code></pre> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过函数 updateStateByKey 实现。根据于 key 的前置状态和 key 的新值，对 key 进行更新，返回一个新状态的 DStream。</p> </li> 
  </ol> 
  <h3><a id="_230"></a>执行查看效果</h3> 
  <ol> 
   <li>执行 nc -lk 9999<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019072314435983.png" alt="在这里插入图片描述"></li> 
   <li>然后执行以上代码<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723144419216.png" alt="在这里插入图片描述"></li> 
   <li>不断的在 1. 中输入不同的单词，观察 IDEA 控制台输出<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190723144509369.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019072314451319.png" alt="在这里插入图片描述"></li> 
  </ol> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象：sparkStreaming每隔5s计算一次当前5s内的数据，然后将每个批次的结果数据累加输出。</p> 
  <h2><a id="SparkStreamingreduceByKeyAndWindow_240"></a>SparkStreaming开窗函数reduceByKeyAndWindow，实现单词计数</h2> 
  <h3><a id="_241"></a>架构图</h3> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813204024405.png" alt="在这里插入图片描述"></p> 
  <h3><a id="_243"></a>实现流程</h3> 
  <ol> 
   <li>安装并启动生产者 <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在 linux 服务器上用 YUM 安装 nc 工具，nc 命令是 netcat 命令的简称，都是用来设置路由器。我们可以利用它向某个端口发送数据。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install -y nc</p> </li> 
   <li>启动一个服务器 并监听 9999 端口 <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999 ，向指定的端口发送数据。</p> </li> 
   <li>编写 Spark Streaming 程序</li> 
  </ol> 
  <pre><code>	import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
	import org.apache.spark.streaming.{Seconds, StreamingContext}
	import org.apache.spark.{SparkConf, SparkContext}
	
	/**
	  * sparkStreming开窗函数---统计一定时间内单词出现的次数
	  */
	object SparkStreamingTCPWindow {
	
	  def main(args: Array[String]): Unit = {
	    //配置sparkConf参数
	    val sparkConf: SparkConf = new SparkConf().setAppName("SparkStreamingTCPWindow").setMaster("local[2]")
	    //构建sparkContext对象
	    val sc: SparkContext = new SparkContext(sparkConf)
	    sc.setLogLevel("WARN")
	    //构建StreamingContext对象，每个批处理的时间间隔
	    val scc: StreamingContext = new StreamingContext(sc,Seconds(5))
	    //注册一个监听的IP地址和端口  用来收集数据
	    val lines: ReceiverInputDStream[String] = scc.socketTextStream("192.168.200.160",9999)
	    //切分每一行记录
	    val words: DStream[String] = lines.flatMap(_.split(" "))
	    //每个单词记为1
	    val wordAndOne: DStream[(String, Int)] = words.map((_,1))
	    //reduceByKeyAndWindow函数参数意义：
	    // windowDuration:表示window框住的时间长度，如本例5秒切分一次RDD，框10秒，就会保留最近2次切分的RDD
	    //slideDuration:  表示window滑动的时间长度，即每隔多久执行本计算
	    val result: DStream[(String, Int)] = wordAndOne.reduceByKeyAndWindow((a:Int,b:Int)=&gt;a+b,Seconds(10),Seconds(5))
	    result.print()
	    scc.start()
	    scc.awaitTermination()
	  }
	}
</code></pre> 
  <h3><a id="_285"></a>执行查看效果</h3> 
  <ol> 
   <li>先执行 nc -lk 9999<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813205207805.png" alt="在这里插入图片描述"></li> 
   <li>然后在执行以上代码<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813205220587.png" alt="在这里插入图片描述"></li> 
   <li>断的在（1）中输入不同的单词，观察IDEA控制台输出<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813205237117.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813205245409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813205303835.png" alt="在这里插入图片描述"></li> 
  </ol> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象： Spark Streaming 每个5s 计算一次当前在窗口大小为 10s 内的数据，然后将结果数据输出。</p> 
  <h2><a id="SparkStreaming_296"></a>SparkStreaming开窗函数统计一定时间内的热门词汇</h2> 
  <h3><a id="_297"></a>架构图</h3> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813205410571.png" alt="在这里插入图片描述"></p> 
  <h3><a id="_299"></a>实现流程</h3> 
  <ol> 
   <li> <p>安装并启动生产者</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在 linux 服务器上用 YUM 安装 nc 工具，nc 命令是 netcat 命令的简称，都是用来设置路由器。我们可以利用它向某个端口发送数据。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install -y nc</p> </li> 
   <li> <p>启动一个服务器并监听 9999 端口</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nc -lk 9999</p> </li> 
   <li> <p>编写 Spark Streaming 程序</p> </li> 
  </ol> 
  <pre><code>	package cn.test.spark
	
	import org.apache.spark.rdd.RDD
	import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
	import org.apache.spark.streaming.{Seconds, StreamingContext}
	import org.apache.spark.{SparkConf, SparkContext}
	
	/**
	  * sparkStreming开窗函数应用----统计一定时间内的热门词汇
	  */
	object SparkStreamingTCPWindowHotWords {
	
	  def main(args: Array[String]): Unit = {
	    //配置sparkConf参数
	    val sparkConf: SparkConf = new SparkConf().setAppName("SparkStreamingTCPWindowHotWords").setMaster("local[2]")
	    //构建sparkContext对象
	    val sc: SparkContext = new SparkContext(sparkConf)
	    sc.setLogLevel("WARN")
	    //构建StreamingContext对象，每个批处理的时间间隔
	    val scc: StreamingContext = new StreamingContext(sc,Seconds(5))
	    //注册一个监听的IP地址和端口  用来收集数据
	    val lines: ReceiverInputDStream[String] = scc.socketTextStream("192.168.200.160",9999)
	    //切分每一行记录
	    val words: DStream[String] = lines.flatMap(_.split(" "))
	    //每个单词记为1
	    val wordAndOne: DStream[(String, Int)] = words.map((_,1))
	    //reduceByKeyAndWindow函数参数意义：
	    // windowDuration:表示window框住的时间长度，如本例5秒切分一次RDD，框10秒，就会保留最近2次切分的RDD
	    //slideDuration:  表示window滑动的时间长度，即每隔多久执行本计算
	    val result: DStream[(String, Int)] = wordAndOne.reduceByKeyAndWindow((a:Int,b:Int)=&gt;a+b,Seconds(5),Seconds(5))
	    val data=result.transform(rdd=&gt;{
	      //降序处理后，取前3位
	      val dataRDD: RDD[(String, Int)] = rdd.sortBy(t=&gt;t._2,false)
	      val sortResult: Array[(String, Int)] = dataRDD.take(3)
	      println("--------------print top 3 begin--------------")
	      sortResult.foreach(println)
	      println("--------------print top 3 end--------------")
	      dataRDD
	    })
	    data.print()
	    scc.start()
	    scc.awaitTermination()
	  }
	}
</code></pre> 
  <h3><a id="_357"></a>执行查看效果</h3> 
  <ol> 
   <li>先执行 nc -lk 9999<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813205815157.png" alt="在这里插入图片描述"></li> 
   <li>在执行以上代码<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813205834450.png" alt="在这里插入图片描述"></li> 
   <li>不断的在 1. 中输入不同的单词，观察 IDEA 控制台输出<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019081320590845.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813205911859.png" alt="在这里插入图片描述"></li> 
  </ol> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现象：sparkStreaming每隔5s计算一次当前在窗口大小为10s内的数据，然后将单词出现次数最多的前3位进行输出打印。/p&gt; </p>
  <h1><a id="Spark_Streamingflume_367"></a>Spark Streaming整合flume实战</h1> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>flume作为日志实时采集的框架，可以与SparkStreaming实时处理框进行对接，flume实时产生数据，sparkStreaming做实时处理。</b></p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Spark Streaming 对接 <font color="blue">FlumeNG有两种方式</font>，一种是FlumeNG将消息<font color="red">Push</font>推给Spark Streaming，还有一种是Spark Streaming从flume 中 <font color="red">Poll </font>拉取数据。</b></p> 
  <h2><a id="Poll__372"></a>Poll 方式</h2> 
  <ol> 
   <li>安装flume1.6以上</li> 
   <li>下载依赖包<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spark-streaming-flume-sink_2.11-2.0.2.jar放入到flume的lib目录下。/p&gt;</p></li> 
   <li>写flume的agent，注意既然是拉取的方式，那么flume向自己所在的机器上产数据就行</li> 
   <li>编写flume-poll.conf配置文件</li> 
  </ol> 
  <pre><code>	a1.sources = r1
	a1.sinks = k1
	a1.channels = c1
	#source
	a1.sources.r1.channels = c1
	a1.sources.r1.type = spooldir
	a1.sources.r1.spoolDir = /root/data
	a1.sources.r1.fileHeader = true
	#channel
	a1.channels.c1.type =memory
	a1.channels.c1.capacity = 20000
	a1.channels.c1.transactionCapacity=5000
	#sinks
	a1.sinks.k1.channel = c1
	a1.sinks.k1.type = org.apache.spark.streaming.flume.sink.SparkSink
	a1.sinks.k1.hostname=hdp-node-01
	a1.sinks.k1.port = 8888
	a1.sinks.k1.batchSize= 2000                           
</code></pre> 
  <p>启动flume：</p> 
  <pre><code>flume-ng agent -n a1 -c /opt/bigdata/flume/conf -f /opt/bigdata/flume/conf/flume-poll.conf -Dflume.root.logger=INFO,console
</code></pre> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务器上的 /root/data目录下准备数据文件data.txt</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019081321052661.png" alt="在这里插入图片描述"><br> 5. 启动 spark-streaming 应用程序，去 flume 所在机器拉取数据<br> 6. 代码实现<br> </p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要添加pom依赖</p> 
  <pre><code>	&lt;properties&gt;
   	 	&lt;scala.version&gt;2.11.8&lt;/scala.version&gt;
    	&lt;hadoop.version&gt;2.7.4&lt;/hadoop.version&gt;
    	&lt;spark.version&gt;2.0.2&lt;/spark.version&gt;
    	&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    	&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
	&lt;/properties&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
    		&lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
    		&lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt;
    		&lt;version&gt;2.0.2&lt;/version&gt;
		&lt;/dependency&gt;
    	&lt;dependency&gt;
       	 	&lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
        	&lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt;
        	&lt;version&gt;${spark.version}&lt;/version&gt;
    	&lt;/dependency&gt;
    		&lt;!--引入spark-streaming-flume的包--&gt;
    	&lt;dependency&gt;
        	&lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
        	&lt;artifactId&gt;spark-streaming-flume_2.10&lt;/artifactId&gt;
        	&lt;version&gt;2.0.2&lt;/version&gt;
    	&lt;/dependency&gt;
	&lt;/dependencies&gt;
</code></pre> 
  <p>具体代码如下：</p> 
  <pre><code> import java.net.InetSocketAddress
 import org.apache.spark.storage.StorageLevel
 import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
 import org.apache.spark.streaming.flume.{FlumeUtils, SparkFlumeEvent}
 import org.apache.spark.{SparkConf, SparkContext}
 import org.apache.spark.streaming.{Seconds, StreamingContext}
 
 object FlumeDir {
   def main(args: Array[String]): Unit = {
     val conf: SparkConf = new SparkConf().setAppName("FlumeDir").setMaster("local[2]")
     val sc = new SparkContext(conf)
     sc.setLogLevel("WARN")
     val scc = new StreamingContext(sc,Seconds(5))
     scc.checkpoint("./spark_flume_dir")
 
     //设置flume地址
     val addresses: Seq[InetSocketAddress] = Seq (new InetSocketAddress("192.168.44.127",8888))
     val flumeds: ReceiverInputDStream[SparkFlumeEvent] = FlumeUtils.createPollingStream(scc,addresses,StorageLevel.MEMORY_AND_DISK)
     val lineds: DStream[String] = flumeds.map(x=&gt;new String(x.event.getBody.array()))
     lineds.flatMap(_.split(" ")).map((_,1)).reduceByKey(_+_).print()
     scc.start()
     scc.awaitTermination()
 
   }
 }
</code></pre> 
  <ol start="7"> 
   <li></li> 
  </ol> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813211539827.png" alt="在这里插入图片描述"></p> 
  <h2><a id="Push_467"></a>Push方式</h2> 
  <p>（1）编写flume-push.conf配置文件</p> 
  <pre><code>#push mode
a1.sources = r1
a1.sinks = k1
a1.channels = c1
#source
a1.sources.r1.channels = c1
a1.sources.r1.type = spooldir
a1.sources.r1.spoolDir = /root/data
a1.sources.r1.fileHeader = true
#channel
a1.channels.c1.type =memory
a1.channels.c1.capacity = 20000
a1.channels.c1.transactionCapacity=5000
#sinks
a1.sinks.k1.channel = c1
a1.sinks.k1.type = avro
a1.sinks.k1.hostname=172.16.43.63
a1.sinks.k1.port = 8888
a1.sinks.k1.batchSize= 2000                        
</code></pre> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意配置文件中指明的hostname和port是spark应用程序所在服务器的ip地址和端口</p> 
  <ol start="2"> 
   <li>代码实现如下：</li> 
  </ol> 
  <pre><code>	package cn.test.spark
	
	import java.net.InetSocketAddress
	
	import org.apache.spark.storage.StorageLevel
	import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
	import org.apache.spark.streaming.flume.{FlumeUtils, SparkFlumeEvent}
	import org.apache.spark.streaming.{Seconds, StreamingContext}
	import org.apache.spark.{SparkConf, SparkContext}
	
	/**
	  * sparkStreaming整合flume  推模式Push
	  */
	object SparkStreaming_Flume_Push {
	  //newValues 表示当前批次汇总成的(word,1)中相同单词的所有的1
	  //runningCount 历史的所有相同key的value总和
	  def updateFunction(newValues: Seq[Int], runningCount: Option[Int]): Option[Int] = {
	    val newCount =runningCount.getOrElse(0)+newValues.sum
	    Some(newCount)
	  }
	
	
	  def main(args: Array[String]): Unit = {
	    //配置sparkConf参数
	    val sparkConf: SparkConf = new SparkConf().setAppName("SparkStreaming_Flume_Push").setMaster("local[2]")
	    //构建sparkContext对象
	    val sc: SparkContext = new SparkContext(sparkConf)
	    //构建StreamingContext对象，每个批处理的时间间隔
	    val scc: StreamingContext = new StreamingContext(sc, Seconds(5))
	    //设置日志输出级别
	    sc.setLogLevel("WARN")
	    //设置检查点目录
	    scc.checkpoint("./")
	    //flume推数据过来
	    // 当前应用程序部署的服务器ip地址，跟flume配置文件保持一致
	    val flumeStream: ReceiverInputDStream[SparkFlumeEvent] = FlumeUtils.createStream(scc,"172.16.43.63",8888,StorageLevel.MEMORY_AND_DISK)
	
	    //获取flume中数据，数据存在event的body中，转化为String
	    val lineStream: DStream[String] = flumeStream.map(x=&gt;new String(x.event.getBody.array()))
	    //实现单词汇总
	   val result: DStream[(String, Int)] = lineStream.flatMap(_.split(" ")).map((_,1)).updateStateByKey(updateFunction)
	
	    result.print()
	    scc.start()
	    scc.awaitTermination()
	  }
	
	}
	}
</code></pre> 
  <ol start="3"> 
   <li> <p>启动执行<br> 先执行spark代码<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813212113653.png" alt="在这里插入图片描述"><br> 然后在执行flume配置文件<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813212127108.png" alt="在这里插入图片描述"></p> </li> 
   <li> <p>观察 IDEA 控制台输出<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813212144381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> </li> 
  </ol> 
  <h1><a id="6	Spark_Streamingkafka_554"></a>6. Spark Streaming整合kafka实战</h1> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>kafka作为一个实时的分布式消息队列，实时的生产和消费消息，这里我们可以利用SparkStreaming实时计算框架实时地读取kafka中的数据然后进行计算。</b></p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>在spark1.3版本后，kafkaUtils里面提供了两个创建dstream的方法，一种为KafkaUtils.createDstream，另一种为KafkaUtils.createDirectStream。</b></p> 
  <h2><a id="KafkaUtilscreateDstream_558"></a>KafkaUtils.createDstream方式</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造函数为KafkaUtils.createDstream(ssc, [zk], [consumer group id], [per-topic,partitions] ) 使用了receivers来接收数据，利用的是Kafka高层次的消费者api，对于所有的receivers接收到的数据将会保存在Spark executors中，然后通过Spark Streaming启动job来处理这些数据，默认会丢失，可启用WAL日志，它同步将接受到数据保存到分布式文件系统上比如HDFS。 所以数据在出错的情况下可以恢复出来 。</p> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190813213050229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70) 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个receiver来对kafka进行定时拉取数据，ssc的rdd分区和kafka的topic分区不是一个概念，故如果增加特定主消费的线程数仅仅是增加一个receiver中消费topic的线程数，并不增加spark的并行处理数据数量 。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于不同的group和topic可以使用多个receivers创建不同的DStream 。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果启用了WAL (spark.streaming.receiver.writeAheadLog.enable=true) 同时需要设置存储级别(默认StorageLevel.MEMORY_AND_DISK_SER_2)， 即KafkaUtils.createStream(….,StorageLevel.MEMORY_AND_DISK_SER) 。</p> 
  <h3><a id="KafkaUtilscreateDstream_569"></a>KafkaUtils.createDstream实战</h3> 
  <ol> 
   <li> <p>添加 kafka 的 pom 依赖</p> <pre><code>&lt;properties&gt;
    &lt;scala.version&gt;2.11.8&lt;/scala.version&gt;
    &lt;hadoop.version&gt;2.7.4&lt;/hadoop.version&gt;
    &lt;spark.version&gt;2.0.2&lt;/spark.version&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
    &lt;artifactId&gt;spark-streaming-kafka-0-8_2.11&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
        &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt;
        &lt;version&gt;2.0.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
        &lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt;
        &lt;version&gt;${spark.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
        &lt;artifactId&gt;spark-hive_2.11&lt;/artifactId&gt;
        &lt;version&gt;2.0.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

</code></pre> 
    <ol start="2"> 
     <li> <p>启动 zookeeper 集群<br> <a href="http://zkServer.sh" rel="nofollow" data-token="044664981ccd9834616e3777728fcc12">zkServer.sh</a> start</p> </li> 
     <li> <p>启动 kafka 集群<br> <a href="http://kafka-server-start.sh" rel="nofollow" data-token="b9f6c8484ab81172e0051b2d979139d4">kafka-server-start.sh</a> /export/servers/kafka/config/server.properties</p> </li> 
     <li> <p>创建 topic<br> <a href="http://kafka-topics.sh" rel="nofollow" data-token="94665fe671700fbf9986a1866ec87a6b">kafka-topics.sh</a> --create --zookeeper hdp-node-01:2181 --replication-factor 1 --partitions 3 --topic kafka_spark</p> </li> 
     <li> <p>向 topic 中生产数据<br> 通过 shell 命令向 topic 发送消息<br> <a href="http://kafka-console-producer.sh" rel="nofollow" data-token="298e1b725030be18569e82c184925a8a">kafka-console-producer.sh</a> --broker-list hdp-node-01:9092 --topic kafka_spark<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813213555143.png" alt="在这里插入图片描述"></p> </li> 
     <li> <p>编写 Spark Streaming</p> </li> 
    </ol> <pre><code>import org.apache.spark.streaming.dstream.DStream
import org.apache.spark.streaming.kafka.KafkaUtils
import org.apache.spark.streaming.{Seconds, StreamingContext}
import org.apache.spark.{SparkConf, SparkContext}

import scala.collection.immutable

//todo:利用sparkStreaming接受kafka中的数据实现单词计数----采用receivers
object SparkStreamingKafka_Receiver_checkpoint {

  def updateFunc(a:Seq[Int], b:Option[Int]) :Option[Int] ={
    Some(a.sum+b.getOrElse(0))
  }
  def main(args: Array[String]): Unit = {
    val checkpointPath = "./kafka-receiver"

    val ssc = StreamingContext.getOrCreate(checkpointPath, () =&gt; {
      createFunc(checkpointPath)
    })
    ssc.start()
    ssc.awaitTermination()
  }
  def createFunc(checkpointPath:String): StreamingContext = {

    //todo:1、创建sparkConf
     val sparkConf: SparkConf = new SparkConf()
                                .setAppName("SparkStreamingKafka_Receiver_checkpoint")
                                .setMaster("local[4]")
                                //todo:开启wal预写日志
                                .set("spark.streaming.receiver.writeAheadLog.enable","true")
    //todo:2、创建sparkContext
    val sc = new SparkContext(sparkConf)

    sc.setLogLevel("WARN")

    //todo:3、创建StreamingContext
    val ssc = new StreamingContext(sc,Seconds(5))
    ssc.checkpoint(checkpointPath)
    //todo:4、指定zkServer
    val zkServer="node1:2181,node2:2181,node3:2181"

    //todo:5、指定groupId
    val groupId="spark-kafka-receiver01"

    //todo:6、指定topics 这个可以利用一个消费者组来消费多个topic,
    //(topic_name -&gt; numPartitions)  指定topic消费的线程数
    val topics=Map("kafka_spark"-&gt;1)

    //todo:7、并行运行更多的接收器读取kafak topic中的数据，这里设置3个
    val resultDStream: immutable.IndexedSeq[DStream[String]] = (1 to 3).map(x =&gt; {
      //todo:8、通过使用KafkaUtils的createStream接受kafka topic中的数据，生成DStream
      val kafkaDataDStream: DStream[String] = KafkaUtils.createStream(ssc, zkServer, groupId, topics).map(x =&gt; x._2)
      kafkaDataDStream
    }
    )
    //todo:利用StreamContext将所有的DStream组合在一起
    val kafkaDStream: DStream[String] = ssc.union(resultDStream)

    //todo:8、获取kafka中topic的内容

    //todo:9、切分每一行。每个单词记为1
    val wordAndOne: DStream[(String, Int)] = kafkaDStream.flatMap(_.split(" ")).map((_,1))

    //todo:10、相同单词出现的次数累加
    val result: DStream[(String, Int)] = wordAndOne.updateStateByKey(updateFunc)

    //todo:打印
    result.print()
    ssc

  }

}
</code></pre> 
    <ol start="7"> 
     <li>运行代码，查看控制台数据</li> 
    </ol> <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813214325379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这种方式实现，刚开始的时候系统正常运行，没有发现问题，但是如果系统异常重新启动sparkstreaming程序后，发现程序会重复处理已经处理过的数据，这种基于receiver的方式，是使用Kafka的高阶API来在ZooKeeper中保存消费过的offset的。这是消费Kafka数据的传统方式。这种方式配合着WAL机制可以保证数据零丢失的高可靠性，但是却无法保证数据被处理一次且仅一次，可能会处理两次。因为Spark和ZooKeeper之间可能是不同步的。官方现在也已经不推荐这种整合方式，官网相关地址下面我们使用官网推荐的第二种方式kafkaUtils的createDirectStream()方式。</p> </li> 
  </ol> 
  <h2><a id="KafkaUtilscreateDirectStream_697"></a>KafkaUtils.createDirectStream方式</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>不同于Receiver接收数据，这种方式定期地从kafka的topic下对应的partition中查询最新的偏移量，再根据偏移量范围在每个batch里面处理数据，Spark通过调用kafka简单的消费者Api读取一定范围的数据。</b></p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813214627533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 相比基于Receiver方式有几个优点：</p> 
  <p><mark>简化并行:</mark></p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不需要创建多个kafka输入流，然后union它们，sparkStreaming将会创建和kafka分区一种的rdd的分区数，而且会从kafka中并行读取数据，spark中RDD的分区数和kafka中的分区数据是一一对应的关系。</p> 
  <p><mark>高效:</mark></p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种实现数据的零丢失是将数据预先保存在WAL中，会复制一遍数据，会导致数据被拷贝两次，第一次是被kafka复制，另一次是写到WAL中。而没有receiver的这种方式消除了这个问题。</p> 
  <p><mark>恰好一次语义(Exactly-once-semantics):</mark></p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Receiver读取kafka数据是通过kafka高层次api把偏移量写入zookeeper中，虽然这种方法可以通过数据保存在WAL中保证数据不丢失，但是可能会因为sparkStreaming和ZK中保存的偏移量不一致而导致数据被消费了多次。EOS通过实现kafka低层次api，偏移量仅仅被ssc保存在checkpoint中，消除了zk和ssc偏移量不一致的问题。缺点是无法使用基于zookeeper的kafka监控工具</p> 
  <ol> 
   <li>依赖到上面的案例即可,其余步骤也相同,接下来代码实现：</li> 
  </ol> 
  <pre><code>	import kafka.serializer.StringDecoder
	import org.apache.spark.streaming.dstream.InputDStream
	import org.apache.spark.streaming.kafka.KafkaUtils
	import org.apache.spark.streaming.{Seconds, StreamingContext}
	import org.apache.spark.{SparkConf, SparkContext}
	
	object KafkaTest2 {
	
	  def updateFunction(olds:Seq[Int],news:Option[Int]) : Option[Int] = {
	    Some(olds.sum + news.getOrElse(0))
	  }
	
	  def main(args: Array[String]): Unit = {
	      val conf: SparkConf = new SparkConf().setAppName("testkafka2").setMaster("local[2]")
	      val sc = new SparkContext(conf)
	      sc.setLogLevel("ERROR")
	      val scc = new StreamingContext(sc,Seconds(5))
	      scc.checkpoint("./spark_kafka")
	      val brokers = "node2:9092,node3:9092,node4:9092"
	      val topicSet = "mdj".split(",").toSet
	      val kafkaParam = Map("metadata.broker.list"-&gt;brokers)
	
	      val kafkads: InputDStream[(String, String)] = KafkaUtils.createDirectStream[String,String,StringDecoder,StringDecoder](scc,kafkaParam,topicSet)
	      kafkads.map(_._2).map(_.split(" ")).map((_,1)).updateStateByKey(updateFunction).print()
	
	      scc.start()
	      scc.awaitTermination()
	
	  }
	}
</code></pre> 
  <ol start="2"> 
   <li>查看效果<br> 向 topic 中添加数据<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813214945224.png" alt="在这里插入图片描述"><br> 查看控制台的输出：<img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190813214956666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdUFyZVJpZGljdWxvdXM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li> 
  </ol> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e44c3c0e64.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
