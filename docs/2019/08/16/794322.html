<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Docker Networking 章节3. 构建你的第一个Docker网络 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Docker Networking 章节3. 构建你的第一个Docker网络" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="这个章节讨论了Docker网络实际的例子，它跨多个主机上多个容器和多个主机，我们也讨论下面的内容： Pipework方案介绍 跨主机的多个容器 面向扩展网络--介绍Open vSwitch 覆盖网络--Flannel Docker网络方案比较 介绍Pipework网络方案 Pipework允许你在任意复杂的场景中将容器连接起来。 实际场景中，它创建一个合法的Linux网桥，在容器中增加一个新的接口，把接口附加到网桥上；容器获得一个能相互通信的网络段。 Pipework是一个shell脚本并且安装很简单： #sudo wget -O /usr/local/bin/pipework https://raw.githubusercontent.com/jpetazzo/pipework/master/pipework &amp;&amp; sudo chmod +x /usr/local/bin/pipework 下图展示了使用Pipework方案容器之间的通信： 首先，创建两个容器： 现在，使用Pipework将它们连接起来： #sudo pipework brpipe c1 192.168.1.1/24 这个命令在宿主机上创建了一个网桥brpripe。在容器c1中增加了eth1接口，设置IP地址是192.168.1.1并且添加接口到网桥上，如下所示： #sudo pipework brpipe c2 192.168.1.2/24 因为已经存在网桥brpipe，所以这个命令将不会再次创建。它将增加一个eth1接口到容器C2上并且添加到网桥上，如下所示： 现在这容器是北联系起来了并且能相互ping通，就像他们在相同的子网192.168.1.0/24中。Pipework提供了给容器增加静态IP的优势。 给容器采用Weave网络方案 Weave创建了一个虚拟的网络，它能跨主机连接Docke容器就像他们全部被连接在一个交换机上。这个Weave路由器本身作为一个Docker容器运行同时它能加密路由流量以便在Internet网络中传输。服务由Weave网络中的应用程序容器提供可以访问互联网，不管这些容器在哪里运行。 使用以下代码安装Weave: #sudo curl -L git.io/weave -o /usr/local/bin/weave #sudo chmod a+x /usr/local/bin/weave 下面展示了使用Weave网络容器跨主机通信： 在 $HOST1上，我们运行命令： # weave launch # eval $(weave proxy-env) # docker run --name c1 -ti ubuntu 在$HOST2上，我们重复相同的步骤: # weave launch $HOST1 # eval $(weave proxy-env) # docker run --name c2 -ti ubuntu 在$HOST1启动的容器中，执行命令可以有如下输出： 你能看到Weave网络接口，ethwe，使用ifconfig命令： 相似的，在$HOST2启动的容器中，有如下的输出： 这样我们就有了它——分别位于不同的主机上两个容器，彼此愉快地通信。 Open vSwitch 默认情况下，Docker使用Linux网桥docker0，然而，有些情况下我们需要的是Open vSwitch(OVS)而不是Linux网桥。一个单一的Linux网桥能使用1024个端口-这个限制了Docker仅仅能创建1024个容器的规模，每个占用一个网络接口。 单节点OVS 我们将安装单节点的OVS，生成两个容器并且通过OVS桥连接他们。 使用下面的命令安装OVS： # sudo apt-get install openvswitch-switch 下面的命令安装ovs-docker工具： # cd /usr/bin # wget https://raw.githubusercontent.com/openvswitch/ovs/master/utilities/ovs- docker # chmod a+rwx ovs-docker 下图展示了单节点的OVS 创建一个OVS桥 接下来，我们将增加一个新的OVS桥并且配置它从而得到连接在不同网络中的容器，如下所示： # ovs-vsctl add-br ovs-br1 # ifconfig ovs-br1 173.16.1.1 netmask 255.255.255.0 up 接下来的步骤将从OVS桥上增加一个端口给Docker的容器： &nbsp; 1.生成两个Ubuntu的Docker容器： # docker run -I -t --name container1 ubuntu /bin/bash # docekr run -I -t --name container2 ubuntu /bin/bash &nbsp; 2.把容器链接到OVS网桥上： # ovs-docker add-port ovs-br1 eth1 container1 --ipaddress=173.16.1.2/24 # ovs-docker add-port ovs-br1 eth1 container2 --ipaddress=173.16.1.3/24 &nbsp; 3.通过ping命令测试通过OVS网桥相连的容器的连通性，首先，查询他们各自的IP地址： &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 现在我们知道了container1和container2的IP地址，就可以ping它们： &nbsp; &nbsp; 跨主机OVS 接下来我们研究跨主机情况下使用OVS连接Docker容器。 让我们考虑展示在下面图表中设置，包含Host1和Host2两个主机，运行Ubuntu14.04系统： 在两个宿主机上安装Docker和Open vSwitch： # wget -qO- https://get.docker.com/ | sh # sudo apt-get install openvswitch-switch 安装ovs-docker工具 # cd /usr/bin # wget https://raw.githubusercontent.com/openvswitch/ovs/master/utilities/ovs- docker # chmod a+rwx ovs-docker 默认情况下，Docker选择一个随机网络来运行它的容器。它创建一个网桥docker0，并且给他分配了一个地址（172.17.42.1）。所以，Host1和Host2的docker0网桥地址是一样的，因此，这是十分困难对于容器在宿主机之间通信。为了克服这个问题，我们给网络分配静态IP地址，92.168.10.0/24。 接下来，我们改变默认的Docker子网： 在Host1上执行下面的命令： # service docker stop # ip link set dev docker0 down # ip addr del 172.17.42.1/16 dev docker0 # ip addr add 192.168.10.1/24 dev docker0 # ip link set dev docker0 up # ip addr show docker0 # service docker start 增加br0 OVS网桥： # ovs-vsctl add-br br0 给其它主机创建创建管道并且连接起来： # add-port br0 gre0—set interface gre0 type=gre options:remote_ip=30.30.30.8 把br0网桥连接到docker0网桥上： # brctl addif docker0 br0 在Host2上执行下面的命令： # service docker stop # iptables -t nat -F POSTROUTING # ip link set dev docker0 down # ip addr del 172.17.42.1/16 dev docker0 # ip addr add 192.168.10.2/24 dev docker0 # ip link set dev docker0 up # ip addr show docker0 # service docker start 增加br0 OVS网桥： # ip link set br0 up # ovs-vsctl add-br br0 创建到另一个主机的通道并连接起来： # br0 bridge ovs-vsctl add-port br0 gre0—set interface gre0 type=gre options:remote_ip=30.30.30.7 把br0网桥连接到docker0网桥上： # brctl addif docker0 br0 这样docker0网桥就添加到另一个网桥br0上。这个时候，它就是一个OVS网桥，这意味着在容器之间全部的流量也都会由br0网桥路由。 除此之外，我们使用了一条GRE隧道将运行容器的两台主机的网络连接起来，该隧道连接到OVS的br0网桥，因此也连接到docker0网桥上。 在两个宿主机上执行了上面的命令后，应该能够从两台主机上ping docker0桥接地址。 在主机1上，使用ping命令生成以下输出： 在主机2上，使用ping命令生成以下输出： 让我们看看如何在这两个主机上创建容器： 在HOST1上，使用下面的命令： # docker run -t -i --name container1 ubuntu:latest /bin/bash 在HOST2上，使用下面的命令： # docker run -t -i --name container2 ubuntu:latest /bin/bash 现在我们可以从container1上 ping container2。通过这种方式，我们使用Open vSwitch在多个主机上连接Docker容器。 网络与overlay网络--Flannel Flannel是虚拟网络层，给每个宿主机上Docker容器提供一个子网。它与CoreOS封装在一起，但也可以在其他Linux操作系统上配置。Flannel通过实际连接到Docker桥来创建覆盖层，容器连接到Docker桥，如下图所示。要安装Flannel，需要两台主机或VM，它们可以是CoreOS，或者最好是Linux OS，如图所示： Flannel代码可以从GitHub中克隆出来，如果需要的话，还可以在不同版本的Linux操作系统上本地构建，如下所示。它预装在CoreOS中： # git clone https://github.com/coreos/flannel.git Cloning into &#39;flannel&#39;... remote: Counting objects: 2141, done. remote: Compressing objects: 100% (19/19), done. remote: Total 2141 (delta 6), reused 0 (delta 0), pack-reused 2122 Receiving objects: 100% (2141/2141), 4. Checking connectivity… done. # sudo docker run -v `pwd`:/opt/flannel -i -t google/golang /bin/bash -c &quot;cd /opt/flannel &amp;&amp; ./build&quot; Building flanneld… 可以使用Vagrant和VirtualBox轻松配置CoreOS机器，如下面的链接中提到的教程所述： https://coreos.com/os/docs/latest/booting-on-vagrant.html 创建并登录到机器之后，我们将发现使用etcd配置自动创建的Flannel桥接器: # ifconfig flannel0 flannel0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt; mtu 1472 inet 10.1.30.0 netmask 255.255.0.0 destination 10.1.30.0 unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 txqueuelen 500 (UNSPEC) RX packets 243 bytes 20692 (20.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 304 bytes 25536 (24.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Flannle环境可以通过查看subnet.env来检查 # cat /run/flannel/subnet.env FLANNEL_NETWORK=10.1.0.0/16 FLANNEL_SUBNET=10.1.30.1/24 FLANNEL_MTU=1472 FLANNEL_IPMASQ=tru Docker守护进程需要使用以下命令重新启动，以便从Flannel网桥用子网重新实例化网络: 第二个主机的Flannel环境也可以通过查看subnet.env来检查： # cat /run/flannel/subnet.env FLANNEL_NETWORK=10.1.0.0/16 FLANNEL_SUBNET=10.1.31.1/24 FLANNEL_MTU=1472 FLANNEL_IPMASQ=true 另一个子网分配给第二个主机。Docker服务也可以在此主机中通过连接到Flannel网桥而重新启动： Docker可以在各自的主机中创建容器，并且可以使用ping命令对它们进行测试，以检查Flannel覆盖网络的连接性。 对于主机1，使用以下命令： 对于主机2，使用以下命令： 因此，在前面的示例中，我们可以看到Flannel通过在每个主机上运行flanneld代理来降低复杂性，该代理负责从预配置的地址空间分配子网租约。Flannel内部使用etcd存储网络配置和其他细节，比如主机IP和分配的子网。包的转发使用后端策略实现。 Flannel还旨在解决Kubernetes部署在GCE之外的云提供商上的问题，Flannel覆盖网格网络可以通过为每个服务器创建子网来为每个pod分配唯一的IP地址。 总结 在本章中，我们学习了Docker容器如何使用不同的网络选项(如Weave、OVS和Tlannel)在多个主机之间通信。Pipework使用了老的的Linux bridge、Weave创建虚拟网络、OVS使用GRE隧道技术，以及Flannel为每个主机提供一个单独的子网，以便将容器连接到多个主机。有些方案(如Pipework)是遗留的，在一段时间内将会废弃，而另一些则被设计用于特定操作系统的上下文中，比如带有CoreOS的Flannel。 &nbsp; 网络方案 Weave 虚拟化Overlay网络 Flannel 创建隔离的子网 Open vSwitch GRE管道 Pipework Linux网桥 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在下一章中，我们将讨论在使用Kubernetes、Docker Swarm和Mesosphere等框架时，Docker容器是如何互联的。" />
<meta property="og:description" content="这个章节讨论了Docker网络实际的例子，它跨多个主机上多个容器和多个主机，我们也讨论下面的内容： Pipework方案介绍 跨主机的多个容器 面向扩展网络--介绍Open vSwitch 覆盖网络--Flannel Docker网络方案比较 介绍Pipework网络方案 Pipework允许你在任意复杂的场景中将容器连接起来。 实际场景中，它创建一个合法的Linux网桥，在容器中增加一个新的接口，把接口附加到网桥上；容器获得一个能相互通信的网络段。 Pipework是一个shell脚本并且安装很简单： #sudo wget -O /usr/local/bin/pipework https://raw.githubusercontent.com/jpetazzo/pipework/master/pipework &amp;&amp; sudo chmod +x /usr/local/bin/pipework 下图展示了使用Pipework方案容器之间的通信： 首先，创建两个容器： 现在，使用Pipework将它们连接起来： #sudo pipework brpipe c1 192.168.1.1/24 这个命令在宿主机上创建了一个网桥brpripe。在容器c1中增加了eth1接口，设置IP地址是192.168.1.1并且添加接口到网桥上，如下所示： #sudo pipework brpipe c2 192.168.1.2/24 因为已经存在网桥brpipe，所以这个命令将不会再次创建。它将增加一个eth1接口到容器C2上并且添加到网桥上，如下所示： 现在这容器是北联系起来了并且能相互ping通，就像他们在相同的子网192.168.1.0/24中。Pipework提供了给容器增加静态IP的优势。 给容器采用Weave网络方案 Weave创建了一个虚拟的网络，它能跨主机连接Docke容器就像他们全部被连接在一个交换机上。这个Weave路由器本身作为一个Docker容器运行同时它能加密路由流量以便在Internet网络中传输。服务由Weave网络中的应用程序容器提供可以访问互联网，不管这些容器在哪里运行。 使用以下代码安装Weave: #sudo curl -L git.io/weave -o /usr/local/bin/weave #sudo chmod a+x /usr/local/bin/weave 下面展示了使用Weave网络容器跨主机通信： 在 $HOST1上，我们运行命令： # weave launch # eval $(weave proxy-env) # docker run --name c1 -ti ubuntu 在$HOST2上，我们重复相同的步骤: # weave launch $HOST1 # eval $(weave proxy-env) # docker run --name c2 -ti ubuntu 在$HOST1启动的容器中，执行命令可以有如下输出： 你能看到Weave网络接口，ethwe，使用ifconfig命令： 相似的，在$HOST2启动的容器中，有如下的输出： 这样我们就有了它——分别位于不同的主机上两个容器，彼此愉快地通信。 Open vSwitch 默认情况下，Docker使用Linux网桥docker0，然而，有些情况下我们需要的是Open vSwitch(OVS)而不是Linux网桥。一个单一的Linux网桥能使用1024个端口-这个限制了Docker仅仅能创建1024个容器的规模，每个占用一个网络接口。 单节点OVS 我们将安装单节点的OVS，生成两个容器并且通过OVS桥连接他们。 使用下面的命令安装OVS： # sudo apt-get install openvswitch-switch 下面的命令安装ovs-docker工具： # cd /usr/bin # wget https://raw.githubusercontent.com/openvswitch/ovs/master/utilities/ovs- docker # chmod a+rwx ovs-docker 下图展示了单节点的OVS 创建一个OVS桥 接下来，我们将增加一个新的OVS桥并且配置它从而得到连接在不同网络中的容器，如下所示： # ovs-vsctl add-br ovs-br1 # ifconfig ovs-br1 173.16.1.1 netmask 255.255.255.0 up 接下来的步骤将从OVS桥上增加一个端口给Docker的容器： &nbsp; 1.生成两个Ubuntu的Docker容器： # docker run -I -t --name container1 ubuntu /bin/bash # docekr run -I -t --name container2 ubuntu /bin/bash &nbsp; 2.把容器链接到OVS网桥上： # ovs-docker add-port ovs-br1 eth1 container1 --ipaddress=173.16.1.2/24 # ovs-docker add-port ovs-br1 eth1 container2 --ipaddress=173.16.1.3/24 &nbsp; 3.通过ping命令测试通过OVS网桥相连的容器的连通性，首先，查询他们各自的IP地址： &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 现在我们知道了container1和container2的IP地址，就可以ping它们： &nbsp; &nbsp; 跨主机OVS 接下来我们研究跨主机情况下使用OVS连接Docker容器。 让我们考虑展示在下面图表中设置，包含Host1和Host2两个主机，运行Ubuntu14.04系统： 在两个宿主机上安装Docker和Open vSwitch： # wget -qO- https://get.docker.com/ | sh # sudo apt-get install openvswitch-switch 安装ovs-docker工具 # cd /usr/bin # wget https://raw.githubusercontent.com/openvswitch/ovs/master/utilities/ovs- docker # chmod a+rwx ovs-docker 默认情况下，Docker选择一个随机网络来运行它的容器。它创建一个网桥docker0，并且给他分配了一个地址（172.17.42.1）。所以，Host1和Host2的docker0网桥地址是一样的，因此，这是十分困难对于容器在宿主机之间通信。为了克服这个问题，我们给网络分配静态IP地址，92.168.10.0/24。 接下来，我们改变默认的Docker子网： 在Host1上执行下面的命令： # service docker stop # ip link set dev docker0 down # ip addr del 172.17.42.1/16 dev docker0 # ip addr add 192.168.10.1/24 dev docker0 # ip link set dev docker0 up # ip addr show docker0 # service docker start 增加br0 OVS网桥： # ovs-vsctl add-br br0 给其它主机创建创建管道并且连接起来： # add-port br0 gre0—set interface gre0 type=gre options:remote_ip=30.30.30.8 把br0网桥连接到docker0网桥上： # brctl addif docker0 br0 在Host2上执行下面的命令： # service docker stop # iptables -t nat -F POSTROUTING # ip link set dev docker0 down # ip addr del 172.17.42.1/16 dev docker0 # ip addr add 192.168.10.2/24 dev docker0 # ip link set dev docker0 up # ip addr show docker0 # service docker start 增加br0 OVS网桥： # ip link set br0 up # ovs-vsctl add-br br0 创建到另一个主机的通道并连接起来： # br0 bridge ovs-vsctl add-port br0 gre0—set interface gre0 type=gre options:remote_ip=30.30.30.7 把br0网桥连接到docker0网桥上： # brctl addif docker0 br0 这样docker0网桥就添加到另一个网桥br0上。这个时候，它就是一个OVS网桥，这意味着在容器之间全部的流量也都会由br0网桥路由。 除此之外，我们使用了一条GRE隧道将运行容器的两台主机的网络连接起来，该隧道连接到OVS的br0网桥，因此也连接到docker0网桥上。 在两个宿主机上执行了上面的命令后，应该能够从两台主机上ping docker0桥接地址。 在主机1上，使用ping命令生成以下输出： 在主机2上，使用ping命令生成以下输出： 让我们看看如何在这两个主机上创建容器： 在HOST1上，使用下面的命令： # docker run -t -i --name container1 ubuntu:latest /bin/bash 在HOST2上，使用下面的命令： # docker run -t -i --name container2 ubuntu:latest /bin/bash 现在我们可以从container1上 ping container2。通过这种方式，我们使用Open vSwitch在多个主机上连接Docker容器。 网络与overlay网络--Flannel Flannel是虚拟网络层，给每个宿主机上Docker容器提供一个子网。它与CoreOS封装在一起，但也可以在其他Linux操作系统上配置。Flannel通过实际连接到Docker桥来创建覆盖层，容器连接到Docker桥，如下图所示。要安装Flannel，需要两台主机或VM，它们可以是CoreOS，或者最好是Linux OS，如图所示： Flannel代码可以从GitHub中克隆出来，如果需要的话，还可以在不同版本的Linux操作系统上本地构建，如下所示。它预装在CoreOS中： # git clone https://github.com/coreos/flannel.git Cloning into &#39;flannel&#39;... remote: Counting objects: 2141, done. remote: Compressing objects: 100% (19/19), done. remote: Total 2141 (delta 6), reused 0 (delta 0), pack-reused 2122 Receiving objects: 100% (2141/2141), 4. Checking connectivity… done. # sudo docker run -v `pwd`:/opt/flannel -i -t google/golang /bin/bash -c &quot;cd /opt/flannel &amp;&amp; ./build&quot; Building flanneld… 可以使用Vagrant和VirtualBox轻松配置CoreOS机器，如下面的链接中提到的教程所述： https://coreos.com/os/docs/latest/booting-on-vagrant.html 创建并登录到机器之后，我们将发现使用etcd配置自动创建的Flannel桥接器: # ifconfig flannel0 flannel0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt; mtu 1472 inet 10.1.30.0 netmask 255.255.0.0 destination 10.1.30.0 unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 txqueuelen 500 (UNSPEC) RX packets 243 bytes 20692 (20.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 304 bytes 25536 (24.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Flannle环境可以通过查看subnet.env来检查 # cat /run/flannel/subnet.env FLANNEL_NETWORK=10.1.0.0/16 FLANNEL_SUBNET=10.1.30.1/24 FLANNEL_MTU=1472 FLANNEL_IPMASQ=tru Docker守护进程需要使用以下命令重新启动，以便从Flannel网桥用子网重新实例化网络: 第二个主机的Flannel环境也可以通过查看subnet.env来检查： # cat /run/flannel/subnet.env FLANNEL_NETWORK=10.1.0.0/16 FLANNEL_SUBNET=10.1.31.1/24 FLANNEL_MTU=1472 FLANNEL_IPMASQ=true 另一个子网分配给第二个主机。Docker服务也可以在此主机中通过连接到Flannel网桥而重新启动： Docker可以在各自的主机中创建容器，并且可以使用ping命令对它们进行测试，以检查Flannel覆盖网络的连接性。 对于主机1，使用以下命令： 对于主机2，使用以下命令： 因此，在前面的示例中，我们可以看到Flannel通过在每个主机上运行flanneld代理来降低复杂性，该代理负责从预配置的地址空间分配子网租约。Flannel内部使用etcd存储网络配置和其他细节，比如主机IP和分配的子网。包的转发使用后端策略实现。 Flannel还旨在解决Kubernetes部署在GCE之外的云提供商上的问题，Flannel覆盖网格网络可以通过为每个服务器创建子网来为每个pod分配唯一的IP地址。 总结 在本章中，我们学习了Docker容器如何使用不同的网络选项(如Weave、OVS和Tlannel)在多个主机之间通信。Pipework使用了老的的Linux bridge、Weave创建虚拟网络、OVS使用GRE隧道技术，以及Flannel为每个主机提供一个单独的子网，以便将容器连接到多个主机。有些方案(如Pipework)是遗留的，在一段时间内将会废弃，而另一些则被设计用于特定操作系统的上下文中，比如带有CoreOS的Flannel。 &nbsp; 网络方案 Weave 虚拟化Overlay网络 Flannel 创建隔离的子网 Open vSwitch GRE管道 Pipework Linux网桥 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在下一章中，我们将讨论在使用Kubernetes、Docker Swarm和Mesosphere等框架时，Docker容器是如何互联的。" />
<link rel="canonical" href="https://uzzz.org/2019/08/16/794322.html" />
<meta property="og:url" content="https://uzzz.org/2019/08/16/794322.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-16T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"这个章节讨论了Docker网络实际的例子，它跨多个主机上多个容器和多个主机，我们也讨论下面的内容： Pipework方案介绍 跨主机的多个容器 面向扩展网络--介绍Open vSwitch 覆盖网络--Flannel Docker网络方案比较 介绍Pipework网络方案 Pipework允许你在任意复杂的场景中将容器连接起来。 实际场景中，它创建一个合法的Linux网桥，在容器中增加一个新的接口，把接口附加到网桥上；容器获得一个能相互通信的网络段。 Pipework是一个shell脚本并且安装很简单： #sudo wget -O /usr/local/bin/pipework https://raw.githubusercontent.com/jpetazzo/pipework/master/pipework &amp;&amp; sudo chmod +x /usr/local/bin/pipework 下图展示了使用Pipework方案容器之间的通信： 首先，创建两个容器： 现在，使用Pipework将它们连接起来： #sudo pipework brpipe c1 192.168.1.1/24 这个命令在宿主机上创建了一个网桥brpripe。在容器c1中增加了eth1接口，设置IP地址是192.168.1.1并且添加接口到网桥上，如下所示： #sudo pipework brpipe c2 192.168.1.2/24 因为已经存在网桥brpipe，所以这个命令将不会再次创建。它将增加一个eth1接口到容器C2上并且添加到网桥上，如下所示： 现在这容器是北联系起来了并且能相互ping通，就像他们在相同的子网192.168.1.0/24中。Pipework提供了给容器增加静态IP的优势。 给容器采用Weave网络方案 Weave创建了一个虚拟的网络，它能跨主机连接Docke容器就像他们全部被连接在一个交换机上。这个Weave路由器本身作为一个Docker容器运行同时它能加密路由流量以便在Internet网络中传输。服务由Weave网络中的应用程序容器提供可以访问互联网，不管这些容器在哪里运行。 使用以下代码安装Weave: #sudo curl -L git.io/weave -o /usr/local/bin/weave #sudo chmod a+x /usr/local/bin/weave 下面展示了使用Weave网络容器跨主机通信： 在 $HOST1上，我们运行命令： # weave launch # eval $(weave proxy-env) # docker run --name c1 -ti ubuntu 在$HOST2上，我们重复相同的步骤: # weave launch $HOST1 # eval $(weave proxy-env) # docker run --name c2 -ti ubuntu 在$HOST1启动的容器中，执行命令可以有如下输出： 你能看到Weave网络接口，ethwe，使用ifconfig命令： 相似的，在$HOST2启动的容器中，有如下的输出： 这样我们就有了它——分别位于不同的主机上两个容器，彼此愉快地通信。 Open vSwitch 默认情况下，Docker使用Linux网桥docker0，然而，有些情况下我们需要的是Open vSwitch(OVS)而不是Linux网桥。一个单一的Linux网桥能使用1024个端口-这个限制了Docker仅仅能创建1024个容器的规模，每个占用一个网络接口。 单节点OVS 我们将安装单节点的OVS，生成两个容器并且通过OVS桥连接他们。 使用下面的命令安装OVS： # sudo apt-get install openvswitch-switch 下面的命令安装ovs-docker工具： # cd /usr/bin # wget https://raw.githubusercontent.com/openvswitch/ovs/master/utilities/ovs- docker # chmod a+rwx ovs-docker 下图展示了单节点的OVS 创建一个OVS桥 接下来，我们将增加一个新的OVS桥并且配置它从而得到连接在不同网络中的容器，如下所示： # ovs-vsctl add-br ovs-br1 # ifconfig ovs-br1 173.16.1.1 netmask 255.255.255.0 up 接下来的步骤将从OVS桥上增加一个端口给Docker的容器： &nbsp; 1.生成两个Ubuntu的Docker容器： # docker run -I -t --name container1 ubuntu /bin/bash # docekr run -I -t --name container2 ubuntu /bin/bash &nbsp; 2.把容器链接到OVS网桥上： # ovs-docker add-port ovs-br1 eth1 container1 --ipaddress=173.16.1.2/24 # ovs-docker add-port ovs-br1 eth1 container2 --ipaddress=173.16.1.3/24 &nbsp; 3.通过ping命令测试通过OVS网桥相连的容器的连通性，首先，查询他们各自的IP地址： &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 现在我们知道了container1和container2的IP地址，就可以ping它们： &nbsp; &nbsp; 跨主机OVS 接下来我们研究跨主机情况下使用OVS连接Docker容器。 让我们考虑展示在下面图表中设置，包含Host1和Host2两个主机，运行Ubuntu14.04系统： 在两个宿主机上安装Docker和Open vSwitch： # wget -qO- https://get.docker.com/ | sh # sudo apt-get install openvswitch-switch 安装ovs-docker工具 # cd /usr/bin # wget https://raw.githubusercontent.com/openvswitch/ovs/master/utilities/ovs- docker # chmod a+rwx ovs-docker 默认情况下，Docker选择一个随机网络来运行它的容器。它创建一个网桥docker0，并且给他分配了一个地址（172.17.42.1）。所以，Host1和Host2的docker0网桥地址是一样的，因此，这是十分困难对于容器在宿主机之间通信。为了克服这个问题，我们给网络分配静态IP地址，92.168.10.0/24。 接下来，我们改变默认的Docker子网： 在Host1上执行下面的命令： # service docker stop # ip link set dev docker0 down # ip addr del 172.17.42.1/16 dev docker0 # ip addr add 192.168.10.1/24 dev docker0 # ip link set dev docker0 up # ip addr show docker0 # service docker start 增加br0 OVS网桥： # ovs-vsctl add-br br0 给其它主机创建创建管道并且连接起来： # add-port br0 gre0—set interface gre0 type=gre options:remote_ip=30.30.30.8 把br0网桥连接到docker0网桥上： # brctl addif docker0 br0 在Host2上执行下面的命令： # service docker stop # iptables -t nat -F POSTROUTING # ip link set dev docker0 down # ip addr del 172.17.42.1/16 dev docker0 # ip addr add 192.168.10.2/24 dev docker0 # ip link set dev docker0 up # ip addr show docker0 # service docker start 增加br0 OVS网桥： # ip link set br0 up # ovs-vsctl add-br br0 创建到另一个主机的通道并连接起来： # br0 bridge ovs-vsctl add-port br0 gre0—set interface gre0 type=gre options:remote_ip=30.30.30.7 把br0网桥连接到docker0网桥上： # brctl addif docker0 br0 这样docker0网桥就添加到另一个网桥br0上。这个时候，它就是一个OVS网桥，这意味着在容器之间全部的流量也都会由br0网桥路由。 除此之外，我们使用了一条GRE隧道将运行容器的两台主机的网络连接起来，该隧道连接到OVS的br0网桥，因此也连接到docker0网桥上。 在两个宿主机上执行了上面的命令后，应该能够从两台主机上ping docker0桥接地址。 在主机1上，使用ping命令生成以下输出： 在主机2上，使用ping命令生成以下输出： 让我们看看如何在这两个主机上创建容器： 在HOST1上，使用下面的命令： # docker run -t -i --name container1 ubuntu:latest /bin/bash 在HOST2上，使用下面的命令： # docker run -t -i --name container2 ubuntu:latest /bin/bash 现在我们可以从container1上 ping container2。通过这种方式，我们使用Open vSwitch在多个主机上连接Docker容器。 网络与overlay网络--Flannel Flannel是虚拟网络层，给每个宿主机上Docker容器提供一个子网。它与CoreOS封装在一起，但也可以在其他Linux操作系统上配置。Flannel通过实际连接到Docker桥来创建覆盖层，容器连接到Docker桥，如下图所示。要安装Flannel，需要两台主机或VM，它们可以是CoreOS，或者最好是Linux OS，如图所示： Flannel代码可以从GitHub中克隆出来，如果需要的话，还可以在不同版本的Linux操作系统上本地构建，如下所示。它预装在CoreOS中： # git clone https://github.com/coreos/flannel.git Cloning into &#39;flannel&#39;... remote: Counting objects: 2141, done. remote: Compressing objects: 100% (19/19), done. remote: Total 2141 (delta 6), reused 0 (delta 0), pack-reused 2122 Receiving objects: 100% (2141/2141), 4. Checking connectivity… done. # sudo docker run -v `pwd`:/opt/flannel -i -t google/golang /bin/bash -c &quot;cd /opt/flannel &amp;&amp; ./build&quot; Building flanneld… 可以使用Vagrant和VirtualBox轻松配置CoreOS机器，如下面的链接中提到的教程所述： https://coreos.com/os/docs/latest/booting-on-vagrant.html 创建并登录到机器之后，我们将发现使用etcd配置自动创建的Flannel桥接器: # ifconfig flannel0 flannel0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt; mtu 1472 inet 10.1.30.0 netmask 255.255.0.0 destination 10.1.30.0 unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 txqueuelen 500 (UNSPEC) RX packets 243 bytes 20692 (20.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 304 bytes 25536 (24.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Flannle环境可以通过查看subnet.env来检查 # cat /run/flannel/subnet.env FLANNEL_NETWORK=10.1.0.0/16 FLANNEL_SUBNET=10.1.30.1/24 FLANNEL_MTU=1472 FLANNEL_IPMASQ=tru Docker守护进程需要使用以下命令重新启动，以便从Flannel网桥用子网重新实例化网络: 第二个主机的Flannel环境也可以通过查看subnet.env来检查： # cat /run/flannel/subnet.env FLANNEL_NETWORK=10.1.0.0/16 FLANNEL_SUBNET=10.1.31.1/24 FLANNEL_MTU=1472 FLANNEL_IPMASQ=true 另一个子网分配给第二个主机。Docker服务也可以在此主机中通过连接到Flannel网桥而重新启动： Docker可以在各自的主机中创建容器，并且可以使用ping命令对它们进行测试，以检查Flannel覆盖网络的连接性。 对于主机1，使用以下命令： 对于主机2，使用以下命令： 因此，在前面的示例中，我们可以看到Flannel通过在每个主机上运行flanneld代理来降低复杂性，该代理负责从预配置的地址空间分配子网租约。Flannel内部使用etcd存储网络配置和其他细节，比如主机IP和分配的子网。包的转发使用后端策略实现。 Flannel还旨在解决Kubernetes部署在GCE之外的云提供商上的问题，Flannel覆盖网格网络可以通过为每个服务器创建子网来为每个pod分配唯一的IP地址。 总结 在本章中，我们学习了Docker容器如何使用不同的网络选项(如Weave、OVS和Tlannel)在多个主机之间通信。Pipework使用了老的的Linux bridge、Weave创建虚拟网络、OVS使用GRE隧道技术，以及Flannel为每个主机提供一个单独的子网，以便将容器连接到多个主机。有些方案(如Pipework)是遗留的，在一段时间内将会废弃，而另一些则被设计用于特定操作系统的上下文中，比如带有CoreOS的Flannel。 &nbsp; 网络方案 Weave 虚拟化Overlay网络 Flannel 创建隔离的子网 Open vSwitch GRE管道 Pipework Linux网桥 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在下一章中，我们将讨论在使用Kubernetes、Docker Swarm和Mesosphere等框架时，Docker容器是如何互联的。","@type":"BlogPosting","url":"https://uzzz.org/2019/08/16/794322.html","headline":"Docker Networking 章节3. 构建你的第一个Docker网络","dateModified":"2019-08-16T00:00:00+08:00","datePublished":"2019-08-16T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/08/16/794322.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Docker Networking 章节3. 构建你的第一个Docker网络</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>这个章节讨论了Docker网络实际的例子，它跨多个主机上多个容器和多个主机，我们也讨论下面的内容：</p> 
  <ul>
   <li>Pipework方案介绍</li> 
   <li>跨主机的多个容器</li> 
   <li>面向扩展网络--介绍Open vSwitch</li> 
   <li>覆盖网络--Flannel</li> 
   <li>Docker网络方案比较</li> 
  </ul>
  <h1>介绍Pipework网络方案</h1> 
  <p>Pipework允许你在任意复杂的场景中将容器连接起来。</p> 
  <p>实际场景中，它创建一个合法的Linux网桥，在容器中增加一个新的接口，把接口附加到网桥上；容器获得一个能相互通信的网络段。</p> 
  <p>Pipework是一个shell脚本并且安装很简单：</p> 
  <pre class="has">
<code>#sudo wget -O /usr/local/bin/pipework
https://raw.githubusercontent.com/jpetazzo/pipework/master/pipework &amp;&amp; sudo
chmod +x /usr/local/bin/pipework</code></pre> 
  <p>下图展示了使用Pipework方案容器之间的通信：</p> 
  <p><img alt="" class="has" height="347" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190724204441647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="369"></p> 
  <p>首先，创建两个容器：</p> 
  <p><img alt="" class="has" height="603" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190724204554532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="487"></p> 
  <p>现在，使用Pipework将它们连接起来：</p> 
  <pre class="has">
<code>#sudo pipework brpipe c1 192.168.1.1/24</code></pre> 
  <p>这个命令在宿主机上创建了一个网桥brpripe。在容器c1中增加了eth1接口，设置IP地址是192.168.1.1并且添加接口到网桥上，如下所示：</p> 
  <p><img alt="" class="has" height="349" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190724204928761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="466"></p> 
  <pre class="has">
<code>#sudo pipework brpipe c2 192.168.1.2/24</code></pre> 
  <p>因为已经存在网桥brpipe，所以这个命令将不会再次创建。它将增加一个eth1接口到容器C2上并且添加到网桥上，如下所示：</p> 
  <p><img alt="" class="has" height="350" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190724205725547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="490"></p> 
  <p>现在这容器是北联系起来了并且能相互ping通，就像他们在相同的子网192.168.1.0/24中。Pipework提供了给容器增加静态IP的优势。</p> 
  <h1>给容器采用Weave网络方案</h1> 
  <p>Weave创建了一个虚拟的网络，它能跨主机连接Docke容器就像他们全部被连接在一个交换机上。这个Weave路由器本身作为一个Docker容器运行同时它能加密路由流量以便在Internet网络中传输。服务由Weave网络中的应用程序容器提供可以访问互联网，不管这些容器在哪里运行。</p> 
  <p>使用以下代码安装Weave:</p> 
  <pre class="has">
<code>#sudo curl -L git.io/weave -o /usr/local/bin/weave
#sudo chmod a+x /usr/local/bin/weave</code></pre> 
  <p>下面展示了使用Weave网络容器跨主机通信：</p> 
  <p><img alt="" class="has" height="214" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190729210013798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="369"></p> 
  <p>在 $HOST1上，我们运行命令：</p> 
  <pre class="has">
<code># weave launch
# eval $(weave proxy-env)
# docker run --name c1 -ti ubuntu</code></pre> 
  <p>在$HOST2上，我们重复相同的步骤:</p> 
  <pre class="has">
<code># weave launch $HOST1
# eval $(weave proxy-env)
# docker run --name c2 -ti ubuntu</code></pre> 
  <p>在$HOST1启动的容器中，执行命令可以有如下输出：</p> 
  <p><img alt="" class="has" height="435" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190729210857119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="456"></p> 
  <p>你能看到Weave网络接口，ethwe，使用ifconfig命令：</p> 
  <p><img alt="" class="has" height="351" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019072921100365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="446"></p> 
  <p><img alt="" class="has" height="74" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190729211052768.png" width="445"></p> 
  <p>相似的，在$HOST2启动的容器中，有如下的输出：</p> 
  <p><img alt="" class="has" height="153" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190729211157971.png" width="443"></p> 
  <p>这样我们就有了它——分别位于不同的主机上两个容器，彼此愉快地通信。</p> 
  <h1>Open vSwitch</h1> 
  <p>默认情况下，Docker使用Linux网桥docker0，然而，有些情况下我们需要的是Open vSwitch(OVS)而不是Linux网桥。一个单一的Linux网桥能使用1024个端口-这个限制了Docker仅仅能创建1024个容器的规模，每个占用一个网络接口。</p> 
  <h2>单节点OVS</h2> 
  <p>我们将安装单节点的OVS，生成两个容器并且通过OVS桥连接他们。</p> 
  <p>使用下面的命令安装OVS：</p> 
  <pre class="has">
<code># sudo apt-get install openvswitch-switch</code></pre> 
  <p>下面的命令安装ovs-docker工具：</p> 
  <pre class="has">
<code># cd /usr/bin
# wget
https://raw.githubusercontent.com/openvswitch/ovs/master/utilities/ovs-
docker
# chmod a+rwx ovs-docker</code></pre> 
  <p>下图展示了单节点的OVS</p> 
  <p><img alt="" class="has" height="289" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019080822002064.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="459"></p> 
  <p>创建一个OVS桥</p> 
  <p>接下来，我们将增加一个新的OVS桥并且配置它从而得到连接在不同网络中的容器，如下所示：</p> 
  <pre class="has">
<code># ovs-vsctl add-br ovs-br1
# ifconfig ovs-br1 173.16.1.1 netmask 255.255.255.0 up</code></pre> 
  <p>接下来的步骤将从OVS桥上增加一个端口给Docker的容器：</p> 
  <p>&nbsp; 1.生成两个Ubuntu的Docker容器：</p> 
  <pre class="has">
<code># docker run -I -t --name container1 ubuntu /bin/bash
# docekr run -I -t --name container2 ubuntu /bin/bash</code></pre> 
  <p>&nbsp; 2.把容器链接到OVS网桥上：</p> 
  <pre class="has">
<code># ovs-docker add-port ovs-br1 eth1 container1 --ipaddress=173.16.1.2/24
# ovs-docker add-port ovs-br1 eth1 container2 --ipaddress=173.16.1.3/24</code></pre> 
  <p>&nbsp; 3.通过<em>ping</em>命令测试通过OVS网桥相连的容器的连通性，首先，查询他们各自的IP地址：</p> 
  <p>&nbsp; &nbsp;&nbsp;<img alt="" class="has" height="507" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190808221025280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="458"></p> 
  <p>&nbsp; &nbsp; 现在我们知道了container1和container2的IP地址，就可以ping它们：</p> 
  <p>&nbsp; &nbsp;<img alt="" class="has" height="239" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190808221119566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="431"></p> 
  <h2>跨主机OVS</h2> 
  <p>接下来我们研究跨主机情况下使用OVS连接Docker容器。</p> 
  <p>让我们考虑展示在下面图表中设置，包含Host1和Host2两个主机，运行Ubuntu14.04系统：</p> 
  <p><img alt="" class="has" height="334" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190808222057647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="538"></p> 
  <p>在两个宿主机上安装Docker和Open vSwitch：</p> 
  <pre class="has">
<code># wget -qO- https://get.docker.com/ | sh
# sudo apt-get install openvswitch-switch</code></pre> 
  <p>安装ovs-docker工具</p> 
  <pre class="has">
<code># cd /usr/bin
# wget
https://raw.githubusercontent.com/openvswitch/ovs/master/utilities/ovs-
docker
# chmod a+rwx ovs-docker</code></pre> 
  <p>默认情况下，Docker选择一个随机网络来运行它的容器。它创建一个网桥docker0，并且给他分配了一个地址（172.17.42.1）。所以，Host1和Host2的docker0网桥地址是一样的，因此，这是十分困难对于容器在宿主机之间通信。为了克服这个问题，我们给网络分配静态IP地址，92.168.10.0/24。</p> 
  <p>接下来，我们改变默认的Docker子网：</p> 
  <p>在Host1上执行下面的命令：</p> 
  <pre class="has">
<code># service docker stop
# ip link set dev docker0 down
# ip addr del 172.17.42.1/16 dev docker0
# ip addr add 192.168.10.1/24 dev docker0
# ip link set dev docker0 up
# ip addr show docker0
# service docker start</code></pre> 
  <p>增加br0 OVS网桥：</p> 
  <pre class="has">
<code># ovs-vsctl add-br br0</code></pre> 
  <p>给其它主机创建创建管道并且连接起来：</p> 
  <pre class="has">
<code># add-port br0 gre0—set interface gre0 type=gre
options:remote_ip=30.30.30.8</code></pre> 
  <p>把br0网桥连接到docker0网桥上：</p> 
  <pre class="has">
<code># brctl addif docker0 br0</code></pre> 
  <p>在Host2上执行下面的命令：</p> 
  <pre class="has">
<code># service docker stop
# iptables -t nat -F POSTROUTING
# ip link set dev docker0 down
# ip addr del 172.17.42.1/16 dev docker0
# ip addr add 192.168.10.2/24 dev docker0
# ip link set dev docker0 up
# ip addr show docker0
# service docker start</code></pre> 
  <p>增加br0 OVS网桥：</p> 
  <pre class="has">
<code># ip link set br0 up
# ovs-vsctl add-br br0</code></pre> 
  <p>创建到另一个主机的通道并连接起来：</p> 
  <pre class="has">
<code># br0 bridge ovs-vsctl add-port br0 gre0—set interface gre0 type=gre
options:remote_ip=30.30.30.7</code></pre> 
  <p>把br0网桥连接到docker0网桥上：</p> 
  <pre class="has">
<code># brctl addif docker0 br0</code></pre> 
  <p>这样docker0网桥就添加到另一个网桥br0上。这个时候，它就是一个OVS网桥，这意味着在容器之间全部的流量也都会由br0网桥路由。</p> 
  <p>除此之外，我们使用了一条GRE隧道将运行容器的两台主机的网络连接起来，该隧道连接到OVS的br0网桥，因此也连接到docker0网桥上。</p> 
  <p>在两个宿主机上执行了上面的命令后，应该能够从两台主机上ping docker0桥接地址。</p> 
  <p>在主机1上，使用ping命令生成以下输出：</p> 
  <p><img alt="" class="has" height="146" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190809102917376.png" width="568"></p> 
  <p>在主机2上，使用ping命令生成以下输出：</p> 
  <p><img alt="" class="has" height="144" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190809102946891.png" width="570"></p> 
  <p>让我们看看如何在这两个主机上创建容器：</p> 
  <p>在HOST1上，使用下面的命令：</p> 
  <pre class="has">
<code># docker run -t -i --name container1 ubuntu:latest /bin/bash</code></pre> 
  <p>在HOST2上，使用下面的命令：</p> 
  <pre class="has">
<code># docker run -t -i --name container2 ubuntu:latest /bin/bash</code></pre> 
  <p>现在我们可以从container1上 ping container2。通过这种方式，我们使用Open vSwitch在多个主机上连接Docker容器。</p> 
  <h2>网络与overlay网络--Flannel</h2> 
  <p>Flannel是虚拟网络层，给每个宿主机上Docker容器提供一个子网。它与CoreOS封装在一起，但也可以在其他Linux操作系统上配置。Flannel通过实际连接到Docker桥来创建覆盖层，容器连接到Docker桥，如下图所示。要安装Flannel，需要两台主机或VM，它们可以是CoreOS，或者最好是Linux OS，如图所示：</p> 
  <p><img alt="" class="has" height="412" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/201908091128175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="633"></p> 
  <p>Flannel代码可以从GitHub中克隆出来，如果需要的话，还可以在不同版本的Linux操作系统上本地构建，如下所示。它预装在CoreOS中：</p> 
  <pre class="has">
<code># git clone https://github.com/coreos/flannel.git
Cloning into 'flannel'...
remote: Counting objects: 2141, done.
remote: Compressing objects: 100% (19/19), done.
remote: Total 2141 (delta 6), reused 0 (delta 0), pack-reused 2122
Receiving objects: 100% (2141/2141), 4.
Checking connectivity… done.


# sudo docker run -v `pwd`:/opt/flannel -i -t google/golang /bin/bash -c
"cd /opt/flannel &amp;&amp; ./build"
Building flanneld…</code></pre> 
  <p>可以使用Vagrant和VirtualBox轻松配置CoreOS机器，如下面的链接中提到的教程所述：</p> 
  <p><a href="https://coreos.com/os/docs/latest/booting-on-vagrant.html" rel="nofollow" data-token="c8337d2c56d9995b40fce6c8412b9e13">https://coreos.com/os/docs/latest/booting-on-vagrant.html</a></p> 
  <p>创建并登录到机器之后，我们将发现使用etcd配置自动创建的Flannel桥接器:</p> 
  <pre class="has">
<code># ifconfig flannel0
flannel0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt; mtu 1472
inet 10.1.30.0 netmask 255.255.0.0 destination 10.1.30.0
unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
txqueuelen 500 (UNSPEC)
RX packets 243 bytes 20692 (20.2 KiB)
RX errors 0 dropped 0 overruns 0 frame 0
TX packets 304 bytes 25536 (24.9 KiB)
TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</code></pre> 
  <p>Flannle环境可以通过查看subnet.env来检查</p> 
  <pre class="has">
<code># cat /run/flannel/subnet.env
FLANNEL_NETWORK=10.1.0.0/16
FLANNEL_SUBNET=10.1.30.1/24
FLANNEL_MTU=1472
FLANNEL_IPMASQ=tru</code></pre> 
  <p>Docker守护进程需要使用以下命令重新启动，以便从Flannel网桥用子网重新实例化网络:</p> 
  <p><img alt="" class="has" height="294" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190809113135871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="699"></p> 
  <p>第二个主机的Flannel环境也可以通过查看subnet.env来检查：</p> 
  <pre class="has">
<code># cat /run/flannel/subnet.env
FLANNEL_NETWORK=10.1.0.0/16
FLANNEL_SUBNET=10.1.31.1/24
FLANNEL_MTU=1472
FLANNEL_IPMASQ=true</code></pre> 
  <p>另一个子网分配给第二个主机。Docker服务也可以在此主机中通过连接到Flannel网桥而重新启动：</p> 
  <p><img alt="" class="has" height="384" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190809113900999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="680"></p> 
  <p>Docker可以在各自的主机中创建容器，并且可以使用ping命令对它们进行测试，以检查Flannel覆盖网络的连接性。<br> 对于主机1，使用以下命令：</p> 
  <p><img alt="" class="has" height="535" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190809114038918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="726"></p> 
  <p>对于主机2，使用以下命令：</p> 
  <p><img alt="" class="has" height="543" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190809114115575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNTU4MjY=,size_16,color_FFFFFF,t_70" width="638"></p> 
  <p>因此，在前面的示例中，我们可以看到Flannel通过在每个主机上运行flanneld代理来降低复杂性，该代理负责从预配置的地址空间分配子网租约。Flannel内部使用etcd存储网络配置和其他细节，比如主机IP和分配的子网。包的转发使用后端策略实现。</p> 
  <p>Flannel还旨在解决Kubernetes部署在GCE之外的云提供商上的问题，Flannel覆盖网格网络可以通过为每个服务器创建子网来为每个pod分配唯一的IP地址。</p> 
  <h1>总结</h1> 
  <p>在本章中，我们学习了Docker容器如何使用不同的网络选项(如Weave、OVS和Tlannel)在多个主机之间通信。Pipework使用了老的的Linux bridge、Weave创建虚拟网络、OVS使用GRE隧道技术，以及Flannel为每个主机提供一个单独的子网，以便将容器连接到多个主机。有些方案(如Pipework)是遗留的，在一段时间内将会废弃，而另一些则被设计用于特定操作系统的上下文中，比如带有CoreOS的Flannel。</p> 
  <table align="left" border="1" cellpadding="1" cellspacing="1" style="width:500px;">
   <tbody>
    <tr>
     <td>&nbsp;</td> 
     <td>网络方案</td> 
    </tr>
    <tr>
     <td>Weave</td> 
     <td>虚拟化Overlay网络</td> 
    </tr>
    <tr>
     <td>Flannel</td> 
     <td>创建隔离的子网</td> 
    </tr>
    <tr>
     <td>Open vSwitch</td> 
     <td>GRE管道</td> 
    </tr>
    <tr>
     <td>Pipework</td> 
     <td>Linux网桥</td> 
    </tr>
   </tbody>
  </table>
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>在下一章中，我们将讨论在使用Kubernetes、Docker Swarm和Mesosphere等框架时，Docker容器是如何互联的。</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
