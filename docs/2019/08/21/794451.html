<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>笔记 :归纳总结 (一) | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="笔记 :归纳总结 (一)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="文章目录 资料 分割线 分割线 特征工程 损失函数 目标检测 传统目标检测 R - CNN SPP Net Fast R - CNN 数据结构与算法 资料 决策边界（decision boundary） logistic回归，以及决策边界与回归的区别 吴恩达机器学习笔记16-决策边界(decision boundary) 机器学习中线性模型和非线性的区别 机器学习中线性模型和非线性的区别 怎样区分线性和非线性 线性模型 线性分类器和非线性分类器 机器学习之广义线性模型 广义线性模型到底是个什么鬼？| 协和八 逻辑回归(logistics regression) 解释logistic回归为什么要使用sigmoid函数 LG为什么用sigmoid函数 《深度学习导论及案例分析》一2.15通用逼近定理 大意就是：隐藏节点只要足够多，就能逼近任一函数 机器学习（二）：k近邻法（kNN） 机器学习：K-近邻算法（KNN） 几种距离度量方法比较 闵氏距离的缺点： (1)将各个分量的量纲(scale)，也就是“单位”相同的看待了; (2)未考虑各个分量的分布（期望，方差等）可能是不同的。 距离和相似度度量方法 独立同分布 为什么机器学习训练时总是要求样本是独立同分布? 番外 不是需要独立同分布，而是因为如果不是独立同分布，概率模型就太复杂了， 复杂到完全没法计算，所以只能姑且用独立同分布建模了。 【机器学习】线性回归原理推导与算法描述 逻辑回归推导 逻辑回归（Logistic Regression）推导 logistic回归的数学推导 一、线性回归和逻辑回归 logistic回归，以及决策边界与回归的区别 逻辑回归与线性回归的区别 【机器学习】Logistic Regression 的前世今生（理论篇） 【面试】逻辑回归（***） 线性回归、逻辑回归（LR）(***) 逻辑回归（LR）个人学习总结篇 机器学习中的损失函数（凸函数辨别） 深度学习/机器学习入门基础数学知识整理（三）：凸优化，Hessian，牛顿法 在梯度下降法中，为什么梯度的负方向是函数下降最快的方向 【聚类】五种主要聚类算法 聚类算法及其评估指标 机器学习实战（三）——决策树 机器学习之-常见决策树算法(ID3、C4.5、CART) 信息增益就是分类前的熵 - 分类后的熵 信息增益会偏向取值较多的特征 信息增益率使用信息增益除以分支结构的熵 决策树算法——机器学习（理论+图解+python代码） CART树理解（一） 树类算法之—决策树Cart树Gini系数就算原理 基尼指数省略了对数计算，运算量比较小 而且CART树约定为二叉树 AdaBoost原理详解 机器学习（四）— 从gbdt到xgboost 详述Xgboost原理 SVM 点到直线距离公式的向量推导方法 核函数详解 核函数(kernekl)最通俗易懂的理解 常用的核函数 SMO算法最通俗易懂的解释 序列最小优化算法（SMO）浅析 SVM通常用对偶问题来求解，这样的好处有两个： 1、变量只有N个（N为训练集中的样本个数）， 原始问题中的变量数量与样本点的特征个数相同，当样本特征非常多时，求解难度较大。 2、可以方便地引入核函数，求解非线性SVM。 ROC曲线和PR(Precision-Recall)曲线的联系 详解 | Dropout为何能防止过拟合？ （BN）批量归一化全面解析 Batch Normalization(批量归一化) 深度学习（六）——BN算法（Batch Normalization）的原理和作用 但是，随着网络层次加深参数对分布的影响不定。 导致网络每层间以及不同迭代的相同相同层的输入分布发生改变， 导致网络需要重新适应新的分布，迫使我们降低学习率降低影响 神经网络的归一化（Normalization） 神经网络中normalization方法小结 神经网络算法Batch Normalization的分析与展望 | 大牛讲堂 神经网络为什么要归一化 理解BN(Batch Normalization) 关于BN(Batch Normalization)的一些归纳和总结 BN算法优势 【深度学习】深入理解Batch Normalization批标准化 郭耀华’s Blog 深度学习 — 优化入门四（Batch Normalization（批量归一化）一） 数据同分布中的数据指的是样本向量，数学上对应的是联合分布函数 大家属于同一个分布函数 不使用BN，非线性变化几次后特征向量的分布分布似乎发生了变化 BN的具体操作是，对一个批次中每条数据的对应位置进行标准归一化 向量服从同一分布这个到底想表示什么 BN(Batch Normalization) 原理与使用过程详解 统计机器学习中的一个经典假设是“源空间（source domain）和目标空间（target domain）的数据分布（distribution）是一致的 可是这里Google仅仅说“通过mini-batch来规范化某些层/所有层的输入， 从而可以固定每层输入信号的均值与方差”就可以解决问题。 如果covariate shift可以用这么简单的方法解决，那前人对其的研究也真真是白做了。 此外，试想，均值方差一致的分布就是同样的分布吗？ 深度学习—BN的理解（一） 网络训练过程中使得每一层神经网络的输入保持相同分布的。 它位于X=WU+B激活值获得之后，非线性函数变换之前 而Normalization则是把分布强行拉回到均值为0方差为1的标准正态分布， 使得激活输入值落在非线性函数对输入比较敏感的区域， 这样输入的小变化就会导致损失函数较大的变化，避免梯度消失问题产生，加速收敛 BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。 ReLU和BN层简析 BN层的出现，主要是为了解决机器学习IID问题，即训练集和测试集保持独立同分布。 如果输入的分布不能保持稳定，那么训练就会很难收敛. 为什么conv+bn+relu是有效的？ 第一，relu激活函数不是一到负数就成为dead cell的，如果是较大的负数，比如-0.5，-0.1这样子的，还是可以从dead变为active的，因为其他参数的调整，可以使输入发生变化。 只有较大的梯度，将这个神经元的激活值变为比较小的负数，比如-1000，才会形成dead relu。 第二，bn在relu之前还是之后貌似结果差别不大，翻了下原始论文，猜测作者应该是先对sigmoid做了实验，把BN放在了之前，然后relu就直接follow之前的做法了。 第三，需要理解bn的作用在于通过平滑隐藏层输入的分布，帮助随机梯度下降的进行，缓解随机梯度下降梯度衰减的情况。从这个角度来说，前和后应该是都能起到作用的。 神经网络细节 每个神经元增加两个调节参数（scale和shift），这两个参数是通过训练来学习到的，用来对变换后的激活反变换， 使得网络表达能力增强，即对变换后的激活进行如下的scale和shift操作 对这个scale和shift不太理解 深度学习中 Batch Normalization为什么效果好？知乎 BN所做的就是解决这个梯度传播的问题，因为BN作用抹去了w的scale影响 Batch Normalization原理及其TensorFlow实现——为了减少深度神经网络中的internal covariate shift，论文中提出了Batch Normalization算法，首先是对”每一层“的输入做一个Batch Normalization 变换（五星） Internal Covariate Shift与Normalization（五星） 而机器学习中有个很重要的假设：IID独立同分布假设， 就是假设训练数据和测试数据是满足相同分布的， 这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障。 那么，细化到神经网络的每一层间，每轮训练时分布都是不一致， 相对的训练效果就得不到保障，所以称为层间的covariate shift。 在深度神经网络中，由于第一层参数的改变，导致了传递给第二层的输入的分布也会发生改变， 也就是说在更新参数的过程中，无形中发生了internal covariate shift BN的作用是啥 保证每一层输入数据同分布，同时解决了梯度消失与梯度爆炸问题 每一层输入数据同分布是使用训练集训练模型有效的前提 如果不使用BN，不断的非线性变化使得不同样本对每一层的输入数据发生了层间Covariate Shift 使用BN后强制使每一层的输入分布回到均值0方差1的分布中，类似数据预处理步骤中的标准归一化 （举例理解，不同老师改同一份试卷得分不同） 同时BN的过程中增加两个调节参数（scale和shift）, 抹去了w的scale影响,从而避免了梯度消失与梯度爆炸 矩阵向量求导(Vector derivation) 常见的几种最优化方法（梯度下降法、牛顿法、拟牛顿法、共轭梯度法等） 梯度下降法的缺点： 　　靠近极小值时收敛速度减慢 　　 批量梯度下降： 每迭代一步，都要用到训练集所有的数据，如果m很大，那么可想而知这种方法的迭代速度会相当的慢 随机梯度下降： SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向， 可能会“之字形”地下降 梯度下降法的推导（非常详细、易懂的推导） 为什么参数这样更新能使loss降低 为什么局部下降最快的方向就是梯度的负方向呢 一阶泰勒展开式的推导过程 关于梯度下降法和牛顿法的数学推导 梯度下降法和牛顿法的总结与比较 利用牛顿法求解目标函数的最小值其实是转化成求使目标函数的一阶导为0的参数值。 这一转换的理论依据是，函数的极值点处的一阶导数为0. 牛顿法与Hessian矩阵 牛顿法 主要有两方面的应用： 1. 求方程的根； 2. 求解最优化方法； 要解决 f′(x) = 0 的问题 最后： xn+1 = xn - f&#39;(xn) / f&#39;′(xn) 深度学习——优化器算法Optimizer详解（BGD、SGD、MBGD、Momentum、NAG、Adagrad、Adadelta、RMSprop、Adam） 什么是指数加权平均、偏差修正？ 指数加权移动平均(Exponential Weighted Moving Average) 衡量机器学习模型的三大指标：准确率、精度和召回率。 分布不平衡数据集 --------------------------- 召回率=真正例/（真正例 + 假反例） 精度=真正例/（真正例 + 假正例） 分割线 为什么logistic回归的要用sigmoid函数？优缺点? logistic是基于Bernoulli分布的假设，而Bernoulli分布的指数族的形式就是1/(1+exp(-z)) 优点： 1.数据压缩能力，将数据规约在［0，1］之间 2.导数形式优秀，方便计算 缺点： 1.容易梯度消失，x在两端时的梯度趋近于0 2.非0中心化，在神经网络算法等情况下，造成反向传播时权重的全正全负的情况。 什么是伯努利分布 为什么logistics服从伯努利分布 指数族怎么解释 对比牛顿法、梯度下降法的关系 分割线 最全算法工程师面试题目整理(一) 1. 为什么logistic回归的要用sigmoid函数？优缺点？ 2. 对比牛顿法、梯度下降法的关系 3. 常见的正则化有是么，有什么作用，为什么l1是会把feature压缩到0而l2做不到？ 4. 分类模型如何选择？如何判断效果？如何计算AUC？你最熟悉的ensemble Classification model是什么？ 2018年BAT面试经验分享（计算机视觉算法岗 场景题：在直播网站（YY或斗鱼等）上面有一个在唱歌的女主播， 突然唱歌的时候就把衣服脱光了，你要怎么用算法检测出来这个事情，然后把这直播间关闭了。 （答：主要从动作分析、场景分析、文字分析、语音分析这四个方面来回答）。 计算机视觉与深度学习算法工程师面试题整理 1. 在梯度下降法中，为什么梯度的负方向是函数下降最快的方向？ 一阶泰勒展开的参数更新可知 2. 为什么引入Relu呢？ 3. bias的作用 y = Wx + b 才是完整的决策边界（或超平面）方程，才能囊括所有可能情况 如果没有b，就是默认b =0， 直观上就是决策边界（或超平面）必须经过原点 计算机视觉算法面试整理 直方图均衡化 计算机视觉实习面试经历 面试官很看重深度学习项目经历，因为我有一段用tensorflow进行人脸检测的实习经历， 所以被问人脸检测现状、 当前比较好的人脸检测的深度学习模型及其比较、如何获取数据集、检测效果。。。 又问了fast r-cnn具体实现，以及r-cnn发展历程--我简单介绍了fast r-cnn流程， 很可惜这段实习当时比较水，所以坦诚不太会。 计算机视觉相关面经总结 【计算机视觉算法岗面经】“吐血”整理：2019秋招资料 特征工程 特征归一化 特征归一化，意义、方法、使用场景 检验样本是否服从正态分布，处理偏态分布 数据预处理——样本分布（正态分布、偏态分布） 如何进行数据变换(转) 通俗易懂理解特征归一化对梯度下降算法的重要性 扁的那一个方向，是数域较大的方向 需要梯度下降求解的模型需要归一化处理（比如线性回归，逻辑回归等） 对于决策树模型就不需要归一化处理了 归一化的好处： 消除数据特征之间量纲的影响， 在梯度下降中的好处是参数更新的更加平稳 数据预处理：独热编码（One-Hot Encoding）和 LabelEncoder标签编码 通常用独热编码处理，类别间不具有大小关系的特征 如果按序号编码，转换后类别间产生了大小关系，相应的距离计算不合理 图片不足时的处理方法（训练数据不足的处理方法） * 基于数据，主要通过数据增强 * 使用生成模型，比如生成对抗网络？ * 基于模型，简化模型，添加正则项 * fine-tune模型 损失函数 机器学习者都应该知道的五种损失函数 目标检测 【更新中】目标检测——梳理，准备面试 计算机视觉目标检测算法综述 Fast R-CNN（理解） 传统目标检测 传统目标检测三步曲： 1. 区域选择（滑动窗口，SelectiveSearch） 2. 特征提取（SIFI，HOG） 3. 分类器训练（SVM，Adaboost） 传统目标检测流程（传统目标检测该怎么做） 第一步：训练集构造 （构建正负例样本） 正例样本：GT 负例样本：候选区域与GT重叠度在20%-50%之间， 而且与已有的负例样本的IOU少于70% 第二步：提取每个正负例样本的特征 第三步：训练分类器 第四步：把训练时的FP收集起来，对上一步训练好的模型进行二次训练 预测流程： 1.获取候选框 2.提取候选框的特征向量 3.将特征向量输入到分类器中 4.排序，过滤 a.对每个候选框根据获得的概率值进行降序排序 b.概率值小于0.5的直接过滤 c.剩下的候选框按顺序从第一个开始计算与后面候选框的IOU，保留IOU小于30%的 最后剩下的就是目标区域 补充: 手工设计的特征鲁棒性比较差，只是一些表层特征 R - CNN 1.候选区域通过SelectiveSearch生成 2.使用CNN进行特征提取 R - CNN训练流程 1.使用SelectiveSearch生成2000个候选框（构建正负例样本） 2.候选框缩放到固定尺寸（eg：227×227） 3.使用CNN提取候选框特征 4.分类训练：将特征向量输入到SVM分类器 回归训练：将特征向量输入到全连接网络进行Bounding Box回归 补充：这里分类器用SVM代替，为什么不用softmax ------------------------------------------------------- 问题： 1.算力冗余 先生成候选区域，再对区域进行卷积，这里有两个问题： 其一是候选区域会有一定程度的重叠，对相同区域进行重复卷积； 其二是每个区域进行新的卷积需要新的存储空间。 2.图片缩放 候选区域中的图像输入CNN（卷积层并不要求输入图像的尺寸固定，只有第一个全连接层需要确定输入维度， 因为它和前一层之间的权重矩阵是固定大小的，其他的全连接层也不要求图像的尺寸固定）中需要固定尺寸（227 * 227）， 会造成物体形变，导致检测性能下降。 3.训练测试不简洁 候选区域生成、特征提取、分类、回归都是分开操作， 中间数据还需要单独保存。 SPP Net 候选框特征向量提取方式的改进 通过SPP解决固定输入尺寸的限制 1.并不是先裁剪候选框，再对候选框进行卷积提取特征， 而是先对原图卷积，再从特征图中获取Proposal区域对应的特征图像 将 R - CNN 的多次卷积简化为一次卷积（减少计算量，减少存储量） 2.将特征图像输入SPP层得到固定长度的特征向量 SPP具体做法 对输入的特征图进行三种尺度的切分：4×4，2×2，1×1 对切分出来的每个小块进行max pooling下采样 将结果排列成一列向量输入到全连接中 Fast R - CNN ... 使用 smoothL1 loss的好处 数据结构与算法 详解什么是尾递归（通俗易懂，示例讲解） 递归与尾递归总结 什么场景适合尾递归" />
<meta property="og:description" content="文章目录 资料 分割线 分割线 特征工程 损失函数 目标检测 传统目标检测 R - CNN SPP Net Fast R - CNN 数据结构与算法 资料 决策边界（decision boundary） logistic回归，以及决策边界与回归的区别 吴恩达机器学习笔记16-决策边界(decision boundary) 机器学习中线性模型和非线性的区别 机器学习中线性模型和非线性的区别 怎样区分线性和非线性 线性模型 线性分类器和非线性分类器 机器学习之广义线性模型 广义线性模型到底是个什么鬼？| 协和八 逻辑回归(logistics regression) 解释logistic回归为什么要使用sigmoid函数 LG为什么用sigmoid函数 《深度学习导论及案例分析》一2.15通用逼近定理 大意就是：隐藏节点只要足够多，就能逼近任一函数 机器学习（二）：k近邻法（kNN） 机器学习：K-近邻算法（KNN） 几种距离度量方法比较 闵氏距离的缺点： (1)将各个分量的量纲(scale)，也就是“单位”相同的看待了; (2)未考虑各个分量的分布（期望，方差等）可能是不同的。 距离和相似度度量方法 独立同分布 为什么机器学习训练时总是要求样本是独立同分布? 番外 不是需要独立同分布，而是因为如果不是独立同分布，概率模型就太复杂了， 复杂到完全没法计算，所以只能姑且用独立同分布建模了。 【机器学习】线性回归原理推导与算法描述 逻辑回归推导 逻辑回归（Logistic Regression）推导 logistic回归的数学推导 一、线性回归和逻辑回归 logistic回归，以及决策边界与回归的区别 逻辑回归与线性回归的区别 【机器学习】Logistic Regression 的前世今生（理论篇） 【面试】逻辑回归（***） 线性回归、逻辑回归（LR）(***) 逻辑回归（LR）个人学习总结篇 机器学习中的损失函数（凸函数辨别） 深度学习/机器学习入门基础数学知识整理（三）：凸优化，Hessian，牛顿法 在梯度下降法中，为什么梯度的负方向是函数下降最快的方向 【聚类】五种主要聚类算法 聚类算法及其评估指标 机器学习实战（三）——决策树 机器学习之-常见决策树算法(ID3、C4.5、CART) 信息增益就是分类前的熵 - 分类后的熵 信息增益会偏向取值较多的特征 信息增益率使用信息增益除以分支结构的熵 决策树算法——机器学习（理论+图解+python代码） CART树理解（一） 树类算法之—决策树Cart树Gini系数就算原理 基尼指数省略了对数计算，运算量比较小 而且CART树约定为二叉树 AdaBoost原理详解 机器学习（四）— 从gbdt到xgboost 详述Xgboost原理 SVM 点到直线距离公式的向量推导方法 核函数详解 核函数(kernekl)最通俗易懂的理解 常用的核函数 SMO算法最通俗易懂的解释 序列最小优化算法（SMO）浅析 SVM通常用对偶问题来求解，这样的好处有两个： 1、变量只有N个（N为训练集中的样本个数）， 原始问题中的变量数量与样本点的特征个数相同，当样本特征非常多时，求解难度较大。 2、可以方便地引入核函数，求解非线性SVM。 ROC曲线和PR(Precision-Recall)曲线的联系 详解 | Dropout为何能防止过拟合？ （BN）批量归一化全面解析 Batch Normalization(批量归一化) 深度学习（六）——BN算法（Batch Normalization）的原理和作用 但是，随着网络层次加深参数对分布的影响不定。 导致网络每层间以及不同迭代的相同相同层的输入分布发生改变， 导致网络需要重新适应新的分布，迫使我们降低学习率降低影响 神经网络的归一化（Normalization） 神经网络中normalization方法小结 神经网络算法Batch Normalization的分析与展望 | 大牛讲堂 神经网络为什么要归一化 理解BN(Batch Normalization) 关于BN(Batch Normalization)的一些归纳和总结 BN算法优势 【深度学习】深入理解Batch Normalization批标准化 郭耀华’s Blog 深度学习 — 优化入门四（Batch Normalization（批量归一化）一） 数据同分布中的数据指的是样本向量，数学上对应的是联合分布函数 大家属于同一个分布函数 不使用BN，非线性变化几次后特征向量的分布分布似乎发生了变化 BN的具体操作是，对一个批次中每条数据的对应位置进行标准归一化 向量服从同一分布这个到底想表示什么 BN(Batch Normalization) 原理与使用过程详解 统计机器学习中的一个经典假设是“源空间（source domain）和目标空间（target domain）的数据分布（distribution）是一致的 可是这里Google仅仅说“通过mini-batch来规范化某些层/所有层的输入， 从而可以固定每层输入信号的均值与方差”就可以解决问题。 如果covariate shift可以用这么简单的方法解决，那前人对其的研究也真真是白做了。 此外，试想，均值方差一致的分布就是同样的分布吗？ 深度学习—BN的理解（一） 网络训练过程中使得每一层神经网络的输入保持相同分布的。 它位于X=WU+B激活值获得之后，非线性函数变换之前 而Normalization则是把分布强行拉回到均值为0方差为1的标准正态分布， 使得激活输入值落在非线性函数对输入比较敏感的区域， 这样输入的小变化就会导致损失函数较大的变化，避免梯度消失问题产生，加速收敛 BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。 ReLU和BN层简析 BN层的出现，主要是为了解决机器学习IID问题，即训练集和测试集保持独立同分布。 如果输入的分布不能保持稳定，那么训练就会很难收敛. 为什么conv+bn+relu是有效的？ 第一，relu激活函数不是一到负数就成为dead cell的，如果是较大的负数，比如-0.5，-0.1这样子的，还是可以从dead变为active的，因为其他参数的调整，可以使输入发生变化。 只有较大的梯度，将这个神经元的激活值变为比较小的负数，比如-1000，才会形成dead relu。 第二，bn在relu之前还是之后貌似结果差别不大，翻了下原始论文，猜测作者应该是先对sigmoid做了实验，把BN放在了之前，然后relu就直接follow之前的做法了。 第三，需要理解bn的作用在于通过平滑隐藏层输入的分布，帮助随机梯度下降的进行，缓解随机梯度下降梯度衰减的情况。从这个角度来说，前和后应该是都能起到作用的。 神经网络细节 每个神经元增加两个调节参数（scale和shift），这两个参数是通过训练来学习到的，用来对变换后的激活反变换， 使得网络表达能力增强，即对变换后的激活进行如下的scale和shift操作 对这个scale和shift不太理解 深度学习中 Batch Normalization为什么效果好？知乎 BN所做的就是解决这个梯度传播的问题，因为BN作用抹去了w的scale影响 Batch Normalization原理及其TensorFlow实现——为了减少深度神经网络中的internal covariate shift，论文中提出了Batch Normalization算法，首先是对”每一层“的输入做一个Batch Normalization 变换（五星） Internal Covariate Shift与Normalization（五星） 而机器学习中有个很重要的假设：IID独立同分布假设， 就是假设训练数据和测试数据是满足相同分布的， 这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障。 那么，细化到神经网络的每一层间，每轮训练时分布都是不一致， 相对的训练效果就得不到保障，所以称为层间的covariate shift。 在深度神经网络中，由于第一层参数的改变，导致了传递给第二层的输入的分布也会发生改变， 也就是说在更新参数的过程中，无形中发生了internal covariate shift BN的作用是啥 保证每一层输入数据同分布，同时解决了梯度消失与梯度爆炸问题 每一层输入数据同分布是使用训练集训练模型有效的前提 如果不使用BN，不断的非线性变化使得不同样本对每一层的输入数据发生了层间Covariate Shift 使用BN后强制使每一层的输入分布回到均值0方差1的分布中，类似数据预处理步骤中的标准归一化 （举例理解，不同老师改同一份试卷得分不同） 同时BN的过程中增加两个调节参数（scale和shift）, 抹去了w的scale影响,从而避免了梯度消失与梯度爆炸 矩阵向量求导(Vector derivation) 常见的几种最优化方法（梯度下降法、牛顿法、拟牛顿法、共轭梯度法等） 梯度下降法的缺点： 　　靠近极小值时收敛速度减慢 　　 批量梯度下降： 每迭代一步，都要用到训练集所有的数据，如果m很大，那么可想而知这种方法的迭代速度会相当的慢 随机梯度下降： SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向， 可能会“之字形”地下降 梯度下降法的推导（非常详细、易懂的推导） 为什么参数这样更新能使loss降低 为什么局部下降最快的方向就是梯度的负方向呢 一阶泰勒展开式的推导过程 关于梯度下降法和牛顿法的数学推导 梯度下降法和牛顿法的总结与比较 利用牛顿法求解目标函数的最小值其实是转化成求使目标函数的一阶导为0的参数值。 这一转换的理论依据是，函数的极值点处的一阶导数为0. 牛顿法与Hessian矩阵 牛顿法 主要有两方面的应用： 1. 求方程的根； 2. 求解最优化方法； 要解决 f′(x) = 0 的问题 最后： xn+1 = xn - f&#39;(xn) / f&#39;′(xn) 深度学习——优化器算法Optimizer详解（BGD、SGD、MBGD、Momentum、NAG、Adagrad、Adadelta、RMSprop、Adam） 什么是指数加权平均、偏差修正？ 指数加权移动平均(Exponential Weighted Moving Average) 衡量机器学习模型的三大指标：准确率、精度和召回率。 分布不平衡数据集 --------------------------- 召回率=真正例/（真正例 + 假反例） 精度=真正例/（真正例 + 假正例） 分割线 为什么logistic回归的要用sigmoid函数？优缺点? logistic是基于Bernoulli分布的假设，而Bernoulli分布的指数族的形式就是1/(1+exp(-z)) 优点： 1.数据压缩能力，将数据规约在［0，1］之间 2.导数形式优秀，方便计算 缺点： 1.容易梯度消失，x在两端时的梯度趋近于0 2.非0中心化，在神经网络算法等情况下，造成反向传播时权重的全正全负的情况。 什么是伯努利分布 为什么logistics服从伯努利分布 指数族怎么解释 对比牛顿法、梯度下降法的关系 分割线 最全算法工程师面试题目整理(一) 1. 为什么logistic回归的要用sigmoid函数？优缺点？ 2. 对比牛顿法、梯度下降法的关系 3. 常见的正则化有是么，有什么作用，为什么l1是会把feature压缩到0而l2做不到？ 4. 分类模型如何选择？如何判断效果？如何计算AUC？你最熟悉的ensemble Classification model是什么？ 2018年BAT面试经验分享（计算机视觉算法岗 场景题：在直播网站（YY或斗鱼等）上面有一个在唱歌的女主播， 突然唱歌的时候就把衣服脱光了，你要怎么用算法检测出来这个事情，然后把这直播间关闭了。 （答：主要从动作分析、场景分析、文字分析、语音分析这四个方面来回答）。 计算机视觉与深度学习算法工程师面试题整理 1. 在梯度下降法中，为什么梯度的负方向是函数下降最快的方向？ 一阶泰勒展开的参数更新可知 2. 为什么引入Relu呢？ 3. bias的作用 y = Wx + b 才是完整的决策边界（或超平面）方程，才能囊括所有可能情况 如果没有b，就是默认b =0， 直观上就是决策边界（或超平面）必须经过原点 计算机视觉算法面试整理 直方图均衡化 计算机视觉实习面试经历 面试官很看重深度学习项目经历，因为我有一段用tensorflow进行人脸检测的实习经历， 所以被问人脸检测现状、 当前比较好的人脸检测的深度学习模型及其比较、如何获取数据集、检测效果。。。 又问了fast r-cnn具体实现，以及r-cnn发展历程--我简单介绍了fast r-cnn流程， 很可惜这段实习当时比较水，所以坦诚不太会。 计算机视觉相关面经总结 【计算机视觉算法岗面经】“吐血”整理：2019秋招资料 特征工程 特征归一化 特征归一化，意义、方法、使用场景 检验样本是否服从正态分布，处理偏态分布 数据预处理——样本分布（正态分布、偏态分布） 如何进行数据变换(转) 通俗易懂理解特征归一化对梯度下降算法的重要性 扁的那一个方向，是数域较大的方向 需要梯度下降求解的模型需要归一化处理（比如线性回归，逻辑回归等） 对于决策树模型就不需要归一化处理了 归一化的好处： 消除数据特征之间量纲的影响， 在梯度下降中的好处是参数更新的更加平稳 数据预处理：独热编码（One-Hot Encoding）和 LabelEncoder标签编码 通常用独热编码处理，类别间不具有大小关系的特征 如果按序号编码，转换后类别间产生了大小关系，相应的距离计算不合理 图片不足时的处理方法（训练数据不足的处理方法） * 基于数据，主要通过数据增强 * 使用生成模型，比如生成对抗网络？ * 基于模型，简化模型，添加正则项 * fine-tune模型 损失函数 机器学习者都应该知道的五种损失函数 目标检测 【更新中】目标检测——梳理，准备面试 计算机视觉目标检测算法综述 Fast R-CNN（理解） 传统目标检测 传统目标检测三步曲： 1. 区域选择（滑动窗口，SelectiveSearch） 2. 特征提取（SIFI，HOG） 3. 分类器训练（SVM，Adaboost） 传统目标检测流程（传统目标检测该怎么做） 第一步：训练集构造 （构建正负例样本） 正例样本：GT 负例样本：候选区域与GT重叠度在20%-50%之间， 而且与已有的负例样本的IOU少于70% 第二步：提取每个正负例样本的特征 第三步：训练分类器 第四步：把训练时的FP收集起来，对上一步训练好的模型进行二次训练 预测流程： 1.获取候选框 2.提取候选框的特征向量 3.将特征向量输入到分类器中 4.排序，过滤 a.对每个候选框根据获得的概率值进行降序排序 b.概率值小于0.5的直接过滤 c.剩下的候选框按顺序从第一个开始计算与后面候选框的IOU，保留IOU小于30%的 最后剩下的就是目标区域 补充: 手工设计的特征鲁棒性比较差，只是一些表层特征 R - CNN 1.候选区域通过SelectiveSearch生成 2.使用CNN进行特征提取 R - CNN训练流程 1.使用SelectiveSearch生成2000个候选框（构建正负例样本） 2.候选框缩放到固定尺寸（eg：227×227） 3.使用CNN提取候选框特征 4.分类训练：将特征向量输入到SVM分类器 回归训练：将特征向量输入到全连接网络进行Bounding Box回归 补充：这里分类器用SVM代替，为什么不用softmax ------------------------------------------------------- 问题： 1.算力冗余 先生成候选区域，再对区域进行卷积，这里有两个问题： 其一是候选区域会有一定程度的重叠，对相同区域进行重复卷积； 其二是每个区域进行新的卷积需要新的存储空间。 2.图片缩放 候选区域中的图像输入CNN（卷积层并不要求输入图像的尺寸固定，只有第一个全连接层需要确定输入维度， 因为它和前一层之间的权重矩阵是固定大小的，其他的全连接层也不要求图像的尺寸固定）中需要固定尺寸（227 * 227）， 会造成物体形变，导致检测性能下降。 3.训练测试不简洁 候选区域生成、特征提取、分类、回归都是分开操作， 中间数据还需要单独保存。 SPP Net 候选框特征向量提取方式的改进 通过SPP解决固定输入尺寸的限制 1.并不是先裁剪候选框，再对候选框进行卷积提取特征， 而是先对原图卷积，再从特征图中获取Proposal区域对应的特征图像 将 R - CNN 的多次卷积简化为一次卷积（减少计算量，减少存储量） 2.将特征图像输入SPP层得到固定长度的特征向量 SPP具体做法 对输入的特征图进行三种尺度的切分：4×4，2×2，1×1 对切分出来的每个小块进行max pooling下采样 将结果排列成一列向量输入到全连接中 Fast R - CNN ... 使用 smoothL1 loss的好处 数据结构与算法 详解什么是尾递归（通俗易懂，示例讲解） 递归与尾递归总结 什么场景适合尾递归" />
<link rel="canonical" href="https://uzzz.org/2019/08/21/794451.html" />
<meta property="og:url" content="https://uzzz.org/2019/08/21/794451.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-21T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"文章目录 资料 分割线 分割线 特征工程 损失函数 目标检测 传统目标检测 R - CNN SPP Net Fast R - CNN 数据结构与算法 资料 决策边界（decision boundary） logistic回归，以及决策边界与回归的区别 吴恩达机器学习笔记16-决策边界(decision boundary) 机器学习中线性模型和非线性的区别 机器学习中线性模型和非线性的区别 怎样区分线性和非线性 线性模型 线性分类器和非线性分类器 机器学习之广义线性模型 广义线性模型到底是个什么鬼？| 协和八 逻辑回归(logistics regression) 解释logistic回归为什么要使用sigmoid函数 LG为什么用sigmoid函数 《深度学习导论及案例分析》一2.15通用逼近定理 大意就是：隐藏节点只要足够多，就能逼近任一函数 机器学习（二）：k近邻法（kNN） 机器学习：K-近邻算法（KNN） 几种距离度量方法比较 闵氏距离的缺点： (1)将各个分量的量纲(scale)，也就是“单位”相同的看待了; (2)未考虑各个分量的分布（期望，方差等）可能是不同的。 距离和相似度度量方法 独立同分布 为什么机器学习训练时总是要求样本是独立同分布? 番外 不是需要独立同分布，而是因为如果不是独立同分布，概率模型就太复杂了， 复杂到完全没法计算，所以只能姑且用独立同分布建模了。 【机器学习】线性回归原理推导与算法描述 逻辑回归推导 逻辑回归（Logistic Regression）推导 logistic回归的数学推导 一、线性回归和逻辑回归 logistic回归，以及决策边界与回归的区别 逻辑回归与线性回归的区别 【机器学习】Logistic Regression 的前世今生（理论篇） 【面试】逻辑回归（***） 线性回归、逻辑回归（LR）(***) 逻辑回归（LR）个人学习总结篇 机器学习中的损失函数（凸函数辨别） 深度学习/机器学习入门基础数学知识整理（三）：凸优化，Hessian，牛顿法 在梯度下降法中，为什么梯度的负方向是函数下降最快的方向 【聚类】五种主要聚类算法 聚类算法及其评估指标 机器学习实战（三）——决策树 机器学习之-常见决策树算法(ID3、C4.5、CART) 信息增益就是分类前的熵 - 分类后的熵 信息增益会偏向取值较多的特征 信息增益率使用信息增益除以分支结构的熵 决策树算法——机器学习（理论+图解+python代码） CART树理解（一） 树类算法之—决策树Cart树Gini系数就算原理 基尼指数省略了对数计算，运算量比较小 而且CART树约定为二叉树 AdaBoost原理详解 机器学习（四）— 从gbdt到xgboost 详述Xgboost原理 SVM 点到直线距离公式的向量推导方法 核函数详解 核函数(kernekl)最通俗易懂的理解 常用的核函数 SMO算法最通俗易懂的解释 序列最小优化算法（SMO）浅析 SVM通常用对偶问题来求解，这样的好处有两个： 1、变量只有N个（N为训练集中的样本个数）， 原始问题中的变量数量与样本点的特征个数相同，当样本特征非常多时，求解难度较大。 2、可以方便地引入核函数，求解非线性SVM。 ROC曲线和PR(Precision-Recall)曲线的联系 详解 | Dropout为何能防止过拟合？ （BN）批量归一化全面解析 Batch Normalization(批量归一化) 深度学习（六）——BN算法（Batch Normalization）的原理和作用 但是，随着网络层次加深参数对分布的影响不定。 导致网络每层间以及不同迭代的相同相同层的输入分布发生改变， 导致网络需要重新适应新的分布，迫使我们降低学习率降低影响 神经网络的归一化（Normalization） 神经网络中normalization方法小结 神经网络算法Batch Normalization的分析与展望 | 大牛讲堂 神经网络为什么要归一化 理解BN(Batch Normalization) 关于BN(Batch Normalization)的一些归纳和总结 BN算法优势 【深度学习】深入理解Batch Normalization批标准化 郭耀华’s Blog 深度学习 — 优化入门四（Batch Normalization（批量归一化）一） 数据同分布中的数据指的是样本向量，数学上对应的是联合分布函数 大家属于同一个分布函数 不使用BN，非线性变化几次后特征向量的分布分布似乎发生了变化 BN的具体操作是，对一个批次中每条数据的对应位置进行标准归一化 向量服从同一分布这个到底想表示什么 BN(Batch Normalization) 原理与使用过程详解 统计机器学习中的一个经典假设是“源空间（source domain）和目标空间（target domain）的数据分布（distribution）是一致的 可是这里Google仅仅说“通过mini-batch来规范化某些层/所有层的输入， 从而可以固定每层输入信号的均值与方差”就可以解决问题。 如果covariate shift可以用这么简单的方法解决，那前人对其的研究也真真是白做了。 此外，试想，均值方差一致的分布就是同样的分布吗？ 深度学习—BN的理解（一） 网络训练过程中使得每一层神经网络的输入保持相同分布的。 它位于X=WU+B激活值获得之后，非线性函数变换之前 而Normalization则是把分布强行拉回到均值为0方差为1的标准正态分布， 使得激活输入值落在非线性函数对输入比较敏感的区域， 这样输入的小变化就会导致损失函数较大的变化，避免梯度消失问题产生，加速收敛 BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。 ReLU和BN层简析 BN层的出现，主要是为了解决机器学习IID问题，即训练集和测试集保持独立同分布。 如果输入的分布不能保持稳定，那么训练就会很难收敛. 为什么conv+bn+relu是有效的？ 第一，relu激活函数不是一到负数就成为dead cell的，如果是较大的负数，比如-0.5，-0.1这样子的，还是可以从dead变为active的，因为其他参数的调整，可以使输入发生变化。 只有较大的梯度，将这个神经元的激活值变为比较小的负数，比如-1000，才会形成dead relu。 第二，bn在relu之前还是之后貌似结果差别不大，翻了下原始论文，猜测作者应该是先对sigmoid做了实验，把BN放在了之前，然后relu就直接follow之前的做法了。 第三，需要理解bn的作用在于通过平滑隐藏层输入的分布，帮助随机梯度下降的进行，缓解随机梯度下降梯度衰减的情况。从这个角度来说，前和后应该是都能起到作用的。 神经网络细节 每个神经元增加两个调节参数（scale和shift），这两个参数是通过训练来学习到的，用来对变换后的激活反变换， 使得网络表达能力增强，即对变换后的激活进行如下的scale和shift操作 对这个scale和shift不太理解 深度学习中 Batch Normalization为什么效果好？知乎 BN所做的就是解决这个梯度传播的问题，因为BN作用抹去了w的scale影响 Batch Normalization原理及其TensorFlow实现——为了减少深度神经网络中的internal covariate shift，论文中提出了Batch Normalization算法，首先是对”每一层“的输入做一个Batch Normalization 变换（五星） Internal Covariate Shift与Normalization（五星） 而机器学习中有个很重要的假设：IID独立同分布假设， 就是假设训练数据和测试数据是满足相同分布的， 这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障。 那么，细化到神经网络的每一层间，每轮训练时分布都是不一致， 相对的训练效果就得不到保障，所以称为层间的covariate shift。 在深度神经网络中，由于第一层参数的改变，导致了传递给第二层的输入的分布也会发生改变， 也就是说在更新参数的过程中，无形中发生了internal covariate shift BN的作用是啥 保证每一层输入数据同分布，同时解决了梯度消失与梯度爆炸问题 每一层输入数据同分布是使用训练集训练模型有效的前提 如果不使用BN，不断的非线性变化使得不同样本对每一层的输入数据发生了层间Covariate Shift 使用BN后强制使每一层的输入分布回到均值0方差1的分布中，类似数据预处理步骤中的标准归一化 （举例理解，不同老师改同一份试卷得分不同） 同时BN的过程中增加两个调节参数（scale和shift）, 抹去了w的scale影响,从而避免了梯度消失与梯度爆炸 矩阵向量求导(Vector derivation) 常见的几种最优化方法（梯度下降法、牛顿法、拟牛顿法、共轭梯度法等） 梯度下降法的缺点： 　　靠近极小值时收敛速度减慢 　　 批量梯度下降： 每迭代一步，都要用到训练集所有的数据，如果m很大，那么可想而知这种方法的迭代速度会相当的慢 随机梯度下降： SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向， 可能会“之字形”地下降 梯度下降法的推导（非常详细、易懂的推导） 为什么参数这样更新能使loss降低 为什么局部下降最快的方向就是梯度的负方向呢 一阶泰勒展开式的推导过程 关于梯度下降法和牛顿法的数学推导 梯度下降法和牛顿法的总结与比较 利用牛顿法求解目标函数的最小值其实是转化成求使目标函数的一阶导为0的参数值。 这一转换的理论依据是，函数的极值点处的一阶导数为0. 牛顿法与Hessian矩阵 牛顿法 主要有两方面的应用： 1. 求方程的根； 2. 求解最优化方法； 要解决 f′(x) = 0 的问题 最后： xn+1 = xn - f&#39;(xn) / f&#39;′(xn) 深度学习——优化器算法Optimizer详解（BGD、SGD、MBGD、Momentum、NAG、Adagrad、Adadelta、RMSprop、Adam） 什么是指数加权平均、偏差修正？ 指数加权移动平均(Exponential Weighted Moving Average) 衡量机器学习模型的三大指标：准确率、精度和召回率。 分布不平衡数据集 --------------------------- 召回率=真正例/（真正例 + 假反例） 精度=真正例/（真正例 + 假正例） 分割线 为什么logistic回归的要用sigmoid函数？优缺点? logistic是基于Bernoulli分布的假设，而Bernoulli分布的指数族的形式就是1/(1+exp(-z)) 优点： 1.数据压缩能力，将数据规约在［0，1］之间 2.导数形式优秀，方便计算 缺点： 1.容易梯度消失，x在两端时的梯度趋近于0 2.非0中心化，在神经网络算法等情况下，造成反向传播时权重的全正全负的情况。 什么是伯努利分布 为什么logistics服从伯努利分布 指数族怎么解释 对比牛顿法、梯度下降法的关系 分割线 最全算法工程师面试题目整理(一) 1. 为什么logistic回归的要用sigmoid函数？优缺点？ 2. 对比牛顿法、梯度下降法的关系 3. 常见的正则化有是么，有什么作用，为什么l1是会把feature压缩到0而l2做不到？ 4. 分类模型如何选择？如何判断效果？如何计算AUC？你最熟悉的ensemble Classification model是什么？ 2018年BAT面试经验分享（计算机视觉算法岗 场景题：在直播网站（YY或斗鱼等）上面有一个在唱歌的女主播， 突然唱歌的时候就把衣服脱光了，你要怎么用算法检测出来这个事情，然后把这直播间关闭了。 （答：主要从动作分析、场景分析、文字分析、语音分析这四个方面来回答）。 计算机视觉与深度学习算法工程师面试题整理 1. 在梯度下降法中，为什么梯度的负方向是函数下降最快的方向？ 一阶泰勒展开的参数更新可知 2. 为什么引入Relu呢？ 3. bias的作用 y = Wx + b 才是完整的决策边界（或超平面）方程，才能囊括所有可能情况 如果没有b，就是默认b =0， 直观上就是决策边界（或超平面）必须经过原点 计算机视觉算法面试整理 直方图均衡化 计算机视觉实习面试经历 面试官很看重深度学习项目经历，因为我有一段用tensorflow进行人脸检测的实习经历， 所以被问人脸检测现状、 当前比较好的人脸检测的深度学习模型及其比较、如何获取数据集、检测效果。。。 又问了fast r-cnn具体实现，以及r-cnn发展历程--我简单介绍了fast r-cnn流程， 很可惜这段实习当时比较水，所以坦诚不太会。 计算机视觉相关面经总结 【计算机视觉算法岗面经】“吐血”整理：2019秋招资料 特征工程 特征归一化 特征归一化，意义、方法、使用场景 检验样本是否服从正态分布，处理偏态分布 数据预处理——样本分布（正态分布、偏态分布） 如何进行数据变换(转) 通俗易懂理解特征归一化对梯度下降算法的重要性 扁的那一个方向，是数域较大的方向 需要梯度下降求解的模型需要归一化处理（比如线性回归，逻辑回归等） 对于决策树模型就不需要归一化处理了 归一化的好处： 消除数据特征之间量纲的影响， 在梯度下降中的好处是参数更新的更加平稳 数据预处理：独热编码（One-Hot Encoding）和 LabelEncoder标签编码 通常用独热编码处理，类别间不具有大小关系的特征 如果按序号编码，转换后类别间产生了大小关系，相应的距离计算不合理 图片不足时的处理方法（训练数据不足的处理方法） * 基于数据，主要通过数据增强 * 使用生成模型，比如生成对抗网络？ * 基于模型，简化模型，添加正则项 * fine-tune模型 损失函数 机器学习者都应该知道的五种损失函数 目标检测 【更新中】目标检测——梳理，准备面试 计算机视觉目标检测算法综述 Fast R-CNN（理解） 传统目标检测 传统目标检测三步曲： 1. 区域选择（滑动窗口，SelectiveSearch） 2. 特征提取（SIFI，HOG） 3. 分类器训练（SVM，Adaboost） 传统目标检测流程（传统目标检测该怎么做） 第一步：训练集构造 （构建正负例样本） 正例样本：GT 负例样本：候选区域与GT重叠度在20%-50%之间， 而且与已有的负例样本的IOU少于70% 第二步：提取每个正负例样本的特征 第三步：训练分类器 第四步：把训练时的FP收集起来，对上一步训练好的模型进行二次训练 预测流程： 1.获取候选框 2.提取候选框的特征向量 3.将特征向量输入到分类器中 4.排序，过滤 a.对每个候选框根据获得的概率值进行降序排序 b.概率值小于0.5的直接过滤 c.剩下的候选框按顺序从第一个开始计算与后面候选框的IOU，保留IOU小于30%的 最后剩下的就是目标区域 补充: 手工设计的特征鲁棒性比较差，只是一些表层特征 R - CNN 1.候选区域通过SelectiveSearch生成 2.使用CNN进行特征提取 R - CNN训练流程 1.使用SelectiveSearch生成2000个候选框（构建正负例样本） 2.候选框缩放到固定尺寸（eg：227×227） 3.使用CNN提取候选框特征 4.分类训练：将特征向量输入到SVM分类器 回归训练：将特征向量输入到全连接网络进行Bounding Box回归 补充：这里分类器用SVM代替，为什么不用softmax ------------------------------------------------------- 问题： 1.算力冗余 先生成候选区域，再对区域进行卷积，这里有两个问题： 其一是候选区域会有一定程度的重叠，对相同区域进行重复卷积； 其二是每个区域进行新的卷积需要新的存储空间。 2.图片缩放 候选区域中的图像输入CNN（卷积层并不要求输入图像的尺寸固定，只有第一个全连接层需要确定输入维度， 因为它和前一层之间的权重矩阵是固定大小的，其他的全连接层也不要求图像的尺寸固定）中需要固定尺寸（227 * 227）， 会造成物体形变，导致检测性能下降。 3.训练测试不简洁 候选区域生成、特征提取、分类、回归都是分开操作， 中间数据还需要单独保存。 SPP Net 候选框特征向量提取方式的改进 通过SPP解决固定输入尺寸的限制 1.并不是先裁剪候选框，再对候选框进行卷积提取特征， 而是先对原图卷积，再从特征图中获取Proposal区域对应的特征图像 将 R - CNN 的多次卷积简化为一次卷积（减少计算量，减少存储量） 2.将特征图像输入SPP层得到固定长度的特征向量 SPP具体做法 对输入的特征图进行三种尺度的切分：4×4，2×2，1×1 对切分出来的每个小块进行max pooling下采样 将结果排列成一列向量输入到全连接中 Fast R - CNN ... 使用 smoothL1 loss的好处 数据结构与算法 详解什么是尾递归（通俗易懂，示例讲解） 递归与尾递归总结 什么场景适合尾递归","@type":"BlogPosting","url":"https://uzzz.org/2019/08/21/794451.html","headline":"笔记 :归纳总结 (一)","dateModified":"2019-08-21T00:00:00+08:00","datePublished":"2019-08-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/08/21/794451.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>笔记 :归纳总结 (一)</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div id="content_views" class="markdown_views prism-tomorrow-night-eighties"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> 
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path> 
  </svg> 
  <p></p>
  <div class="toc">
   <h3>文章目录</h3>
   <ul>
    <li><a href="#_1" rel="nofollow" data-token="478b451f06ef61b6b2c27f833f17ba83">资料</a></li>
    <ul>
     <li><a href="#_276" rel="nofollow" data-token="b0f7d27361ae5e1318f911d984ebee9b">分割线</a></li>
     <li><a href="#_299" rel="nofollow" data-token="caab20699fc7de2944cabc11a3279159">分割线</a></li>
     <li><a href="#_343" rel="nofollow" data-token="57d82d202dd256e19c25dcb51f0db666">特征工程</a></li>
     <li><a href="#_376" rel="nofollow" data-token="aa8259161b9570658e6d7eebe4dd916d">损失函数</a></li>
     <li><a href="#_379" rel="nofollow" data-token="f79c0f49668c859e4225a0eb398878f6">目标检测</a></li>
     <ul>
      <ul>
       <ul>
        <ul>
         <li><a href="#_384" rel="nofollow" data-token="9f6006ed6fe862a556cc7a20d740d0b9">传统目标检测</a></li>
         <li><a href="#R__CNN_421" rel="nofollow" data-token="cc0ba8f932de94aef001c4aab0003920">R - CNN</a></li>
         <li><a href="#SPP_Net_452" rel="nofollow" data-token="0563f17b5d477ac2917836adea41fc1d">SPP Net</a></li>
         <li><a href="#Fast_R__CNN_469" rel="nofollow" data-token="5747397113b8ee13757aa14c52c230af">Fast R - CNN</a></li>
        </ul>
       </ul>
      </ul>
     </ul>
     <li><a href="#_476" rel="nofollow" data-token="39b0e3f4afa62402e46dd3c315697898">数据结构与算法</a></li>
    </ul>
   </ul>
  </div>
  <p></p> 
  <h1><a id="_1"></a>资料</h1> 
  <p><a href="https://www.jianshu.com/p/9f40c95a2c5e" rel="nofollow" data-token="d7eb75ca74b72411ed4e2f9638ed3ce3">决策边界（decision boundary）</a><br> <a href="https://blog.csdn.net/zxyhhjs2017/article/details/78842379" rel="nofollow" data-token="ff6b57cf8cda300d6977e35ab2143e79">logistic回归，以及决策边界与回归的区别</a><br> <a href="https://www.cnblogs.com/sl0309/p/10390705.html" rel="nofollow" data-token="bb6d51ed06f2d2d8fb39fb537519a3a3">吴恩达机器学习笔记16-决策边界(decision boundary)</a><br> <a href="https://zhuanlan.zhihu.com/p/37866896" rel="nofollow" data-token="a90922c48c2f502e6808a38e7385c39b">机器学习中线性模型和非线性的区别</a><br> <a href="https://blog.csdn.net/wbcnb/article/details/78306970#commentsedit" rel="nofollow" data-token="6de08f56d6580d5791948214cbe0c40f">机器学习中线性模型和非线性的区别</a><br> <a href="http://www.elecfans.com/d/654034.html" rel="nofollow" data-token="54c0cf0aaf1108acf6798700f5d343bd">怎样区分线性和非线性</a><br> <a href="https://blog.csdn.net/u010358304/article/details/81257595" rel="nofollow" data-token="02dfd35fd038bbeaf65326beda323d4a">线性模型</a><br> <a href="https://blog.csdn.net/u014755493/article/details/70182532" rel="nofollow" data-token="4bf38fb12d954822a19e03a61d784ab5">线性分类器和非线性分类器</a></p> 
  <hr> 
  <p><a href="https://blog.csdn.net/weixin_37140379/article/details/82289704" rel="nofollow" data-token="1980e257bfb6d0b42e0df658a9313de5">机器学习之广义线性模型</a><br> <a href="http://www.360doc.com/content/18/0416/12/33459258_746066459.shtml" rel="nofollow" data-token="e7c52b9b021324b8a72d6b7d9a9f71ae">广义线性模型到底是个什么鬼？| 协和八</a><br> <a href="https://blog.csdn.net/weixin_39445556/article/details/83930186" rel="nofollow" data-token="370cd21c7e43a931de0f6abc4a85a543">逻辑回归(logistics regression)</a><br> <a href="https://blog.csdn.net/qq_19645269/article/details/79551576" rel="nofollow" data-token="34bb1c18797e016ecb3dea9348a7259d">解释logistic回归为什么要使用sigmoid函数</a><br> <a href="https://www.jianshu.com/p/20d2141d74d2" rel="nofollow" data-token="9757b1525cb56ad01f87d7164ba8026c">LG为什么用sigmoid函数</a></p> 
  <hr> 
  <p><a href="https://yq.aliyun.com/articles/89552" rel="nofollow" data-token="75b9311b47e40368716117b805889eab">《深度学习导论及案例分析》一2.15通用逼近定理</a><br> 大意就是：隐藏节点只要足够多，就能逼近任一函数</p> 
  <hr> 
  <p><a href="https://blog.csdn.net/eeeee123456/article/details/79927128" rel="nofollow" data-token="bafb4740aa4cc482e2a43002b358fbb8">机器学习（二）：k近邻法（kNN）</a><br> <a href="https://www.cnblogs.com/fwl8888/p/9661130.html" rel="nofollow" data-token="c75a36132ce2c1785c2ad862cb0b98f3">机器学习：K-近邻算法（KNN）</a></p> 
  <hr> 
  <p><a href="https://blog.csdn.net/J_Boom/article/details/86763024" rel="nofollow" data-token="74c19b17cb360ca853ea317badd0f76b">几种距离度量方法比较</a></p> 
  <pre><code>闵氏距离的缺点：
(1)将各个分量的量纲(scale)，也就是“单位”相同的看待了;
(2)未考虑各个分量的分布（期望，方差等）可能是不同的。
</code></pre> 
  <p><a href="https://blog.csdn.net/pipisorry/article/details/45651315" rel="nofollow" data-token="f8d594d6daf80c666076bd4c4c4126ed">距离和相似度度量方法</a></p> 
  <hr> 
  <p><a href="https://blog.csdn.net/FRBeVrQbN4L/article/details/80153788" rel="nofollow" data-token="e0bd148e555877555e502c3e136ea0c5">独立同分布</a><br> <a href="https://www.jianshu.com/p/c83740db5c95" rel="nofollow" data-token="f099a73fbc035149cef5e14eb94c6bd9">为什么机器学习训练时总是要求样本是独立同分布?</a></p> 
  <ul> 
   <li>番外</li> 
  </ul> 
  <pre><code>不是需要独立同分布，而是因为如果不是独立同分布，概率模型就太复杂了，
复杂到完全没法计算，所以只能姑且用独立同分布建模了。
</code></pre> 
  <hr> 
  <p><a href="https://blog.csdn.net/pxhdky/article/details/82388964" rel="nofollow" data-token="63aa67acfa80bac30eea63e2537cfac7">【机器学习】线性回归原理推导与算法描述</a></p> 
  <hr> 
  <p><a href="https://blog.csdn.net/u014258807/article/details/80616647" rel="nofollow" data-token="4bf339be718b237345149dd873cadcdb">逻辑回归推导</a><br> <a href="https://www.cnblogs.com/lxs0731/p/8573044.html" rel="nofollow" data-token="5aeb967744517c0e3da118c825aa55db">逻辑回归（Logistic Regression）推导</a><br> <a href="https://blog.csdn.net/powder_snow/article/details/78886918" rel="nofollow" data-token="614a571db526d6355521ad514f79dce7">logistic回归的数学推导</a><br> <a href="https://blog.csdn.net/jiaoyangwm/article/details/81139362" rel="nofollow" data-token="06af9c87e153b68ecb18014e300457a0">一、线性回归和逻辑回归</a><br> <a href="https://blog.csdn.net/zxyhhjs2017/article/details/78842379" rel="nofollow" data-token="ff6b57cf8cda300d6977e35ab2143e79">logistic回归，以及决策边界与回归的区别</a><br> <a href="https://blog.51cto.com/12597095/2093869" rel="nofollow" data-token="7d650e6c848566e1f7d869095f95f702">逻辑回归与线性回归的区别</a><br> <a href="https://blog.csdn.net/cyh_24/article/details/50359055" rel="nofollow" data-token="e04e6e3af68b327b1213ea77c47e045b">【机器学习】Logistic Regression 的前世今生（理论篇）</a><br> <a href="https://www.jianshu.com/p/ece51cf6aa36" rel="nofollow" data-token="78665b787e642e7449965bab9bf2afcc">【面试】逻辑回归（***）</a><br> <a href="https://www.cnblogs.com/zhibei/p/9349254.html" rel="nofollow" data-token="e3cebb3715e0895fc0e910334bd7a865">线性回归、逻辑回归（LR）(***)</a><br> <a href="https://www.jianshu.com/p/fa411ffb5490" rel="nofollow" data-token="a6f0eb16032688e0b65cbea0afc49dcd">逻辑回归（LR）个人学习总结篇</a></p> 
  <hr> 
  <p><a href="https://blog.csdn.net/lc574260570/article/details/81708616" rel="nofollow" data-token="b95ea523287f7865e7801a83c8747895">机器学习中的损失函数（凸函数辨别）</a><br> <a href="https://blog.csdn.net/xbinworld/article/details/79113218" rel="nofollow" data-token="df4537cf55f894651ca6d3d22104da28">深度学习/机器学习入门基础数学知识整理（三）：凸优化，Hessian，牛顿法</a><br> <a href="https://blog.csdn.net/llwleon/article/details/79237053" rel="nofollow" data-token="45951cdd69addfcdb96bf0c684767a4d">在梯度下降法中，为什么梯度的负方向是函数下降最快的方向</a></p> 
  <hr> 
  <p><a href="https://blog.csdn.net/u011511601/article/details/81951939" rel="nofollow" data-token="89b8da59c3d994de4461988f1253866e">【聚类】五种主要聚类算法</a><br> <a href="https://www.cnblogs.com/czhwust/p/mlclusterpre.html" rel="nofollow" data-token="587154a426180cb2dcf7c6ffc3b753ab">聚类算法及其评估指标</a></p> 
  <hr> 
  <p><a href="https://blog.csdn.net/jiaoyangwm/article/details/79525237" rel="nofollow" data-token="796ee6584f2e7f1154c96e16c3476723">机器学习实战（三）——决策树</a><br> <a href="https://shuwoom.com/?p=1452" rel="nofollow" data-token="25760fcf29576e8e7cf6f203c347316a">机器学习之-常见决策树算法(ID3、C4.5、CART)</a></p> 
  <pre><code>信息增益就是分类前的熵 - 分类后的熵

信息增益会偏向取值较多的特征
信息增益率使用信息增益除以分支结构的熵
</code></pre> 
  <p><a href="https://blog.csdn.net/huacha__/article/details/80919426" rel="nofollow" data-token="8bd948472a2e8c905a443564eff955f9">决策树算法——机器学习（理论+图解+python代码）</a><br> <a href="https://www.jianshu.com/p/ba3e67ca96b0" rel="nofollow" data-token="22e64e984f79b71c66e785f07202a8b9">CART树理解（一）</a><br> <a href="https://blog.csdn.net/weixin_41843918/article/details/90485566" rel="nofollow" data-token="5d7064a8bea589db162b639558b0da49">树类算法之—决策树Cart树Gini系数就算原理</a></p> 
  <pre><code>基尼指数省略了对数计算，运算量比较小

而且CART树约定为二叉树
</code></pre> 
  <hr> 
  <p><a href="https://www.cnblogs.com/ScorpioLu/p/8295990.html" rel="nofollow" data-token="623223a1eaffff3b615107458c61af30">AdaBoost原理详解</a><br> <a href="https://www.cnblogs.com/mfryf/p/5946815.html" rel="nofollow" data-token="906d64dc9e42010638f3f0df9888b494">机器学习（四）— 从gbdt到xgboost</a><br> <a href="https://www.cnblogs.com/kuangsyx/p/9043168.html" rel="nofollow" data-token="f48c348673c13f2995551c036ca581fb">详述Xgboost原理</a></p> 
  <hr> 
  <ul> 
   <li>SVM<br> <a href="http://www.360doc.com/content/18/0811/10/47813312_777396011.shtml" rel="nofollow" data-token="08d07c7e3e3549eed3aa8f3a0a9df67f">点到直线距离公式的向量推导方法</a><br> <a href="https://blog.csdn.net/kateyabc/article/details/79980880" rel="nofollow" data-token="2e485169e9bf80f0e1f5e09463f64eb8">核函数详解</a><br> <a href="https://www.tinymind.cn/articles/655" rel="nofollow" data-token="3e5aef1281b3fdb7276a347902d6434c">核函数(kernekl)最通俗易懂的理解</a><br> <a href="https://blog.csdn.net/weixin_41048094/article/details/82796312" rel="nofollow" data-token="4500ac6039a1cbc9c3101b3018553a4a">常用的核函数</a><br> <a href="https://blog.csdn.net/qq_39521554/article/details/80723770" rel="nofollow" data-token="27b0f787656693e83974972c67052cb9">SMO算法最通俗易懂的解释</a><br> <a href="https://www.jianshu.com/p/eef51f939ace" rel="nofollow" data-token="59b840b32864aa61dee1552bfa764b1b">序列最小优化算法（SMO）浅析</a></li> 
  </ul> 
  <pre><code>SVM通常用对偶问题来求解，这样的好处有两个：
1、变量只有N个（N为训练集中的样本个数），
原始问题中的变量数量与样本点的特征个数相同，当样本特征非常多时，求解难度较大。
2、可以方便地引入核函数，求解非线性SVM。
</code></pre> 
  <hr> 
  <p><a href="http://blog.sina.com.cn/s/blog_17b9e19320102x7ru.html" rel="nofollow" data-token="dae1afecad11e9ab008b80ccd56bce90">ROC曲线和PR(Precision-Recall)曲线的联系</a></p> 
  <hr> 
  <p><a href="https://blog.csdn.net/dQCFKyQDXYm3F8rB0/article/details/81976571" rel="nofollow" data-token="670e68bed8612e68a4a3cdc0652c52b7">详解 | Dropout为何能防止过拟合？</a></p> 
  <hr> 
  <p><a href="https://blog.csdn.net/qq_41853758/article/details/82930944" rel="nofollow" data-token="c588125adcda070c9b1453ec9342c2fd">（BN）批量归一化全面解析</a><br> <a href="https://blog.csdn.net/clearch/article/details/80266622" rel="nofollow" data-token="859942c1f28230629ec61a62b22fe5fd">Batch Normalization(批量归一化)</a><br> <a href="https://blog.csdn.net/qq_37100442/article/details/81776191" rel="nofollow" data-token="daf8112799cfbaa4ff8a7babcafcca36">深度学习（六）——BN算法（Batch Normalization）的原理和作用</a></p> 
  <pre><code>但是，随着网络层次加深参数对分布的影响不定。
导致网络每层间以及不同迭代的相同相同层的输入分布发生改变，
导致网络需要重新适应新的分布，迫使我们降低学习率降低影响
</code></pre> 
  <p><a href="https://blog.csdn.net/lingdexixixi/article/details/79691255" rel="nofollow" data-token="ad757d988acc22bb947552690e4b2226">神经网络的归一化（Normalization）</a><br> <a href="https://blog.csdn.net/qq_24153697/article/details/79880202" rel="nofollow" data-token="40794b819f6b3e681549af322dd9aa2c">神经网络中normalization方法小结</a><br> <a href="https://www.leiphone.com/news/201611/oykRjZskXc2kByKx.html" rel="nofollow" data-token="90635447eab4a93b67cf2a99941e724f">神经网络算法Batch Normalization的分析与展望 | 大牛讲堂</a><br> <a href="https://blog.csdn.net/dbat2015/article/details/50008315" rel="nofollow" data-token="46e340b7e58bd547f93ef3c1db914cdf">神经网络为什么要归一化</a><br> <a href="https://blog.csdn.net/KHFlash/article/details/82415719" rel="nofollow" data-token="661b5386f1bf2d352aa863149a64b373">理解BN(Batch Normalization)</a><br> <a href="https://blog.csdn.net/weixin_40533355/article/details/88554586" rel="nofollow" data-token="3f21d467cb6eb592fdf4281661bc27d2">关于BN(Batch Normalization)的一些归纳和总结</a><br> <a href="https://blog.csdn.net/qq_31511955/article/details/80505919" rel="nofollow" data-token="e4060cc5480c996a4a012c931a891380">BN算法优势</a><br> <a href="https://www.cnblogs.com/guoyaohua/p/8724433.html" rel="nofollow" data-token="bb71f69dba6a8241e9f9cac8a10adbd3">【深度学习】深入理解Batch Normalization批标准化 郭耀华’s Blog</a><br> <a href="https://blog.csdn.net/weixin_42398658/article/details/84560411" rel="nofollow" data-token="89c9e140c367e8594883177c372f1091">深度学习 — 优化入门四（Batch Normalization（批量归一化）一）</a></p> 
  <pre><code>数据同分布中的数据指的是样本向量，数学上对应的是联合分布函数
大家属于同一个分布函数

不使用BN，非线性变化几次后特征向量的分布分布似乎发生了变化
BN的具体操作是，对一个批次中每条数据的对应位置进行标准归一化

向量服从同一分布这个到底想表示什么
</code></pre> 
  <p><a href="https://blog.csdn.net/sinat_33741547/article/details/87158830" rel="nofollow" data-token="d9ff8cd6432d02ab39245f48558ea8bf">BN(Batch Normalization) 原理与使用过程详解</a><br> <a href="https://yq.aliyun.com/articles/394535" rel="nofollow" data-token="353b32a3c1fd88dacf7ce3138689d55a">统计机器学习中的一个经典假设是“源空间（source domain）和目标空间（target domain）的数据分布（distribution）是一致的</a></p> 
  <pre><code>可是这里Google仅仅说“通过mini-batch来规范化某些层/所有层的输入，
从而可以固定每层输入信号的均值与方差”就可以解决问题。
如果covariate shift可以用这么简单的方法解决，那前人对其的研究也真真是白做了。
此外，试想，均值方差一致的分布就是同样的分布吗？
</code></pre> 
  <p><a href="https://www.cnblogs.com/eilearn/p/9780696.html" rel="nofollow" data-token="e31731ff699a414093a50a3f22bd26e0">深度学习—BN的理解（一）</a></p> 
  <pre><code>网络训练过程中使得每一层神经网络的输入保持相同分布的。

它位于X=WU+B激活值获得之后，非线性函数变换之前
而Normalization则是把分布强行拉回到均值为0方差为1的标准正态分布，
使得激活输入值落在非线性函数对输入比较敏感的区域，
这样输入的小变化就会导致损失函数较大的变化，避免梯度消失问题产生，加速收敛

BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。
</code></pre> 
  <p><a href="https://blog.csdn.net/huang_nansen/article/details/86619108" rel="nofollow" data-token="225d5d8d4d0db92b775ff247ab9b6eae">ReLU和BN层简析</a></p> 
  <pre><code>BN层的出现，主要是为了解决机器学习IID问题，即训练集和测试集保持独立同分布。
如果输入的分布不能保持稳定，那么训练就会很难收敛.
</code></pre> 
  <p><a href="https://coding.m.imooc.com/questiondetail.html?qid=72679" rel="nofollow" data-token="1fb7d24fe5a9c59bb9282e6ce52902bb">为什么conv+bn+relu是有效的？</a></p> 
  <pre><code>第一，relu激活函数不是一到负数就成为dead cell的，如果是较大的负数，比如-0.5，-0.1这样子的，还是可以从dead变为active的，因为其他参数的调整，可以使输入发生变化。
只有较大的梯度，将这个神经元的激活值变为比较小的负数，比如-1000，才会形成dead relu。

第二，bn在relu之前还是之后貌似结果差别不大，翻了下原始论文，猜测作者应该是先对sigmoid做了实验，把BN放在了之前，然后relu就直接follow之前的做法了。

第三，需要理解bn的作用在于通过平滑隐藏层输入的分布，帮助随机梯度下降的进行，缓解随机梯度下降梯度衰减的情况。从这个角度来说，前和后应该是都能起到作用的。
</code></pre> 
  <p><a href="https://blog.csdn.net/zfnice/article/details/94319369" rel="nofollow" data-token="9145a948f10c9252333a502e56733d3d">神经网络细节</a></p> 
  <pre><code>每个神经元增加两个调节参数（scale和shift），这两个参数是通过训练来学习到的，用来对变换后的激活反变换，
使得网络表达能力增强，即对变换后的激活进行如下的scale和shift操作

对这个scale和shift不太理解
</code></pre> 
  <p><a href="https://www.zhihu.com/question/38102762" rel="nofollow" data-token="72e7de2030bb00f9b23dbf81b0ab96f6">深度学习中 Batch Normalization为什么效果好？知乎</a></p> 
  <pre><code>BN所做的就是解决这个梯度传播的问题，因为BN作用抹去了w的scale影响
</code></pre> 
  <p><a href="https://www.cnblogs.com/bonelee/p/8528722.html" rel="nofollow" data-token="8fc12a4f678baf3711d60d07b0aa303d">Batch Normalization原理及其TensorFlow实现——为了减少深度神经网络中的internal covariate shift，论文中提出了Batch Normalization算法，首先是对”每一层“的输入做一个Batch Normalization 变换（五星）</a></p> 
  <p><a href="https://blog.csdn.net/sinat_33741547/article/details/87158830" rel="nofollow" data-token="d9ff8cd6432d02ab39245f48558ea8bf">Internal Covariate Shift与Normalization（五星）</a></p> 
  <pre><code>而机器学习中有个很重要的假设：IID独立同分布假设，
就是假设训练数据和测试数据是满足相同分布的，
这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障。
那么，细化到神经网络的每一层间，每轮训练时分布都是不一致，
相对的训练效果就得不到保障，所以称为层间的covariate shift。

在深度神经网络中，由于第一层参数的改变，导致了传递给第二层的输入的分布也会发生改变，
也就是说在更新参数的过程中，无形中发生了internal covariate shift
</code></pre> 
  <ul> 
   <li>BN的作用是啥</li> 
  </ul> 
  <pre><code>保证每一层输入数据同分布，同时解决了梯度消失与梯度爆炸问题

每一层输入数据同分布是使用训练集训练模型有效的前提
如果不使用BN，不断的非线性变化使得不同样本对每一层的输入数据发生了层间Covariate Shift
使用BN后强制使每一层的输入分布回到均值0方差1的分布中，类似数据预处理步骤中的标准归一化
（举例理解，不同老师改同一份试卷得分不同）

同时BN的过程中增加两个调节参数（scale和shift）, 抹去了w的scale影响,从而避免了梯度消失与梯度爆炸
</code></pre> 
  <hr> 
  <p><a href="https://blog.csdn.net/max_hope/article/details/80264229" rel="nofollow" data-token="6ecb632b495130bdef1f754272321d10">矩阵向量求导(Vector derivation)</a></p> 
  <hr> 
  <p><a href="https://www.cnblogs.com/shixiangwan/p/7532830.html" rel="nofollow" data-token="2f7451f5aa8bc5c233b75e8f5a241d73">常见的几种最优化方法（梯度下降法、牛顿法、拟牛顿法、共轭梯度法等）</a></p> 
  <pre><code>梯度下降法的缺点：
　　靠近极小值时收敛速度减慢
　　
批量梯度下降：
每迭代一步，都要用到训练集所有的数据，如果m很大，那么可想而知这种方法的迭代速度会相当的慢

随机梯度下降：
SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向，
可能会“之字形”地下降
</code></pre> 
  <p><a href="https://blog.csdn.net/pengchengliu/article/details/80932232" rel="nofollow" data-token="f20d7de8072f0131fac02d557feae052">梯度下降法的推导（非常详细、易懂的推导）</a></p> 
  <pre><code>为什么参数这样更新能使loss降低
为什么局部下降最快的方向就是梯度的负方向呢

一阶泰勒展开式的推导过程
</code></pre> 
  <p><a href="https://blog.csdn.net/qq_28739605/article/details/80862810" rel="nofollow" data-token="a361c7b48ce26a4f9618899f183146be">关于梯度下降法和牛顿法的数学推导</a><br> <a href="https://www.cnblogs.com/lyr2015/p/9010532.html" rel="nofollow" data-token="aa2e49d71e276d8d18b9d1e003fe5bd2">梯度下降法和牛顿法的总结与比较</a></p> 
  <pre><code>利用牛顿法求解目标函数的最小值其实是转化成求使目标函数的一阶导为0的参数值。
这一转换的理论依据是，函数的极值点处的一阶导数为0.
</code></pre> 
  <p><a href="https://blog.csdn.net/linolzhang/article/details/60151623" rel="nofollow" data-token="990503b0504f78de83a869c250b7064c">牛顿法与Hessian矩阵</a></p> 
  <pre><code>牛顿法 主要有两方面的应用：
1. 求方程的根；
2. 求解最优化方法；

要解决 f′(x) = 0 的问题

最后：
xn+1 = xn - f'(xn) / f'′(xn)
</code></pre> 
  <hr> 
  <p><a href="https://www.cnblogs.com/guoyaohua/p/8542554.html" rel="nofollow" data-token="28f5dbe198b1d98e9f5a790c396786bd">深度学习——优化器算法Optimizer详解（BGD、SGD、MBGD、Momentum、NAG、Adagrad、Adadelta、RMSprop、Adam）</a><br> <a href="https://www.cnblogs.com/guoyaohua/p/8544835.html" rel="nofollow" data-token="343d1d4d0a72082d360874b834cda120">什么是指数加权平均、偏差修正？</a><br> <a href="https://blog.csdn.net/mzpmzk/article/details/80085929" rel="nofollow" data-token="8f2b16b18c4d9a35a7f1ceca1cba5b6f">指数加权移动平均(Exponential Weighted Moving Average)</a></p> 
  <hr> 
  <p><a href="https://www.cnblogs.com/xuexuefirst/p/8858274.html" rel="nofollow" data-token="48ed89c819caa9c26c63630d0c136657">衡量机器学习模型的三大指标：准确率、精度和召回率。</a></p> 
  <pre><code>分布不平衡数据集
---------------------------
召回率=真正例/（真正例 + 假反例） 
精度=真正例/（真正例 + 假正例）
</code></pre> 
  <hr> 
  <hr> 
  <h2><a id="_276"></a>分割线</h2> 
  <ul> 
   <li>为什么logistic回归的要用sigmoid函数？优缺点?</li> 
  </ul> 
  <pre><code>logistic是基于Bernoulli分布的假设，而Bernoulli分布的指数族的形式就是1/(1+exp(-z))

优点：
1.数据压缩能力，将数据规约在［0，1］之间
2.导数形式优秀，方便计算

缺点：
1.容易梯度消失，x在两端时的梯度趋近于0
2.非0中心化，在神经网络算法等情况下，造成反向传播时权重的全正全负的情况。

什么是伯努利分布
为什么logistics服从伯努利分布
指数族怎么解释
</code></pre> 
  <hr> 
  <ul> 
   <li>对比牛顿法、梯度下降法的关系</li> 
  </ul> 
  <pre><code></code></pre> 
  <hr> 
  <h2><a id="_299"></a>分割线</h2> 
  <p><a href="https://blog.csdn.net/weixin_40355324/article/details/79560979" rel="nofollow" data-token="4b38bc7d26d9ccc1ef72f10b4a3b6c0a">最全算法工程师面试题目整理(一)</a></p> 
  <pre><code>1.  为什么logistic回归的要用sigmoid函数？优缺点？
2. 对比牛顿法、梯度下降法的关系
3. 常见的正则化有是么，有什么作用，为什么l1是会把feature压缩到0而l2做不到？
4. 分类模型如何选择？如何判断效果？如何计算AUC？你最熟悉的ensemble Classification model是什么？
</code></pre> 
  <p><a href="https://blog.csdn.net/qq_28214097/article/details/80007627" rel="nofollow" data-token="c211ac602d8e20f552ecc69a079ead29">2018年BAT面试经验分享（计算机视觉算法岗</a></p> 
  <pre><code>场景题：在直播网站（YY或斗鱼等）上面有一个在唱歌的女主播，
突然唱歌的时候就把衣服脱光了，你要怎么用算法检测出来这个事情，然后把这直播间关闭了。
（答：主要从动作分析、场景分析、文字分析、语音分析这四个方面来回答）。
</code></pre> 
  <p><a href="https://blog.csdn.net/qq_23225317/article/details/82467755" rel="nofollow" data-token="25cb01a45f98a91519ccb1cbb1e7fe98">计算机视觉与深度学习算法工程师面试题整理</a></p> 
  <pre><code>1. 在梯度下降法中，为什么梯度的负方向是函数下降最快的方向？
	一阶泰勒展开的参数更新可知
	
2.  为什么引入Relu呢？
	
3.  bias的作用
	y = Wx	 + b 才是完整的决策边界（或超平面）方程，才能囊括所有可能情况
	如果没有b，就是默认b =0，
	直观上就是决策边界（或超平面）必须经过原点
</code></pre> 
  <p><a href="https://blog.csdn.net/qq_21997625/article/details/85344989" rel="nofollow" data-token="9eef0427cc0b5abc61f9652c3607f725">计算机视觉算法面试整理</a></p> 
  <pre><code>直方图均衡化
</code></pre> 
  <p><a href="https://blog.csdn.net/sysu_yuhaibao/article/details/79544015" rel="nofollow" data-token="d22356c8c900566ea7863f19cb4c8fad">计算机视觉实习面试经历</a></p> 
  <pre><code>面试官很看重深度学习项目经历，因为我有一段用tensorflow进行人脸检测的实习经历，
所以被问人脸检测现状、
当前比较好的人脸检测的深度学习模型及其比较、如何获取数据集、检测效果。。。
又问了fast r-cnn具体实现，以及r-cnn发展历程--我简单介绍了fast r-cnn流程，
很可惜这段实习当时比较水，所以坦诚不太会。
</code></pre> 
  <p><a href="https://blog.csdn.net/qq_20110551/article/details/81394017" rel="nofollow" data-token="22f882e740f7cc5c12b3afcb3bf988a4">计算机视觉相关面经总结</a></p> 
  <p><a href="https://blog.csdn.net/liuxiao214/article/details/83043170" rel="nofollow" data-token="de461d65737c668778cf40ea2734ad1d">【计算机视觉算法岗面经】“吐血”整理：2019秋招资料</a></p> 
  <hr> 
  <h2><a id="_343"></a>特征工程</h2> 
  <p><a href="https://blog.csdn.net/u011089523/article/details/80198312" rel="nofollow" data-token="0cf842469fe21d579c49e6397aff92a3">特征归一化</a><br> <a href="https://blog.csdn.net/luckoovy/article/details/82346223" rel="nofollow" data-token="5697bb59e0a7b3f24265ccd899452407">特征归一化，意义、方法、使用场景</a><br> <a href="https://blog.csdn.net/m0_37870649/article/details/80556630" rel="nofollow" data-token="12876de00a4d4eb16112c216d763f265">检验样本是否服从正态分布，处理偏态分布</a><br> <a href="https://blog.csdn.net/csdn_lzw/article/details/83387570" rel="nofollow" data-token="27bab32623df26310ecfb923ee0159cc">数据预处理——样本分布（正态分布、偏态分布）</a><br> <a href="https://www.cnblogs.com/gczr/p/7119826.html" rel="nofollow" data-token="75fee2ef079d3fc3810be8805026af87">如何进行数据变换(转)</a><br> <a href="https://blog.csdn.net/feijie7788/article/details/89812737" rel="nofollow" data-token="b2685face48205114212886de9156e1f">通俗易懂理解特征归一化对梯度下降算法的重要性</a></p> 
  <pre><code>扁的那一个方向，是数域较大的方向

需要梯度下降求解的模型需要归一化处理（比如线性回归，逻辑回归等）
对于决策树模型就不需要归一化处理了

归一化的好处：
消除数据特征之间量纲的影响，
在梯度下降中的好处是参数更新的更加平稳
</code></pre> 
  <hr> 
  <p><a href="https://www.cnblogs.com/zongfa/p/9305657.html" rel="nofollow" data-token="70df3d7bbaf87a9e5df65d73e854354a">数据预处理：独热编码（One-Hot Encoding）和 LabelEncoder标签编码</a></p> 
  <pre><code>通常用独热编码处理，类别间不具有大小关系的特征
如果按序号编码，转换后类别间产生了大小关系，相应的距离计算不合理
</code></pre> 
  <hr> 
  <ul> 
   <li>图片不足时的处理方法（训练数据不足的处理方法）</li> 
  </ul> 
  <pre><code>* 基于数据，主要通过数据增强
* 使用生成模型，比如生成对抗网络？
* 基于模型，简化模型，添加正则项
* fine-tune模型
</code></pre> 
  <h2><a id="_376"></a>损失函数</h2> 
  <p><a href="https://www.jianshu.com/p/b715888f079b" rel="nofollow" data-token="fd53d092f9f04203eb1a36578dc0285c">机器学习者都应该知道的五种损失函数</a></p> 
  <h2><a id="_379"></a>目标检测</h2> 
  <p><a href="https://blog.csdn.net/s000da/article/details/81105833" rel="nofollow" data-token="331c4c5b2d0c1c6eda6a5612cb2a9d1c">【更新中】目标检测——梳理，准备面试</a><br> <a href="https://blog.csdn.net/qq_16525279/article/details/81698684" rel="nofollow" data-token="246c2f12ea4ec55fde3a8611105517af">计算机视觉目标检测算法综述</a><br> <a href="https://www.cnblogs.com/CZiFan/p/9903518.html" rel="nofollow" data-token="e497aa16e05d7ac99cbd68f78fb5934d">Fast R-CNN（理解）</a></p> 
  <h6><a id="_384"></a>传统目标检测</h6> 
  <pre><code>传统目标检测三步曲：
1. 区域选择（滑动窗口，SelectiveSearch）
2. 特征提取（SIFI，HOG）
3. 分类器训练（SVM，Adaboost）
</code></pre> 
  <ul> 
   <li>传统目标检测流程（传统目标检测该怎么做）</li> 
  </ul> 
  <pre><code>第一步：训练集构造
（构建正负例样本）
正例样本：GT

负例样本：候选区域与GT重叠度在20%-50%之间，
而且与已有的负例样本的IOU少于70%

第二步：提取每个正负例样本的特征

第三步：训练分类器

第四步：把训练时的FP收集起来，对上一步训练好的模型进行二次训练

预测流程：
1.获取候选框
2.提取候选框的特征向量
3.将特征向量输入到分类器中
4.排序，过滤
	a.对每个候选框根据获得的概率值进行降序排序
	b.概率值小于0.5的直接过滤
	c.剩下的候选框按顺序从第一个开始计算与后面候选框的IOU，保留IOU小于30%的
	
最后剩下的就是目标区域
</code></pre> 
  <pre><code>补充: 手工设计的特征鲁棒性比较差，只是一些表层特征
</code></pre> 
  <h6><a id="R__CNN_421"></a>R - CNN</h6> 
  <pre><code>1.候选区域通过SelectiveSearch生成
2.使用CNN进行特征提取
</code></pre> 
  <ul> 
   <li>R - CNN训练流程</li> 
  </ul> 
  <pre><code>1.使用SelectiveSearch生成2000个候选框（构建正负例样本）
2.候选框缩放到固定尺寸（eg：227×227）
3.使用CNN提取候选框特征
4.分类训练：将特征向量输入到SVM分类器
  回归训练：将特征向量输入到全连接网络进行Bounding Box回归
</code></pre> 
  <pre><code>补充：这里分类器用SVM代替，为什么不用softmax
-------------------------------------------------------
问题：
1.算力冗余
先生成候选区域，再对区域进行卷积，这里有两个问题：
其一是候选区域会有一定程度的重叠，对相同区域进行重复卷积；
其二是每个区域进行新的卷积需要新的存储空间。

2.图片缩放
候选区域中的图像输入CNN（卷积层并不要求输入图像的尺寸固定，只有第一个全连接层需要确定输入维度，
因为它和前一层之间的权重矩阵是固定大小的，其他的全连接层也不要求图像的尺寸固定）中需要固定尺寸（227 * 227），
会造成物体形变，导致检测性能下降。

3.训练测试不简洁
候选区域生成、特征提取、分类、回归都是分开操作，
中间数据还需要单独保存。
</code></pre> 
  <h6><a id="SPP_Net_452"></a>SPP Net</h6> 
  <ul> 
   <li>候选框特征向量提取方式的改进</li> 
   <li>通过SPP解决固定输入尺寸的限制</li> 
  </ul> 
  <pre><code>1.并不是先裁剪候选框，再对候选框进行卷积提取特征，
而是先对原图卷积，再从特征图中获取Proposal区域对应的特征图像
将 R - CNN 的多次卷积简化为一次卷积（减少计算量，减少存储量）

2.将特征图像输入SPP层得到固定长度的特征向量
</code></pre> 
  <ul> 
   <li>SPP具体做法</li> 
  </ul> 
  <pre><code>对输入的特征图进行三种尺度的切分：4×4，2×2，1×1
对切分出来的每个小块进行max pooling下采样
将结果排列成一列向量输入到全连接中
</code></pre> 
  <h6><a id="Fast_R__CNN_469"></a>Fast R - CNN</h6> 
  <pre><code>...
</code></pre> 
  <blockquote> 
   <p>使用 smoothL1 loss的好处</p> 
  </blockquote> 
  <h2><a id="_476"></a>数据结构与算法</h2> 
  <p><a href="https://blog.csdn.net/Vermont_/article/details/84557065" rel="nofollow" data-token="e69e1246a88b04cb2878c58472322e5c">详解什么是尾递归（通俗易懂，示例讲解）</a><br> <a href="https://www.cnblogs.com/huan-guo/p/8489905.html" rel="nofollow" data-token="14576ffc9ac54ff8df38434abdf8e4c3">递归与尾递归总结</a></p> 
  <pre><code>什么场景适合尾递归
</code></pre> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e44c3c0e64.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
