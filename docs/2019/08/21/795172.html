<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>win10 + bazel-0.20.0 + tensorflow-1.13.1 编译tensorflow GPU版本的C++库 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="win10 + bazel-0.20.0 + tensorflow-1.13.1 编译tensorflow GPU版本的C++库" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="win10 + bazel-0.20.0 + tensorflow-1.13.1 编译tensorflow GPU版本的C++库 安装所需软件/库 Step1. 安装vs2015，CUDA 10.0和cuDNN 7.6 Step2. 安装msys2 Step3. 安装bazel Step4. 下载编译所需文件（tensorflow源码及其他文件） Step5. 使用powershell进行配置与编译 Step6. 整理生成的文件——dll，lib，include Step7. 调用模型测试程序 支线任务 参考资料： windows+bazel+tensorflow-v1.12.0(GPU)编译生成dll与lib; Error: “execution of scripts is disabled on this system” ; tensorflow1.4 c++编译以及API使用; window+tensorflow+cuda+cudnn 出现‘CUDnn_STATUS_ALLOC_FAILED’的可能解决办法; Return coordinates for bounding boxes Google’s Object Detection API; visualize_boxes_and_labels_on_image_array 函数. ---------------------- 超长文多图预警!!! ---------------------- 安装所需软件/库 vs2015; Anaconda3; CUDA 10.0; cuDNN 7.6; python3.6.7; tensorflow-1.13.1; bazel0.20.0; msys2-x86_64-20190524. Step1. 安装vs2015，CUDA 10.0和cuDNN 7.6 vs2015的安装这里就不多说了，Anaconda3、CUDA和cuDNN的安装可参考cmake编译opencv： Win10+cmake3.14.4+cuda10.0+cudnn7.6+opencv-4.0.0+contrib+vs2015。 Step2. 安装msys2 进入msys2官网，选择msys2-x86_64-20190524.exe，或直接点击此链接: msys2-x86_64-20190524，进行下载。 下载好后开始安装，点击Next： 接下来选择安装路径，我个人为了避免安装在系统盘，将盘符改成了D盘，如下图。然而在之后的编译过程中发现，msys64会在C盘再安装一遍，所以这里推荐使用默认，即安装在 C:\msys64 下。接着点击Next，进入下一步。 这里直接Next： 软件开始安装，稍微等一会儿就好了。 安装完成，点击Finish： 弹出一个类似cmd的命令窗口，输入一下命令： pacman -Syu 询问是否进行安装，输入y，回车： 第一个命令执行完毕： 接着输入以下命令： pacman -S git 同样地，询问是否安装输入 y，然后回车： 第二个命令执行完毕： 接着输入： pacman -S patch unzip grep 是否安装输入 y，回车： 第三个命令执行完毕： 软件装好以后，需要配置环境变量。 将以下路径添加到系统变量 Path 中： D:\msys64 D:\msys64\usr\bin 注意，如果之前装在C盘，则需要进行相应修改。 如下图所示： msys2安装配置完毕！ Step3. 安装bazel 进入github，选择合适的bazel版本进行下载。 如果CUDA和Tensorflow的版本与本文一致，也可点此链接下载：bazel-0.20.0-windows-x86_64.exe。 github上选择下载文件如下图所示： 将下载好的 .exe 文件复制到 D:\msys64 下（路径根据个人安装情况而定），更名为 bazel.exe。 复制完成后，配置bazel环境变量。 新建三个系统变量：BAZEL_SH，BAZEL_VC，BAZEL_VS。相应的路径如以下表格所示： 变量 值 BAZEL_SH D:\msys64\usr\bin\bash.exe BAZEL_VC D:\Program Files (x86)\Microsoft Visual Studio 14.0\VC BAZEL_VS D:\Program Files (x86)\Microsoft Visual Studio 14.0 环境变量配置完成： bazel安装配置完毕！ Step4. 下载编译所需文件（tensorflow源码及其他文件） 进入tensorflow-v1.13.1源码的github的页面 ，点击页面右侧绿色按钮Clone or download，然后点击Download ZIP进行下载，如下图所示。 或者也可直接点此链接：tensorflow-1.13.1 进行下载。 下载时间也许会很长，请耐心等待。 进入tensorflow-windows-build-script-master的github页面，下载tensorflow-windows-build-script-master.zip(此链接可直接下载)。 以上两个 .zip 文件下载完成后，在D盘新建一个文件夹，命名为 tensorflow-1.13.1 （也可根据个人喜好决定）。 将下载好的 tensorflow-1.13.1.zip 解压到刚刚新建的文件夹下，重新命名为 source； 将 tensorflow-windows-build-script-master.zip 解压到任意位置，然后把其中的 patches 和 build.ps1 文件，复制到新建的 D:\tensorflow-1.13.1目录下，如下图所示： 将 patches 下的 eigen_half.patch 复制到 tensorflow-1.13.1\source\third_party 下： 将 patches 下的 tf_exported_symbols_msvc.lds 复制到 tensorflow-1.13.1\source\tensorflow 下： 用文本编辑器打开 build.ps1 文件，将以下语句注释掉： Copy-Item …\patches\tf_exported_symbols_msvc.lds tensorflow\ 防止编译时出现Copy-Item命令的问题。 位置在 build.ps1 的180行，如下图所示： 编译所需文件准备完毕！ Step5. 使用powershell进行配置与编译 在 C:\Windows\SysWOW64\WindowsPowerShell\v1.0 目录下，右键以管理员身份运行 powershell.exe： 在 powershell 窗口中输入以下命令，转到 tensorflow-1.13.1 目录下： cd D:\tensorflow-1.13.1 输入bazel编译的选项： $parameterString = &quot;--config=opt --config=cuda --define=no_tensorflow_py_deps=true --copt=-nvcc_options=disable-warnings //tensorflow:libtensorflow_cc.so --verbose_failures&quot; 然后输入以下命令，执行 build.ps1 脚本文件： .\build.ps1 -BazelBuildParameters $parameterString -BuildCppAPI -ReserveSource 执行命令时出现 UnauthorizedAccess 错误，说明可能是 powershell 的执行策略受限，输入以下命令查看当前执行策略： Get-ExecutionPolicy 我这里显示的是Restricted（受限的），所以需要输入以下语句来取消限制： Set-ExecutionPolicy Unrestricted 询问是否改变执行策略，输入 y，回车。 修改好后，可以再次输入： Get-ExecutionPolicy 查看当前执行策略是否已经取消限制。 执行策略的问题解决以后，重新执行 build.ps1 脚本文件： .\build.ps1 -BazelBuildParameters $parameterString -BuildCppAPI -ReserveSource 如果一切正常，我们将开始编译前的配置。可参照以下两图进行配置。有些提问可以直接按回车来选择默认配置，括号中出现 default 字眼的，都可以这么做。 注意 ：当问到GPU的计算能力（compute capability），即出现 [Default is: 3.5, 7.0]: 时，先不要急着按回车。我们先找到跟自己显卡对应的计算能力，再进行填写，可参考后面的方法来查看显卡的计算能力。 打开设备管理器，找到自己的显卡型号： 然后进入NVDIA官网的CUDA GPUs页面，点击 CUDA-Enabled GeForce and TITAN Products，找到自己的显卡型号对应的数值，将其填入 [Default is: 3.5, 7.0]: 后面，回车继续配置。 都配置完成后，编译正式开始。注意保持网络通畅，因为编译之前需要下载各种依赖库，网络异常会导致下载失败停止编译。编译时间很长，不要光盯着屏幕看，该吃吃该喝喝该玩玩该睡睡。 编译可能出现无法解析的外部符号的问题，以下面的错误为例： 无法解析的外部符号 “public: virtual __cdecl tensorflow::internal::LogMessage::~LogMessage(void)” (??1LogMessage@internal@tensorflow@@UEAA@XZ)，该符号在函数 “public: void __cdecl tensorflow::internal::LogMessage::`vbase destructor’(void)” (??_DLogMessage@internal@tensorflow@@QEAAXXZ) 中被引用 解决方法： 用文本编辑器打开 D:\tensorflow-1.13.1\source\tensorflow\tf_exported_symbols_msvc.lds ，找到前面一个括号中带问号的内容： ??1LogMessage@internal@tensorflow@@UEAA@XZ 将其删除。如果有多个无法解析外部符号的问题，用同样的方法逐一删除即可。 确认全部清除后，重新执行以下命令配置和编译： .\build.ps1 -BazelBuildParameters $parameterString -BuildCppAPI -ReserveSource 如果一切正常，在漫长的等待之后，将会出现以下结果： 注意：第一个红框部分为编译生成的动态库 libtensorflow_cc.so 所在位置，请记录下来，后面需要用到。 编译任务圆满完成！！！ 可以稍作休息小小庆祝一下！ Step6. 整理生成的文件——dll，lib，include 新建一个文件夹，在文件夹中创建以下三个目录：dll，lib，include。 根据编译结束时显示的动态库所在位置，找到生成的库 libtensorflow_cc.so 和 liblibtensorflow_cc.so.ifso。 将 libtensorflow_cc.so 更名为 tensorflow_cc.dll，放到刚才创建的 dll 目录下； 将 liblibtensorflow_cc.so.ifso 更名为 tensorflow_cc.lib，放到刚才创建的 lib 目录下。 接下来要做的是填满 include 目录，该步相对繁琐，最终将包含以下文件夹： 1）在include目录中新建名为 _bin 的文件夹。参考以下路径，打开 _embedded_binaries 目录，将下图红框中的文件复制到 _bin 文件夹中： C:\Users\xxx_bazel_xxx\install\d5b1be53d8db6a1e2d160364df2e7ef6_embedded_binaries 2-1) 参考以下路径，将下图红框中的 bazel-out 文件夹复制到 include 目录下： C:\Users\xxx_bazel_xxx\y46qiod6\execroot\org_tensorflow 2-2) 参考以下路径，将 protobuf_archive 文件夹复制到 include 下的 bazel-out\x64_windows-opt\genfiles\external 目录中： C:\Users\xxx_bazel_xxx\y46qiod6\external 3） 将 D:\tensorflow-1.13.1\source 下的 tensorflow 和 third_party 复制到 include 目录下： 4-1) 参照以下路径，将下图红框中的 external 文件夹复制到 include 目录下： C:\Users\xxx_bazel_xxx\y46qiod6 4-2) 参照以下路径，将 embedded_tools 文件夹下的所有文件复制到 include 下的 external\bazel_tools 目录中（如果 external 里面没有该文件夹，需新建并命名为 bazel_tools）： C:\Users\xxx_bazel_xxx\install\d5b1be53d8db6a1e2d160364df2e7ef6_embedded_binaries\embedded_tools 4-3) 将 D:\tensorflow-1.13.1\source 下的 tensorflow 复制到 include 下的 external\org_tensorflow 目录中（如果 external 里面没有该文件夹，需新建并命名为 rg_tensorflow）： 至此，调用tensorflow所需的库及包含的目录准备完毕！ Step7. 调用模型测试程序 新建测试工程，在 .cpp 文件中写入以下代码： #define COMPILER_MSVC #define NOMINMAX #define PLATFORM_WINDOWS // 指定使用tensorflow/core/platform/windows/cpu_info.h #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;opencv2/opencv.hpp&gt; #include&quot;tensorflow/core/public/session.h&quot; #include &quot;tensorflow/core/platform/env.h&quot; #include &lt;time.h&gt; using namespace tensorflow; using namespace cv; using std::cout; using std::endl; int main() { const std::string model_path = &quot;frozen_inference_graph.pb&quot;;// tensorflow模型文件，注意不能含有中文 const std::string image_path = &quot;image1.jpg&quot;; // 待inference的图片grace_hopper.jpg // 设置输入图像 cv::Mat img = cv::imread(image_path); cv::cvtColor(img, img, cv::COLOR_BGR2RGB); int height = img.rows; int width = img.cols; int depth = img.channels(); // 取图像数据，赋给tensorflow支持的Tensor变量中 tensorflow::Tensor input_tensor(DT_UINT8, TensorShape({ 1, height, width, depth })); const uint8* source_data = img.data; auto input_tensor_mapped = input_tensor.tensor&lt;uint8, 4&gt;(); for (int i = 0; i &lt; height; i++) { const uint8* source_row = source_data + (i * width * depth); for (int j = 0; j &lt; width; j++) { const uint8* source_pixel = source_row + (j * depth); for (int c = 0; c &lt; depth; c++) { const uint8* source_value = source_pixel + c; input_tensor_mapped(0, i, j, c) = *source_value; } } } // 初始化tensorflow session Session* session; Status status = NewSession(SessionOptions(), &amp;session); if (!status.ok()) { std::cerr &lt;&lt; status.ToString() &lt;&lt; endl; return -1; } else { cout &lt;&lt; &quot;Session created successfully&quot; &lt;&lt; endl; } // 读取二进制的模型文件到graph中 tensorflow::GraphDef graph_def; status = ReadBinaryProto(Env::Default(), model_path, &amp;graph_def); if (!status.ok()) { std::cerr &lt;&lt; status.ToString() &lt;&lt; endl; return -1; } else { cout &lt;&lt; &quot;Load graph protobuf successfully&quot; &lt;&lt; endl; } // 将graph加载到session status = session-&gt;Create(graph_def); if (!status.ok()) { std::cerr &lt;&lt; status.ToString() &lt;&lt; endl; return -1; } else { cout &lt;&lt; &quot;Add graph to session successfully&quot; &lt;&lt; endl; } // 输入inputs，“ x_input”是我在模型中定义的输入数据名称 std::vector&lt;std::pair&lt;std::string, tensorflow::Tensor&gt;&gt; inputs = { { &quot;image_tensor:0&quot;, input_tensor }, }; // 输出outputs std::vector&lt;tensorflow::Tensor&gt; outputs; //批处理识别 double start = clock(); std::vector&lt;std::string&gt; output_nodes; output_nodes.push_back(&quot;num_detections&quot;); output_nodes.push_back(&quot;detection_boxes&quot;); output_nodes.push_back(&quot;detection_scores&quot;); output_nodes.push_back(&quot;detection_classes&quot;); // 运行会话，最终结果保存在outputs中 status = session-&gt;Run(inputs, { output_nodes }, {}, &amp;outputs); if (!status.ok()) { std::cerr &lt;&lt; status.ToString() &lt;&lt; endl; return -1; } else { cout &lt;&lt; &quot;Run session successfully&quot; &lt;&lt; endl; } double finish = clock(); double duration = (double)(finish - start) / CLOCKS_PER_SEC; cout &lt;&lt; &quot;spend time:&quot; &lt;&lt; duration &lt;&lt; endl; cv::imshow(&quot;image&quot;, img); cv::waitKey(); return 0; } 先别急着编译工程，首先我们需要把环境配置好： 配置opencv (Release版本)； 配置tensorflow C++库。 opencv库配置就不多赘述，这里主要说明tensorflow库的配置。 1）包含目录： D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\external\org_tensorflow;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\external\protobuf_archive\src;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\external\com_google_absl;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\external\eigen_archive;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\bazel-out\x64_windows-opt\genfiles; 2）库目录： D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\lib; 3）链接器输入附加依赖项： tensorflow_cc.lib; 环境配置好后，将之前生成的动态库放入应用程序目录，即复制 tensorflow_cc.dll 到与工程文件 .sln 同级的 x64\Release 文件夹下，如下图所示： 接下来，从网盘下载模型文件 frozen_inference_graph.pb 和测试图片 image1.jpg（点此链接） 模型文件在 tensorflow\ssd_mobilenet_v1_coco_2017_11_17 目录下； 测试图片在 tensorflow\test_images 目录下。 把它们放到与 .cpp 文件同级的目录下，如下图所示： 编译前的准备工作完成，现在我们可以编译生成项目。生成之前，注意选择 Release 和 x64，如下图红框所示： 编译可能出现无法解析的外部符号的问题，以下面的错误为例： 无法解析的外部符号 “public: virtual __cdecl tensorflow::internal::LogMessage::~LogMessage(void)” (??1LogMessage@internal@tensorflow@@UEAA@XZ)，该符号在函数 “public: void __cdecl tensorflow::internal::LogMessage::`vbase destructor’(void)” (??_DLogMessage@internal@tensorflow@@QEAAXXZ) 中被引用 解决方法： 用文本编辑器打开 D:\tensorflow-1.13.1\source\tensorflow\tf_exported_symbols_msvc.lds ，将前面一个括号中带问号的内容： ??1LogMessage@internal@tensorflow@@UEAA@XZ 复制到该文件的末尾，如下图所示。 如果有多个无法解析外部符号的问题，用同样的方法逐一添加。全部添加完成后保存关闭文件，然后重新编译tensorflow，也就是说从运行脚本文件开始，后面的流程要重新走一遍，想想有点心累，不过都已经走到这里了，半途而废有点说不过去呀，咬咬牙重来一遍吧。 上面的问题已经成功解决，没有意外，还会出现max问题： 解决办法如下： 双击错误提示，跳转到有max问题的文件： logging.h 和 tensor_shape.h，分别进行以下修改： 1）logging.h: 将第250行的 if (TF_PREDICT_FALSE(v2 &gt;= std::numeric_limits&lt;int&gt;::max())) { \ 改为 if (TF_PREDICT_FALSE(v2 &gt;= (std::numeric_limits&lt;int&gt;::max)())) { \ 修改后如下图所示： 2）tensor_shape.h: 将108-111行的 static const int64 kMaxRep16 = std::numeric_limits&lt;uint16&gt;::max() - 1; static const int64 kMaxRep32 = std::numeric_limits&lt;uint32&gt;::max() - 1; static const uint16 kUnknownRep16 = std::numeric_limits&lt;uint16&gt;::max(); static const uint32 kUnknownRep32 = std::numeric_limits&lt;uint32&gt;::max(); 改为： static const int64 kMaxRep16 = (std::numeric_limits&lt;uint16&gt;::max)() - 1; static const int64 kMaxRep32 = (std::numeric_limits&lt;uint32&gt;::max)() - 1; static const uint16 kUnknownRep16 = (std::numeric_limits&lt;uint16&gt;::max)(); static const uint32 kUnknownRep32 = (std::numeric_limits&lt;uint32&gt;::max)(); 修改后如下图所示： 修改好后我们重新生成项目，如果上面的步骤都没有问题，将会出现下面的结果： 没错！编译成功！小腿抖起来小曲儿唱起来! 到这里还没有结束，将程序运行起来，你将看到以下结果： 红框部分说明GPU和模型调用没毛病，妥妥地成功！小腿再次抖起来小曲儿再次唱起来! tensorflow C++库的生成和调用全部结束！ 支线任务 注意，这是作业，不是彩蛋。 测试程序结尾出现了以下神秘图片： 蓝狗？！ 还别说，狗狗蓝色的美瞳还真是洋气，蓝色的皮鞋更显骚气。 灵魂三问：小狗为什么是蓝色？定位框在哪？识别的结果在哪？ 这就需要骚年们好好的研究和琢磨了。 Happy Ending:" />
<meta property="og:description" content="win10 + bazel-0.20.0 + tensorflow-1.13.1 编译tensorflow GPU版本的C++库 安装所需软件/库 Step1. 安装vs2015，CUDA 10.0和cuDNN 7.6 Step2. 安装msys2 Step3. 安装bazel Step4. 下载编译所需文件（tensorflow源码及其他文件） Step5. 使用powershell进行配置与编译 Step6. 整理生成的文件——dll，lib，include Step7. 调用模型测试程序 支线任务 参考资料： windows+bazel+tensorflow-v1.12.0(GPU)编译生成dll与lib; Error: “execution of scripts is disabled on this system” ; tensorflow1.4 c++编译以及API使用; window+tensorflow+cuda+cudnn 出现‘CUDnn_STATUS_ALLOC_FAILED’的可能解决办法; Return coordinates for bounding boxes Google’s Object Detection API; visualize_boxes_and_labels_on_image_array 函数. ---------------------- 超长文多图预警!!! ---------------------- 安装所需软件/库 vs2015; Anaconda3; CUDA 10.0; cuDNN 7.6; python3.6.7; tensorflow-1.13.1; bazel0.20.0; msys2-x86_64-20190524. Step1. 安装vs2015，CUDA 10.0和cuDNN 7.6 vs2015的安装这里就不多说了，Anaconda3、CUDA和cuDNN的安装可参考cmake编译opencv： Win10+cmake3.14.4+cuda10.0+cudnn7.6+opencv-4.0.0+contrib+vs2015。 Step2. 安装msys2 进入msys2官网，选择msys2-x86_64-20190524.exe，或直接点击此链接: msys2-x86_64-20190524，进行下载。 下载好后开始安装，点击Next： 接下来选择安装路径，我个人为了避免安装在系统盘，将盘符改成了D盘，如下图。然而在之后的编译过程中发现，msys64会在C盘再安装一遍，所以这里推荐使用默认，即安装在 C:\msys64 下。接着点击Next，进入下一步。 这里直接Next： 软件开始安装，稍微等一会儿就好了。 安装完成，点击Finish： 弹出一个类似cmd的命令窗口，输入一下命令： pacman -Syu 询问是否进行安装，输入y，回车： 第一个命令执行完毕： 接着输入以下命令： pacman -S git 同样地，询问是否安装输入 y，然后回车： 第二个命令执行完毕： 接着输入： pacman -S patch unzip grep 是否安装输入 y，回车： 第三个命令执行完毕： 软件装好以后，需要配置环境变量。 将以下路径添加到系统变量 Path 中： D:\msys64 D:\msys64\usr\bin 注意，如果之前装在C盘，则需要进行相应修改。 如下图所示： msys2安装配置完毕！ Step3. 安装bazel 进入github，选择合适的bazel版本进行下载。 如果CUDA和Tensorflow的版本与本文一致，也可点此链接下载：bazel-0.20.0-windows-x86_64.exe。 github上选择下载文件如下图所示： 将下载好的 .exe 文件复制到 D:\msys64 下（路径根据个人安装情况而定），更名为 bazel.exe。 复制完成后，配置bazel环境变量。 新建三个系统变量：BAZEL_SH，BAZEL_VC，BAZEL_VS。相应的路径如以下表格所示： 变量 值 BAZEL_SH D:\msys64\usr\bin\bash.exe BAZEL_VC D:\Program Files (x86)\Microsoft Visual Studio 14.0\VC BAZEL_VS D:\Program Files (x86)\Microsoft Visual Studio 14.0 环境变量配置完成： bazel安装配置完毕！ Step4. 下载编译所需文件（tensorflow源码及其他文件） 进入tensorflow-v1.13.1源码的github的页面 ，点击页面右侧绿色按钮Clone or download，然后点击Download ZIP进行下载，如下图所示。 或者也可直接点此链接：tensorflow-1.13.1 进行下载。 下载时间也许会很长，请耐心等待。 进入tensorflow-windows-build-script-master的github页面，下载tensorflow-windows-build-script-master.zip(此链接可直接下载)。 以上两个 .zip 文件下载完成后，在D盘新建一个文件夹，命名为 tensorflow-1.13.1 （也可根据个人喜好决定）。 将下载好的 tensorflow-1.13.1.zip 解压到刚刚新建的文件夹下，重新命名为 source； 将 tensorflow-windows-build-script-master.zip 解压到任意位置，然后把其中的 patches 和 build.ps1 文件，复制到新建的 D:\tensorflow-1.13.1目录下，如下图所示： 将 patches 下的 eigen_half.patch 复制到 tensorflow-1.13.1\source\third_party 下： 将 patches 下的 tf_exported_symbols_msvc.lds 复制到 tensorflow-1.13.1\source\tensorflow 下： 用文本编辑器打开 build.ps1 文件，将以下语句注释掉： Copy-Item …\patches\tf_exported_symbols_msvc.lds tensorflow\ 防止编译时出现Copy-Item命令的问题。 位置在 build.ps1 的180行，如下图所示： 编译所需文件准备完毕！ Step5. 使用powershell进行配置与编译 在 C:\Windows\SysWOW64\WindowsPowerShell\v1.0 目录下，右键以管理员身份运行 powershell.exe： 在 powershell 窗口中输入以下命令，转到 tensorflow-1.13.1 目录下： cd D:\tensorflow-1.13.1 输入bazel编译的选项： $parameterString = &quot;--config=opt --config=cuda --define=no_tensorflow_py_deps=true --copt=-nvcc_options=disable-warnings //tensorflow:libtensorflow_cc.so --verbose_failures&quot; 然后输入以下命令，执行 build.ps1 脚本文件： .\build.ps1 -BazelBuildParameters $parameterString -BuildCppAPI -ReserveSource 执行命令时出现 UnauthorizedAccess 错误，说明可能是 powershell 的执行策略受限，输入以下命令查看当前执行策略： Get-ExecutionPolicy 我这里显示的是Restricted（受限的），所以需要输入以下语句来取消限制： Set-ExecutionPolicy Unrestricted 询问是否改变执行策略，输入 y，回车。 修改好后，可以再次输入： Get-ExecutionPolicy 查看当前执行策略是否已经取消限制。 执行策略的问题解决以后，重新执行 build.ps1 脚本文件： .\build.ps1 -BazelBuildParameters $parameterString -BuildCppAPI -ReserveSource 如果一切正常，我们将开始编译前的配置。可参照以下两图进行配置。有些提问可以直接按回车来选择默认配置，括号中出现 default 字眼的，都可以这么做。 注意 ：当问到GPU的计算能力（compute capability），即出现 [Default is: 3.5, 7.0]: 时，先不要急着按回车。我们先找到跟自己显卡对应的计算能力，再进行填写，可参考后面的方法来查看显卡的计算能力。 打开设备管理器，找到自己的显卡型号： 然后进入NVDIA官网的CUDA GPUs页面，点击 CUDA-Enabled GeForce and TITAN Products，找到自己的显卡型号对应的数值，将其填入 [Default is: 3.5, 7.0]: 后面，回车继续配置。 都配置完成后，编译正式开始。注意保持网络通畅，因为编译之前需要下载各种依赖库，网络异常会导致下载失败停止编译。编译时间很长，不要光盯着屏幕看，该吃吃该喝喝该玩玩该睡睡。 编译可能出现无法解析的外部符号的问题，以下面的错误为例： 无法解析的外部符号 “public: virtual __cdecl tensorflow::internal::LogMessage::~LogMessage(void)” (??1LogMessage@internal@tensorflow@@UEAA@XZ)，该符号在函数 “public: void __cdecl tensorflow::internal::LogMessage::`vbase destructor’(void)” (??_DLogMessage@internal@tensorflow@@QEAAXXZ) 中被引用 解决方法： 用文本编辑器打开 D:\tensorflow-1.13.1\source\tensorflow\tf_exported_symbols_msvc.lds ，找到前面一个括号中带问号的内容： ??1LogMessage@internal@tensorflow@@UEAA@XZ 将其删除。如果有多个无法解析外部符号的问题，用同样的方法逐一删除即可。 确认全部清除后，重新执行以下命令配置和编译： .\build.ps1 -BazelBuildParameters $parameterString -BuildCppAPI -ReserveSource 如果一切正常，在漫长的等待之后，将会出现以下结果： 注意：第一个红框部分为编译生成的动态库 libtensorflow_cc.so 所在位置，请记录下来，后面需要用到。 编译任务圆满完成！！！ 可以稍作休息小小庆祝一下！ Step6. 整理生成的文件——dll，lib，include 新建一个文件夹，在文件夹中创建以下三个目录：dll，lib，include。 根据编译结束时显示的动态库所在位置，找到生成的库 libtensorflow_cc.so 和 liblibtensorflow_cc.so.ifso。 将 libtensorflow_cc.so 更名为 tensorflow_cc.dll，放到刚才创建的 dll 目录下； 将 liblibtensorflow_cc.so.ifso 更名为 tensorflow_cc.lib，放到刚才创建的 lib 目录下。 接下来要做的是填满 include 目录，该步相对繁琐，最终将包含以下文件夹： 1）在include目录中新建名为 _bin 的文件夹。参考以下路径，打开 _embedded_binaries 目录，将下图红框中的文件复制到 _bin 文件夹中： C:\Users\xxx_bazel_xxx\install\d5b1be53d8db6a1e2d160364df2e7ef6_embedded_binaries 2-1) 参考以下路径，将下图红框中的 bazel-out 文件夹复制到 include 目录下： C:\Users\xxx_bazel_xxx\y46qiod6\execroot\org_tensorflow 2-2) 参考以下路径，将 protobuf_archive 文件夹复制到 include 下的 bazel-out\x64_windows-opt\genfiles\external 目录中： C:\Users\xxx_bazel_xxx\y46qiod6\external 3） 将 D:\tensorflow-1.13.1\source 下的 tensorflow 和 third_party 复制到 include 目录下： 4-1) 参照以下路径，将下图红框中的 external 文件夹复制到 include 目录下： C:\Users\xxx_bazel_xxx\y46qiod6 4-2) 参照以下路径，将 embedded_tools 文件夹下的所有文件复制到 include 下的 external\bazel_tools 目录中（如果 external 里面没有该文件夹，需新建并命名为 bazel_tools）： C:\Users\xxx_bazel_xxx\install\d5b1be53d8db6a1e2d160364df2e7ef6_embedded_binaries\embedded_tools 4-3) 将 D:\tensorflow-1.13.1\source 下的 tensorflow 复制到 include 下的 external\org_tensorflow 目录中（如果 external 里面没有该文件夹，需新建并命名为 rg_tensorflow）： 至此，调用tensorflow所需的库及包含的目录准备完毕！ Step7. 调用模型测试程序 新建测试工程，在 .cpp 文件中写入以下代码： #define COMPILER_MSVC #define NOMINMAX #define PLATFORM_WINDOWS // 指定使用tensorflow/core/platform/windows/cpu_info.h #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;opencv2/opencv.hpp&gt; #include&quot;tensorflow/core/public/session.h&quot; #include &quot;tensorflow/core/platform/env.h&quot; #include &lt;time.h&gt; using namespace tensorflow; using namespace cv; using std::cout; using std::endl; int main() { const std::string model_path = &quot;frozen_inference_graph.pb&quot;;// tensorflow模型文件，注意不能含有中文 const std::string image_path = &quot;image1.jpg&quot;; // 待inference的图片grace_hopper.jpg // 设置输入图像 cv::Mat img = cv::imread(image_path); cv::cvtColor(img, img, cv::COLOR_BGR2RGB); int height = img.rows; int width = img.cols; int depth = img.channels(); // 取图像数据，赋给tensorflow支持的Tensor变量中 tensorflow::Tensor input_tensor(DT_UINT8, TensorShape({ 1, height, width, depth })); const uint8* source_data = img.data; auto input_tensor_mapped = input_tensor.tensor&lt;uint8, 4&gt;(); for (int i = 0; i &lt; height; i++) { const uint8* source_row = source_data + (i * width * depth); for (int j = 0; j &lt; width; j++) { const uint8* source_pixel = source_row + (j * depth); for (int c = 0; c &lt; depth; c++) { const uint8* source_value = source_pixel + c; input_tensor_mapped(0, i, j, c) = *source_value; } } } // 初始化tensorflow session Session* session; Status status = NewSession(SessionOptions(), &amp;session); if (!status.ok()) { std::cerr &lt;&lt; status.ToString() &lt;&lt; endl; return -1; } else { cout &lt;&lt; &quot;Session created successfully&quot; &lt;&lt; endl; } // 读取二进制的模型文件到graph中 tensorflow::GraphDef graph_def; status = ReadBinaryProto(Env::Default(), model_path, &amp;graph_def); if (!status.ok()) { std::cerr &lt;&lt; status.ToString() &lt;&lt; endl; return -1; } else { cout &lt;&lt; &quot;Load graph protobuf successfully&quot; &lt;&lt; endl; } // 将graph加载到session status = session-&gt;Create(graph_def); if (!status.ok()) { std::cerr &lt;&lt; status.ToString() &lt;&lt; endl; return -1; } else { cout &lt;&lt; &quot;Add graph to session successfully&quot; &lt;&lt; endl; } // 输入inputs，“ x_input”是我在模型中定义的输入数据名称 std::vector&lt;std::pair&lt;std::string, tensorflow::Tensor&gt;&gt; inputs = { { &quot;image_tensor:0&quot;, input_tensor }, }; // 输出outputs std::vector&lt;tensorflow::Tensor&gt; outputs; //批处理识别 double start = clock(); std::vector&lt;std::string&gt; output_nodes; output_nodes.push_back(&quot;num_detections&quot;); output_nodes.push_back(&quot;detection_boxes&quot;); output_nodes.push_back(&quot;detection_scores&quot;); output_nodes.push_back(&quot;detection_classes&quot;); // 运行会话，最终结果保存在outputs中 status = session-&gt;Run(inputs, { output_nodes }, {}, &amp;outputs); if (!status.ok()) { std::cerr &lt;&lt; status.ToString() &lt;&lt; endl; return -1; } else { cout &lt;&lt; &quot;Run session successfully&quot; &lt;&lt; endl; } double finish = clock(); double duration = (double)(finish - start) / CLOCKS_PER_SEC; cout &lt;&lt; &quot;spend time:&quot; &lt;&lt; duration &lt;&lt; endl; cv::imshow(&quot;image&quot;, img); cv::waitKey(); return 0; } 先别急着编译工程，首先我们需要把环境配置好： 配置opencv (Release版本)； 配置tensorflow C++库。 opencv库配置就不多赘述，这里主要说明tensorflow库的配置。 1）包含目录： D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\external\org_tensorflow;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\external\protobuf_archive\src;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\external\com_google_absl;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\external\eigen_archive;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\bazel-out\x64_windows-opt\genfiles; 2）库目录： D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\lib; 3）链接器输入附加依赖项： tensorflow_cc.lib; 环境配置好后，将之前生成的动态库放入应用程序目录，即复制 tensorflow_cc.dll 到与工程文件 .sln 同级的 x64\Release 文件夹下，如下图所示： 接下来，从网盘下载模型文件 frozen_inference_graph.pb 和测试图片 image1.jpg（点此链接） 模型文件在 tensorflow\ssd_mobilenet_v1_coco_2017_11_17 目录下； 测试图片在 tensorflow\test_images 目录下。 把它们放到与 .cpp 文件同级的目录下，如下图所示： 编译前的准备工作完成，现在我们可以编译生成项目。生成之前，注意选择 Release 和 x64，如下图红框所示： 编译可能出现无法解析的外部符号的问题，以下面的错误为例： 无法解析的外部符号 “public: virtual __cdecl tensorflow::internal::LogMessage::~LogMessage(void)” (??1LogMessage@internal@tensorflow@@UEAA@XZ)，该符号在函数 “public: void __cdecl tensorflow::internal::LogMessage::`vbase destructor’(void)” (??_DLogMessage@internal@tensorflow@@QEAAXXZ) 中被引用 解决方法： 用文本编辑器打开 D:\tensorflow-1.13.1\source\tensorflow\tf_exported_symbols_msvc.lds ，将前面一个括号中带问号的内容： ??1LogMessage@internal@tensorflow@@UEAA@XZ 复制到该文件的末尾，如下图所示。 如果有多个无法解析外部符号的问题，用同样的方法逐一添加。全部添加完成后保存关闭文件，然后重新编译tensorflow，也就是说从运行脚本文件开始，后面的流程要重新走一遍，想想有点心累，不过都已经走到这里了，半途而废有点说不过去呀，咬咬牙重来一遍吧。 上面的问题已经成功解决，没有意外，还会出现max问题： 解决办法如下： 双击错误提示，跳转到有max问题的文件： logging.h 和 tensor_shape.h，分别进行以下修改： 1）logging.h: 将第250行的 if (TF_PREDICT_FALSE(v2 &gt;= std::numeric_limits&lt;int&gt;::max())) { \ 改为 if (TF_PREDICT_FALSE(v2 &gt;= (std::numeric_limits&lt;int&gt;::max)())) { \ 修改后如下图所示： 2）tensor_shape.h: 将108-111行的 static const int64 kMaxRep16 = std::numeric_limits&lt;uint16&gt;::max() - 1; static const int64 kMaxRep32 = std::numeric_limits&lt;uint32&gt;::max() - 1; static const uint16 kUnknownRep16 = std::numeric_limits&lt;uint16&gt;::max(); static const uint32 kUnknownRep32 = std::numeric_limits&lt;uint32&gt;::max(); 改为： static const int64 kMaxRep16 = (std::numeric_limits&lt;uint16&gt;::max)() - 1; static const int64 kMaxRep32 = (std::numeric_limits&lt;uint32&gt;::max)() - 1; static const uint16 kUnknownRep16 = (std::numeric_limits&lt;uint16&gt;::max)(); static const uint32 kUnknownRep32 = (std::numeric_limits&lt;uint32&gt;::max)(); 修改后如下图所示： 修改好后我们重新生成项目，如果上面的步骤都没有问题，将会出现下面的结果： 没错！编译成功！小腿抖起来小曲儿唱起来! 到这里还没有结束，将程序运行起来，你将看到以下结果： 红框部分说明GPU和模型调用没毛病，妥妥地成功！小腿再次抖起来小曲儿再次唱起来! tensorflow C++库的生成和调用全部结束！ 支线任务 注意，这是作业，不是彩蛋。 测试程序结尾出现了以下神秘图片： 蓝狗？！ 还别说，狗狗蓝色的美瞳还真是洋气，蓝色的皮鞋更显骚气。 灵魂三问：小狗为什么是蓝色？定位框在哪？识别的结果在哪？ 这就需要骚年们好好的研究和琢磨了。 Happy Ending:" />
<link rel="canonical" href="https://uzzz.org/2019/08/21/795172.html" />
<meta property="og:url" content="https://uzzz.org/2019/08/21/795172.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-21T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"win10 + bazel-0.20.0 + tensorflow-1.13.1 编译tensorflow GPU版本的C++库 安装所需软件/库 Step1. 安装vs2015，CUDA 10.0和cuDNN 7.6 Step2. 安装msys2 Step3. 安装bazel Step4. 下载编译所需文件（tensorflow源码及其他文件） Step5. 使用powershell进行配置与编译 Step6. 整理生成的文件——dll，lib，include Step7. 调用模型测试程序 支线任务 参考资料： windows+bazel+tensorflow-v1.12.0(GPU)编译生成dll与lib; Error: “execution of scripts is disabled on this system” ; tensorflow1.4 c++编译以及API使用; window+tensorflow+cuda+cudnn 出现‘CUDnn_STATUS_ALLOC_FAILED’的可能解决办法; Return coordinates for bounding boxes Google’s Object Detection API; visualize_boxes_and_labels_on_image_array 函数. ---------------------- 超长文多图预警!!! ---------------------- 安装所需软件/库 vs2015; Anaconda3; CUDA 10.0; cuDNN 7.6; python3.6.7; tensorflow-1.13.1; bazel0.20.0; msys2-x86_64-20190524. Step1. 安装vs2015，CUDA 10.0和cuDNN 7.6 vs2015的安装这里就不多说了，Anaconda3、CUDA和cuDNN的安装可参考cmake编译opencv： Win10+cmake3.14.4+cuda10.0+cudnn7.6+opencv-4.0.0+contrib+vs2015。 Step2. 安装msys2 进入msys2官网，选择msys2-x86_64-20190524.exe，或直接点击此链接: msys2-x86_64-20190524，进行下载。 下载好后开始安装，点击Next： 接下来选择安装路径，我个人为了避免安装在系统盘，将盘符改成了D盘，如下图。然而在之后的编译过程中发现，msys64会在C盘再安装一遍，所以这里推荐使用默认，即安装在 C:\\msys64 下。接着点击Next，进入下一步。 这里直接Next： 软件开始安装，稍微等一会儿就好了。 安装完成，点击Finish： 弹出一个类似cmd的命令窗口，输入一下命令： pacman -Syu 询问是否进行安装，输入y，回车： 第一个命令执行完毕： 接着输入以下命令： pacman -S git 同样地，询问是否安装输入 y，然后回车： 第二个命令执行完毕： 接着输入： pacman -S patch unzip grep 是否安装输入 y，回车： 第三个命令执行完毕： 软件装好以后，需要配置环境变量。 将以下路径添加到系统变量 Path 中： D:\\msys64 D:\\msys64\\usr\\bin 注意，如果之前装在C盘，则需要进行相应修改。 如下图所示： msys2安装配置完毕！ Step3. 安装bazel 进入github，选择合适的bazel版本进行下载。 如果CUDA和Tensorflow的版本与本文一致，也可点此链接下载：bazel-0.20.0-windows-x86_64.exe。 github上选择下载文件如下图所示： 将下载好的 .exe 文件复制到 D:\\msys64 下（路径根据个人安装情况而定），更名为 bazel.exe。 复制完成后，配置bazel环境变量。 新建三个系统变量：BAZEL_SH，BAZEL_VC，BAZEL_VS。相应的路径如以下表格所示： 变量 值 BAZEL_SH D:\\msys64\\usr\\bin\\bash.exe BAZEL_VC D:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC BAZEL_VS D:\\Program Files (x86)\\Microsoft Visual Studio 14.0 环境变量配置完成： bazel安装配置完毕！ Step4. 下载编译所需文件（tensorflow源码及其他文件） 进入tensorflow-v1.13.1源码的github的页面 ，点击页面右侧绿色按钮Clone or download，然后点击Download ZIP进行下载，如下图所示。 或者也可直接点此链接：tensorflow-1.13.1 进行下载。 下载时间也许会很长，请耐心等待。 进入tensorflow-windows-build-script-master的github页面，下载tensorflow-windows-build-script-master.zip(此链接可直接下载)。 以上两个 .zip 文件下载完成后，在D盘新建一个文件夹，命名为 tensorflow-1.13.1 （也可根据个人喜好决定）。 将下载好的 tensorflow-1.13.1.zip 解压到刚刚新建的文件夹下，重新命名为 source； 将 tensorflow-windows-build-script-master.zip 解压到任意位置，然后把其中的 patches 和 build.ps1 文件，复制到新建的 D:\\tensorflow-1.13.1目录下，如下图所示： 将 patches 下的 eigen_half.patch 复制到 tensorflow-1.13.1\\source\\third_party 下： 将 patches 下的 tf_exported_symbols_msvc.lds 复制到 tensorflow-1.13.1\\source\\tensorflow 下： 用文本编辑器打开 build.ps1 文件，将以下语句注释掉： Copy-Item …\\patches\\tf_exported_symbols_msvc.lds tensorflow\\ 防止编译时出现Copy-Item命令的问题。 位置在 build.ps1 的180行，如下图所示： 编译所需文件准备完毕！ Step5. 使用powershell进行配置与编译 在 C:\\Windows\\SysWOW64\\WindowsPowerShell\\v1.0 目录下，右键以管理员身份运行 powershell.exe： 在 powershell 窗口中输入以下命令，转到 tensorflow-1.13.1 目录下： cd D:\\tensorflow-1.13.1 输入bazel编译的选项： $parameterString = &quot;--config=opt --config=cuda --define=no_tensorflow_py_deps=true --copt=-nvcc_options=disable-warnings //tensorflow:libtensorflow_cc.so --verbose_failures&quot; 然后输入以下命令，执行 build.ps1 脚本文件： .\\build.ps1 -BazelBuildParameters $parameterString -BuildCppAPI -ReserveSource 执行命令时出现 UnauthorizedAccess 错误，说明可能是 powershell 的执行策略受限，输入以下命令查看当前执行策略： Get-ExecutionPolicy 我这里显示的是Restricted（受限的），所以需要输入以下语句来取消限制： Set-ExecutionPolicy Unrestricted 询问是否改变执行策略，输入 y，回车。 修改好后，可以再次输入： Get-ExecutionPolicy 查看当前执行策略是否已经取消限制。 执行策略的问题解决以后，重新执行 build.ps1 脚本文件： .\\build.ps1 -BazelBuildParameters $parameterString -BuildCppAPI -ReserveSource 如果一切正常，我们将开始编译前的配置。可参照以下两图进行配置。有些提问可以直接按回车来选择默认配置，括号中出现 default 字眼的，都可以这么做。 注意 ：当问到GPU的计算能力（compute capability），即出现 [Default is: 3.5, 7.0]: 时，先不要急着按回车。我们先找到跟自己显卡对应的计算能力，再进行填写，可参考后面的方法来查看显卡的计算能力。 打开设备管理器，找到自己的显卡型号： 然后进入NVDIA官网的CUDA GPUs页面，点击 CUDA-Enabled GeForce and TITAN Products，找到自己的显卡型号对应的数值，将其填入 [Default is: 3.5, 7.0]: 后面，回车继续配置。 都配置完成后，编译正式开始。注意保持网络通畅，因为编译之前需要下载各种依赖库，网络异常会导致下载失败停止编译。编译时间很长，不要光盯着屏幕看，该吃吃该喝喝该玩玩该睡睡。 编译可能出现无法解析的外部符号的问题，以下面的错误为例： 无法解析的外部符号 “public: virtual __cdecl tensorflow::internal::LogMessage::~LogMessage(void)” (??1LogMessage@internal@tensorflow@@UEAA@XZ)，该符号在函数 “public: void __cdecl tensorflow::internal::LogMessage::`vbase destructor’(void)” (??_DLogMessage@internal@tensorflow@@QEAAXXZ) 中被引用 解决方法： 用文本编辑器打开 D:\\tensorflow-1.13.1\\source\\tensorflow\\tf_exported_symbols_msvc.lds ，找到前面一个括号中带问号的内容： ??1LogMessage@internal@tensorflow@@UEAA@XZ 将其删除。如果有多个无法解析外部符号的问题，用同样的方法逐一删除即可。 确认全部清除后，重新执行以下命令配置和编译： .\\build.ps1 -BazelBuildParameters $parameterString -BuildCppAPI -ReserveSource 如果一切正常，在漫长的等待之后，将会出现以下结果： 注意：第一个红框部分为编译生成的动态库 libtensorflow_cc.so 所在位置，请记录下来，后面需要用到。 编译任务圆满完成！！！ 可以稍作休息小小庆祝一下！ Step6. 整理生成的文件——dll，lib，include 新建一个文件夹，在文件夹中创建以下三个目录：dll，lib，include。 根据编译结束时显示的动态库所在位置，找到生成的库 libtensorflow_cc.so 和 liblibtensorflow_cc.so.ifso。 将 libtensorflow_cc.so 更名为 tensorflow_cc.dll，放到刚才创建的 dll 目录下； 将 liblibtensorflow_cc.so.ifso 更名为 tensorflow_cc.lib，放到刚才创建的 lib 目录下。 接下来要做的是填满 include 目录，该步相对繁琐，最终将包含以下文件夹： 1）在include目录中新建名为 _bin 的文件夹。参考以下路径，打开 _embedded_binaries 目录，将下图红框中的文件复制到 _bin 文件夹中： C:\\Users\\xxx_bazel_xxx\\install\\d5b1be53d8db6a1e2d160364df2e7ef6_embedded_binaries 2-1) 参考以下路径，将下图红框中的 bazel-out 文件夹复制到 include 目录下： C:\\Users\\xxx_bazel_xxx\\y46qiod6\\execroot\\org_tensorflow 2-2) 参考以下路径，将 protobuf_archive 文件夹复制到 include 下的 bazel-out\\x64_windows-opt\\genfiles\\external 目录中： C:\\Users\\xxx_bazel_xxx\\y46qiod6\\external 3） 将 D:\\tensorflow-1.13.1\\source 下的 tensorflow 和 third_party 复制到 include 目录下： 4-1) 参照以下路径，将下图红框中的 external 文件夹复制到 include 目录下： C:\\Users\\xxx_bazel_xxx\\y46qiod6 4-2) 参照以下路径，将 embedded_tools 文件夹下的所有文件复制到 include 下的 external\\bazel_tools 目录中（如果 external 里面没有该文件夹，需新建并命名为 bazel_tools）： C:\\Users\\xxx_bazel_xxx\\install\\d5b1be53d8db6a1e2d160364df2e7ef6_embedded_binaries\\embedded_tools 4-3) 将 D:\\tensorflow-1.13.1\\source 下的 tensorflow 复制到 include 下的 external\\org_tensorflow 目录中（如果 external 里面没有该文件夹，需新建并命名为 rg_tensorflow）： 至此，调用tensorflow所需的库及包含的目录准备完毕！ Step7. 调用模型测试程序 新建测试工程，在 .cpp 文件中写入以下代码： #define COMPILER_MSVC #define NOMINMAX #define PLATFORM_WINDOWS // 指定使用tensorflow/core/platform/windows/cpu_info.h #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;opencv2/opencv.hpp&gt; #include&quot;tensorflow/core/public/session.h&quot; #include &quot;tensorflow/core/platform/env.h&quot; #include &lt;time.h&gt; using namespace tensorflow; using namespace cv; using std::cout; using std::endl; int main() { const std::string model_path = &quot;frozen_inference_graph.pb&quot;;// tensorflow模型文件，注意不能含有中文 const std::string image_path = &quot;image1.jpg&quot;; // 待inference的图片grace_hopper.jpg // 设置输入图像 cv::Mat img = cv::imread(image_path); cv::cvtColor(img, img, cv::COLOR_BGR2RGB); int height = img.rows; int width = img.cols; int depth = img.channels(); // 取图像数据，赋给tensorflow支持的Tensor变量中 tensorflow::Tensor input_tensor(DT_UINT8, TensorShape({ 1, height, width, depth })); const uint8* source_data = img.data; auto input_tensor_mapped = input_tensor.tensor&lt;uint8, 4&gt;(); for (int i = 0; i &lt; height; i++) { const uint8* source_row = source_data + (i * width * depth); for (int j = 0; j &lt; width; j++) { const uint8* source_pixel = source_row + (j * depth); for (int c = 0; c &lt; depth; c++) { const uint8* source_value = source_pixel + c; input_tensor_mapped(0, i, j, c) = *source_value; } } } // 初始化tensorflow session Session* session; Status status = NewSession(SessionOptions(), &amp;session); if (!status.ok()) { std::cerr &lt;&lt; status.ToString() &lt;&lt; endl; return -1; } else { cout &lt;&lt; &quot;Session created successfully&quot; &lt;&lt; endl; } // 读取二进制的模型文件到graph中 tensorflow::GraphDef graph_def; status = ReadBinaryProto(Env::Default(), model_path, &amp;graph_def); if (!status.ok()) { std::cerr &lt;&lt; status.ToString() &lt;&lt; endl; return -1; } else { cout &lt;&lt; &quot;Load graph protobuf successfully&quot; &lt;&lt; endl; } // 将graph加载到session status = session-&gt;Create(graph_def); if (!status.ok()) { std::cerr &lt;&lt; status.ToString() &lt;&lt; endl; return -1; } else { cout &lt;&lt; &quot;Add graph to session successfully&quot; &lt;&lt; endl; } // 输入inputs，“ x_input”是我在模型中定义的输入数据名称 std::vector&lt;std::pair&lt;std::string, tensorflow::Tensor&gt;&gt; inputs = { { &quot;image_tensor:0&quot;, input_tensor }, }; // 输出outputs std::vector&lt;tensorflow::Tensor&gt; outputs; //批处理识别 double start = clock(); std::vector&lt;std::string&gt; output_nodes; output_nodes.push_back(&quot;num_detections&quot;); output_nodes.push_back(&quot;detection_boxes&quot;); output_nodes.push_back(&quot;detection_scores&quot;); output_nodes.push_back(&quot;detection_classes&quot;); // 运行会话，最终结果保存在outputs中 status = session-&gt;Run(inputs, { output_nodes }, {}, &amp;outputs); if (!status.ok()) { std::cerr &lt;&lt; status.ToString() &lt;&lt; endl; return -1; } else { cout &lt;&lt; &quot;Run session successfully&quot; &lt;&lt; endl; } double finish = clock(); double duration = (double)(finish - start) / CLOCKS_PER_SEC; cout &lt;&lt; &quot;spend time:&quot; &lt;&lt; duration &lt;&lt; endl; cv::imshow(&quot;image&quot;, img); cv::waitKey(); return 0; } 先别急着编译工程，首先我们需要把环境配置好： 配置opencv (Release版本)； 配置tensorflow C++库。 opencv库配置就不多赘述，这里主要说明tensorflow库的配置。 1）包含目录： D:\\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76;D:\\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\\include;D:\\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\\include\\external\\org_tensorflow;D:\\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\\include\\external\\protobuf_archive\\src;D:\\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\\include\\external\\com_google_absl;D:\\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\\include\\external\\eigen_archive;D:\\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\\include\\bazel-out\\x64_windows-opt\\genfiles; 2）库目录： D:\\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\\lib; 3）链接器输入附加依赖项： tensorflow_cc.lib; 环境配置好后，将之前生成的动态库放入应用程序目录，即复制 tensorflow_cc.dll 到与工程文件 .sln 同级的 x64\\Release 文件夹下，如下图所示： 接下来，从网盘下载模型文件 frozen_inference_graph.pb 和测试图片 image1.jpg（点此链接） 模型文件在 tensorflow\\ssd_mobilenet_v1_coco_2017_11_17 目录下； 测试图片在 tensorflow\\test_images 目录下。 把它们放到与 .cpp 文件同级的目录下，如下图所示： 编译前的准备工作完成，现在我们可以编译生成项目。生成之前，注意选择 Release 和 x64，如下图红框所示： 编译可能出现无法解析的外部符号的问题，以下面的错误为例： 无法解析的外部符号 “public: virtual __cdecl tensorflow::internal::LogMessage::~LogMessage(void)” (??1LogMessage@internal@tensorflow@@UEAA@XZ)，该符号在函数 “public: void __cdecl tensorflow::internal::LogMessage::`vbase destructor’(void)” (??_DLogMessage@internal@tensorflow@@QEAAXXZ) 中被引用 解决方法： 用文本编辑器打开 D:\\tensorflow-1.13.1\\source\\tensorflow\\tf_exported_symbols_msvc.lds ，将前面一个括号中带问号的内容： ??1LogMessage@internal@tensorflow@@UEAA@XZ 复制到该文件的末尾，如下图所示。 如果有多个无法解析外部符号的问题，用同样的方法逐一添加。全部添加完成后保存关闭文件，然后重新编译tensorflow，也就是说从运行脚本文件开始，后面的流程要重新走一遍，想想有点心累，不过都已经走到这里了，半途而废有点说不过去呀，咬咬牙重来一遍吧。 上面的问题已经成功解决，没有意外，还会出现max问题： 解决办法如下： 双击错误提示，跳转到有max问题的文件： logging.h 和 tensor_shape.h，分别进行以下修改： 1）logging.h: 将第250行的 if (TF_PREDICT_FALSE(v2 &gt;= std::numeric_limits&lt;int&gt;::max())) { \\ 改为 if (TF_PREDICT_FALSE(v2 &gt;= (std::numeric_limits&lt;int&gt;::max)())) { \\ 修改后如下图所示： 2）tensor_shape.h: 将108-111行的 static const int64 kMaxRep16 = std::numeric_limits&lt;uint16&gt;::max() - 1; static const int64 kMaxRep32 = std::numeric_limits&lt;uint32&gt;::max() - 1; static const uint16 kUnknownRep16 = std::numeric_limits&lt;uint16&gt;::max(); static const uint32 kUnknownRep32 = std::numeric_limits&lt;uint32&gt;::max(); 改为： static const int64 kMaxRep16 = (std::numeric_limits&lt;uint16&gt;::max)() - 1; static const int64 kMaxRep32 = (std::numeric_limits&lt;uint32&gt;::max)() - 1; static const uint16 kUnknownRep16 = (std::numeric_limits&lt;uint16&gt;::max)(); static const uint32 kUnknownRep32 = (std::numeric_limits&lt;uint32&gt;::max)(); 修改后如下图所示： 修改好后我们重新生成项目，如果上面的步骤都没有问题，将会出现下面的结果： 没错！编译成功！小腿抖起来小曲儿唱起来! 到这里还没有结束，将程序运行起来，你将看到以下结果： 红框部分说明GPU和模型调用没毛病，妥妥地成功！小腿再次抖起来小曲儿再次唱起来! tensorflow C++库的生成和调用全部结束！ 支线任务 注意，这是作业，不是彩蛋。 测试程序结尾出现了以下神秘图片： 蓝狗？！ 还别说，狗狗蓝色的美瞳还真是洋气，蓝色的皮鞋更显骚气。 灵魂三问：小狗为什么是蓝色？定位框在哪？识别的结果在哪？ 这就需要骚年们好好的研究和琢磨了。 Happy Ending:","@type":"BlogPosting","url":"https://uzzz.org/2019/08/21/795172.html","headline":"win10 + bazel-0.20.0 + tensorflow-1.13.1 编译tensorflow GPU版本的C++库","dateModified":"2019-08-21T00:00:00+08:00","datePublished":"2019-08-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/08/21/795172.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>win10 + bazel-0.20.0 + tensorflow-1.13.1 编译tensorflow GPU版本的C++库</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> 
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path> 
  </svg> 
  <p></p>
  <div class="toc">
   <h3>win10 + bazel-0.20.0 + tensorflow-1.13.1 编译tensorflow GPU版本的C++库</h3>
   <ul>
    <li><a href="#_11" rel="nofollow" data-token="cb40185be6be9cd64c5c6e98d9f9911c">安装所需软件/库</a></li>
    <li><a href="#Step1_vs2015CUDA_100cuDNN_76_21" rel="nofollow" data-token="090dfdf4336470d37e3a1224951465ba">Step1. 安装vs2015，CUDA 10.0和cuDNN 7.6</a></li>
    <li><a href="#Step2_msys2_25" rel="nofollow" data-token="fe67b641fde887d9f824db5225c34476">Step2. 安装msys2</a></li>
    <li><a href="#Step3_bazel_86" rel="nofollow" data-token="7de0c9440ab3c952378527c7949f9351">Step3. 安装bazel</a></li>
    <li><a href="#Step4_tensorflow_110" rel="nofollow" data-token="56e645c681324966ac515ee1e9f195dc">Step4. 下载编译所需文件（tensorflow源码及其他文件）</a></li>
    <li><a href="#Step5_powershell_140" rel="nofollow" data-token="ff45969981343f169958741aad667520">Step5. 使用powershell进行配置与编译</a></li>
    <li><a href="#Step6_dlllibinclude_211" rel="nofollow" data-token="bd24cb611da6d0dc370ddc0f3c4b5956">Step6. 整理生成的文件——dll，lib，include</a></li>
    <li><a href="#Step7__257" rel="nofollow" data-token="88f7a71ca9952877fb0fa2b01a818610">Step7. 调用模型测试程序</a></li>
    <li><a href="#_469" rel="nofollow" data-token="82285a7cfedf098e3bc93f4bb61b580c">支线任务</a></li>
   </ul>
  </div>
  <p></p> 
  <p>参考资料：</p> 
  <ul> 
   <li><a href="https://blog.csdn.net/qq_35975447/article/details/91986142" rel="nofollow" data-token="924ebcb509be1c43b6c7fa25ca80f369">windows+bazel+tensorflow-v1.12.0(GPU)编译生成dll与lib</a>;</li> 
   <li><a href="https://www.quadrotech-it.com/blog/allowing-powershell-scripts-to-execute/" rel="nofollow" data-token="fb7e345152367f0251127a7344a68864">Error: “execution of scripts is disabled on this system” </a>;</li> 
   <li><a href="https://blog.csdn.net/zwx1995zwx/article/details/79064064" rel="nofollow" data-token="5a2129a2dcb0c6364c02485eebf3e969">tensorflow1.4 c++编译以及API使用</a>;</li> 
   <li><a href="https://blog.csdn.net/qq_40635998/article/details/87297634" rel="nofollow" data-token="5c643eb55e915cde00aa6b47c1f3f89c">window+tensorflow+cuda+cudnn 出现‘CUDnn_STATUS_ALLOC_FAILED’的可能解决办法</a>;</li> 
   <li><a href="https://stackoverflow.com/questions/47110528/return-coordinates-for-bounding-boxes-googles-object-detection-api" rel="nofollow" data-token="f8406c80e5d88fe8d7dee8332aa7ba32">Return coordinates for bounding boxes Google’s Object Detection API</a>;</li> 
   <li><a href="https://blog.csdn.net/weixin_44345862/article/details/93187794" rel="nofollow" data-token="34591d0a1dd90932f43768da71520b77">visualize_boxes_and_labels_on_image_array 函数</a>.</li> 
  </ul> 
  <p><strong><font color="darkred" size="6">---------------------- 超长文多图预警!!! ----------------------</font></strong></p> 
  <h1><a id="_11"></a>安装所需软件/库</h1> 
  <ul> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> <a href="" rel="nofollow" data-token="165af54af7eb395bbecd5b57515c97ba">vs2015</a>;</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> <a href="https://www.anaconda.com/distribution/" rel="nofollow" data-token="c5d61e496d190e59be382e3467ef44b2">Anaconda3</a>;</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> <a href="https://developer.nvidia.com/cuda-10.0-download-archive" rel="nofollow" data-token="f0ac21a8105cc9bc22dd7deeb33d97f5">CUDA 10.0</a>;</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> <a href="https://developer.nvidia.com/rdp/cudnn-download" rel="nofollow" data-token="e9329a5862427b2ceb90e63b831a9bcc">cuDNN 7.6</a>;</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> <a href="https://www.python.org/ftp/python/3.6.7/python-3.6.7-amd64.exe" rel="nofollow" data-token="f2c72877f6913a460e45c7c7febd2004">python3.6.7</a>;</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> <a href="https://github.com/tensorflow/tensorflow/archive/v1.13.1.zip" rel="nofollow" data-token="24684c24567db721548717f3abf6505c">tensorflow-1.13.1</a>;</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> <a href="https://github.com/bazelbuild/bazel/releases/download/0.20.0/bazel-0.20.0-windows-x86_64.exe" rel="nofollow" data-token="0df42c5ab7d32ffc67d214a3e1cda2ae">bazel0.20.0</a>;</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="true" disabled> <a href="http://repo.msys2.org/distrib/x86_64/msys2-x86_64-20190524.exe" rel="nofollow" data-token="cb9120e5fd34fbda0f0ee2b3aa2c3b1b">msys2-x86_64-20190524</a>.</li> 
  </ul> 
  <h1><a id="Step1_vs2015CUDA_100cuDNN_76_21"></a>Step1. 安装vs2015，CUDA 10.0和cuDNN 7.6</h1> 
  <p>vs2015的安装这里就不多说了，Anaconda3、CUDA和cuDNN的安装可参考<a href="https://blog.csdn.net/atpalain_csdn/article/details/90755764" rel="nofollow" data-token="3db3bbe3d06364c6d90b74c3bd248677">cmake编译opencv： Win10+cmake3.14.4+cuda10.0+cudnn7.6+opencv-4.0.0+contrib+vs2015</a>。</p> 
  <h1><a id="Step2_msys2_25"></a>Step2. 安装msys2</h1> 
  <p>进入<a href="http://www.msys2.org" rel="nofollow" data-token="fbe9a85ecebaba1a4f8b2a375329e00d">msys2官网</a>，选择<kbd>msys2-x86_64-20190524.exe</kbd>，或直接点击此链接: <a href="http://repo.msys2.org/distrib/x86_64/msys2-x86_64-20190524.exe" rel="nofollow" data-token="cb9120e5fd34fbda0f0ee2b3aa2c3b1b">msys2-x86_64-20190524</a>，进行下载。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190731191057540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 下载好后开始安装，点击<kbd>Next</kbd>：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802085811927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 接下来选择安装路径，我个人为了避免安装在系统盘，将盘符改成了D盘，如下图。然而在之后的编译过程中发现，msys64会在C盘再安装一遍，所以这里推荐使用默认，即安装在 <strong>C:\msys64</strong> 下。接着点击<kbd>Next</kbd>，进入下一步。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802090006387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 这里直接<kbd>Next</kbd>：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802090015879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 软件开始安装，稍微等一会儿就好了。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802090051412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 安装完成，点击<kbd>Finish</kbd>：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802090105872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 弹出一个类似cmd的命令窗口，输入一下命令：</p> 
  <pre><code>pacman -Syu
</code></pre> 
  <p>询问是否进行安装，输入<strong>y</strong>，回车：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802090116872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 第一个命令执行完毕：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802090125509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 接着输入以下命令：</p> 
  <pre><code>pacman -S git
</code></pre> 
  <p>同样地，询问是否安装输入 <strong>y</strong>，然后回车：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802090134244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 第二个命令执行完毕：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802090142826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 接着输入：</p> 
  <pre><code>pacman -S patch unzip grep
</code></pre> 
  <p>是否安装输入 <strong>y</strong>，回车：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802090205876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 第三个命令执行完毕：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802090214838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
  <p>软件装好以后，需要配置环境变量。<br> 将以下路径添加到系统变量 <strong>Path</strong> 中：</p> 
  <blockquote> 
   <p>D:\msys64<br> D:\msys64\usr\bin</p> 
  </blockquote> 
  <p>注意，如果之前装在C盘，则需要进行相应修改。<br> 如下图所示：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802093848814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> msys2安装配置完毕！</p> 
  <h1><a id="Step3_bazel_86"></a>Step3. 安装bazel</h1> 
  <p>进入<a href="https://github.com/bazelbuild/bazel/tags" rel="nofollow" data-token="892f4981c9c0614c9422b5a1fa721fbc">github</a>，选择合适的bazel版本进行下载。<br> 如果CUDA和Tensorflow的版本与本文一致，也可点此链接下载：<a href="https://github.com/bazelbuild/bazel/releases/download/0.20.0/bazel-0.20.0-windows-x86_64.exe" rel="nofollow" data-token="0df42c5ab7d32ffc67d214a3e1cda2ae">bazel-0.20.0-windows-x86_64.exe</a>。<br> github上选择下载文件如下图所示：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802102319152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 将下载好的 <strong>.exe</strong> 文件复制到 <strong>D:\msys64</strong> 下（路径根据个人安装情况而定），更名为 <strong>bazel.exe</strong>。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802102617358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 复制完成后，配置bazel环境变量。<br> 新建三个系统变量：<strong>BAZEL_SH</strong>，<strong>BAZEL_VC</strong>，<strong>BAZEL_VS</strong>。相应的路径如以下表格所示：</p> 
  <table> 
   <thead> 
    <tr> 
     <th align="left">变量</th> 
     <th align="left">值</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td align="left">BAZEL_SH</td> 
     <td align="left">D:\msys64\usr\bin\bash.exe</td> 
    </tr> 
    <tr> 
     <td align="left">BAZEL_VC</td> 
     <td align="left">D:\Program Files (x86)\Microsoft Visual Studio 14.0\VC</td> 
    </tr> 
    <tr> 
     <td align="left">BAZEL_VS</td> 
     <td align="left">D:\Program Files (x86)\Microsoft Visual Studio 14.0</td> 
    </tr> 
   </tbody> 
  </table>
  <p>环境变量配置完成：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802102302445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
  <p>bazel安装配置完毕！</p> 
  <h1><a id="Step4_tensorflow_110"></a>Step4. 下载编译所需文件（tensorflow源码及其他文件）</h1> 
  <p>进入<a href="https://github.com/tensorflow/tensorflow/tree/v1.13.1" rel="nofollow" data-token="b98817c0c22ddc7ce25ebec88769a89d">tensorflow-v1.13.1源码的github的页面</a> ，点击页面右侧绿色按钮<kbd>Clone or download</kbd>，然后点击<kbd>Download ZIP</kbd>进行下载，如下图所示。<br> 或者也可直接点此链接：<a href="https://github.com/tensorflow/tensorflow/archive/v1.13.1.zip" rel="nofollow" data-token="24684c24567db721548717f3abf6505c">tensorflow-1.13.1</a> 进行下载。<br> 下载时间也许会很长，请耐心等待。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802104948915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 进入<a href="https://github.com/guikarist/tensorflow-windows-build-script" rel="nofollow" data-token="efb4b05de08710b8a88daecfb02c30f2">tensorflow-windows-build-script-master的github页面</a>，下载<a href="https://github.com/guikarist/tensorflow-windows-build-script/archive/master.zip" rel="nofollow" data-token="c1eb4628d255e2714cb0aa1aa8b71755">tensorflow-windows-build-script-master.zip</a>(此链接可直接下载)。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802143121669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
  <p>以上两个 <strong>.zip</strong> 文件下载完成后，在D盘新建一个文件夹，命名为 <strong>tensorflow-1.13.1</strong> （也可根据个人喜好决定）。</p> 
  <ul> 
   <li>将下载好的 <strong>tensorflow-1.13.1.zip</strong> 解压到刚刚新建的文件夹下，重新命名为 <strong>source</strong>；</li> 
   <li>将 <strong>tensorflow-windows-build-script-master.zip</strong> 解压到任意位置，然后把其中的 <strong>patches</strong> 和 <strong>build.ps1</strong> 文件，复制到新建的 <strong>D:\tensorflow-1.13.1</strong>目录下，如下图所示：</li> 
  </ul> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802143907521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
  <ul> 
   <li>将 <strong>patches</strong> 下的 <strong>eigen_half.patch</strong> 复制到 <strong>tensorflow-1.13.1\source\third_party</strong> 下：</li> 
  </ul> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105019224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
  <ul> 
   <li>将 <strong>patches</strong> 下的 <strong>tf_exported_symbols_msvc.lds</strong> 复制到 <strong>tensorflow-1.13.1\source\tensorflow</strong> 下：</li> 
  </ul> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105037643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
  <ul> 
   <li>用文本编辑器打开 <strong>build.ps1</strong> 文件，将以下语句注释掉：</li> 
  </ul> 
  <blockquote> 
   <p>Copy-Item …\patches\tf_exported_symbols_msvc.lds tensorflow\</p> 
  </blockquote> 
  <p>防止编译时出现Copy-Item命令的问题。<br> 位置在 <strong>build.ps1</strong> 的180行，如下图所示：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105050398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 编译所需文件准备完毕！</p> 
  <h1><a id="Step5_powershell_140"></a>Step5. 使用powershell进行配置与编译</h1> 
  <p>在 <strong>C:\Windows\SysWOW64\WindowsPowerShell\v1.0</strong> 目录下，右键以管理员身份运行 <strong>powershell.exe</strong>：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802175453748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 在 <strong>powershell</strong> 窗口中输入以下命令，转到 <strong>tensorflow-1.13.1</strong> 目录下：</p> 
  <pre><code>cd D:\tensorflow-1.13.1
</code></pre> 
  <p>输入bazel编译的选项：</p> 
  <pre><code>$parameterString = "--config=opt --config=cuda --define=no_tensorflow_py_deps=true --copt=-nvcc_options=disable-warnings //tensorflow:libtensorflow_cc.so --verbose_failures"
</code></pre> 
  <p>然后输入以下命令，执行 <strong>build.ps1</strong> 脚本文件：</p> 
  <pre><code>.\build.ps1 -BazelBuildParameters $parameterString -BuildCppAPI -ReserveSource
</code></pre> 
  <p>执行命令时出现 <strong>UnauthorizedAccess</strong> 错误，说明可能是 <strong>powershell</strong> 的执行策略受限，输入以下命令查看当前执行策略：</p> 
  <pre><code>Get-ExecutionPolicy
</code></pre> 
  <p>我这里显示的是Restricted（受限的），所以需要输入以下语句来取消限制：</p> 
  <pre><code>Set-ExecutionPolicy Unrestricted
</code></pre> 
  <p>询问是否改变执行策略，输入 <strong>y</strong>，回车。<br> 修改好后，可以再次输入：</p> 
  <pre><code>Get-ExecutionPolicy
</code></pre> 
  <p>查看当前执行策略是否已经取消限制。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105105774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 执行策略的问题解决以后，重新执行 <strong>build.ps1</strong> 脚本文件：</p> 
  <pre><code>.\build.ps1 -BazelBuildParameters $parameterString -BuildCppAPI -ReserveSource
</code></pre> 
  <p>如果一切正常，我们将开始编译前的配置。可参照以下两图进行配置。有些提问可以直接按回车来选择默认配置，括号中出现 <strong>default</strong> 字眼的，都可以这么做。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105222501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> <font color="darkred"><strong>注意</strong> </font>：当问到GPU的计算能力（<strong>compute capability</strong>），即出现 <strong>[Default is: 3.5, 7.0]:</strong> 时，先不要急着按回车。我们先找到跟自己显卡对应的计算能力，再进行填写，可参考后面的方法来查看显卡的计算能力。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105233941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 打开设备管理器，找到自己的显卡型号：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105313465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 然后进入NVDIA官网的<a href="https://developer.nvidia.com/cuda-gpus" rel="nofollow" data-token="e60de530bdddde811c71f132c127712e">CUDA GPUs</a>页面，点击 <strong>CUDA-Enabled GeForce and TITAN Products</strong>，找到自己的显卡型号对应的数值，将其填入 <strong>[Default is: 3.5, 7.0]:</strong> 后面，回车继续配置。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105327286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 都配置完成后，编译正式开始。注意保持网络通畅，因为编译之前需要下载各种依赖库，网络异常会导致下载失败停止编译。编译时间很长，不要光盯着屏幕看，该吃吃该喝喝该玩玩该睡睡。</p> 
  <p>编译可能出现无法解析的外部符号的问题，以下面的错误为例：</p> 
  <blockquote> 
   <p>无法解析的外部符号 “public: virtual __cdecl tensorflow::internal::LogMessage::~LogMessage(void)” (??1LogMessage@internal@tensorflow@@UEAA@XZ)，该符号在函数 “public: void __cdecl tensorflow::internal::LogMessage::`vbase destructor’(void)” (??_DLogMessage@internal@tensorflow@@QEAAXXZ) 中被引用</p> 
  </blockquote> 
  <p>解决方法：<br> 用文本编辑器打开 <strong>D:\tensorflow-1.13.1\source\tensorflow\tf_exported_symbols_msvc.lds</strong> ，找到前面一个括号中带问号的内容：</p> 
  <blockquote> 
   <p>??1LogMessage@internal@tensorflow@@UEAA@XZ</p> 
  </blockquote> 
  <p>将其删除。如果有多个无法解析外部符号的问题，用同样的方法逐一删除即可。<br> 确认全部清除后，重新执行以下命令配置和编译：</p> 
  <pre><code>.\build.ps1 -BazelBuildParameters $parameterString -BuildCppAPI -ReserveSource
</code></pre> 
  <p>如果一切正常，在漫长的等待之后，将会出现以下结果：<br> <font color="darkred"><strong>注意</strong></font>：第一个红框部分为编译生成的动态库 <strong>libtensorflow_cc.so</strong> 所在位置，请记录下来，后面需要用到。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105203534.png#pic_center" alt="在这里插入图片描述"><br> 编译任务圆满完成！！！<br> 可以稍作休息小小庆祝一下！</p> 
  <h1><a id="Step6_dlllibinclude_211"></a>Step6. 整理生成的文件——dll，lib，include</h1> 
  <p>新建一个文件夹，在文件夹中创建以下三个目录：<strong>dll</strong>，<strong>lib</strong>，<strong>include</strong>。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105344946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 根据编译结束时显示的动态库所在位置，找到生成的库 <strong>libtensorflow_cc.so</strong> 和 <strong>liblibtensorflow_cc.so.ifso</strong>。</p> 
  <ul> 
   <li>将 <strong>libtensorflow_cc.so</strong> 更名为 <strong>tensorflow_cc.dll</strong>，放到刚才创建的 <strong>dll</strong> 目录下；</li> 
   <li>将 <strong>liblibtensorflow_cc.so.ifso</strong> 更名为 <strong>tensorflow_cc.lib</strong>，放到刚才创建的 <strong>lib</strong> 目录下。</li> 
  </ul> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019080210540074.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 接下来要做的是填满 <strong>include</strong> 目录，该步相对繁琐，最终将包含以下文件夹：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190805184917129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
  <p>1）在<strong>include</strong>目录中新建名为 <strong>_bin</strong> 的文件夹。参考以下路径，打开 <strong>_embedded_binaries</strong> 目录，将下图红框中的文件复制到 <strong>_bin</strong> 文件夹中：</p> 
  <blockquote> 
   <p>C:\Users\xxx_bazel_xxx\install\d5b1be53d8db6a1e2d160364df2e7ef6_embedded_binaries</p> 
  </blockquote> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105411207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 2-1) 参考以下路径，将下图红框中的 <strong>bazel-out</strong> 文件夹复制到 <strong>include</strong> 目录下：</p> 
  <blockquote> 
   <p>C:\Users\xxx_bazel_xxx\y46qiod6\execroot\org_tensorflow</p> 
  </blockquote> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105422147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 2-2) 参考以下路径，将 <strong>protobuf_archive</strong> 文件夹复制到 <strong>include</strong> 下的 <strong>bazel-out\x64_windows-opt\genfiles\external</strong> 目录中：</p> 
  <blockquote> 
   <p>C:\Users\xxx_bazel_xxx\y46qiod6\external</p> 
  </blockquote> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105437916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
  <p>3） 将 <strong>D:\tensorflow-1.13.1\source</strong> 下的 <strong>tensorflow</strong> 和 <strong>third_party</strong> 复制到 <strong>include</strong> 目录下：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105450459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 4-1) 参照以下路径，将下图红框中的 <strong>external</strong> 文件夹复制到 <strong>include</strong> 目录下：</p> 
  <blockquote> 
   <p>C:\Users\xxx_bazel_xxx\y46qiod6</p> 
  </blockquote> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190805181847956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 4-2) 参照以下路径，将 <strong>embedded_tools</strong> 文件夹下的所有文件复制到 <strong>include</strong> 下的 <strong>external\bazel_tools</strong> 目录中（如果 <strong>external</strong> 里面没有该文件夹，需新建并命名为 <strong>bazel_tools</strong>）：</p> 
  <blockquote> 
   <p>C:\Users\xxx_bazel_xxx\install\d5b1be53d8db6a1e2d160364df2e7ef6_embedded_binaries\embedded_tools</p> 
  </blockquote> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190802105502730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
  <p>4-3) 将 <strong>D:\tensorflow-1.13.1\source</strong> 下的 <strong>tensorflow</strong> 复制到 <strong>include</strong> 下的 <strong>external\org_tensorflow</strong> 目录中（如果 <strong>external</strong> 里面没有该文件夹，需新建并命名为 <strong>rg_tensorflow</strong>）：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190805184813673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 至此，调用tensorflow所需的库及包含的目录准备完毕！</p> 
  <h1><a id="Step7__257"></a>Step7. 调用模型测试程序</h1> 
  <p>新建测试工程，在 <strong>.cpp</strong> 文件中写入以下代码：</p> 
  <pre><code>#define COMPILER_MSVC
#define NOMINMAX
#define PLATFORM_WINDOWS   // 指定使用tensorflow/core/platform/windows/cpu_info.h

#include "stdafx.h"
#include&lt;iostream&gt;
#include&lt;opencv2/opencv.hpp&gt;
#include"tensorflow/core/public/session.h"
#include "tensorflow/core/platform/env.h"
#include &lt;time.h&gt;

using namespace tensorflow;
using namespace cv;
using std::cout;
using std::endl;

int main() {
	const std::string model_path = "frozen_inference_graph.pb";// tensorflow模型文件，注意不能含有中文
	const std::string image_path = "image1.jpg";    // 待inference的图片grace_hopper.jpg

	// 设置输入图像
	cv::Mat img = cv::imread(image_path);
	cv::cvtColor(img, img, cv::COLOR_BGR2RGB);
	int height = img.rows;
	int width = img.cols;
	int depth = img.channels();

	// 取图像数据，赋给tensorflow支持的Tensor变量中
	tensorflow::Tensor input_tensor(DT_UINT8, TensorShape({ 1, height, width, depth }));
	const uint8* source_data = img.data;
	auto input_tensor_mapped = input_tensor.tensor&lt;uint8, 4&gt;();

	for (int i = 0; i &lt; height; i++) {
		const uint8* source_row = source_data + (i * width * depth);
		for (int j = 0; j &lt; width; j++) {
			const uint8* source_pixel = source_row + (j * depth);
			for (int c = 0; c &lt; depth; c++) {
				const uint8* source_value = source_pixel + c;
				input_tensor_mapped(0, i, j, c) = *source_value;
			}
		}
	}

	// 初始化tensorflow session
	Session* session;
	Status status = NewSession(SessionOptions(), &amp;session);
	if (!status.ok()) {
		std::cerr &lt;&lt; status.ToString() &lt;&lt; endl;
		return -1;
	}
	else {
		cout &lt;&lt; "Session created successfully" &lt;&lt; endl;
	}

	// 读取二进制的模型文件到graph中
	tensorflow::GraphDef graph_def;
	status = ReadBinaryProto(Env::Default(), model_path, &amp;graph_def);
	if (!status.ok()) {
		std::cerr &lt;&lt; status.ToString() &lt;&lt; endl;
		return -1;
	}
	else {
		cout &lt;&lt; "Load graph protobuf successfully" &lt;&lt; endl;
	}

	// 将graph加载到session
	status = session-&gt;Create(graph_def);
	if (!status.ok()) {
		std::cerr &lt;&lt; status.ToString() &lt;&lt; endl;
		return -1;
	}
	else {
		cout &lt;&lt; "Add graph to session successfully" &lt;&lt; endl;
	}
	// 输入inputs，“ x_input”是我在模型中定义的输入数据名称
	std::vector&lt;std::pair&lt;std::string, tensorflow::Tensor&gt;&gt; inputs = {
		{ "image_tensor:0", input_tensor },
	};

	// 输出outputs
	std::vector&lt;tensorflow::Tensor&gt; outputs;

	//批处理识别
	double start = clock();
	std::vector&lt;std::string&gt; output_nodes;
	output_nodes.push_back("num_detections");
	output_nodes.push_back("detection_boxes");
	output_nodes.push_back("detection_scores");
	output_nodes.push_back("detection_classes");
	// 运行会话，最终结果保存在outputs中
	status = session-&gt;Run(inputs, { output_nodes }, {}, &amp;outputs);
	if (!status.ok()) {
		std::cerr &lt;&lt; status.ToString() &lt;&lt; endl;
		return -1;
	}
	else {
		cout &lt;&lt; "Run session successfully" &lt;&lt; endl;
	}

	double	finish = clock();
	double duration = (double)(finish - start) / CLOCKS_PER_SEC;
	cout &lt;&lt; "spend time:" &lt;&lt; duration &lt;&lt; endl;
	cv::imshow("image", img);
	cv::waitKey();
	return 0;
}

</code></pre> 
  <p>先别急着编译工程，首先我们需要把环境配置好：</p> 
  <ul> 
   <li>配置opencv (Release版本)；</li> 
   <li>配置tensorflow C++库。</li> 
  </ul> 
  <p>opencv库配置就不多赘述，这里主要说明tensorflow库的配置。<br> 1）包含目录：</p> 
  <pre><code>D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\external\org_tensorflow;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\external\protobuf_archive\src;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\external\com_google_absl;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\external\eigen_archive;D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\include\bazel-out\x64_windows-opt\genfiles;
</code></pre> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019082111173892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
  <p>2）库目录：</p> 
  <pre><code>D:\libtensorflow-gpu-windows-x86_64-1.13.1-avx2cuda10cudnn76\lib;
</code></pre> 
  <p>3）链接器输入附加依赖项：</p> 
  <pre><code>tensorflow_cc.lib;
</code></pre> 
  <p>环境配置好后，将之前生成的动态库放入应用程序目录，即复制 <strong>tensorflow_cc.dll</strong> 到与工程文件 <strong>.sln</strong> 同级的 <strong>x64\Release</strong> 文件夹下，如下图所示：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190821113135307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 接下来，从网盘下载模型文件 <strong>frozen_inference_graph.pb</strong> 和测试图片 <strong>image1.jpg</strong><a href="https://pan.baidu.com/s/1ZEzFABcrpl_4hREYtvgfwQ" rel="nofollow" data-token="354346132f3f4cd660681effe9b32311">（点此链接）<br> </a></p> 
  <ul> 
   <li>模型文件在 <strong>tensorflow\ssd_mobilenet_v1_coco_2017_11_17</strong> 目录下；</li> 
   <li>测试图片在 <strong>tensorflow\test_images</strong> 目录下。</li> 
  </ul> 
  <p>把它们放到与 <strong>.cpp</strong> 文件同级的目录下，如下图所示：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190821113722909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 编译前的准备工作完成，现在我们可以编译生成项目。生成之前，注意选择 <strong>Release</strong> 和 <strong>x64</strong>，如下图红框所示：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190821141329315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 编译可能出现无法解析的外部符号的问题，以下面的错误为例：</p> 
  <blockquote> 
   <p>无法解析的外部符号 “public: virtual __cdecl tensorflow::internal::LogMessage::~LogMessage(void)” (??1LogMessage@internal@tensorflow@@UEAA@XZ)，该符号在函数 “public: void __cdecl tensorflow::internal::LogMessage::`vbase destructor’(void)” (??_DLogMessage@internal@tensorflow@@QEAAXXZ) 中被引用</p> 
  </blockquote> 
  <p>解决方法：<br> 用文本编辑器打开 <strong>D:\tensorflow-1.13.1\source\tensorflow\tf_exported_symbols_msvc.lds</strong> ，将前面一个括号中带问号的内容：</p> 
  <blockquote> 
   <p>??1LogMessage@internal@tensorflow@@UEAA@XZ</p> 
  </blockquote> 
  <p>复制到该文件的末尾，如下图所示。<br> 如果有多个无法解析外部符号的问题，用同样的方法逐一添加。全部添加完成后保存关闭文件，然后重新编译tensorflow，也就是说从运行脚本文件开始，后面的流程要重新走一遍，想想有点心累，不过都已经走到这里了，半途而废有点说不过去呀，咬咬牙重来一遍吧。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019083014574968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
  <p>上面的问题已经成功解决，没有意外，还会出现max问题：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190821141505587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 解决办法如下：<br> 双击错误提示，跳转到有max问题的文件： <strong>logging.h</strong> 和 <strong>tensor_shape.h</strong>，分别进行以下修改：</p> 
  <p>1）<strong>logging.h</strong>:</p> 
  <p>将第250行的</p> 
  <pre><code>if (TF_PREDICT_FALSE(v2 &gt;= std::numeric_limits&lt;int&gt;::max())) {      \
</code></pre> 
  <p>改为</p> 
  <pre><code>if (TF_PREDICT_FALSE(v2 &gt;= (std::numeric_limits&lt;int&gt;::max)())) {      \
</code></pre> 
  <p>修改后如下图所示：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190821142753724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
  <p>2）<strong>tensor_shape.h</strong>:<br> 将108-111行的</p> 
  <pre><code>static const int64 kMaxRep16 = std::numeric_limits&lt;uint16&gt;::max() - 1;
static const int64 kMaxRep32 = std::numeric_limits&lt;uint32&gt;::max() - 1;
static const uint16 kUnknownRep16 = std::numeric_limits&lt;uint16&gt;::max();
static const uint32 kUnknownRep32 = std::numeric_limits&lt;uint32&gt;::max();
</code></pre> 
  <p>改为：</p> 
  <pre><code>static const int64 kMaxRep16 = (std::numeric_limits&lt;uint16&gt;::max)() - 1;
static const int64 kMaxRep32 = (std::numeric_limits&lt;uint32&gt;::max)() - 1;
static const uint16 kUnknownRep16 = (std::numeric_limits&lt;uint16&gt;::max)();
static const uint32 kUnknownRep32 = (std::numeric_limits&lt;uint32&gt;::max)();
</code></pre> 
  <p>修改后如下图所示：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190821142816492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 修改好后我们重新生成项目，如果上面的步骤都没有问题，将会出现下面的结果：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190821144131721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 没错！编译成功！小腿抖起来小曲儿唱起来!</p> 
  <p>到这里还没有结束，将程序运行起来，你将看到以下结果：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190821145102760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 红框部分说明GPU和模型调用没毛病，妥妥地成功！小腿再次抖起来小曲儿再次唱起来!</p> 
  <p>tensorflow C++库的生成和调用全部结束！</p> 
  <h1><a id="_469"></a>支线任务</h1> 
  <p>注意，这是作业，不是彩蛋。<br> 测试程序结尾出现了以下神秘图片：</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190821144619299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 蓝狗？！<br> 还别说，狗狗蓝色的美瞳还真是洋气，蓝色的皮鞋更显骚气。<br> 灵魂三问：小狗为什么是蓝色？定位框在哪？识别的结果在哪？<br> 这就需要骚年们好好的研究和琢磨了。</p> 
  <p><strong><font color="darkred" size="5">Happy Ending:</font></strong></p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190821150755221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0cGFsYWluX2NzZG4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e44c3c0e64.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
