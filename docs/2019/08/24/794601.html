<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>《统计学习方法》机器学习方法总结 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="《统计学习方法》机器学习方法总结" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="终于看完了《统计学习方法》常用的分类器部分，博主吐血总结，包含模型、推导、算法步骤，还有各种细节部分的理解，方便自己以后回顾和复习，很多都是我自己的理解，有问题希望能多交流 这个总结是一个提纲性质的总结，主要目的是回顾知识点，想从头学习建议去看一遍《统计学习方法》 首先概念清晰 1.分类器的模型一般表示为两种：条件概率分布P(Y|X)、决策函数Y = f(X) 2.分类器的优化过程其实是：经验风险最小化和结构风险最小化的过程 一些基础： 凸优化：https://www.jianshu.com/p/6a962fb1b4e0 L1、L2正则化：https://baijiahao.baidu.com/s?id=1621054167310242353&amp;wfr=spider&amp;for=pc 感知机 感知机模型： 几何意义：就是求得分离超平面 wx+b = 0，使得位于两部分的特征向量被分为正、负两类。 对偶形式模型： 适用问题：二类分类 模型特点：分离超平面 模型类型：判别模型 学习策略：极小化误分点到超平面距离 损失函数：误分点到超平面距离 设M是错分样本 输入空间：X属于Rn 输出空间：Y属于{-1，+1} 感知机模型：f(x) = sign(wx + b) 其中sign()是符号函数 x&gt;=0,y取+1，x&lt;0,y取-1 定义训练数据集：T = {(x1,y1),(x2,y2)....(xN,yN)} 感知机的损失函数为： 忽略掉||w||，学习策略为极小化函数间隔，这是一个无约束最优化问题，且所取的x,y是误分类点 学习算法：随机梯度下降 假设误分样本点集合M是固定的，那么损失函数L(w,b)的梯度可直接求Loss的偏导数 分别求损失函数对w和b的偏导数，可得 根据随机梯度下降法思路，每次选择一个错分样本点(xi,yi)，设置一个学习率η，对w,b进行更新： 考虑梯度下降法更新参数的方法，例如更新w，则为 w = w - ηdw 按照这种方法更新w,b 感知机算法： 原始形式学习算法： 输入：训练数据集：T = {(x1,y1),(x2,y2)....(xN,yN)}，其中 xi 属于 X = Rn，yi属于Y = {-1，+1}， i = 1,2,3…N;学习率η(0&lt;η&lt;=1) 输出：w,b; 感知机模型 f(x) = sign(wx+b) 1)选取初值w0,b0 2)在训练集中选取数据（xi,yi） 3)如果yi(wxi + b) &lt;=0,即该样本点为错分样本点，则更新 4)转至2），直至训练数据集没有误分类点 对偶形式 对偶形式基本想法是，将w,b表示为实例xi和标记yi的线性组合的形式，通过求解其系数而求得w,b，假设初始值w0,b0均为0，对误分类点(xi,yi)每次经过随机梯度下降都更新w,b的值。因此最后得到的w,b可以分别表示为，其中αi = niη 实例点更新的次数越多，意味着它离分离超平面越近，也就越难正确分类（就是说因为它难分类，所以为了它更新了很多次参数，那么它对学习结果的影响最大） 对偶形式学习算法 输入：训练数据集：T = {(x1,y1),(x2,y2)....(xN,yN)}，其中 xi 属于 X = Rn，yi属于Y = {-1，+1}， i = 1,2,3…N;学习率η(0&lt;η&lt;=1) 输出：α,b; 感知机模型为 其中α = (α1,α2…αN)^T 1)首先初始化α,b趋近0 2)在训练集中选取数据(xi,yi) 3)如果 则更新α,b 4）然后转至2)，继续更新，直到没有误分类数据 k近邻法 （注意这个不是聚类！！！跟聚类没关系，跟K-means没关系，甚至还是个有监督学习方法） k近邻法模型： 模型由三个基本要素：距离度量、k值选择、分类决策规则 适用问题：多类分类，回归 模型特点：特征空间，样本点 模型类型：判别模型 学习策略：这个思路非常简单，给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，就把该输入实例分为这个类。 损失函数：无 学习算法：无（k临近算法没有显式的学习方法，它是一个将特征空间划分开，然后判断输入点属于特征空间中哪个划分的方法） k近邻法算法 输入：训练数据集：T = {(x1,y1),(x2,y2)....(xN,yN)}，其中 xi 属于 X = Rn的特征向量，yi属于Y = {c1,c2…ck}为实例的类别， i = 1,2,3…N; 实例特征向量x 输出：实例x所属的类y 1)根据给定的距离度量，在训练集T中找出与x最邻近的k个点，涵盖这k个点的x的临域记作Nk(x) 2)在Nk(x)中分类决策规则（如多数表决）决定x的类别y： I为指示函数，即当yi=cj时I为1，否则I为0 k临近法的特殊情况是k=1的情形，称为最近邻算法 距离度量 Lp距离（其实就是向量的p范数），p取不同值的时候，距离也不一样 p取1的时候为街区距离（曼哈顿距离），就是坐标差的绝对值之和 p取2的时候为欧式距离（就是日常生活中用的那个距离），坐标值差的平方和开根号 p取无穷的时候，它是各个坐标距离的最大值 k值的选择 k较小： “学习”的近似误差减小，只有与输入实例较近的训练实例 才会的预测结果起作用，但缺点是“学习”的估计误差会增大，预测结果会对近邻的实例点非常敏感，如果近邻的实例点恰巧是噪声，预测就会出错。k减小意味着整体模型变得复杂，容易发生过拟合。 近似误差：可以理解为对现有训练集的训练误差。 可以理解为模型估计值与实际值之间的差距。 估计误差：可以理解为对测试集的测试误差。可以理解为模型的估计系数与实际系数之间的差距。 k减小，意味着特征空间被划分的更复杂，那么整体模型就变的复杂，容易出现过拟合 k较大： “学习”的估计误差减小，但是“近似误差增大”，与输入实例较远（不相似的）训练实例也会起预测作用，使预测发生错误，k值增大意味着整体的模型变简单。 分类决策规则 采用多数表决规则，等价于经验风险最小化。 为什么等价与经验风险最小化呢，思路也很简单： 考虑分类的损失函数为0-1损失函数时，即预测结果等于标签为1，否则为0 分类函数为： 误分类的概率为： 经验风险就是损失函数的数学期望，就是误分类率 那么误分类率最小化，就要使得yi=cj的个数最大化，也就是说，多数表决规则等价与经验风险最小化。 kd树 考虑这样一个问题，对于k近邻算法，每输入一个点，那我就要对所有的训练样本点遍历一遍，找到k个距离最小的，然后再投票，时间复杂度O(n)，训练集很大时就会很耗时，那么怎么能提高k近邻搜索的效率呢？就可以考虑一些其他的数据结构，比如说树数据结构。 构造kd树 kd树是一个二叉树，左右两个节点表示每次划分出的两个区域。 构造kd树的方法是：构造根结点，使根结点对应于k维空间中包括所有实例点的超矩形区域，通过递归方法，不断的对k维空间进行划分，生成子结点。在超矩形区域（结点上）选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子结点），这时，实例被分到两个子区域，这个过程直到子区域内没有实例时终止，在此过程中，将实例保存在相应的结点上。 构造平衡kd树 思路是：因为输入有多维，那么就按顺序不断的对k为超平面进行分割，从第1维、第2维…一直到第k维，然后回到第一维继续重新分割，一直分割到整个平衡二叉树构造完成，除此之外，为了实现平衡二叉树，每次分割采用该维度的中位数。 输入：k维空间数据集T={x1,x2,…xN} 其中xi = (xi(1),xi(2),…xi(k))^T i = 1,2,…N 输出：kd树 搜索kd树 思路：先从根节点出发，类似于二叉搜索树，找到属于目标点的叶节点（每次按照构造过程的维度，如果小于就去左子树，大于就去右子树），把该叶节点视为最近点，然后回溯，对于每个父结点，如果距离小于子结点，则更新为最近点，同时考虑它的另一个子结点区域有没有最近点，若有，递归找最近点，若没有，继续回退，直到退到根节点，搜索结束，最后的当前最近点就是最近临点。这样的话就把搜索区域从所有点变成了部分区域，增加了效率。 这种类似于二分法的算法，时间复杂度是O(logn)，比O(n)有了明显提升。 kd树的最近邻搜索算法： 朴素贝叶斯法 朴素贝叶斯法模型： 比较好理解，就是使后验概率最大的类别就是分类的结果（可以这么想，通过贝叶斯公式计算出了每个类的后验概率，然后取那个后验概率最大的就是分出的类别） 适用问题：多分类问题 模型特点：特征与类别的联合概率分布，条件独立假设 模型类型：生成模型 学习策略：极大似然估计，极大后验概率估计 学习的损失函数：对数似然函数 学习算法：概率计算公式、EM算法 这个模型的几何意义不明显，推导过程如下： 思路是：首先求后验概率的基础是已知联合概率分布，则先验概率和条件概率分布已知，求后验概率分布，利用贝叶斯公式可求得后验概率，又因为条件概率分布的参数量十分巨大，不易计算，朴素贝叶斯对条件概率分布做了条件独立性假设，即假设X的每个维度的输入特征是独立的，那么条件概率分布写作了每个单独特征的条件概率的连乘的形式。 后验概率最大化就是期望风险最小化 朴素贝叶斯的参数估计（就是模型学习，通过训练集训练模型（学习参数）） 极大似然估计学习参数 首先计算出先验概率的极大似然估计和条件概率的极大似然估计，推导过程有点麻烦，想知道的建议自己百度，书上也没有给出： 看似麻烦，其实先验概率Y=Ck的极大似然估计就是 Ck出现占总样本数的比例 条件概率的极大似然估计就是 Y取Ck的情况中，x取aji的比例 有了参数就可以进行贝叶斯估计了 朴素贝叶斯算法 思路就是先用训练样本计算出参数，然后带入模型，进行预测 贝叶斯估计 用极大似然估计可能会出现所要估计的概率值为0的情况，会影响到后验概率的计算，使分类产生偏差，采用贝叶斯估计来解决这个问题 条件概率的贝叶斯估计为 先验概率的概率分布也做相同方式的变化 决策树 模型：树形结构 适用问题：多类分类、回归 模型特点：分类树、回归树 模型类型：判别模型 学习策略：正则化的极大似然估计 学习的损失函数：对数似然损失 学习算法：特征选择，生成，剪枝 这个模型没什么好说的，就是给定输入，从树的根节点出发每一层按照一种特征分类，下一层考虑新的特征，最后沿着决策树预测出分类，其实就是特征空间的分类。 决策树学习 给定数据集 D = {(x1,y1),(x2,y2)…(xN,yN)} x 为n维向量， y为类别 学习过程就是构建根节点，将所有训练数据都放在根节点，选择一个最优特征，按照这一特征将训练集分割成子集，使得各个子集有一个当前条件下最好的分类，如果这些自己已经能被基本分类，那么构建叶节点，把这些子集放进叶节点，否则就继续选择最优特征分类，直到所有都被正确分类或者没有合适特征为止。这就生成了一棵决策树。 为了防止过拟合，要对决策树进行剪枝处理 因此决策树学习过程有三点： 特征选择、决策树生成、决策树剪枝 特征选择 首先是熵的概念，熵是一个随机变量的不确定性的度量，熵的大小只与随机变量的分类有关，和随机变量的取值无关。 条件熵、经验熵、经验条件熵的概念 经验熵就是用数据来估计分布的熵，经验条件熵就是用数据来估计分布的条件熵。 熵一般用来衡量信息的多少。 信息增益和信息增益比 这两个概念是用来选择特征的关键 根据信息增益准则的特征选择方法是：对训练数据集，计算每个特征的信息增益，并比较它们的大小，选择信息增益最大的特征 把信息增益考虑成，使用这个特征分类后信息量增长了多少 信息增益算法 这个经验条件熵计算，发现和之前公式给的不一样？上面等式右边命名是条件概率分布，其实可以看作A特征把数据集分成了多个子集，然后直接计算在A作用后，D的新的分布的熵，就是等式右边的经验条件熵 信息增益比： 决策树生成 ID3算法，就是从根节点开始，一层一层进行特征选择，构建决策树，特征选择采用信息增益来衡量 C4.5算法，跟ID3一样，区别是用信息增益比来选择特征 决策树剪枝 减少过拟合，降低模型规模，考虑为结构风险最小化。 决策树剪枝通过极小化决策树整体的损失函数或代价函数来实现 设t是树T的叶节点，叶结点有Nt个样本点，其中k类的样本点有Ntk个，Ht（T）为叶节点t上的经验熵，α&gt;=0为参数，则决策树学习的损失函数为 所以利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行特征选择。 树的剪枝算法 逻辑斯谛回归和最大熵模型 刚开始看逻辑斯谛回归的时候一直不明白，逻辑斯谛分布我也懂，就是sigmoid函数，它和分类器有什么关心呢，后来看了别人总结的感知机、SVM和逻辑斯谛回归模型的区别，好像有些明白了，本质上都是找到将样本分开的超平面，只是如何利用这个超平面有区别 感知机是求错分类点到超平面的距离最小化，即感知机模型的最优化问题是使得错误分类点到超平面距离之和最小化。 SVM是最大化几何间隔，即最优化问题是最大化样本点到分离超平面的最小距离。 逻辑斯谛回归模型则是将超平面作为sigmoid函数的输入，获得了样本点被分为正例和反例的条件概率，然后用极大似然估计极大化这个后验概率分布，也就是说逻辑斯蒂回归模型的最优化问题是极大似然估计样本的后验概率分布。 模型：这个模型是条件概率分布（不同于感知机和SVM是决策函数） 适用问题：多类分类 模型特点：特征条件下类别的条件概率分布，对数线性模型 模型类型：判别模型 学习策略：极大似然估计，正则化的极大似然估计 学习的损失函数：逻辑斯谛损失 学习算法：改进的迭代尺度算法，梯度下降，拟牛顿法 这个模型怎么理解呢，看括号内的输入，其实就是把超平面wx+b=0作为输入，这是什么含义呢，就是说逻辑斯谛回归模型把线性函数wx+b转换成了概率，剩下的就可以用极大似然估计来估计模型参数了。就是说，用概率模型替代了决策函数。看一下书上的解释。 对于这个条件概率模型，用极大似然估计来学习参数，求得条件概率模型的似然函数和对数似然函数，接着采用梯度下降法或者逆牛顿法求解。 最大熵模型 首先要知道，最大熵模型是一个多类分类器，它是基于最大熵原理 最大熵原理 最大熵原理是概率模型学习的一个准则，最大熵原理认为，学习概率模型时，在所有可能的概率模型中，上最大的模型是最好的模型。通常用约束条件来确定概率模型的集合，所以，最大熵原理也可以表述为在满足约束条件的模型集合中选取熵最大的模型。 回忆熵的计算公式，其中X的分布为P(X) 接着考虑最大熵模型 最大熵模型是一个条件概率分布P(Y|X),类似逻辑斯谛回归模型，是将分类面输入进逻辑斯谛分布函数里，产生的概率模型，最大熵模型是先找到一个约束，然后找到满足这个约束的所有模型，然后根据最大熵原理选择熵最大的模型，这个模型P(Y|X)就是最终的模型 问题在于约束怎么找，用特征函数f(x,y)描述输入x和输出y之间的某个事实，定义是 有了特征函数，围绕特征函数就能求出它的联合分布的期望值，和基于模型的条件概率分布P(Y|X)与经验分布的期望值（我理解就是利用这种方法使得P(Y|X)满足了某种要求，即引入了P(Y|X)的约束）也就是说，如果P(Y|X)参与了的期望与它本身联合分布的期望一致，那么就说明P(Y|X)模型能够反映分类的情况。 约束就是令上面的两种期望相等，就得出了模型学习的约束条件。假如说找了n个条件函数，就有n个约束条件。 有了约束条件，就可以得到最大熵模型了，还是前面说的，考虑最大熵原理，满足约束条件的，熵最大的模型，就是我们要找的最大熵模型。 最大熵模型的学习 最大熵模型的学习，个人理解就是，想办法找到满足约束条件的，并且熵最大的模型。 最大熵模型的学习就是求解最大熵模型的过程。 所以目标函数就是条件熵，另外还要满足上述的约束条件，除此之外，还要使得条件概率在y所有取值下的和为1（这点感觉总会被漏掉） 这不就是我们第一喜欢的约束最优化问题吗（一点都不喜欢），看到这个就想起了拉格朗日对偶法，毕竟基本上都是靠它解决约束最优化问题的。 思路就是先把求极大转化为求极小，然后引入拉格朗日乘子，定义拉格朗日函数，然后把原始问题（极小极大问题）转换成对偶问题（极大极小问题）求解。当然还要满足KKT条件，才能使得原始问题和对偶问题的解等价。 这样就把最大熵模型转化成了对偶问题。 极大似然估计 接下来就是一个证明了物理含义和数学证明高度相关的事实，对偶函数的极大化等价于最大熵模型的极大似然估计。 最后，最大熵模型还可以写成更一般的形式。 最大熵模型与逻辑斯谛回归有类似的形式，我理解就是都把模型转换成了概率模型，学习过程都利用了极大似然估计，而且形式上也很相似，它们称为对数线性模型。模型学习就是在给定的训练数据条件下对模型进行极大似然估计或正则化的极大似然估计。 支持向量机 书上支持向量机的介绍非常详细，推导也非常详细，所以大部分都是书的截图（内容实在太多了）但是建议没事多推导几次就能记住了 模型：对于线性可分支持向量机就是一个超平面，形式上和感知机一样 对偶形式模型： 适用问题：二类分类 模型特点：分离超平面、核技巧 模型类型：判别模型 学习策略：极小化正则化合页损失，软间隔最大化 学习的损失函数：合页损失 学习算法：序列最小最优化算法 线性可分支持向量机 函数间隔和几何间隔 函数间隔分为：关于超平面关于样本点的函数间隔和超平面关于训练集的函数间隔间隔，其中后者就是所有前者里的最小值。 几何间隔也这么划分，几何间隔就是函数间隔的归一化，保证了w,b同时扩大倍数的时候（这个时候超平面不变），衡量的方式不改变。 所以支持向量机的学习实际就是求最大化几何间隔的过程。 间隔最大化 这个问题其实就是约束最优化问题，这里的操作非常酷炫，先把最优化问题写出来： 目标函数就是最大化几何间隔，约束条件是，每个超平面样本点的几何间隔都大于超平面关于数据集的几何间隔，那有n个样本点就有n个约束条件。 接着改写问题，把几何间隔用函数间隔表示出来 再考虑到，如果同时将w,b扩大倍，变成λw,λb,函数间隔变成了λγ^ ,这样的变化对最优化问题没有影响（带入以下，目标函数中λ被分子分母约掉了，约束条件两边同乘λ，也被约掉了），所以就可以产生等价的最优化问题，那么直接把γ^ 取1，带入上述问题，就把问题得到了简化。同时按照惯例把最大化问题变成最小化问题（取倒数），前面那个系数1/2是为了后面的推导方便加上去的，对实际求解没有影响（后面介绍到间隔margin的时候，它等于2/||w||，w是分离超平面的的法向量，可能这也算它的几何含义）。 这是凸二次规划问题 这个很重要且很常用所以贴一下 接下来就要求解约束凸二次规划问题了。 支持向量和间隔边界 在现行可分的情况下，训练数据集的样本点中与分离超平面最近的样本点的实例称为支持向量，就是使得约束等号成立的点 支持向量机之所以叫这个名字，就是因为它的支持向量，它决定分离超平面时只有支持向量起作用，其他实例点不起作用。 再考虑回最优化问题，这个问题有N个约束条件，不好求解，这个时候就要使用熟悉的拉格朗日对偶法，将原始问题转换为对偶问题求解（这是求解凸优化问题的常用方法，利用将问题转化为较为简单的对偶问题） 然后就按步骤来，构建拉格朗日函数，转换成对偶问题求解，同时求解中还用到了KKT条件中的对偶互补条件。书上很详细就直接放上书上的内容 上述推导还是挺重要的，而且一步一步推导下来也不难，建议自己推一遍就能非常理解了，同时要先看一下拉格朗日对偶法的求解步骤，不然可能有点迷。 线性支持向量机 前面说的是线性可分支持向量机，但如果是线性不可分的情况怎么办，如果有部分点混在另一个类里，那不就存在点不满足最优化问题的约束条件了，所以要想办法把它扩展为线性不可分的问题，解决方案就是将硬件个最大化修改为软间隔最大化。 思路就是修改目标函数和约束条件，对每个样本点引进松弛变量，同时在目标函数增加一个罚项（这个问题实质上由经验风险最小化变成了经验风险最小化+结构风险最小化） 那么线性不可分支持向量机的学习变成了一个新的凸二次规划问题（原始问题） 线性支持向量机的模型就表述为 形式上和线性可分支持向量机是一样的，但是学习的最优化问题发生了改变 推导过程和线性可分支持向量机也是类似的，我就不放上来了，想推导可以自己看书。 合页损失函数 它是线性支持向量机的另一种解释，优化目标变为经验损失+正则化项。 非线性支持向量机与核函数 思路就是通过核函数，把分类平面映射到高维空间里，实现非线性支持向量机。 具体做法是，把对偶问题中的内积换成核函数即可。 非线性支持向量机算法 提升方法 模型： AdaBboost: 提升树： 适用问题：二类分类 模型特点：弱分类器的线性组合 模型类型：判别模型 学习策略：极小化加法模型的指数损失 损失函数：指数损失 学习算法：前向分布加法算法 思路：提升算法就是把一些弱分类器线性组合起来，组合成强分类器的算法。 强可学习、弱可学习 在概率近似正确（PAC）学习的框架中，一个概念（一个类）如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这种算法是强可学习的;一个概念，如果存在一个多项式的学习算法能够学习它，学习的正确率仅比随机猜测好，那么称这个概念是弱可学习的。后来证明强可学习和弱可学习是等价的，也就是说，一个概念是强可学习的充要条件是这个概念是弱可学习的。 AdaBoost算法 AdaBoost算法是迭代学习的过程，不断的找新的弱分类器，然后更新每个数据集的权值（它会把分类错误的样本的权值不断提升，所以后面找的新的弱分类器主要用于这些样本点的分类），同时更新分类器的权值，然后把新的组合好的分类器继续放进去迭代，最后合成一个多个弱分类器线性组合成的强分类器。就类似于，前面的弱分类器分出来一部分，剩下的分类效果不好就换个分类器继续分，直到分类效果比较好） AdaBoost算法模型是一个加法模型，物理含义也很明显，不需要推导，就是M个弱分类器的加权求和。 AdaBoost模型学习 对于加法模型，使用前向分布算法求解最优化问题。损失函数为指数损失函数，所以问题是一个经验风险极小化的过程。 学习思路是： 每次迭代的时候都要找到合适的弱分类器G(x)，并计算出它对应的权值α，具体地，在第m次迭代的时候，已知了fm-1(x)，那么fm(x) = fm-1(x) + αm * Gm(x)，所以学习过程中每次迭代就是找到新的弱分类器和参数。 推导过程如下： 首先假设损失函数为指数损失函数（先考虑损失函数是它，按照它来推导，最后证明和AdaBoost算法的等价） 考虑第m次迭代的时候，根据迭代的递推公式： 极小化损失函数可表示为下图 通过8.21式可以看出，w只与之前的模型有关，那么可以看做一个常数，最优化问题与它无关，因此问题就是求解α和G，使得8.21式取得最小。 接下来对这两个参数分别考虑。首先对于G，它是一个弱分类器，那么使8.21最小的G就是使第m论加权训练数据分类误差率最小的基本分类器。 那么对于任意的α&gt;0，最小的G由下式得到： 它的物理含义很明显，就是对于前m-1次迭代产生的新的权值的样本，取那个使得分类误差率（就是错分率）最小的分类器。找到G之后，重写优化目标，对α求偏导，就求得了α 最后在迭代过程中权值是不断进行更新的，因此看一下权值如何更新（这里的w其实就是每次迭代样本参数的权值了，下面就能写出每次迭代权值如何更新） 这个步骤实际就是把上面两个公式带入到wm+1,i的公式里就可以了 最后和AdaBoost算法步骤样本权值更新比较，只差规范化因此，证明两者等价，也就是证明了损失函数是指数损失函数。 提升树模型 模型：提升树模型同样也是一个线性加法模型，不同之处在于，它是以决策树为基函数的提升方法 提升树算法同样采用前向分步算法，针对不同问题，它的损失函数也不同。 回归问题的提升树算法 梯度提升算法 EM算法 EM算法即期望极大算法，它是一个计算具有隐变量问题的一般方法，没有具体模型。例如假如我们知道一个随机变量的概率分布，就能通过极大似然估计来估计出它的参数，但是如果这个问题具有隐变量，例如两个不同分布混在一起，先要直到样本属于哪个分布，才能确定它的实际分布的参数，这就不能直接用极大斯然估计求解，而EM算法通过迭代，可以求出近似的参数的极大似然估计 适用问题：概率模型参数估计 模型特点：含隐变量概率模型 学习策略：极大似然估计、极大后验概率估计 学习的损失函数：对数似然损失 学习算法：概率计算公式、EM算法 EM算法 算法思路就是先求期望，再求极大，然后反复迭代至收敛" />
<meta property="og:description" content="终于看完了《统计学习方法》常用的分类器部分，博主吐血总结，包含模型、推导、算法步骤，还有各种细节部分的理解，方便自己以后回顾和复习，很多都是我自己的理解，有问题希望能多交流 这个总结是一个提纲性质的总结，主要目的是回顾知识点，想从头学习建议去看一遍《统计学习方法》 首先概念清晰 1.分类器的模型一般表示为两种：条件概率分布P(Y|X)、决策函数Y = f(X) 2.分类器的优化过程其实是：经验风险最小化和结构风险最小化的过程 一些基础： 凸优化：https://www.jianshu.com/p/6a962fb1b4e0 L1、L2正则化：https://baijiahao.baidu.com/s?id=1621054167310242353&amp;wfr=spider&amp;for=pc 感知机 感知机模型： 几何意义：就是求得分离超平面 wx+b = 0，使得位于两部分的特征向量被分为正、负两类。 对偶形式模型： 适用问题：二类分类 模型特点：分离超平面 模型类型：判别模型 学习策略：极小化误分点到超平面距离 损失函数：误分点到超平面距离 设M是错分样本 输入空间：X属于Rn 输出空间：Y属于{-1，+1} 感知机模型：f(x) = sign(wx + b) 其中sign()是符号函数 x&gt;=0,y取+1，x&lt;0,y取-1 定义训练数据集：T = {(x1,y1),(x2,y2)....(xN,yN)} 感知机的损失函数为： 忽略掉||w||，学习策略为极小化函数间隔，这是一个无约束最优化问题，且所取的x,y是误分类点 学习算法：随机梯度下降 假设误分样本点集合M是固定的，那么损失函数L(w,b)的梯度可直接求Loss的偏导数 分别求损失函数对w和b的偏导数，可得 根据随机梯度下降法思路，每次选择一个错分样本点(xi,yi)，设置一个学习率η，对w,b进行更新： 考虑梯度下降法更新参数的方法，例如更新w，则为 w = w - ηdw 按照这种方法更新w,b 感知机算法： 原始形式学习算法： 输入：训练数据集：T = {(x1,y1),(x2,y2)....(xN,yN)}，其中 xi 属于 X = Rn，yi属于Y = {-1，+1}， i = 1,2,3…N;学习率η(0&lt;η&lt;=1) 输出：w,b; 感知机模型 f(x) = sign(wx+b) 1)选取初值w0,b0 2)在训练集中选取数据（xi,yi） 3)如果yi(wxi + b) &lt;=0,即该样本点为错分样本点，则更新 4)转至2），直至训练数据集没有误分类点 对偶形式 对偶形式基本想法是，将w,b表示为实例xi和标记yi的线性组合的形式，通过求解其系数而求得w,b，假设初始值w0,b0均为0，对误分类点(xi,yi)每次经过随机梯度下降都更新w,b的值。因此最后得到的w,b可以分别表示为，其中αi = niη 实例点更新的次数越多，意味着它离分离超平面越近，也就越难正确分类（就是说因为它难分类，所以为了它更新了很多次参数，那么它对学习结果的影响最大） 对偶形式学习算法 输入：训练数据集：T = {(x1,y1),(x2,y2)....(xN,yN)}，其中 xi 属于 X = Rn，yi属于Y = {-1，+1}， i = 1,2,3…N;学习率η(0&lt;η&lt;=1) 输出：α,b; 感知机模型为 其中α = (α1,α2…αN)^T 1)首先初始化α,b趋近0 2)在训练集中选取数据(xi,yi) 3)如果 则更新α,b 4）然后转至2)，继续更新，直到没有误分类数据 k近邻法 （注意这个不是聚类！！！跟聚类没关系，跟K-means没关系，甚至还是个有监督学习方法） k近邻法模型： 模型由三个基本要素：距离度量、k值选择、分类决策规则 适用问题：多类分类，回归 模型特点：特征空间，样本点 模型类型：判别模型 学习策略：这个思路非常简单，给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，就把该输入实例分为这个类。 损失函数：无 学习算法：无（k临近算法没有显式的学习方法，它是一个将特征空间划分开，然后判断输入点属于特征空间中哪个划分的方法） k近邻法算法 输入：训练数据集：T = {(x1,y1),(x2,y2)....(xN,yN)}，其中 xi 属于 X = Rn的特征向量，yi属于Y = {c1,c2…ck}为实例的类别， i = 1,2,3…N; 实例特征向量x 输出：实例x所属的类y 1)根据给定的距离度量，在训练集T中找出与x最邻近的k个点，涵盖这k个点的x的临域记作Nk(x) 2)在Nk(x)中分类决策规则（如多数表决）决定x的类别y： I为指示函数，即当yi=cj时I为1，否则I为0 k临近法的特殊情况是k=1的情形，称为最近邻算法 距离度量 Lp距离（其实就是向量的p范数），p取不同值的时候，距离也不一样 p取1的时候为街区距离（曼哈顿距离），就是坐标差的绝对值之和 p取2的时候为欧式距离（就是日常生活中用的那个距离），坐标值差的平方和开根号 p取无穷的时候，它是各个坐标距离的最大值 k值的选择 k较小： “学习”的近似误差减小，只有与输入实例较近的训练实例 才会的预测结果起作用，但缺点是“学习”的估计误差会增大，预测结果会对近邻的实例点非常敏感，如果近邻的实例点恰巧是噪声，预测就会出错。k减小意味着整体模型变得复杂，容易发生过拟合。 近似误差：可以理解为对现有训练集的训练误差。 可以理解为模型估计值与实际值之间的差距。 估计误差：可以理解为对测试集的测试误差。可以理解为模型的估计系数与实际系数之间的差距。 k减小，意味着特征空间被划分的更复杂，那么整体模型就变的复杂，容易出现过拟合 k较大： “学习”的估计误差减小，但是“近似误差增大”，与输入实例较远（不相似的）训练实例也会起预测作用，使预测发生错误，k值增大意味着整体的模型变简单。 分类决策规则 采用多数表决规则，等价于经验风险最小化。 为什么等价与经验风险最小化呢，思路也很简单： 考虑分类的损失函数为0-1损失函数时，即预测结果等于标签为1，否则为0 分类函数为： 误分类的概率为： 经验风险就是损失函数的数学期望，就是误分类率 那么误分类率最小化，就要使得yi=cj的个数最大化，也就是说，多数表决规则等价与经验风险最小化。 kd树 考虑这样一个问题，对于k近邻算法，每输入一个点，那我就要对所有的训练样本点遍历一遍，找到k个距离最小的，然后再投票，时间复杂度O(n)，训练集很大时就会很耗时，那么怎么能提高k近邻搜索的效率呢？就可以考虑一些其他的数据结构，比如说树数据结构。 构造kd树 kd树是一个二叉树，左右两个节点表示每次划分出的两个区域。 构造kd树的方法是：构造根结点，使根结点对应于k维空间中包括所有实例点的超矩形区域，通过递归方法，不断的对k维空间进行划分，生成子结点。在超矩形区域（结点上）选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子结点），这时，实例被分到两个子区域，这个过程直到子区域内没有实例时终止，在此过程中，将实例保存在相应的结点上。 构造平衡kd树 思路是：因为输入有多维，那么就按顺序不断的对k为超平面进行分割，从第1维、第2维…一直到第k维，然后回到第一维继续重新分割，一直分割到整个平衡二叉树构造完成，除此之外，为了实现平衡二叉树，每次分割采用该维度的中位数。 输入：k维空间数据集T={x1,x2,…xN} 其中xi = (xi(1),xi(2),…xi(k))^T i = 1,2,…N 输出：kd树 搜索kd树 思路：先从根节点出发，类似于二叉搜索树，找到属于目标点的叶节点（每次按照构造过程的维度，如果小于就去左子树，大于就去右子树），把该叶节点视为最近点，然后回溯，对于每个父结点，如果距离小于子结点，则更新为最近点，同时考虑它的另一个子结点区域有没有最近点，若有，递归找最近点，若没有，继续回退，直到退到根节点，搜索结束，最后的当前最近点就是最近临点。这样的话就把搜索区域从所有点变成了部分区域，增加了效率。 这种类似于二分法的算法，时间复杂度是O(logn)，比O(n)有了明显提升。 kd树的最近邻搜索算法： 朴素贝叶斯法 朴素贝叶斯法模型： 比较好理解，就是使后验概率最大的类别就是分类的结果（可以这么想，通过贝叶斯公式计算出了每个类的后验概率，然后取那个后验概率最大的就是分出的类别） 适用问题：多分类问题 模型特点：特征与类别的联合概率分布，条件独立假设 模型类型：生成模型 学习策略：极大似然估计，极大后验概率估计 学习的损失函数：对数似然函数 学习算法：概率计算公式、EM算法 这个模型的几何意义不明显，推导过程如下： 思路是：首先求后验概率的基础是已知联合概率分布，则先验概率和条件概率分布已知，求后验概率分布，利用贝叶斯公式可求得后验概率，又因为条件概率分布的参数量十分巨大，不易计算，朴素贝叶斯对条件概率分布做了条件独立性假设，即假设X的每个维度的输入特征是独立的，那么条件概率分布写作了每个单独特征的条件概率的连乘的形式。 后验概率最大化就是期望风险最小化 朴素贝叶斯的参数估计（就是模型学习，通过训练集训练模型（学习参数）） 极大似然估计学习参数 首先计算出先验概率的极大似然估计和条件概率的极大似然估计，推导过程有点麻烦，想知道的建议自己百度，书上也没有给出： 看似麻烦，其实先验概率Y=Ck的极大似然估计就是 Ck出现占总样本数的比例 条件概率的极大似然估计就是 Y取Ck的情况中，x取aji的比例 有了参数就可以进行贝叶斯估计了 朴素贝叶斯算法 思路就是先用训练样本计算出参数，然后带入模型，进行预测 贝叶斯估计 用极大似然估计可能会出现所要估计的概率值为0的情况，会影响到后验概率的计算，使分类产生偏差，采用贝叶斯估计来解决这个问题 条件概率的贝叶斯估计为 先验概率的概率分布也做相同方式的变化 决策树 模型：树形结构 适用问题：多类分类、回归 模型特点：分类树、回归树 模型类型：判别模型 学习策略：正则化的极大似然估计 学习的损失函数：对数似然损失 学习算法：特征选择，生成，剪枝 这个模型没什么好说的，就是给定输入，从树的根节点出发每一层按照一种特征分类，下一层考虑新的特征，最后沿着决策树预测出分类，其实就是特征空间的分类。 决策树学习 给定数据集 D = {(x1,y1),(x2,y2)…(xN,yN)} x 为n维向量， y为类别 学习过程就是构建根节点，将所有训练数据都放在根节点，选择一个最优特征，按照这一特征将训练集分割成子集，使得各个子集有一个当前条件下最好的分类，如果这些自己已经能被基本分类，那么构建叶节点，把这些子集放进叶节点，否则就继续选择最优特征分类，直到所有都被正确分类或者没有合适特征为止。这就生成了一棵决策树。 为了防止过拟合，要对决策树进行剪枝处理 因此决策树学习过程有三点： 特征选择、决策树生成、决策树剪枝 特征选择 首先是熵的概念，熵是一个随机变量的不确定性的度量，熵的大小只与随机变量的分类有关，和随机变量的取值无关。 条件熵、经验熵、经验条件熵的概念 经验熵就是用数据来估计分布的熵，经验条件熵就是用数据来估计分布的条件熵。 熵一般用来衡量信息的多少。 信息增益和信息增益比 这两个概念是用来选择特征的关键 根据信息增益准则的特征选择方法是：对训练数据集，计算每个特征的信息增益，并比较它们的大小，选择信息增益最大的特征 把信息增益考虑成，使用这个特征分类后信息量增长了多少 信息增益算法 这个经验条件熵计算，发现和之前公式给的不一样？上面等式右边命名是条件概率分布，其实可以看作A特征把数据集分成了多个子集，然后直接计算在A作用后，D的新的分布的熵，就是等式右边的经验条件熵 信息增益比： 决策树生成 ID3算法，就是从根节点开始，一层一层进行特征选择，构建决策树，特征选择采用信息增益来衡量 C4.5算法，跟ID3一样，区别是用信息增益比来选择特征 决策树剪枝 减少过拟合，降低模型规模，考虑为结构风险最小化。 决策树剪枝通过极小化决策树整体的损失函数或代价函数来实现 设t是树T的叶节点，叶结点有Nt个样本点，其中k类的样本点有Ntk个，Ht（T）为叶节点t上的经验熵，α&gt;=0为参数，则决策树学习的损失函数为 所以利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行特征选择。 树的剪枝算法 逻辑斯谛回归和最大熵模型 刚开始看逻辑斯谛回归的时候一直不明白，逻辑斯谛分布我也懂，就是sigmoid函数，它和分类器有什么关心呢，后来看了别人总结的感知机、SVM和逻辑斯谛回归模型的区别，好像有些明白了，本质上都是找到将样本分开的超平面，只是如何利用这个超平面有区别 感知机是求错分类点到超平面的距离最小化，即感知机模型的最优化问题是使得错误分类点到超平面距离之和最小化。 SVM是最大化几何间隔，即最优化问题是最大化样本点到分离超平面的最小距离。 逻辑斯谛回归模型则是将超平面作为sigmoid函数的输入，获得了样本点被分为正例和反例的条件概率，然后用极大似然估计极大化这个后验概率分布，也就是说逻辑斯蒂回归模型的最优化问题是极大似然估计样本的后验概率分布。 模型：这个模型是条件概率分布（不同于感知机和SVM是决策函数） 适用问题：多类分类 模型特点：特征条件下类别的条件概率分布，对数线性模型 模型类型：判别模型 学习策略：极大似然估计，正则化的极大似然估计 学习的损失函数：逻辑斯谛损失 学习算法：改进的迭代尺度算法，梯度下降，拟牛顿法 这个模型怎么理解呢，看括号内的输入，其实就是把超平面wx+b=0作为输入，这是什么含义呢，就是说逻辑斯谛回归模型把线性函数wx+b转换成了概率，剩下的就可以用极大似然估计来估计模型参数了。就是说，用概率模型替代了决策函数。看一下书上的解释。 对于这个条件概率模型，用极大似然估计来学习参数，求得条件概率模型的似然函数和对数似然函数，接着采用梯度下降法或者逆牛顿法求解。 最大熵模型 首先要知道，最大熵模型是一个多类分类器，它是基于最大熵原理 最大熵原理 最大熵原理是概率模型学习的一个准则，最大熵原理认为，学习概率模型时，在所有可能的概率模型中，上最大的模型是最好的模型。通常用约束条件来确定概率模型的集合，所以，最大熵原理也可以表述为在满足约束条件的模型集合中选取熵最大的模型。 回忆熵的计算公式，其中X的分布为P(X) 接着考虑最大熵模型 最大熵模型是一个条件概率分布P(Y|X),类似逻辑斯谛回归模型，是将分类面输入进逻辑斯谛分布函数里，产生的概率模型，最大熵模型是先找到一个约束，然后找到满足这个约束的所有模型，然后根据最大熵原理选择熵最大的模型，这个模型P(Y|X)就是最终的模型 问题在于约束怎么找，用特征函数f(x,y)描述输入x和输出y之间的某个事实，定义是 有了特征函数，围绕特征函数就能求出它的联合分布的期望值，和基于模型的条件概率分布P(Y|X)与经验分布的期望值（我理解就是利用这种方法使得P(Y|X)满足了某种要求，即引入了P(Y|X)的约束）也就是说，如果P(Y|X)参与了的期望与它本身联合分布的期望一致，那么就说明P(Y|X)模型能够反映分类的情况。 约束就是令上面的两种期望相等，就得出了模型学习的约束条件。假如说找了n个条件函数，就有n个约束条件。 有了约束条件，就可以得到最大熵模型了，还是前面说的，考虑最大熵原理，满足约束条件的，熵最大的模型，就是我们要找的最大熵模型。 最大熵模型的学习 最大熵模型的学习，个人理解就是，想办法找到满足约束条件的，并且熵最大的模型。 最大熵模型的学习就是求解最大熵模型的过程。 所以目标函数就是条件熵，另外还要满足上述的约束条件，除此之外，还要使得条件概率在y所有取值下的和为1（这点感觉总会被漏掉） 这不就是我们第一喜欢的约束最优化问题吗（一点都不喜欢），看到这个就想起了拉格朗日对偶法，毕竟基本上都是靠它解决约束最优化问题的。 思路就是先把求极大转化为求极小，然后引入拉格朗日乘子，定义拉格朗日函数，然后把原始问题（极小极大问题）转换成对偶问题（极大极小问题）求解。当然还要满足KKT条件，才能使得原始问题和对偶问题的解等价。 这样就把最大熵模型转化成了对偶问题。 极大似然估计 接下来就是一个证明了物理含义和数学证明高度相关的事实，对偶函数的极大化等价于最大熵模型的极大似然估计。 最后，最大熵模型还可以写成更一般的形式。 最大熵模型与逻辑斯谛回归有类似的形式，我理解就是都把模型转换成了概率模型，学习过程都利用了极大似然估计，而且形式上也很相似，它们称为对数线性模型。模型学习就是在给定的训练数据条件下对模型进行极大似然估计或正则化的极大似然估计。 支持向量机 书上支持向量机的介绍非常详细，推导也非常详细，所以大部分都是书的截图（内容实在太多了）但是建议没事多推导几次就能记住了 模型：对于线性可分支持向量机就是一个超平面，形式上和感知机一样 对偶形式模型： 适用问题：二类分类 模型特点：分离超平面、核技巧 模型类型：判别模型 学习策略：极小化正则化合页损失，软间隔最大化 学习的损失函数：合页损失 学习算法：序列最小最优化算法 线性可分支持向量机 函数间隔和几何间隔 函数间隔分为：关于超平面关于样本点的函数间隔和超平面关于训练集的函数间隔间隔，其中后者就是所有前者里的最小值。 几何间隔也这么划分，几何间隔就是函数间隔的归一化，保证了w,b同时扩大倍数的时候（这个时候超平面不变），衡量的方式不改变。 所以支持向量机的学习实际就是求最大化几何间隔的过程。 间隔最大化 这个问题其实就是约束最优化问题，这里的操作非常酷炫，先把最优化问题写出来： 目标函数就是最大化几何间隔，约束条件是，每个超平面样本点的几何间隔都大于超平面关于数据集的几何间隔，那有n个样本点就有n个约束条件。 接着改写问题，把几何间隔用函数间隔表示出来 再考虑到，如果同时将w,b扩大倍，变成λw,λb,函数间隔变成了λγ^ ,这样的变化对最优化问题没有影响（带入以下，目标函数中λ被分子分母约掉了，约束条件两边同乘λ，也被约掉了），所以就可以产生等价的最优化问题，那么直接把γ^ 取1，带入上述问题，就把问题得到了简化。同时按照惯例把最大化问题变成最小化问题（取倒数），前面那个系数1/2是为了后面的推导方便加上去的，对实际求解没有影响（后面介绍到间隔margin的时候，它等于2/||w||，w是分离超平面的的法向量，可能这也算它的几何含义）。 这是凸二次规划问题 这个很重要且很常用所以贴一下 接下来就要求解约束凸二次规划问题了。 支持向量和间隔边界 在现行可分的情况下，训练数据集的样本点中与分离超平面最近的样本点的实例称为支持向量，就是使得约束等号成立的点 支持向量机之所以叫这个名字，就是因为它的支持向量，它决定分离超平面时只有支持向量起作用，其他实例点不起作用。 再考虑回最优化问题，这个问题有N个约束条件，不好求解，这个时候就要使用熟悉的拉格朗日对偶法，将原始问题转换为对偶问题求解（这是求解凸优化问题的常用方法，利用将问题转化为较为简单的对偶问题） 然后就按步骤来，构建拉格朗日函数，转换成对偶问题求解，同时求解中还用到了KKT条件中的对偶互补条件。书上很详细就直接放上书上的内容 上述推导还是挺重要的，而且一步一步推导下来也不难，建议自己推一遍就能非常理解了，同时要先看一下拉格朗日对偶法的求解步骤，不然可能有点迷。 线性支持向量机 前面说的是线性可分支持向量机，但如果是线性不可分的情况怎么办，如果有部分点混在另一个类里，那不就存在点不满足最优化问题的约束条件了，所以要想办法把它扩展为线性不可分的问题，解决方案就是将硬件个最大化修改为软间隔最大化。 思路就是修改目标函数和约束条件，对每个样本点引进松弛变量，同时在目标函数增加一个罚项（这个问题实质上由经验风险最小化变成了经验风险最小化+结构风险最小化） 那么线性不可分支持向量机的学习变成了一个新的凸二次规划问题（原始问题） 线性支持向量机的模型就表述为 形式上和线性可分支持向量机是一样的，但是学习的最优化问题发生了改变 推导过程和线性可分支持向量机也是类似的，我就不放上来了，想推导可以自己看书。 合页损失函数 它是线性支持向量机的另一种解释，优化目标变为经验损失+正则化项。 非线性支持向量机与核函数 思路就是通过核函数，把分类平面映射到高维空间里，实现非线性支持向量机。 具体做法是，把对偶问题中的内积换成核函数即可。 非线性支持向量机算法 提升方法 模型： AdaBboost: 提升树： 适用问题：二类分类 模型特点：弱分类器的线性组合 模型类型：判别模型 学习策略：极小化加法模型的指数损失 损失函数：指数损失 学习算法：前向分布加法算法 思路：提升算法就是把一些弱分类器线性组合起来，组合成强分类器的算法。 强可学习、弱可学习 在概率近似正确（PAC）学习的框架中，一个概念（一个类）如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这种算法是强可学习的;一个概念，如果存在一个多项式的学习算法能够学习它，学习的正确率仅比随机猜测好，那么称这个概念是弱可学习的。后来证明强可学习和弱可学习是等价的，也就是说，一个概念是强可学习的充要条件是这个概念是弱可学习的。 AdaBoost算法 AdaBoost算法是迭代学习的过程，不断的找新的弱分类器，然后更新每个数据集的权值（它会把分类错误的样本的权值不断提升，所以后面找的新的弱分类器主要用于这些样本点的分类），同时更新分类器的权值，然后把新的组合好的分类器继续放进去迭代，最后合成一个多个弱分类器线性组合成的强分类器。就类似于，前面的弱分类器分出来一部分，剩下的分类效果不好就换个分类器继续分，直到分类效果比较好） AdaBoost算法模型是一个加法模型，物理含义也很明显，不需要推导，就是M个弱分类器的加权求和。 AdaBoost模型学习 对于加法模型，使用前向分布算法求解最优化问题。损失函数为指数损失函数，所以问题是一个经验风险极小化的过程。 学习思路是： 每次迭代的时候都要找到合适的弱分类器G(x)，并计算出它对应的权值α，具体地，在第m次迭代的时候，已知了fm-1(x)，那么fm(x) = fm-1(x) + αm * Gm(x)，所以学习过程中每次迭代就是找到新的弱分类器和参数。 推导过程如下： 首先假设损失函数为指数损失函数（先考虑损失函数是它，按照它来推导，最后证明和AdaBoost算法的等价） 考虑第m次迭代的时候，根据迭代的递推公式： 极小化损失函数可表示为下图 通过8.21式可以看出，w只与之前的模型有关，那么可以看做一个常数，最优化问题与它无关，因此问题就是求解α和G，使得8.21式取得最小。 接下来对这两个参数分别考虑。首先对于G，它是一个弱分类器，那么使8.21最小的G就是使第m论加权训练数据分类误差率最小的基本分类器。 那么对于任意的α&gt;0，最小的G由下式得到： 它的物理含义很明显，就是对于前m-1次迭代产生的新的权值的样本，取那个使得分类误差率（就是错分率）最小的分类器。找到G之后，重写优化目标，对α求偏导，就求得了α 最后在迭代过程中权值是不断进行更新的，因此看一下权值如何更新（这里的w其实就是每次迭代样本参数的权值了，下面就能写出每次迭代权值如何更新） 这个步骤实际就是把上面两个公式带入到wm+1,i的公式里就可以了 最后和AdaBoost算法步骤样本权值更新比较，只差规范化因此，证明两者等价，也就是证明了损失函数是指数损失函数。 提升树模型 模型：提升树模型同样也是一个线性加法模型，不同之处在于，它是以决策树为基函数的提升方法 提升树算法同样采用前向分步算法，针对不同问题，它的损失函数也不同。 回归问题的提升树算法 梯度提升算法 EM算法 EM算法即期望极大算法，它是一个计算具有隐变量问题的一般方法，没有具体模型。例如假如我们知道一个随机变量的概率分布，就能通过极大似然估计来估计出它的参数，但是如果这个问题具有隐变量，例如两个不同分布混在一起，先要直到样本属于哪个分布，才能确定它的实际分布的参数，这就不能直接用极大斯然估计求解，而EM算法通过迭代，可以求出近似的参数的极大似然估计 适用问题：概率模型参数估计 模型特点：含隐变量概率模型 学习策略：极大似然估计、极大后验概率估计 学习的损失函数：对数似然损失 学习算法：概率计算公式、EM算法 EM算法 算法思路就是先求期望，再求极大，然后反复迭代至收敛" />
<link rel="canonical" href="https://uzzz.org/2019/08/24/794601.html" />
<meta property="og:url" content="https://uzzz.org/2019/08/24/794601.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-24T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"终于看完了《统计学习方法》常用的分类器部分，博主吐血总结，包含模型、推导、算法步骤，还有各种细节部分的理解，方便自己以后回顾和复习，很多都是我自己的理解，有问题希望能多交流 这个总结是一个提纲性质的总结，主要目的是回顾知识点，想从头学习建议去看一遍《统计学习方法》 首先概念清晰 1.分类器的模型一般表示为两种：条件概率分布P(Y|X)、决策函数Y = f(X) 2.分类器的优化过程其实是：经验风险最小化和结构风险最小化的过程 一些基础： 凸优化：https://www.jianshu.com/p/6a962fb1b4e0 L1、L2正则化：https://baijiahao.baidu.com/s?id=1621054167310242353&amp;wfr=spider&amp;for=pc 感知机 感知机模型： 几何意义：就是求得分离超平面 wx+b = 0，使得位于两部分的特征向量被分为正、负两类。 对偶形式模型： 适用问题：二类分类 模型特点：分离超平面 模型类型：判别模型 学习策略：极小化误分点到超平面距离 损失函数：误分点到超平面距离 设M是错分样本 输入空间：X属于Rn 输出空间：Y属于{-1，+1} 感知机模型：f(x) = sign(wx + b) 其中sign()是符号函数 x&gt;=0,y取+1，x&lt;0,y取-1 定义训练数据集：T = {(x1,y1),(x2,y2)....(xN,yN)} 感知机的损失函数为： 忽略掉||w||，学习策略为极小化函数间隔，这是一个无约束最优化问题，且所取的x,y是误分类点 学习算法：随机梯度下降 假设误分样本点集合M是固定的，那么损失函数L(w,b)的梯度可直接求Loss的偏导数 分别求损失函数对w和b的偏导数，可得 根据随机梯度下降法思路，每次选择一个错分样本点(xi,yi)，设置一个学习率η，对w,b进行更新： 考虑梯度下降法更新参数的方法，例如更新w，则为 w = w - ηdw 按照这种方法更新w,b 感知机算法： 原始形式学习算法： 输入：训练数据集：T = {(x1,y1),(x2,y2)....(xN,yN)}，其中 xi 属于 X = Rn，yi属于Y = {-1，+1}， i = 1,2,3…N;学习率η(0&lt;η&lt;=1) 输出：w,b; 感知机模型 f(x) = sign(wx+b) 1)选取初值w0,b0 2)在训练集中选取数据（xi,yi） 3)如果yi(wxi + b) &lt;=0,即该样本点为错分样本点，则更新 4)转至2），直至训练数据集没有误分类点 对偶形式 对偶形式基本想法是，将w,b表示为实例xi和标记yi的线性组合的形式，通过求解其系数而求得w,b，假设初始值w0,b0均为0，对误分类点(xi,yi)每次经过随机梯度下降都更新w,b的值。因此最后得到的w,b可以分别表示为，其中αi = niη 实例点更新的次数越多，意味着它离分离超平面越近，也就越难正确分类（就是说因为它难分类，所以为了它更新了很多次参数，那么它对学习结果的影响最大） 对偶形式学习算法 输入：训练数据集：T = {(x1,y1),(x2,y2)....(xN,yN)}，其中 xi 属于 X = Rn，yi属于Y = {-1，+1}， i = 1,2,3…N;学习率η(0&lt;η&lt;=1) 输出：α,b; 感知机模型为 其中α = (α1,α2…αN)^T 1)首先初始化α,b趋近0 2)在训练集中选取数据(xi,yi) 3)如果 则更新α,b 4）然后转至2)，继续更新，直到没有误分类数据 k近邻法 （注意这个不是聚类！！！跟聚类没关系，跟K-means没关系，甚至还是个有监督学习方法） k近邻法模型： 模型由三个基本要素：距离度量、k值选择、分类决策规则 适用问题：多类分类，回归 模型特点：特征空间，样本点 模型类型：判别模型 学习策略：这个思路非常简单，给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，就把该输入实例分为这个类。 损失函数：无 学习算法：无（k临近算法没有显式的学习方法，它是一个将特征空间划分开，然后判断输入点属于特征空间中哪个划分的方法） k近邻法算法 输入：训练数据集：T = {(x1,y1),(x2,y2)....(xN,yN)}，其中 xi 属于 X = Rn的特征向量，yi属于Y = {c1,c2…ck}为实例的类别， i = 1,2,3…N; 实例特征向量x 输出：实例x所属的类y 1)根据给定的距离度量，在训练集T中找出与x最邻近的k个点，涵盖这k个点的x的临域记作Nk(x) 2)在Nk(x)中分类决策规则（如多数表决）决定x的类别y： I为指示函数，即当yi=cj时I为1，否则I为0 k临近法的特殊情况是k=1的情形，称为最近邻算法 距离度量 Lp距离（其实就是向量的p范数），p取不同值的时候，距离也不一样 p取1的时候为街区距离（曼哈顿距离），就是坐标差的绝对值之和 p取2的时候为欧式距离（就是日常生活中用的那个距离），坐标值差的平方和开根号 p取无穷的时候，它是各个坐标距离的最大值 k值的选择 k较小： “学习”的近似误差减小，只有与输入实例较近的训练实例 才会的预测结果起作用，但缺点是“学习”的估计误差会增大，预测结果会对近邻的实例点非常敏感，如果近邻的实例点恰巧是噪声，预测就会出错。k减小意味着整体模型变得复杂，容易发生过拟合。 近似误差：可以理解为对现有训练集的训练误差。 可以理解为模型估计值与实际值之间的差距。 估计误差：可以理解为对测试集的测试误差。可以理解为模型的估计系数与实际系数之间的差距。 k减小，意味着特征空间被划分的更复杂，那么整体模型就变的复杂，容易出现过拟合 k较大： “学习”的估计误差减小，但是“近似误差增大”，与输入实例较远（不相似的）训练实例也会起预测作用，使预测发生错误，k值增大意味着整体的模型变简单。 分类决策规则 采用多数表决规则，等价于经验风险最小化。 为什么等价与经验风险最小化呢，思路也很简单： 考虑分类的损失函数为0-1损失函数时，即预测结果等于标签为1，否则为0 分类函数为： 误分类的概率为： 经验风险就是损失函数的数学期望，就是误分类率 那么误分类率最小化，就要使得yi=cj的个数最大化，也就是说，多数表决规则等价与经验风险最小化。 kd树 考虑这样一个问题，对于k近邻算法，每输入一个点，那我就要对所有的训练样本点遍历一遍，找到k个距离最小的，然后再投票，时间复杂度O(n)，训练集很大时就会很耗时，那么怎么能提高k近邻搜索的效率呢？就可以考虑一些其他的数据结构，比如说树数据结构。 构造kd树 kd树是一个二叉树，左右两个节点表示每次划分出的两个区域。 构造kd树的方法是：构造根结点，使根结点对应于k维空间中包括所有实例点的超矩形区域，通过递归方法，不断的对k维空间进行划分，生成子结点。在超矩形区域（结点上）选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子结点），这时，实例被分到两个子区域，这个过程直到子区域内没有实例时终止，在此过程中，将实例保存在相应的结点上。 构造平衡kd树 思路是：因为输入有多维，那么就按顺序不断的对k为超平面进行分割，从第1维、第2维…一直到第k维，然后回到第一维继续重新分割，一直分割到整个平衡二叉树构造完成，除此之外，为了实现平衡二叉树，每次分割采用该维度的中位数。 输入：k维空间数据集T={x1,x2,…xN} 其中xi = (xi(1),xi(2),…xi(k))^T i = 1,2,…N 输出：kd树 搜索kd树 思路：先从根节点出发，类似于二叉搜索树，找到属于目标点的叶节点（每次按照构造过程的维度，如果小于就去左子树，大于就去右子树），把该叶节点视为最近点，然后回溯，对于每个父结点，如果距离小于子结点，则更新为最近点，同时考虑它的另一个子结点区域有没有最近点，若有，递归找最近点，若没有，继续回退，直到退到根节点，搜索结束，最后的当前最近点就是最近临点。这样的话就把搜索区域从所有点变成了部分区域，增加了效率。 这种类似于二分法的算法，时间复杂度是O(logn)，比O(n)有了明显提升。 kd树的最近邻搜索算法： 朴素贝叶斯法 朴素贝叶斯法模型： 比较好理解，就是使后验概率最大的类别就是分类的结果（可以这么想，通过贝叶斯公式计算出了每个类的后验概率，然后取那个后验概率最大的就是分出的类别） 适用问题：多分类问题 模型特点：特征与类别的联合概率分布，条件独立假设 模型类型：生成模型 学习策略：极大似然估计，极大后验概率估计 学习的损失函数：对数似然函数 学习算法：概率计算公式、EM算法 这个模型的几何意义不明显，推导过程如下： 思路是：首先求后验概率的基础是已知联合概率分布，则先验概率和条件概率分布已知，求后验概率分布，利用贝叶斯公式可求得后验概率，又因为条件概率分布的参数量十分巨大，不易计算，朴素贝叶斯对条件概率分布做了条件独立性假设，即假设X的每个维度的输入特征是独立的，那么条件概率分布写作了每个单独特征的条件概率的连乘的形式。 后验概率最大化就是期望风险最小化 朴素贝叶斯的参数估计（就是模型学习，通过训练集训练模型（学习参数）） 极大似然估计学习参数 首先计算出先验概率的极大似然估计和条件概率的极大似然估计，推导过程有点麻烦，想知道的建议自己百度，书上也没有给出： 看似麻烦，其实先验概率Y=Ck的极大似然估计就是 Ck出现占总样本数的比例 条件概率的极大似然估计就是 Y取Ck的情况中，x取aji的比例 有了参数就可以进行贝叶斯估计了 朴素贝叶斯算法 思路就是先用训练样本计算出参数，然后带入模型，进行预测 贝叶斯估计 用极大似然估计可能会出现所要估计的概率值为0的情况，会影响到后验概率的计算，使分类产生偏差，采用贝叶斯估计来解决这个问题 条件概率的贝叶斯估计为 先验概率的概率分布也做相同方式的变化 决策树 模型：树形结构 适用问题：多类分类、回归 模型特点：分类树、回归树 模型类型：判别模型 学习策略：正则化的极大似然估计 学习的损失函数：对数似然损失 学习算法：特征选择，生成，剪枝 这个模型没什么好说的，就是给定输入，从树的根节点出发每一层按照一种特征分类，下一层考虑新的特征，最后沿着决策树预测出分类，其实就是特征空间的分类。 决策树学习 给定数据集 D = {(x1,y1),(x2,y2)…(xN,yN)} x 为n维向量， y为类别 学习过程就是构建根节点，将所有训练数据都放在根节点，选择一个最优特征，按照这一特征将训练集分割成子集，使得各个子集有一个当前条件下最好的分类，如果这些自己已经能被基本分类，那么构建叶节点，把这些子集放进叶节点，否则就继续选择最优特征分类，直到所有都被正确分类或者没有合适特征为止。这就生成了一棵决策树。 为了防止过拟合，要对决策树进行剪枝处理 因此决策树学习过程有三点： 特征选择、决策树生成、决策树剪枝 特征选择 首先是熵的概念，熵是一个随机变量的不确定性的度量，熵的大小只与随机变量的分类有关，和随机变量的取值无关。 条件熵、经验熵、经验条件熵的概念 经验熵就是用数据来估计分布的熵，经验条件熵就是用数据来估计分布的条件熵。 熵一般用来衡量信息的多少。 信息增益和信息增益比 这两个概念是用来选择特征的关键 根据信息增益准则的特征选择方法是：对训练数据集，计算每个特征的信息增益，并比较它们的大小，选择信息增益最大的特征 把信息增益考虑成，使用这个特征分类后信息量增长了多少 信息增益算法 这个经验条件熵计算，发现和之前公式给的不一样？上面等式右边命名是条件概率分布，其实可以看作A特征把数据集分成了多个子集，然后直接计算在A作用后，D的新的分布的熵，就是等式右边的经验条件熵 信息增益比： 决策树生成 ID3算法，就是从根节点开始，一层一层进行特征选择，构建决策树，特征选择采用信息增益来衡量 C4.5算法，跟ID3一样，区别是用信息增益比来选择特征 决策树剪枝 减少过拟合，降低模型规模，考虑为结构风险最小化。 决策树剪枝通过极小化决策树整体的损失函数或代价函数来实现 设t是树T的叶节点，叶结点有Nt个样本点，其中k类的样本点有Ntk个，Ht（T）为叶节点t上的经验熵，α&gt;=0为参数，则决策树学习的损失函数为 所以利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行特征选择。 树的剪枝算法 逻辑斯谛回归和最大熵模型 刚开始看逻辑斯谛回归的时候一直不明白，逻辑斯谛分布我也懂，就是sigmoid函数，它和分类器有什么关心呢，后来看了别人总结的感知机、SVM和逻辑斯谛回归模型的区别，好像有些明白了，本质上都是找到将样本分开的超平面，只是如何利用这个超平面有区别 感知机是求错分类点到超平面的距离最小化，即感知机模型的最优化问题是使得错误分类点到超平面距离之和最小化。 SVM是最大化几何间隔，即最优化问题是最大化样本点到分离超平面的最小距离。 逻辑斯谛回归模型则是将超平面作为sigmoid函数的输入，获得了样本点被分为正例和反例的条件概率，然后用极大似然估计极大化这个后验概率分布，也就是说逻辑斯蒂回归模型的最优化问题是极大似然估计样本的后验概率分布。 模型：这个模型是条件概率分布（不同于感知机和SVM是决策函数） 适用问题：多类分类 模型特点：特征条件下类别的条件概率分布，对数线性模型 模型类型：判别模型 学习策略：极大似然估计，正则化的极大似然估计 学习的损失函数：逻辑斯谛损失 学习算法：改进的迭代尺度算法，梯度下降，拟牛顿法 这个模型怎么理解呢，看括号内的输入，其实就是把超平面wx+b=0作为输入，这是什么含义呢，就是说逻辑斯谛回归模型把线性函数wx+b转换成了概率，剩下的就可以用极大似然估计来估计模型参数了。就是说，用概率模型替代了决策函数。看一下书上的解释。 对于这个条件概率模型，用极大似然估计来学习参数，求得条件概率模型的似然函数和对数似然函数，接着采用梯度下降法或者逆牛顿法求解。 最大熵模型 首先要知道，最大熵模型是一个多类分类器，它是基于最大熵原理 最大熵原理 最大熵原理是概率模型学习的一个准则，最大熵原理认为，学习概率模型时，在所有可能的概率模型中，上最大的模型是最好的模型。通常用约束条件来确定概率模型的集合，所以，最大熵原理也可以表述为在满足约束条件的模型集合中选取熵最大的模型。 回忆熵的计算公式，其中X的分布为P(X) 接着考虑最大熵模型 最大熵模型是一个条件概率分布P(Y|X),类似逻辑斯谛回归模型，是将分类面输入进逻辑斯谛分布函数里，产生的概率模型，最大熵模型是先找到一个约束，然后找到满足这个约束的所有模型，然后根据最大熵原理选择熵最大的模型，这个模型P(Y|X)就是最终的模型 问题在于约束怎么找，用特征函数f(x,y)描述输入x和输出y之间的某个事实，定义是 有了特征函数，围绕特征函数就能求出它的联合分布的期望值，和基于模型的条件概率分布P(Y|X)与经验分布的期望值（我理解就是利用这种方法使得P(Y|X)满足了某种要求，即引入了P(Y|X)的约束）也就是说，如果P(Y|X)参与了的期望与它本身联合分布的期望一致，那么就说明P(Y|X)模型能够反映分类的情况。 约束就是令上面的两种期望相等，就得出了模型学习的约束条件。假如说找了n个条件函数，就有n个约束条件。 有了约束条件，就可以得到最大熵模型了，还是前面说的，考虑最大熵原理，满足约束条件的，熵最大的模型，就是我们要找的最大熵模型。 最大熵模型的学习 最大熵模型的学习，个人理解就是，想办法找到满足约束条件的，并且熵最大的模型。 最大熵模型的学习就是求解最大熵模型的过程。 所以目标函数就是条件熵，另外还要满足上述的约束条件，除此之外，还要使得条件概率在y所有取值下的和为1（这点感觉总会被漏掉） 这不就是我们第一喜欢的约束最优化问题吗（一点都不喜欢），看到这个就想起了拉格朗日对偶法，毕竟基本上都是靠它解决约束最优化问题的。 思路就是先把求极大转化为求极小，然后引入拉格朗日乘子，定义拉格朗日函数，然后把原始问题（极小极大问题）转换成对偶问题（极大极小问题）求解。当然还要满足KKT条件，才能使得原始问题和对偶问题的解等价。 这样就把最大熵模型转化成了对偶问题。 极大似然估计 接下来就是一个证明了物理含义和数学证明高度相关的事实，对偶函数的极大化等价于最大熵模型的极大似然估计。 最后，最大熵模型还可以写成更一般的形式。 最大熵模型与逻辑斯谛回归有类似的形式，我理解就是都把模型转换成了概率模型，学习过程都利用了极大似然估计，而且形式上也很相似，它们称为对数线性模型。模型学习就是在给定的训练数据条件下对模型进行极大似然估计或正则化的极大似然估计。 支持向量机 书上支持向量机的介绍非常详细，推导也非常详细，所以大部分都是书的截图（内容实在太多了）但是建议没事多推导几次就能记住了 模型：对于线性可分支持向量机就是一个超平面，形式上和感知机一样 对偶形式模型： 适用问题：二类分类 模型特点：分离超平面、核技巧 模型类型：判别模型 学习策略：极小化正则化合页损失，软间隔最大化 学习的损失函数：合页损失 学习算法：序列最小最优化算法 线性可分支持向量机 函数间隔和几何间隔 函数间隔分为：关于超平面关于样本点的函数间隔和超平面关于训练集的函数间隔间隔，其中后者就是所有前者里的最小值。 几何间隔也这么划分，几何间隔就是函数间隔的归一化，保证了w,b同时扩大倍数的时候（这个时候超平面不变），衡量的方式不改变。 所以支持向量机的学习实际就是求最大化几何间隔的过程。 间隔最大化 这个问题其实就是约束最优化问题，这里的操作非常酷炫，先把最优化问题写出来： 目标函数就是最大化几何间隔，约束条件是，每个超平面样本点的几何间隔都大于超平面关于数据集的几何间隔，那有n个样本点就有n个约束条件。 接着改写问题，把几何间隔用函数间隔表示出来 再考虑到，如果同时将w,b扩大倍，变成λw,λb,函数间隔变成了λγ^ ,这样的变化对最优化问题没有影响（带入以下，目标函数中λ被分子分母约掉了，约束条件两边同乘λ，也被约掉了），所以就可以产生等价的最优化问题，那么直接把γ^ 取1，带入上述问题，就把问题得到了简化。同时按照惯例把最大化问题变成最小化问题（取倒数），前面那个系数1/2是为了后面的推导方便加上去的，对实际求解没有影响（后面介绍到间隔margin的时候，它等于2/||w||，w是分离超平面的的法向量，可能这也算它的几何含义）。 这是凸二次规划问题 这个很重要且很常用所以贴一下 接下来就要求解约束凸二次规划问题了。 支持向量和间隔边界 在现行可分的情况下，训练数据集的样本点中与分离超平面最近的样本点的实例称为支持向量，就是使得约束等号成立的点 支持向量机之所以叫这个名字，就是因为它的支持向量，它决定分离超平面时只有支持向量起作用，其他实例点不起作用。 再考虑回最优化问题，这个问题有N个约束条件，不好求解，这个时候就要使用熟悉的拉格朗日对偶法，将原始问题转换为对偶问题求解（这是求解凸优化问题的常用方法，利用将问题转化为较为简单的对偶问题） 然后就按步骤来，构建拉格朗日函数，转换成对偶问题求解，同时求解中还用到了KKT条件中的对偶互补条件。书上很详细就直接放上书上的内容 上述推导还是挺重要的，而且一步一步推导下来也不难，建议自己推一遍就能非常理解了，同时要先看一下拉格朗日对偶法的求解步骤，不然可能有点迷。 线性支持向量机 前面说的是线性可分支持向量机，但如果是线性不可分的情况怎么办，如果有部分点混在另一个类里，那不就存在点不满足最优化问题的约束条件了，所以要想办法把它扩展为线性不可分的问题，解决方案就是将硬件个最大化修改为软间隔最大化。 思路就是修改目标函数和约束条件，对每个样本点引进松弛变量，同时在目标函数增加一个罚项（这个问题实质上由经验风险最小化变成了经验风险最小化+结构风险最小化） 那么线性不可分支持向量机的学习变成了一个新的凸二次规划问题（原始问题） 线性支持向量机的模型就表述为 形式上和线性可分支持向量机是一样的，但是学习的最优化问题发生了改变 推导过程和线性可分支持向量机也是类似的，我就不放上来了，想推导可以自己看书。 合页损失函数 它是线性支持向量机的另一种解释，优化目标变为经验损失+正则化项。 非线性支持向量机与核函数 思路就是通过核函数，把分类平面映射到高维空间里，实现非线性支持向量机。 具体做法是，把对偶问题中的内积换成核函数即可。 非线性支持向量机算法 提升方法 模型： AdaBboost: 提升树： 适用问题：二类分类 模型特点：弱分类器的线性组合 模型类型：判别模型 学习策略：极小化加法模型的指数损失 损失函数：指数损失 学习算法：前向分布加法算法 思路：提升算法就是把一些弱分类器线性组合起来，组合成强分类器的算法。 强可学习、弱可学习 在概率近似正确（PAC）学习的框架中，一个概念（一个类）如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这种算法是强可学习的;一个概念，如果存在一个多项式的学习算法能够学习它，学习的正确率仅比随机猜测好，那么称这个概念是弱可学习的。后来证明强可学习和弱可学习是等价的，也就是说，一个概念是强可学习的充要条件是这个概念是弱可学习的。 AdaBoost算法 AdaBoost算法是迭代学习的过程，不断的找新的弱分类器，然后更新每个数据集的权值（它会把分类错误的样本的权值不断提升，所以后面找的新的弱分类器主要用于这些样本点的分类），同时更新分类器的权值，然后把新的组合好的分类器继续放进去迭代，最后合成一个多个弱分类器线性组合成的强分类器。就类似于，前面的弱分类器分出来一部分，剩下的分类效果不好就换个分类器继续分，直到分类效果比较好） AdaBoost算法模型是一个加法模型，物理含义也很明显，不需要推导，就是M个弱分类器的加权求和。 AdaBoost模型学习 对于加法模型，使用前向分布算法求解最优化问题。损失函数为指数损失函数，所以问题是一个经验风险极小化的过程。 学习思路是： 每次迭代的时候都要找到合适的弱分类器G(x)，并计算出它对应的权值α，具体地，在第m次迭代的时候，已知了fm-1(x)，那么fm(x) = fm-1(x) + αm * Gm(x)，所以学习过程中每次迭代就是找到新的弱分类器和参数。 推导过程如下： 首先假设损失函数为指数损失函数（先考虑损失函数是它，按照它来推导，最后证明和AdaBoost算法的等价） 考虑第m次迭代的时候，根据迭代的递推公式： 极小化损失函数可表示为下图 通过8.21式可以看出，w只与之前的模型有关，那么可以看做一个常数，最优化问题与它无关，因此问题就是求解α和G，使得8.21式取得最小。 接下来对这两个参数分别考虑。首先对于G，它是一个弱分类器，那么使8.21最小的G就是使第m论加权训练数据分类误差率最小的基本分类器。 那么对于任意的α&gt;0，最小的G由下式得到： 它的物理含义很明显，就是对于前m-1次迭代产生的新的权值的样本，取那个使得分类误差率（就是错分率）最小的分类器。找到G之后，重写优化目标，对α求偏导，就求得了α 最后在迭代过程中权值是不断进行更新的，因此看一下权值如何更新（这里的w其实就是每次迭代样本参数的权值了，下面就能写出每次迭代权值如何更新） 这个步骤实际就是把上面两个公式带入到wm+1,i的公式里就可以了 最后和AdaBoost算法步骤样本权值更新比较，只差规范化因此，证明两者等价，也就是证明了损失函数是指数损失函数。 提升树模型 模型：提升树模型同样也是一个线性加法模型，不同之处在于，它是以决策树为基函数的提升方法 提升树算法同样采用前向分步算法，针对不同问题，它的损失函数也不同。 回归问题的提升树算法 梯度提升算法 EM算法 EM算法即期望极大算法，它是一个计算具有隐变量问题的一般方法，没有具体模型。例如假如我们知道一个随机变量的概率分布，就能通过极大似然估计来估计出它的参数，但是如果这个问题具有隐变量，例如两个不同分布混在一起，先要直到样本属于哪个分布，才能确定它的实际分布的参数，这就不能直接用极大斯然估计求解，而EM算法通过迭代，可以求出近似的参数的极大似然估计 适用问题：概率模型参数估计 模型特点：含隐变量概率模型 学习策略：极大似然估计、极大后验概率估计 学习的损失函数：对数似然损失 学习算法：概率计算公式、EM算法 EM算法 算法思路就是先求期望，再求极大，然后反复迭代至收敛","@type":"BlogPosting","url":"https://uzzz.org/2019/08/24/794601.html","headline":"《统计学习方法》机器学习方法总结","dateModified":"2019-08-24T00:00:00+08:00","datePublished":"2019-08-24T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uzzz.org/2019/08/24/794601.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>《统计学习方法》机器学习方法总结</h1>
        
        
        <ul style="display: block;">
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
 	    <li><a href="/donate/" style="line-height: unset;" target="_blank"><strong>Donate</strong></a></li>
        </ul>
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
<!-- match content ads -->
	        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<ins class="adsbygoogle"
			     style="display:block"
			     data-ad-format="autorelaxed"
			     data-ad-client="ca-pub-8889449066804352"
			     data-ad-slot="1928667997"></ins>
			<script>
			     (adsbygoogle = window.adsbygoogle || []).push({});
			</script>	



        <div id="article_content" class="article_content clearfix">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> 
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path> 
  </svg> 
  <p>终于看完了《统计学习方法》常用的分类器部分，博主吐血总结，包含模型、推导、算法步骤，还有各种细节部分的理解，方便自己以后回顾和复习，很多都是我自己的理解，有问题希望能多交流<br> 这个总结是一个提纲性质的总结，主要目的是回顾知识点，想从头学习建议去看一遍《统计学习方法》<br> 首先概念清晰<br> 1.分类器的模型一般表示为两种：条件概率分布P(Y|X)、决策函数Y = f(X)<br> 2.分类器的优化过程其实是：经验风险最小化和结构风险最小化的过程<br> 一些基础：<br> 凸优化：<a href="https://www.jianshu.com/p/6a962fb1b4e0" rel="nofollow" data-token="6e76600f5026dc0fd9517c9a51abc1a0">https://www.jianshu.com/p/6a962fb1b4e0</a><br> L1、L2正则化：<a href="https://baijiahao.baidu.com/s?id=1621054167310242353&amp;wfr=spider&amp;for=pc" rel="nofollow" data-token="d612e40abc13c815cc3d70b3024b5082">https://baijiahao.baidu.com/s?id=1621054167310242353&amp;wfr=spider&amp;for=pc</a></p> 
  <h2><a id="_9"></a><strong>感知机</strong></h2> 
  <p>感知机模型：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625114037572.png" alt="在这里插入图片描述"></p> 
  <p>几何意义：就是求得<strong>分离超平面</strong> wx+b = 0，使得位于两部分的特征向量被分为正、负两类。<br> 对偶形式模型：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625220654669.png" alt="在这里插入图片描述"><br> 适用问题：二类分类<br> 模型特点：分离超平面<br> 模型类型：判别模型<br> 学习策略：极小化误分点到超平面距离<br> 损失函数：误分点到超平面距离<br> 设M是错分样本<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625103528542.png" alt="在这里插入图片描述"></p> 
  <p>输入空间：X属于Rn<br> 输出空间：Y属于{-1，+1}<br> 感知机模型：<code>f(x) = sign(wx + b)</code> 其中sign()是符号函数 x&gt;=0,y取+1，x&lt;0,y取-1<br> 定义训练数据集：<code>T = {(x1,y1),(x2,y2)....(xN,yN)}</code><br> 感知机的损失函数为：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625103611110.png" alt="在这里插入图片描述"><br> 忽略掉||w||，学习策略为极小化<strong>函数间隔</strong>，这是一个无约束最优化问题，且所取的x,y是误分类点<br> 学习算法：随机梯度下降<br> 假设误分样本点集合M是固定的，那么损失函数L(w,b)的梯度可直接求Loss的偏导数<br> 分别求损失函数对w和b的偏导数，可得<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625104212232.png" alt="在这里插入图片描述"><br> 根据随机梯度下降法思路，每次选择一个错分样本点(xi,yi)，设置一个学习率η，对w,b进行更新：<br> <code>考虑梯度下降法更新参数的方法，例如更新w，则为 w = w - ηdw 按照这种方法更新w,b</code> <br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625104902215.png" alt="在这里插入图片描述"><br> 感知机算法：<br> <strong>原始形式学习算法：</strong><br> 输入：训练数据集：<code>T = {(x1,y1),(x2,y2)....(xN,yN)}</code>，其中 xi 属于 X = Rn，yi属于Y = {-1，+1}， i = 1,2,3…N;学习率η(0&lt;η&lt;=1)<br> 输出：w,b; 感知机模型 f(x) = sign(wx+b)<br> 1)选取初值w0,b0<br> 2)在训练集中选取数据（xi,yi）<br> 3)如果yi(wxi + b) &lt;=0,即该样本点为错分样本点，则更新<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625105619549.png" alt="在这里插入图片描述"><br> 4)转至2），直至训练数据集没有误分类点</p> 
  <p><strong>对偶形式</strong><br> 对偶形式基本想法是，将w,b表示为实例xi和标记yi的线性组合的形式，通过求解其系数而求得w,b，假设初始值w0,b0均为0，对误分类点(xi,yi)每次经过随机梯度下降都更新w,b的值。因此最后得到的w,b可以分别表示为，其中αi = niη<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625110804588.png" alt="在这里插入图片描述"><br> 实例点更新的次数越多，意味着它离分离超平面越近，也就越难正确分类（就是说因为它难分类，所以为了它更新了很多次参数，那么它对学习结果的影响最大）<br> <strong>对偶形式学习算法</strong><br> 输入：训练数据集：<code>T = {(x1,y1),(x2,y2)....(xN,yN)}</code>，其中 xi 属于 X = Rn，yi属于Y = {-1，+1}， i = 1,2,3…N;学习率η(0&lt;η&lt;=1)<br> 输出：α,b; 感知机模型为<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625111823184.png" alt="在这里插入图片描述"><br> 其中α = (α1,α2…αN)^T<br> 1)首先初始化α,b趋近0<br> 2)在训练集中选取数据(xi,yi)<br> 3)如果<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625112216332.png" alt="在这里插入图片描述"><br> 则更新α,b<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625112311138.png" alt="在这里插入图片描述"><br> 4）然后转至2)，继续更新，直到没有误分类数据</p> 
  <h2><a id="k_69"></a><strong>k近邻法</strong></h2> 
  <p>（注意这个不是聚类！！！跟聚类没关系，跟K-means没关系，甚至还是个有监督学习方法）<br> k近邻法模型：<br> 模型由三个基本要素：距离度量、k值选择、分类决策规则<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625124555786.png" alt="在这里插入图片描述"><br> 适用问题：多类分类，回归<br> 模型特点：特征空间，样本点<br> 模型类型：判别模型<br> 学习策略：这个思路非常简单，给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，就把该输入实例分为这个类。<br> 损失函数：无<br> 学习算法：无（k临近算法没有显式的学习方法，它是一个将特征空间划分开，然后判断输入点属于特征空间中哪个划分的方法）<br> <strong>k近邻法算法</strong><br> 输入：训练数据集：<code>T = {(x1,y1),(x2,y2)....(xN,yN)}</code>，其中 xi 属于 X = Rn的特征向量，yi属于Y = {c1,c2…ck}为实例的类别， i = 1,2,3…N; 实例特征向量x<br> 输出：实例x所属的类y<br> 1)根据给定的距离度量，在训练集T中找出与x最邻近的k个点，涵盖这k个点的x的临域记作Nk(x)<br> 2)在Nk(x)中分类决策规则（如多数表决）决定x的类别y：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019062512383028.png" alt="在这里插入图片描述"><br> I为指示函数，即当yi=cj时I为1，否则I为0<br> k临近法的特殊情况是k=1的情形，称为最近邻算法<br> <strong>距离度量</strong><br> Lp距离（其实就是向量的p范数），p取不同值的时候，距离也不一样<br> p取1的时候为街区距离（曼哈顿距离），就是坐标差的绝对值之和<br> p取2的时候为欧式距离（就是日常生活中用的那个距离），坐标值差的平方和开根号<br> p取无穷的时候，它是各个坐标距离的最大值<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019062513151416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>k值的选择</strong><br> <strong>k较小：</strong><br> “学习”的<strong>近似误差</strong>减小，只有与输入实例较近的训练实例 才会的预测结果起作用，但缺点是“学习”的<strong>估计误差</strong>会增大，预测结果会对近邻的实例点非常敏感，如果近邻的实例点恰巧是噪声，预测就会出错。<strong>k减小意味着整体模型变得复杂，容易发生过拟合</strong>。<br> 近似误差：可以理解为对现有训练集的训练误差。 可以理解为模型估计值与实际值之间的差距。<br> 估计误差：可以理解为对测试集的测试误差。可以理解为模型的估计系数与实际系数之间的差距。<br> k减小，意味着特征空间被划分的更复杂，那么整体模型就变的复杂，容易出现过拟合</p> 
  <p><strong>k较大：</strong><br> “学习”的估计误差减小，但是“近似误差增大”，与输入实例较远（不相似的）训练实例也会起预测作用，使预测发生错误，k值增大意味着整体的模型变简单。</p> 
  <p><strong>分类决策规则</strong><br> 采用多数表决规则，<strong>等价于经验风险最小化</strong>。<br> 为什么等价与经验风险最小化呢，思路也很简单：<br> 考虑分类的损失函数为0-1损失函数时，即预测结果等于标签为1，否则为0<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625132229570.png" alt="在这里插入图片描述"><br> 分类函数为：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019062513234680.png" alt="在这里插入图片描述"><br> 误分类的概率为：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625132418460.png" alt="在这里插入图片描述"><br> 经验风险就是损失函数的数学期望，就是误分类率<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625134705690.png" alt="在这里插入图片描述"><br> 那么误分类率最小化，就要使得yi=cj的个数最大化，也就是说，<strong>多数表决规则等价与经验风险最小化。</strong></p> 
  <p><strong>kd树</strong><br> 考虑这样一个问题，对于k近邻算法，每输入一个点，那我就要对所有的训练样本点遍历一遍，找到k个距离最小的，然后再投票，时间复杂度O(n)，训练集很大时就会很耗时，那么怎么能提高k近邻搜索的效率呢？就可以考虑一些其他的数据结构，比如说树数据结构。<br> <strong>构造kd树</strong><br> kd树是一个二叉树，左右两个节点表示每次划分出的两个区域。<br> 构造kd树的方法是：构造根结点，使根结点对应于k维空间中包括所有实例点的超矩形区域，通过递归方法，不断的对k维空间进行划分，生成子结点。在超矩形区域（结点上）选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子结点），这时，实例被分到两个子区域，这个过程直到子区域内没有实例时终止，在此过程中，将实例保存在相应的结点上。<br> <strong>构造平衡kd树</strong><br> 思路是：因为输入有多维，那么就按顺序不断的对k为超平面进行分割，从第1维、第2维…一直到第k维，然后回到第一维继续重新分割，一直分割到整个平衡二叉树构造完成，除此之外，为了实现平衡二叉树，每次分割采用该维度的中位数。</p> 
  <p>输入：k维空间数据集T={x1,x2,…xN}<br> 其中xi = (xi(1),xi(2),…xi(k))^T i = 1,2,…N<br> 输出：kd树<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625204237663.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625204310727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>搜索kd树</strong><br> 思路：先从根节点出发，类似于二叉搜索树，找到属于目标点的叶节点（每次按照构造过程的维度，如果小于就去左子树，大于就去右子树），把该叶节点视为最近点，然后回溯，对于每个父结点，如果距离小于子结点，则更新为最近点，同时考虑它的另一个子结点区域有没有最近点，若有，递归找最近点，若没有，继续回退，直到退到根节点，搜索结束，最后的当前最近点就是最近临点。这样的话就把搜索区域从所有点变成了部分区域，增加了效率。<br> <strong>这种类似于二分法的算法，时间复杂度是O(logn)，比O(n)有了明显提升。</strong></p> 
  <p><strong>kd树的最近邻搜索算法：</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625205239805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625205306772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <h2><a id="_138"></a>朴素贝叶斯法</h2> 
  <p>朴素贝叶斯法模型：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625214056143.png" alt="在这里插入图片描述"><br> 比较好理解，就是使后验概率最大的类别就是分类的结果（可以这么想，通过贝叶斯公式计算出了每个类的后验概率，然后取那个后验概率最大的就是分出的类别）<br> 适用问题：多分类问题<br> 模型特点：特征与类别的联合概率分布，条件独立假设<br> 模型类型：生成模型<br> 学习策略：极大似然估计，极大后验概率估计<br> 学习的损失函数：对数似然函数<br> 学习算法：概率计算公式、EM算法<br> 这个模型的几何意义不明显，推导过程如下：<br> 思路是：首先求后验概率的基础是已知联合概率分布，则先验概率和条件概率分布已知，求后验概率分布，利用贝叶斯公式可求得后验概率，又因为条件概率分布的参数量十分巨大，不易计算，朴素贝叶斯对条件概率分布做了条件独立性假设，即假设X的每个维度的输入特征是独立的，那么条件概率分布写作了每个单独特征的条件概率的连乘的形式。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625220037850.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625215754111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>后验概率最大化就是期望风险最小化</strong><br> <strong>朴素贝叶斯的参数估计</strong>（就是模型学习，通过训练集训练模型（学习参数））<br> <strong>极大似然估计学习参数</strong><br> 首先计算出先验概率的极大似然估计和条件概率的极大似然估计，推导过程有点麻烦，想知道的建议自己百度，书上也没有给出：<br> 看似麻烦，其实先验概率Y=Ck的极大似然估计就是 Ck出现占总样本数的比例<br> 条件概率的极大似然估计就是 Y取Ck的情况中，x取aji的比例<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625232020357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 有了参数就可以进行贝叶斯估计了<br> <strong>朴素贝叶斯算法</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625232412880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 思路就是先用训练样本计算出参数，然后带入模型，进行预测</p> 
  <p><strong>贝叶斯估计</strong><br> 用极大似然估计可能会出现所要估计的概率值为0的情况，会影响到后验概率的计算，使分类产生偏差，采用贝叶斯估计来解决这个问题<br> 条件概率的贝叶斯估计为<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625232722814.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625233037327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">先验概率的概率分布也做相同方式的变化<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190625233141103.png" alt="在这里插入图片描述"></p> 
  <h2><a id="_170"></a>决策树</h2> 
  <p>模型：树形结构<br> 适用问题：多类分类、回归<br> 模型特点：分类树、回归树<br> 模型类型：判别模型<br> 学习策略：正则化的极大似然估计<br> 学习的损失函数：对数似然损失<br> 学习算法：特征选择，生成，剪枝<br> 这个模型没什么好说的，就是给定输入，从树的根节点出发每一层按照一种特征分类，下一层考虑新的特征，最后沿着决策树预测出分类，其实就是特征空间的分类。</p> 
  <p><strong>决策树学习</strong><br> 给定数据集 D = {(x1,y1),(x2,y2)…(xN,yN)}<br> x 为n维向量， y为类别<br> 学习过程就是构建根节点，将所有训练数据都放在根节点，选择一个最优特征，按照这一特征将训练集分割成子集，使得各个子集有一个当前条件下最好的分类，如果这些自己已经能被基本分类，那么构建叶节点，把这些子集放进叶节点，否则就继续选择最优特征分类，直到所有都被正确分类或者没有合适特征为止。这就生成了一棵决策树。<br> 为了防止过拟合，要对决策树进行剪枝处理<br> 因此决策树学习过程有三点：<br> 特征选择、决策树生成、决策树剪枝</p> 
  <p><strong>特征选择</strong><br> 首先是熵的概念，熵是一个随机变量的不确定性的度量，熵的大小只与随机变量的分类有关，和随机变量的取值无关。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626000522234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">条件熵、经验熵、经验条件熵的概念<br> 经验熵就是用数据来估计分布的熵，经验条件熵就是用数据来估计分布的条件熵。<br> 熵一般用来衡量信息的多少。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626000700327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>信息增益和信息增益比</strong><br> 这两个概念是用来选择特征的关键<br> 根据信息增益准则的特征选择方法是：对训练数据集，计算每个特征的信息增益，并比较它们的大小，选择信息增益最大的特征<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626105956681.png" alt="在这里插入图片描述"><br> 把信息增益考虑成，使用这个特征分类后信息量增长了多少<br> <strong>信息增益算法</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626110607325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626110624711.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019062611070395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">这个经验条件熵计算，发现和之前公式给的不一样？上面等式右边命名是条件概率分布，其实可以看作A特征把数据集分成了多个子集，然后直接计算在A作用后，D的新的分布的熵，就是等式右边的经验条件熵</p> 
  <p>信息增益比：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019062611141655.png" alt="在这里插入图片描述"><br> <strong>决策树生成</strong><br> ID3算法，就是从根节点开始，一层一层进行特征选择，构建决策树，特征选择采用信息增益来衡量<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626111611528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626111644566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">C4.5算法，跟ID3一样，区别是用信息增益比来选择特征<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626111759557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>决策树剪枝</strong><br> 减少过拟合，降低模型规模，考虑为结构风险最小化。<br> 决策树剪枝通过极小化决策树整体的损失函数或代价函数来实现<br> 设t是树T的叶节点，叶结点有Nt个样本点，其中k类的样本点有Ntk个，Ht（T）为叶节点t上的经验熵，α&gt;=0为参数，则决策树学习的损失函数为<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626112609718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">所以利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行特征选择。<br> <strong>树的剪枝算法</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019062611280724.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626112833249.png" alt="在这里插入图片描述"></p> 
  <h2><a id="_216"></a>逻辑斯谛回归和最大熵模型</h2> 
  <p>刚开始看逻辑斯谛回归的时候一直不明白，逻辑斯谛分布我也懂，就是sigmoid函数，它和分类器有什么关心呢，后来看了别人总结的感知机、SVM和逻辑斯谛回归模型的区别，好像有些明白了，本质上都是找到将样本分开的超平面，只是如何利用这个超平面有区别<br> 感知机是求错分类点到超平面的距离最小化，即感知机模型的最优化问题是使得错误分类点到超平面距离之和最小化。<br> SVM是最大化几何间隔，即最优化问题是最大化样本点到分离超平面的最小距离。<br> 逻辑斯谛回归模型则是将超平面作为sigmoid函数的输入，获得了样本点被分为正例和反例的条件概率，然后用极大似然估计极大化这个后验概率分布，也就是说逻辑斯蒂回归模型的最优化问题是极大似然估计样本的后验概率分布。</p> 
  <p>模型：这个模型是条件概率分布（不同于感知机和SVM是决策函数）<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626114619895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 适用问题：多类分类<br> 模型特点：特征条件下类别的条件概率分布，对数线性模型<br> 模型类型：判别模型<br> 学习策略：极大似然估计，正则化的极大似然估计<br> 学习的损失函数：逻辑斯谛损失<br> 学习算法：改进的迭代尺度算法，梯度下降，拟牛顿法</p> 
  <p>这个模型怎么理解呢，看括号内的输入，其实就是把超平面wx+b=0作为输入，这是什么含义呢，就是说<strong>逻辑斯谛回归模型把线性函数wx+b转换成了概率</strong>，剩下的就可以用极大似然估计来估计模型参数了。就是说，用概率模型替代了决策函数。看一下书上的解释。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626115814940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626115845466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 对于这个条件概率模型，用极大似然估计来学习参数，求得条件概率模型的似然函数和对数似然函数，接着采用梯度下降法或者逆牛顿法求解。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626131824667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>最大熵模型</strong><br> 首先要知道，最大熵模型是一个多类分类器，它是基于<strong>最大熵原理</strong><br> <strong>最大熵原理</strong><br> 最大熵原理是概率模型学习的一个准则，最大熵原理认为，学习概率模型时，在所有可能的概率模型中，上最大的模型是最好的模型。通常用约束条件来确定概率模型的集合，所以，最大熵原理也可以表述为在满足约束条件的模型集合中选取熵最大的模型。<br> 回忆熵的计算公式，其中X的分布为P(X)<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626140312618.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626140339214.png" alt="在这里插入图片描述"><br> 接着考虑<strong>最大熵模型</strong><br> 最大熵模型是一个条件概率分布P(Y|X),类似逻辑斯谛回归模型，是将分类面输入进逻辑斯谛分布函数里，产生的概率模型，最大熵模型是先找到一个约束，然后找到满足这个约束的所有模型，然后根据最大熵原理选择熵最大的模型，这个模型P(Y|X)就是最终的模型<br> 问题在于约束怎么找，用特征函数f(x,y)描述输入x和输出y之间的某个事实，定义是<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626210855247.png" alt="在这里插入图片描述"></p> 
  <p>有了特征函数，围绕特征函数就能求出它的联合分布的期望值，和基于模型的条件概率分布P(Y|X)与经验分布的期望值（我理解就是利用这种方法使得P(Y|X)满足了某种要求，即引入了P(Y|X)的约束）也就是说，如果P(Y|X)参与了的期望与它本身联合分布的期望一致，那么就说明P(Y|X)模型能够反映分类的情况。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626212706446.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626212726609.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626212746195.png" alt="在这里插入图片描述"></p> 
  <p>约束就是令上面的两种期望相等，就得出了模型学习的约束条件。假如说找了n个条件函数，就有n个约束条件。<br> 有了约束条件，就可以得到最大熵模型了，还是前面说的，考虑最大熵原理，<strong>满足约束条件的</strong>，<strong>熵最大的模型</strong>，就是我们要找的最大熵模型。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626213109202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>最大熵模型的学习</strong><br> 最大熵模型的学习，个人理解就是，想办法找到满足约束条件的，并且熵最大的模型。<br> <strong>最大熵模型的学习就是求解最大熵模型的过程。</strong><br> 所以目标函数就是条件熵，另外还要满足上述的约束条件，除此之外，还要使得条件概率在y所有取值下的和为1（这点感觉总会被漏掉）<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626213459911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 这不就是我们第一喜欢的约束最优化问题吗（一点都不喜欢），看到这个就想起了拉格朗日对偶法，毕竟基本上都是靠它解决约束最优化问题的。<br> 思路就是先把求极大转化为求极小，然后引入拉格朗日乘子，定义拉格朗日函数，然后把原始问题（极小极大问题）转换成对偶问题（极大极小问题）求解。当然还要满足KKT条件，才能使得原始问题和对偶问题的解等价。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626214051166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626214136674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626214207834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 这样就把最大熵模型转化成了对偶问题。<br> <strong>极大似然估计</strong><br> 接下来就是一个证明了物理含义和数学证明高度相关的事实，对偶函数的极大化等价于最大熵模型的极大似然估计。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626214834164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 最后，最大熵模型还可以写成更一般的形式。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626215005871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 最大熵模型与逻辑斯谛回归有类似的形式，我理解就是都把模型转换成了概率模型，学习过程都利用了极大似然估计，而且形式上也很相似，它们称为对数线性模型。模型学习就是在给定的训练数据条件下对模型进行极大似然估计或正则化的极大似然估计。</p> 
  <h2><a id="_271"></a>支持向量机</h2> 
  <p>书上支持向量机的介绍非常详细，推导也非常详细，所以大部分都是书的截图（内容实在太多了）但是建议没事多推导几次就能记住了<br> 模型：对于线性可分支持向量机就是一个超平面，形式上和感知机一样<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626215822629.png" alt="在这里插入图片描述"><br> 对偶形式模型：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626220013964.png" alt="在这里插入图片描述"><br> 适用问题：二类分类<br> 模型特点：分离超平面、核技巧<br> 模型类型：判别模型<br> 学习策略：极小化正则化合页损失，软间隔最大化<br> 学习的损失函数：合页损失<br> 学习算法：序列最小最优化算法</p> 
  <p><strong>线性可分支持向量机</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626224820154.png" alt="在这里插入图片描述"><br> <strong>函数间隔和几何间隔</strong><br> 函数间隔分为：关于超平面关于样本点的函数间隔和超平面关于训练集的函数间隔间隔，其中后者就是所有前者里的最小值。<br> 几何间隔也这么划分，几何间隔就是函数间隔的归一化，保证了w,b同时扩大倍数的时候（这个时候超平面不变），衡量的方式不改变。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626225142401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 所以支持向量机的学习实际就是求最大化几何间隔的过程。<br> <strong>间隔最大化</strong><br> 这个问题其实就是约束最优化问题，这里的操作非常酷炫，先把最优化问题写出来：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626225928827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 目标函数就是最大化几何间隔，约束条件是，每个超平面样本点的几何间隔都大于超平面关于数据集的几何间隔，那有n个样本点就有n个约束条件。<br> 接着改写问题，把<strong>几何间隔用函数间隔表示出来</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626231205587.png" alt="在这里插入图片描述"><br> 再考虑到，如果同时将w,b扩大倍，变成λw,λb,函数间隔变成了λγ^ ,这样的变化对最优化问题没有影响（带入以下，目标函数中λ被分子分母约掉了，约束条件两边同乘λ，也被约掉了），所以就可以产生等价的最优化问题，那么直接把γ^ 取1，带入上述问题，就把问题得到了简化。同时按照惯例把最大化问题变成最小化问题（取倒数），前面那个系数1/2是为了后面的推导方便加上去的，对实际求解没有影响（后面介绍到间隔margin的时候，它等于2/||w||，w是分离超平面的的法向量，可能这也算它的几何含义）。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626232030387.png" alt="在这里插入图片描述"><br> <strong>这是凸二次规划问题</strong><br> 这个很重要且很常用所以贴一下<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/201906262324346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 接下来就要求解约束凸二次规划问题了。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626232841511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>支持向量和间隔边界</strong><br> 在现行可分的情况下，训练数据集的样本点中与分离超平面最近的样本点的实例称为支持向量，就是使得约束等号成立的点<br> 支持向量机之所以叫这个名字，就是因为它的<strong>支持向量</strong>，它决定分离超平面时只有支持向量起作用，其他实例点不起作用。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626234051356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 再考虑回最优化问题，这个问题有N个约束条件，不好求解，这个时候就要使用熟悉的拉格朗日对偶法，将原始问题转换为对偶问题求解（这是求解凸优化问题的常用方法，利用将问题转化为较为简单的对偶问题）<br> 然后就按步骤来，构建拉格朗日函数，转换成对偶问题求解，同时求解中还用到了KKT条件中的对偶互补条件。书上很详细就直接放上书上的内容</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019062623460488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626234639732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626234731933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626234812535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626234846414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">上述推导还是挺重要的，而且一步一步推导下来也不难，建议自己推一遍就能非常理解了，同时要先看一下拉格朗日对偶法的求解步骤，不然可能有点迷。<br> <strong>线性支持向量机</strong><br> 前面说的是线性可分支持向量机，但如果是线性不可分的情况怎么办，如果有部分点混在另一个类里，那不就存在点不满足最优化问题的约束条件了，所以要想办法把它扩展为线性不可分的问题，解决方案就是将硬件个最大化修改为软间隔最大化。</p> 
  <p>思路就是修改目标函数和约束条件，对每个样本点引进松弛变量，同时在目标函数增加一个罚项（这个问题实质上由经验风险最小化变成了经验风险最小化+结构风险最小化）</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626235900961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190626235928166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 那么线性不可分支持向量机的学习变成了一个新的凸二次规划问题（原始问题）</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627000058932.png" alt="在这里插入图片描述"><br> 线性支持向量机的模型就表述为<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627000234986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 形式上和线性可分支持向量机是一样的，但是学习的最优化问题发生了改变<br> 推导过程和线性可分支持向量机也是类似的，我就不放上来了，想推导可以自己看书。<br> <strong>合页损失函数</strong><br> 它是线性支持向量机的另一种解释，优化目标变为经验损失+正则化项。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627000744581.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627000803925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>非线性支持向量机与核函数</strong><br> 思路就是通过核函数，把分类平面映射到高维空间里，实现非线性支持向量机。<br> 具体做法是，把对偶问题中的内积换成核函数即可。<br> <strong>非线性支持向量机算法</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627151027880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <h2><a id="_336"></a>提升方法</h2> 
  <p>模型：<br> AdaBboost:<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627151327906.png" alt="在这里插入图片描述"><br> 提升树：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627151436952.png" alt="在这里插入图片描述"><br> 适用问题：二类分类<br> 模型特点：弱分类器的线性组合<br> 模型类型：判别模型<br> 学习策略：极小化加法模型的指数损失<br> 损失函数：指数损失<br> 学习算法：前向分布加法算法</p> 
  <p>思路：提升算法就是把一些弱分类器线性组合起来，组合成强分类器的算法。</p> 
  <p><strong>强可学习、弱可学习</strong><br> 在概率近似正确（PAC）学习的框架中，一个概念（一个类）如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这种算法是强可学习的;一个概念，如果存在一个多项式的学习算法能够学习它，学习的正确率仅比随机猜测好，那么称这个概念是弱可学习的。后来证明<strong>强可学习和弱可学习是等价的</strong>，也就是说，一个概念是强可学习的充要条件是这个概念是弱可学习的。</p> 
  <p><strong>AdaBoost算法</strong><br> AdaBoost算法是迭代学习的过程，不断的找新的弱分类器，然后更新每个数据集的权值（它会把分类错误的样本的权值不断提升，所以后面找的新的弱分类器主要用于这些样本点的分类），同时更新分类器的权值，然后把新的组合好的分类器继续放进去迭代，最后合成一个多个弱分类器<strong>线性组合</strong>成的强分类器。就类似于，前面的弱分类器分出来一部分，剩下的分类效果不好就换个分类器继续分，直到分类效果比较好）<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627155757322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019062715590172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627155955142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> AdaBoost算法模型是一个加法模型，物理含义也很明显，不需要推导，就是M个弱分类器的加权求和。</p> 
  <p><strong>AdaBoost模型学习</strong><br> 对于加法模型，使用前向分布算法求解最优化问题。损失函数为指数损失函数，所以问题是一个经验风险极小化的过程。<br> 学习思路是：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627163203881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019062716322610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 每次迭代的时候都要找到合适的弱分类器G(x)，并计算出它对应的权值α，具体地，在第m次迭代的时候，已知了fm-1(x)，那么fm(x) = fm-1(x) + αm * Gm(x)，所以学习过程中每次迭代就是找到新的弱分类器和参数。<br> 推导过程如下：<br> 首先假设损失函数为<strong>指数损失函数</strong>（先考虑损失函数是它，按照它来推导，最后证明和AdaBoost算法的等价）<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627164311648.png" alt="在这里插入图片描述"><br> 考虑第m次迭代的时候，根据迭代的递推公式：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627164557338.png" alt="在这里插入图片描述"><br> 极小化损失函数可表示为下图<br> 通过8.21式可以看出，w只与之前的模型有关，那么可以看做一个常数，最优化问题与它无关，因此问题就是求解α和G，使得8.21式取得最小。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627164745876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">接下来对这两个参数分别考虑。首先对于G，它是一个弱分类器，那么使8.21最小的G就是使第m论加权训练数据分类误差率最小的基本分类器。<br> 那么对于任意的α&gt;0，最小的G由下式得到：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627170103794.png" alt="在这里插入图片描述"><br> 它的物理含义很明显，就是对于前m-1次迭代产生的新的权值的样本，取那个使得分类误差率（就是错分率）最小的分类器。找到G之后，重写优化目标，对α求偏导，就求得了α<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627171142247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">最后在迭代过程中权值是不断进行更新的，因此看一下权值如何更新（这里的w其实就是每次迭代样本参数的权值了，下面就能写出每次迭代权值如何更新）<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627171418508.png" alt="在这里插入图片描述"><br> 这个步骤实际就是把上面两个公式带入到wm+1,i的公式里就可以了<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627172653209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 最后和AdaBoost算法步骤样本权值更新比较，只差规范化因此，证明两者等价，也就是证明了损失函数是指数损失函数。</p> 
  <p><strong>提升树模型</strong><br> 模型：提升树模型同样也是一个线性加法模型，不同之处在于，它是以<strong>决策树</strong>为基函数的提升方法<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019062717344158.png" alt="在这里插入图片描述"><br> 提升树算法同样采用前向分步算法，针对不同问题，它的损失函数也不同。</p> 
  <p><strong>回归问题的提升树算法</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627173739308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627173757772.png" alt="在这里插入图片描述"><br> <strong>梯度提升算法</strong><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019062717385767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627173948247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <h2><a id="EM_392"></a>EM算法</h2> 
  <p>EM算法即期望极大算法，它是一个计算具有隐变量问题的一般方法，没有具体模型。例如假如我们知道一个随机变量的概率分布，就能通过极大似然估计来估计出它的参数，但是如果这个问题具有隐变量，例如两个不同分布混在一起，先要直到样本属于哪个分布，才能确定它的实际分布的参数，这就不能直接用极大斯然估计求解，而EM算法通过迭代，可以求出近似的参数的极大似然估计<br> 适用问题：概率模型参数估计<br> 模型特点：含隐变量概率模型<br> 学习策略：极大似然估计、极大后验概率估计<br> 学习的损失函数：对数似然损失<br> 学习算法：概率计算公式、EM算法</p> 
  <p><strong>EM算法</strong><br> 算法思路就是先求期望，再求极大，然后反复迭代至收敛<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627175204641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627175232566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190627175401883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODUyMjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e44c3c0e64.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d293c49e1e4bfe8f276695a5aa953300";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
