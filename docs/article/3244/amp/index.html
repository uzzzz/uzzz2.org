<!DOCTYPE html>
<html amp lang="en-US" i-amphtml-layout="" i-amphtml-no-boilerplate="" transformed="self;v=1">
<head><meta charset="utf-8"><style amp-runtime="" i-amphtml-version="012111242025001">html{overflow-x:hidden!important}html.i-amphtml-fie{height:100%!important;width:100%!important}html:not([amp4ads]),html:not([amp4ads]) body{height:auto!important}html:not([amp4ads]) body{margin:0!important}body{-webkit-text-size-adjust:100%;-moz-text-size-adjust:100%;-ms-text-size-adjust:100%;text-size-adjust:100%}html.i-amphtml-singledoc.i-amphtml-embedded{-ms-touch-action:pan-y pinch-zoom;touch-action:pan-y pinch-zoom}html.i-amphtml-fie>body,html.i-amphtml-singledoc>body{overflow:visible!important}html.i-amphtml-fie:not(.i-amphtml-inabox)>body,html.i-amphtml-singledoc:not(.i-amphtml-inabox)>body{position:relative!important}html.i-amphtml-ios-embed-legacy>body{overflow-x:hidden!important;overflow-y:auto!important;position:absolute!important}html.i-amphtml-ios-embed{overflow-y:auto!important;position:static}#i-amphtml-wrapper{overflow-x:hidden!important;overflow-y:auto!important;position:absolute!important;top:0!important;left:0!important;right:0!important;bottom:0!important;margin:0!important;display:block!important}html.i-amphtml-ios-embed.i-amphtml-ios-overscroll,html.i-amphtml-ios-embed.i-amphtml-ios-overscroll>#i-amphtml-wrapper{-webkit-overflow-scrolling:touch!important}#i-amphtml-wrapper>body{position:relative!important;border-top:1px solid transparent!important}#i-amphtml-wrapper+body{visibility:visible}#i-amphtml-wrapper+body .i-amphtml-lightbox-element,#i-amphtml-wrapper+body[i-amphtml-lightbox]{visibility:hidden}#i-amphtml-wrapper+body[i-amphtml-lightbox] .i-amphtml-lightbox-element{visibility:visible}#i-amphtml-wrapper.i-amphtml-scroll-disabled,.i-amphtml-scroll-disabled{overflow-x:hidden!important;overflow-y:hidden!important}amp-instagram{padding:54px 0px 0px!important;background-color:#fff}amp-iframe iframe{box-sizing:border-box!important}[amp-access][amp-access-hide]{display:none}[subscriptions-dialog],body:not(.i-amphtml-subs-ready) [subscriptions-action],body:not(.i-amphtml-subs-ready) [subscriptions-section]{display:none!important}amp-experiment,amp-live-list>[update]{display:none}amp-list[resizable-children]>.i-amphtml-loading-container.amp-hidden{display:none!important}amp-list [fetch-error],amp-list[load-more] [load-more-button],amp-list[load-more] [load-more-end],amp-list[load-more] [load-more-failed],amp-list[load-more] [load-more-loading]{display:none}amp-list[diffable] div[role=list]{display:block}amp-story-page,amp-story[standalone]{min-height:1px!important;display:block!important;height:100%!important;margin:0!important;padding:0!important;overflow:hidden!important;width:100%!important}amp-story[standalone]{background-color:#000!important;position:relative!important}amp-story-page{background-color:#757575}amp-story .amp-active>div,amp-story .i-amphtml-loader-background{display:none!important}amp-story-page:not(:first-of-type):not([distance]):not([active]){transform:translateY(1000vh)!important}amp-autocomplete{position:relative!important;display:inline-block!important}amp-autocomplete>input,amp-autocomplete>textarea{padding:0.5rem;border:1px solid rgba(0,0,0,0.33)}.i-amphtml-autocomplete-results,amp-autocomplete>input,amp-autocomplete>textarea{font-size:1rem;line-height:1.5rem}[amp-fx^=fly-in]{visibility:hidden}amp-script[nodom],amp-script[sandboxed]{position:fixed!important;top:0!important;width:1px!important;height:1px!important;overflow:hidden!important;visibility:hidden}
/*# sourceURL=/css/ampdoc.css*/[hidden]{display:none!important}.i-amphtml-element{display:inline-block}.i-amphtml-blurry-placeholder{transition:opacity 0.3s cubic-bezier(0.0,0.0,0.2,1)!important;pointer-events:none}[layout=nodisplay]:not(.i-amphtml-element){display:none!important}.i-amphtml-layout-fixed,[layout=fixed][width][height]:not(.i-amphtml-layout-fixed){display:inline-block;position:relative}.i-amphtml-layout-responsive,[layout=responsive][width][height]:not(.i-amphtml-layout-responsive),[width][height][heights]:not([layout]):not(.i-amphtml-layout-responsive),[width][height][sizes]:not(img):not([layout]):not(.i-amphtml-layout-responsive){display:block;position:relative}.i-amphtml-layout-intrinsic,[layout=intrinsic][width][height]:not(.i-amphtml-layout-intrinsic){display:inline-block;position:relative;max-width:100%}.i-amphtml-layout-intrinsic .i-amphtml-sizer{max-width:100%}.i-amphtml-intrinsic-sizer{max-width:100%;display:block!important}.i-amphtml-layout-container,.i-amphtml-layout-fixed-height,[layout=container],[layout=fixed-height][height]:not(.i-amphtml-layout-fixed-height){display:block;position:relative}.i-amphtml-layout-fill,.i-amphtml-layout-fill.i-amphtml-notbuilt,[layout=fill]:not(.i-amphtml-layout-fill),body noscript>*{display:block;overflow:hidden!important;position:absolute;top:0;left:0;bottom:0;right:0}body noscript>*{position:absolute!important;width:100%;height:100%;z-index:2}body noscript{display:inline!important}.i-amphtml-layout-flex-item,[layout=flex-item]:not(.i-amphtml-layout-flex-item){display:block;position:relative;-ms-flex:1 1 auto;flex:1 1 auto}.i-amphtml-layout-fluid{position:relative}.i-amphtml-layout-size-defined{overflow:hidden!important}.i-amphtml-layout-awaiting-size{position:absolute!important;top:auto!important;bottom:auto!important}i-amphtml-sizer{display:block!important}@supports (aspect-ratio:1/1){i-amphtml-sizer.i-amphtml-disable-ar{display:none!important}}.i-amphtml-blurry-placeholder,.i-amphtml-fill-content{display:block;height:0;max-height:100%;max-width:100%;min-height:100%;min-width:100%;width:0;margin:auto}.i-amphtml-layout-size-defined .i-amphtml-fill-content{position:absolute;top:0;left:0;bottom:0;right:0}.i-amphtml-replaced-content,.i-amphtml-screen-reader{padding:0!important;border:none!important}.i-amphtml-screen-reader{position:fixed!important;top:0px!important;left:0px!important;width:4px!important;height:4px!important;opacity:0!important;overflow:hidden!important;margin:0!important;display:block!important;visibility:visible!important}.i-amphtml-screen-reader~.i-amphtml-screen-reader{left:8px!important}.i-amphtml-screen-reader~.i-amphtml-screen-reader~.i-amphtml-screen-reader{left:12px!important}.i-amphtml-screen-reader~.i-amphtml-screen-reader~.i-amphtml-screen-reader~.i-amphtml-screen-reader{left:16px!important}.i-amphtml-unresolved{position:relative;overflow:hidden!important}.i-amphtml-select-disabled{-webkit-user-select:none!important;-ms-user-select:none!important;user-select:none!important}.i-amphtml-notbuilt,[layout]:not(.i-amphtml-element),[width][height][heights]:not([layout]):not(.i-amphtml-element),[width][height][sizes]:not(img):not([layout]):not(.i-amphtml-element){position:relative;overflow:hidden!important;color:transparent!important}.i-amphtml-notbuilt:not(.i-amphtml-layout-container)>*,[layout]:not([layout=container]):not(.i-amphtml-element)>*,[width][height][heights]:not([layout]):not(.i-amphtml-element)>*,[width][height][sizes]:not([layout]):not(.i-amphtml-element)>*{display:none}amp-img:not(.i-amphtml-element)[i-amphtml-ssr]>img.i-amphtml-fill-content{display:block}.i-amphtml-notbuilt:not(.i-amphtml-layout-container),[layout]:not([layout=container]):not(.i-amphtml-element),[width][height][heights]:not([layout]):not(.i-amphtml-element),[width][height][sizes]:not(img):not([layout]):not(.i-amphtml-element){color:transparent!important;line-height:0!important}.i-amphtml-ghost{visibility:hidden!important}.i-amphtml-element>[placeholder],[layout]:not(.i-amphtml-element)>[placeholder],[width][height][heights]:not([layout]):not(.i-amphtml-element)>[placeholder],[width][height][sizes]:not([layout]):not(.i-amphtml-element)>[placeholder]{display:block;line-height:normal}.i-amphtml-element>[placeholder].amp-hidden,.i-amphtml-element>[placeholder].hidden{visibility:hidden}.i-amphtml-element:not(.amp-notsupported)>[fallback],.i-amphtml-layout-container>[placeholder].amp-hidden,.i-amphtml-layout-container>[placeholder].hidden{display:none}.i-amphtml-layout-size-defined>[fallback],.i-amphtml-layout-size-defined>[placeholder]{position:absolute!important;top:0!important;left:0!important;right:0!important;bottom:0!important;z-index:1}amp-img[i-amphtml-ssr]:not(.i-amphtml-element)>[placeholder]{z-index:auto}.i-amphtml-notbuilt>[placeholder]{display:block!important}.i-amphtml-hidden-by-media-query{display:none!important}.i-amphtml-element-error{background:red!important;color:#fff!important;position:relative!important}.i-amphtml-element-error:before{content:attr(error-message)}i-amp-scroll-container,i-amphtml-scroll-container{position:absolute;top:0;left:0;right:0;bottom:0;display:block}i-amp-scroll-container.amp-active,i-amphtml-scroll-container.amp-active{overflow:auto;-webkit-overflow-scrolling:touch}.i-amphtml-loading-container{display:block!important;pointer-events:none;z-index:1}.i-amphtml-notbuilt>.i-amphtml-loading-container{display:block!important}.i-amphtml-loading-container.amp-hidden{visibility:hidden}.i-amphtml-element>[overflow]{cursor:pointer;position:relative;z-index:2;visibility:hidden;display:initial;line-height:normal}.i-amphtml-layout-size-defined>[overflow]{position:absolute}.i-amphtml-element>[overflow].amp-visible{visibility:visible}template{display:none!important}.amp-border-box,.amp-border-box *,.amp-border-box :after,.amp-border-box :before{box-sizing:border-box}amp-pixel{display:none!important}amp-analytics,amp-auto-ads,amp-story-auto-ads{position:fixed!important;top:0!important;width:1px!important;height:1px!important;overflow:hidden!important;visibility:hidden}html.i-amphtml-fie>amp-analytics{position:initial!important}[visible-when-invalid]:not(.visible),form [submit-error],form [submit-success],form [submitting]{display:none}amp-accordion{display:block!important}@media (min-width:1px){:where(amp-accordion>section)>:first-child{margin:0;background-color:#efefef;padding-right:20px;border:1px solid #dfdfdf}:where(amp-accordion>section)>:last-child{margin:0}}amp-accordion>section{float:none!important}amp-accordion>section>*{float:none!important;display:block!important;overflow:hidden!important;position:relative!important}amp-accordion,amp-accordion>section{margin:0}amp-accordion:not(.i-amphtml-built)>section>:last-child{display:none!important}amp-accordion:not(.i-amphtml-built)>section[expanded]>:last-child{display:block!important}
/*# sourceURL=/css/ampshared.css*/</style><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1"><title>低层次特征提取（一）-边缘检测 - 有组织在!</title><link rel="preconnect" href="https://cdn.ampproject.org"><link rel="preload" as="script" href="https://cdn.ampproject.org/v0.js"><script async="" src="https://cdn.ampproject.org/v0.js"></script><script src="https://cdn.ampproject.org/v0/amp-anim-0.1.js" async="" custom-element="amp-anim"></script><style amp-custom="">.amp-wp-enforced-sizes{max-width:100%;margin:0 auto}amp-img.amp-wp-enforced-sizes[layout="intrinsic"] > img,amp-anim.amp-wp-enforced-sizes[layout="intrinsic"] > img{object-fit:contain}html{background:#0a89c0}body{background:#fff;color:#353535;font-family:Georgia,"Times New Roman",Times,Serif;font-weight:300;line-height:1.75em}p{margin:0 0 1em;padding:0}a,a:visited{color:#0a89c0}a:hover,a:active,a:focus{color:#353535}blockquote{color:#353535;background:rgba(127,127,127,.125);border-left:2px solid #0a89c0;margin:8px 0 24px 0;padding:16px}blockquote p:last-child{margin-bottom:0}.amp-wp-meta,.amp-wp-header div,.amp-wp-title,.amp-wp-tax-category,.amp-wp-footer p,.back-to-top{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen-Sans","Ubuntu","Cantarell","Helvetica Neue",sans-serif}.amp-wp-header{background-color:#0a89c0}.amp-wp-header div{color:#fff;font-size:1em;font-weight:400;margin:0 auto;max-width:calc(840px - 32px);padding:.875em 16px;position:relative}.amp-wp-header a{color:#fff;text-decoration:none}.amp-wp-header .amp-wp-site-icon{background-color:#fff;border:1px solid #fff;border-radius:50%;position:absolute;right:18px;top:10px}.amp-wp-article{color:#353535;font-weight:400;margin:1.5em auto;max-width:840px;overflow-wrap:break-word;word-wrap:break-word}.amp-wp-article-header{align-items:center;align-content:stretch;display:flex;flex-wrap:wrap;justify-content:space-between;margin:1.5em 16px 0}.amp-wp-title{color:#353535;display:block;flex:1 0 100%;font-weight:900;margin:0 0 .625em;width:100%}.amp-wp-meta{color:#696969;display:inline-block;flex:2 1 50%;font-size:.875em;line-height:1.5em;margin:0 0 1.5em;padding:0}.amp-wp-article-header .amp-wp-meta:last-of-type{text-align:right}.amp-wp-article-header .amp-wp-meta:first-of-type{text-align:left}.amp-wp-byline amp-img,.amp-wp-byline .amp-wp-author{display:inline-block;vertical-align:middle}.amp-wp-byline amp-img{border:1px solid #0a89c0;border-radius:50%;position:relative;margin-right:6px}.amp-wp-posted-on{text-align:right}.amp-wp-article-content{margin:0 16px}.amp-wp-article-content amp-img{margin:0 auto}.amp-wp-article-footer .amp-wp-meta{display:block}.amp-wp-tax-category{color:#696969;font-size:.875em;line-height:1.5em;margin:1.5em 16px}.amp-wp-footer{border-top:1px solid #c2c2c2;margin:calc(1.5em - 1px) 0 0}.amp-wp-footer div{margin:0 auto;max-width:calc(840px - 32px);padding:1.25em 16px 1.25em;position:relative}.amp-wp-footer h2{font-size:1em;line-height:1.375em;margin:0 0 .5em}.amp-wp-footer p{color:#696969;font-size:.8em;line-height:1.5em;margin:0 85px 0 0}.amp-wp-footer a{text-decoration:none}.back-to-top{bottom:1.275em;font-size:.8em;font-weight:600;line-height:2em;position:absolute;right:16px}.htmledit_views em,.htmledit_views span[lang]{font-style:italic}.htmledit_views{font-family:-apple-system,SF UI Text,Arial,PingFang SC,Hiragino Sans GB,Microsoft YaHei,WenQuanYi Micro Hei,sans-serif,SimHei,SimSun}.htmledit_views a>amp-img,.htmledit_views a>amp-anim{padding:1px;margin:1px;border:none;outline:#0782c1 solid 1px}.htmledit_views p{font-size:16px;color:#4d4d4d;font-weight:400;line-height:26px;margin:0 0 16px;overflow-x:auto}p[align=center]{text-align:center}.htmledit_views amp-img,.htmledit_views amp-anim{max-width:100%}.htmledit_views *{box-sizing:border-box}.htmledit_views h1,.htmledit_views h2,.htmledit_views h3,.htmledit_views h4{color:#4f4f4f;margin:8px 0 16px;font-weight:700}.htmledit_views h1{font-size:28px;line-height:36px}.htmledit_views h2{font-size:24px;line-height:32px}.htmledit_views h3{font-size:22px;line-height:30px}.htmledit_views h4{font-size:20px;line-height:28px}.htmledit_views blockquote{display:block;padding:16px 16px 0;margin:0 0 24px;border-left:8px solid #dddfe4;background:#eef0f4;overflow:auto;overflow-scrolling:touch;word-wrap:normal;word-break:normal}.htmledit_views blockquote p{font-size:16px;line-height:26px;font-weight:400;margin-bottom:16px;color:#4f4f4f}.htmledit_views pre{white-space:pre-wrap;word-wrap:break-word;margin:0 0 24px;overflow-x:auto;padding:8px}.htmledit_views pre{font-family:Consolas,Inconsolata,Courier,monospace;font-size:14px;line-height:22px;color:#000}.htmledit_views pre code,.htmledit_views pre code div,.htmledit_views pre code span{font-family:"Source Code Pro","DejaVu Sans Mono","Ubuntu Mono","Anonymous Pro","Droid Sans Mono",Menlo,Monaco,Consolas,Inconsolata,Courier,monospace,"PingFang SC","Microsoft YaHei",sans-serif}.htmledit_views code{border-radius:4px}.htmledit_views a{color:#4ea1db;text-decoration:none}.htmledit_views a:focus,.htmledit_views a:hover{color:#ca0c16}.htmledit_views a:visited{color:#6795b5}.htmledit_views pre code{display:block;line-height:22px;overflow-x:auto;white-space:pre;word-wrap:normal;border-radius:4px;padding:8px}.htmledit_views pre code:not(.hljs){background-color:#f3f4f5}.htmledit_views pre code,.htmledit_views pre code div,.htmledit_views pre code span{font-size:14px}:root:not(#_):not(#_):not(#_):not(#_):not(#_):not(#_):not(#_):not(#_):not(#_):not(#_):not(#_):not(#_):not(#_):not(#_):not(#_):not(#_):not(#_) .amp-wp-1a5bce8{display:inline}:root:not(#_):not(#_):not(#_):not(#_):not(#_) .amp-wp-6c3ca25{font-size:14px}:root:not(#_):not(#_):not(#_):not(#_):not(#_) .amp-wp-52ff5a2{font-family:SimHei}:root:not(#_):not(#_):not(#_):not(#_):not(#_) .amp-wp-9456def{color:#000}:root:not(#_):not(#_):not(#_):not(#_):not(#_) .amp-wp-b6ce978{font-family:SimHei;font-size:14px}

/*# sourceURL=amp-custom.css */</style><script type="application/ld+json" class="yoast-schema-graph yoast-schema-graph--main">{"@context":"https://schema.org","@graph":[{"@type":"WebSite","@id":"https://uzzz.org/#website","url":"https://uzzz.org/","name":"\u6709\u7ec4\u7ec7\u5728!","potentialAction":{"@type":"SearchAction","target":"https://uzzz.org/?s={search_term_string}","query-input":"required name=search_term_string"}},{"@type":"ImageObject","@id":"https://uzzz.org/article/3244/#primaryimage","url":"http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q101.jpg"},{"@type":"WebPage","@id":"https://uzzz.org/article/3244/#webpage","url":"https://uzzz.org/article/3244/","inLanguage":"en-US","name":"\u4f4e\u5c42\u6b21\u7279\u5f81\u63d0\u53d6\uff08\u4e00\uff09-\u8fb9\u7f18\u68c0\u6d4b - \u6709\u7ec4\u7ec7\u5728!","isPartOf":{"@id":"https://uzzz.org/#website"},"primaryImageOfPage":{"@id":"https://uzzz.org/article/3244/#primaryimage"},"datePublished":"2015-05-12T04:47:09+00:00","dateModified":"2015-05-12T04:47:09+00:00","author":{"@id":"https://uzzz.org/#/schema/person/29673f1347b0abda5882803c72ee5a3f"}},{"@type":["Person"],"@id":"https://uzzz.org/#/schema/person/29673f1347b0abda5882803c72ee5a3f","name":"fandyvon","sameAs":[]}]}</script><link rel="canonical" href="https://uzzz.org/article/3244/"></head>

<body class="">

<header id="top" class="amp-wp-header">
	<div>
		<a href="https://uzzz.org/">
										<amp-img src="https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png" width="32" height="32" class="amp-wp-site-icon i-amphtml-layout-fixed i-amphtml-layout-size-defined" style="width:32px;height:32px;" i-amphtml-layout="fixed"></amp-img>
						<span class="amp-site-title">
				有组织在!			</span>
		</a>

					</div>
</header>

<article class="amp-wp-article">
	<header class="amp-wp-article-header">
		<h1 class="amp-wp-title">低层次特征提取（一）————边缘检测</h1>
			<div class="amp-wp-meta amp-wp-byline">
					<amp-img src="https://secure.gravatar.com/avatar/e786821a74ef0467825a7d60183307bc?s=24&d=mm&r=g" alt="fandyvon" width="24" height="24" layout="fixed" class="i-amphtml-layout-fixed i-amphtml-layout-size-defined" style="width:24px;height:24px;" i-amphtml-layout="fixed"></amp-img>
				<span class="amp-wp-author author vcard">fandyvon</span>
	</div>
<div class="amp-wp-meta amp-wp-posted-on">
	<time datetime="2015-05-12T12:47:09+00:00">
		7 years ago	</time>
</div>
	</header>

	
	<div class="amp-wp-article-content">
		<div id="article_content" class="article_content clearfix">
 <br>
 
 
 
<div class="htmledit_views" id="content_views">
<blockquote>
<div id="sina_keyword_ad_area2">
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">    低层次特征是不需要任何形状/空间关系的信息就可以从图像中自动提取的基本特征。所有低层次方法都可以应用于高层次特征提取，从而在图像中找到形状。第一种低层次特征，称之”edge detection”。它的目的要是要制作一个线图。一阶检测算子相于一阶微分法，二阶边缘检测算子相当于高一阶微分处理。<br></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">    边缘检测：</span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">在视觉计算理论框架中，抽取二维图像上的边缘、角点、纹理等基本特征，是整个系统框架中的第一步。这些特征所组成的图称为基元图</span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">。在不同“尺度”意义下的边缘点，在一定条件下包含了原图像的全部信息。</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">定义：</span></p>
<div>
<div>
<div>
       <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">    •目前，具有对边缘的描述性定义，即两个具有不同灰度的均匀图像区域的边界，即边界反映局部的灰度变化。</span>
      </div>
<div>
       <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">    •局部边缘是图像中局部灰度级以简单（即单调）的方式作极快变换的小区域。这种局部变化可用一定窗口运算的边缘检测算子来检测。</span>
      </div>
</div>
<p>     <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><br></span>
    </p></div>
<div>
     <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">边缘的描述：</span>
    </div>
<div>
<div>
<div>
       <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">1)边缘法线方向——在某点灰度变化最剧烈的方向，与边缘方向垂直；</span>
      </div>
</div>
</div>
<div>
<div>
<div>
       <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">2)边缘方向——与边缘法线方向垂直，是目标边界的切线方向；</span>
      </div>
</div>
<div>
<div data-amp-original-style="display:inline !important;" class="amp-wp-1a5bce8">
<div data-amp-original-style="display:inline !important;" class="amp-wp-1a5bce8">
<div data-amp-original-style="display:inline !important;" class="amp-wp-1a5bce8">
         <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">3) </span><br>
         <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">边缘强度——沿边缘法线方向图像局部的变化强度的量度。</span>
        </div>
</div>
</div>
<p>      <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><br></span>
     </p></div>
<p>     <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><br></span>
    </p></div>
<div>
<div>
      <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">    边缘检测的基本思想是通过检测每个像素和其邻域的状态，以决定该像素是否位于一个物体的边界上。如果一个像素位于一个物体的边界上，则其邻域像素的灰度值的变化就比较大。假如可以应用某种算法检测出这种变化并进行量化表示，那么就可以确定物体的边界。</span><br>
      <span data-amp-original-style="font-size:14px;" class="amp-wp-6c3ca25">
<p><span data-amp-original-style="font-family:SimHei;" class="amp-wp-52ff5a2">边缘检测算法有如下四个步骤：</span></p></span>
     </div>
</div>
<p>    <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"></span> </p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">滤波：边缘检测算法主要是基于图像强度的一阶和二阶导数，但导数的计算对噪声很敏感，因此必须使用滤波器来改善与噪声有关的边缘检测器的性能．需要指出，大多数滤波器在降低噪声的同时也导致了边缘强度的损失，因此，增强边缘和降低噪声之间需要折衷．</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">增强：增强边缘的基础是确定图像各点邻域强度的变化值．增强算法可以将邻域（或局部）强度值有显著变化的点突显出来．边缘增强一般是通过计算梯度幅值来完成的．</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">检测：在图像中有许多点的梯度幅值比较大，而这些点在特定的应用领域中并不都是边缘，所以应该用某种方法来确定哪些点是边缘点．最简单的边缘检测判据是梯度幅值阈值判据．</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">定位：如果某一应用场合要求确定边缘位置，则边缘的位置可在子像素分辨率上来估计，边缘的方位也可以被估计出来．</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">   在边缘检测算法中，前三个步骤用得十分普遍。这是因为大多数场合下，仅仅需要边缘检测器指出边缘出现在图像某一像素点的附近，而没有必要指出边缘的精确位置或方向．边缘检测误差通常是指边缘误分类误差，即把假边缘判别成边缘而保留，而把真边缘判别成假边缘而去掉．边缘估计误差是用概率统计模型来描述边缘的位置和方向误差的．我们将边缘检测误差和边缘估计误差区分开，是因为它们的计算方法完全不同，其误差模型也完全不同．</span></p>
<div>
<div>
      <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">边缘检测的三个共性准则：</span>
     </div>
<div>
      <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">•好的检测结果，或者说对边缘的误测率尽可能低，就是在图像边缘出现的地方检测结果中不应该没有；另一方面不要出现虚假的边缘；</span>
     </div>
<div>
      <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">•对边缘的定位要准确，也就是我们标记出的边缘位置要和图像上真正边缘的中心位置充分接近；</span>
     </div>
<div>
      <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">•对同一边缘要有尽可能低的响应次数，也就是检测响应最好是单像素的。</span>
     </div>
</div>
<p>    <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><br></span> </p>
<div>
     <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">几种常用的边缘检测算子主要有Roberts边缘检测算子，Sobel算子、Prewitt算子、Krisch边缘算子，高斯-拉普拉斯算子。</span>
    </div>
<div>
     <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">边缘大致可以分为两种，一种是阶跃状边缘，边缘两边像素的灰度值明显不同；另一种为屋顶状边缘，边缘处于灰度值由小到大再到小的变化转折点处。<br> 边缘检测的主要工具是边缘检测模板。我们以一个一维模板为例来考察边缘检测模板是如何作用的。假设有一个模板<amp-img title="基于Roberts算子的边缘检测" alt="基于Roberts算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q101.jpg" height="28" width="90" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2228%22%20width=%2290%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Roberts算子的边缘检测" alt="基于Roberts算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q101.jpg" height="28" width="90"></noscript></amp-img> 和一幅图象<amp-img title="基于Roberts算子的边缘检测" alt="基于Roberts算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q4.jpg" height="120" width="312" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%22120%22%20width=%22312%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Roberts算子的边缘检测" alt="基于Roberts算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q4.jpg" height="120" width="312"></noscript></amp-img><br></span> 
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">可以看出，图象中左边暗，右边亮，中间存在着一条明显的边缘，是一个典型阶跃状边缘。使用模板<amp-img title="基于Roberts算子的边缘检测" alt="基于Roberts算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q101.jpg" height="28" width="90" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2228%22%20width=%2290%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Roberts算子的边缘检测" alt="基于Roberts算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q101.jpg" height="28" width="90"></noscript></amp-img> 进行模板操作后，结果如下</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><amp-img title="基于Roberts算子的边缘检测" alt="基于Roberts算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q5.jpg" height="120" width="273" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%22120%22%20width=%22273%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Roberts算子的边缘检测" alt="基于Roberts算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q5.jpg" height="120" width="273"></noscript></amp-img></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">可以看出，边缘检测后的图象在原图象暗亮边缘处的灰度值高很多。观察时，就能发现一条很明显的亮边，其他区域都很暗，这样就起到了边缘检测的作用。<br> 模板的作用是将右邻点的灰度值减去左邻点的灰度值作为该点的灰度值。在灰度相近的区域内，这么做的结果使得该点的灰度值接近于0；而在边缘附近，灰度值有明显的跳变，这么做的结果使得该点的灰度值很大，这样就出现了上面的结果。这种模板就是一种边缘检测器，它在数学上的涵义是一种基于梯度的滤波器，习惯上又称边缘算子。我们知道，梯度是有方向的，和边缘的方向总是垂直的。模板是水平方向的，而上面那幅图象的边缘恰好是垂直方向的，使用模板就可以将它检测出来。如果图象的边缘是水平方向的，我们可以用梯度是垂直<br> 方向的模板<amp-img title="基于Roberts算子的边缘检测" alt="基于Roberts算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q101.jpg" height="28" width="90" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2228%22%20width=%2290%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Roberts算子的边缘检测" alt="基于Roberts算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q101.jpg" height="28" width="90"></noscript></amp-img> 检测它的边缘。如果图象的边缘是45。方向的，我们可以用模板<amp-img title="基于Roberts算子的边缘检测" alt="基于Roberts算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q11.jpg" height="93" width="45" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2293%22%20width=%2245%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Roberts算子的边缘检测" alt="基于Roberts算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q11.jpg" height="93" width="45"></noscript></amp-img> 检测它的边缘。</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">常用的边缘检测模板有Laplacian算子、Roberts算子、Sobel算子、log（Laplacian-Gauss）算子、Kirsch算子和Prewitt算子等。</span> </p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">下面是算子的基本模板：</span></p>
<p>     <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"></span> </p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">1、Roberts算子</span></p>
<p align="left"><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">如果我们沿如下图方向角度求其交叉方向的偏导数，则得到Roberts于1963年提出的交叉算子边缘检测方法。该方法最大优点是计算量小，速度快。但该方法由于是采用偶数模板，如下图所示，所求的(x,y)点处梯度幅度值，其实是图中交叉点处的值，从而导致在图像(x,y)点所求的梯度幅度值偏移了半个像素（见下图）。</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><amp-img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150513180322295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFuZ2IyMDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" width="396" height="244" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%22244%22%20width=%22396%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150513180322295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFuZ2IyMDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" width="396" height="244" class=""></noscript></amp-img></span></p>
<p><amp-img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150513180335056?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFuZ2IyMDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" width="510" height="335" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%22335%22%20width=%22510%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150513180335056?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFuZ2IyMDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" width="510" height="335" class=""></noscript></amp-img><br><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><br></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">Roberts算子的推导：</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><amp-anim alt="" src="https://img-my.csdn.net/uploads/201203/29/1333023490_5422.gif" title="边缘检测" object-fit="contain" width="840" height="400" class="amp-wp-unknown-size amp-wp-unknown-width amp-wp-unknown-height amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%22400%22%20width=%22840%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img alt="" src="https://img-my.csdn.net/uploads/201203/29/1333023490_5422.gif" title="边缘检测" width="840" height="400" class="amp-wp-unknown-size amp-wp-unknown-width amp-wp-unknown-height"></noscript></amp-anim></span></p>
</div>
<div>
     <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span>
    </div>
<div>
     <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span>2、Sobel算子</span></span>
    </div>
<div>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">Sobel算子也有两个，一个是检测水平边缘的模板<amp-img title="基于Sobel算子的边缘检测" alt="基于Sobel算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q51.jpg" height="93" width="128" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2293%22%20width=%22128%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Sobel算子的边缘检测" alt="基于Sobel算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q51.jpg" height="93" width="128"></noscript></amp-img> ，另一个是检测水平边缘的模板<amp-img title="基于Sobel算子的边缘检测" alt="基于Sobel算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q52.jpg" height="93" width="105" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2293%22%20width=%22105%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Sobel算子的边缘检测" alt="基于Sobel算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q52.jpg" height="93" width="105"></noscript></amp-img>。与Prewitt算子相比，Sobel算子对于象素位置的影响作了加权，因此效果更好。</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">sobel算子的另一种形式是各向同性Sobel算子，也有两个模板组成，一个是检测水平边缘的<amp-img title="基于Sobel算子的边缘检测" alt="基于Sobel算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q53.jpg" height="100" width="143" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%22100%22%20width=%22143%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Sobel算子的边缘检测" alt="基于Sobel算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q53.jpg" height="100" width="143"></noscript></amp-img> ，另一个是检测垂直边缘的<amp-img title="基于Sobel算子的边缘检测" alt="基于Sobel算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q54.jpg" height="93" width="137" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2293%22%20width=%22137%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Sobel算子的边缘检测" alt="基于Sobel算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q54.jpg" height="93" width="137"></noscript></amp-img>。各向同性Sobel算子和普通Sobel算子相比，位置加权系数更为准确，在检测不同方向的边缘时梯度的幅度一致。<br></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">Sobel算子的推导：</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><amp-anim alt="" src="https://img-my.csdn.net/uploads/201203/29/1333023593_8659.gif" title="边缘检测" object-fit="contain" width="840" height="400" class="amp-wp-unknown-size amp-wp-unknown-width amp-wp-unknown-height amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%22400%22%20width=%22840%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img alt="" src="https://img-my.csdn.net/uploads/201203/29/1333023593_8659.gif" title="边缘检测" width="840" height="400" class="amp-wp-unknown-size amp-wp-unknown-width amp-wp-unknown-height"></noscript></amp-anim></span></p>
</div>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">3、Prewitt算子</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">Prewitt算子由两部分组成，检测水平边缘的模板</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><amp-img title="基于prewitt算子的边缘检测" alt="基于prewitt算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q41.jpg" height="93" width="125" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2293%22%20width=%22125%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于prewitt算子的边缘检测" alt="基于prewitt算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q41.jpg" height="93" width="125"></noscript></amp-img> 和<amp-img title="基于prewitt算子的边缘检测" alt="基于prewitt算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q42.jpg" height="93" width="98" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2293%22%20width=%2298%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于prewitt算子的边缘检测" alt="基于prewitt算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q42.jpg" height="93" width="98"></noscript></amp-img>检测垂直边缘的模板</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">prewitt算子一个方向求微分，一个方向求平均，所以对噪声相对不敏感。</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">4、laplacian算子</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">Laplacian算子定义为</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><amp-img title="基于Laplacian算子的边缘检测" alt="基于Laplacian算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q31.jpg" height="60" width="287" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2260%22%20width=%22287%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Laplacian算子的边缘检测" alt="基于Laplacian算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q31.jpg" height="60" width="287"></noscript></amp-img></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">它的差分形式为<br><amp-img title="基于Laplacian算子的边缘检测" alt="基于Laplacian算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q32.jpg" height="88" width="436" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2288%22%20width=%22436%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Laplacian算子的边缘检测" alt="基于Laplacian算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q32.jpg" height="88" width="436"></noscript></amp-img></span></p>
<p> 表示成模板的形式就是 <amp-img title="基于Laplacian算子的边缘检测" alt="基于Laplacian算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q33.jpg" height="93" width="125" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2293%22%20width=%22125%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Laplacian算子的边缘检测" alt="基于Laplacian算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q33.jpg" height="93" width="125"></noscript></amp-img>。Laplacian算子另外一种形式是<amp-img title="基于Laplacian算子的边缘检测" alt="基于Laplacian算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q34.jpg" height="93" width="125" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2293%22%20width=%22125%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img title="基于Laplacian算子的边缘检测" alt="基于Laplacian算子的边缘检测" src="http://web.gdut.edu.cn/~dj/jxsb/cai/pic/q34.jpg" height="93" width="125"></noscript></amp-img>，也经常使用。Laplace算子是一种各向同性算子，在只关心边缘的位置而不考虑其周围的象素灰度差值时比较合适。Laplace算子对孤立象素的响应要比对边缘或线的响应要更强烈，因此只适用于无噪声图象。存在噪声情况下，使用Laplacian算子检测边缘之前需要先进行低通滤波。</p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">5、canny算子</span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><br></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">5.1. </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">Canny边缘检测</span>基本原理</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">(1)图象边缘检测必须满足两个条件：一能有效地抑制噪声；二必须尽量精确确定边缘的位置。</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">(2)根据对信噪比与定位乘积进行测度，得到最优化逼近算子。这就是Canny边缘检测算子。</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">(3)类似与Marr（LoG）边缘检测方法，也属于先平滑后求导数的方法。</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">5.2 </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">Canny边缘检测算法：</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">step1:用高斯滤波器平滑图象；</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">step2:用一阶偏导的有限差分来计算梯度的幅值和方向；</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">step3:对梯度幅值进行非极大值抑制；</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">step4:用双阈值算法检测和连接边缘。</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">step1:高斯平滑函数</span></p>
<p><amp-img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150514114247929?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFuZ2IyMDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" width="188" height="80" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2280%22%20width=%22188%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150514114247929?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFuZ2IyMDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" width="188" height="80" class=""></noscript></amp-img></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">Step2：一阶微分卷积模板</span></p>
<p><amp-img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150514114314184?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFuZ2IyMDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" width="234" height="219" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%22219%22%20width=%22234%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150514114314184?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFuZ2IyMDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" width="234" height="219" class=""></noscript></amp-img></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">step3:非极大值抑制仅仅得到全局的梯度并不足以确定边缘，因此为确定边缘，<u>必须保留局部梯度最大的点，而抑制非极大值</u>。（non-maxima </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">suppression,NMS）</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">解决方法：利用梯度的方向。</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><amp-img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150514114332015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFuZ2IyMDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" width="259" height="80" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2280%22%20width=%22259%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150514114332015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFuZ2IyMDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" width="259" height="80" class=""></noscript></amp-img></span></p>
<p></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">图1非极大值抑制</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">四个扇区的标号为0到3，对应3*3邻域的四种可能组合。在每一点上，邻域的中心象素M与沿着梯度线的两个象素相比？？？？。如果M的梯度值不比沿梯度线的两个相邻象素梯度值大，则令M=0。</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">即： </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><amp-img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150514114344277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFuZ2IyMDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" width="207" height="30" class="amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg%20height=%2230%22%20width=%22207%22%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22/>"></i-amphtml-sizer><noscript><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150514114344277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFuZ2IyMDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" width="207" height="30" class=""></noscript></amp-img><br></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">Step4:阈值化</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">减少假边缘段数量的典型方法是对N[i，j]使用一个阈值。将低于阈值的所有值赋零值。但问题是如何选取阈值？</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"> </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">解决方法：<u>双阈值算法</u>。双阈值算法对非极大值抑制图象作用两个阈值τ1和τ2，且2τ1≈τ2，从而可以得到两个阈值边缘图象N1［i,j］和N2［i，j］。由于N2［i，j］使用高阈值得到，因而含有很少的假边缘，但有间断(不闭合)。双阈值法要在N2［i，j］中把边缘连接成轮廓，当到达轮廓的端点时，该算法就在N1［i,j］的8邻点位置寻找可以连接到轮廓上的边缘，这样，算法不断地在</span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">N1［i,j］中收集边缘，直到将N2［i,j］连接起来为止。</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">5.3 </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">canny算法程序实现</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">Canny算法程序中将上述的4个步骤再加以细分，分成以下7步：</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">l </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">生成高斯滤波系数；</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">l </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">用生成的高斯滤波系数对原图像进行平滑；</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">l </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">求滤波后图像的梯度；</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">l </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">进行非最大抑制；</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">l </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">统计图像的直方图，对阈值进行判定；</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">l </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">利用函数寻找边界起点；</span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">l </span><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">根据第6步执行的结果，从一个像素点开始搜索，搜索以该像素点为边界起点的一条边界的一条边界的所有边界点；</span></p>
</div>
<p>   <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><br></span> </p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">各个算子在Matlab中使用格式和边缘检测方法：</span></p>
<h4><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">1. Roberts算子</span></span></h4>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">Roberts交叉算子为梯度幅值计算提供了一种简单的近似方法：</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">Roberts算子是该点连续梯度的近似值，而不是所预期的在点处的近似值。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">在MATLAB中可以由edge函数实现。其语法格式如下：</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I, ‘roberts’)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I, ‘roberts’,thresh)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">[BW,thresh]=edge(I,’roberts’,…)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I,’roberts’)自动选择阈值用Robert算子进行边缘检测。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I,’roberts’,thresh)根据所指定的敏感度阈值thresh用Roberts算子进行边缘检测，它忽略了所有小于阈值的边缘。当thresh为空时，自动选择阈值。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">[BW,thresh]=edge(I,’roberts’,…)返回阈值。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">edge函数对灰度图像I进行边缘检测，返回与I同样大小的二值图像BW，其中1表示I的边缘，0表示非边缘。I是uint8型、uint16型或double型的，BW是uint8型的。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span></span></p>
<pre><code class="language-plain">clc
close all
clear all
%%%生成高斯平滑滤波模板%%%
%%%%%%%%%%%%%%%%%%%%%%%%%
hg=zeros(3,3); %设定高斯平滑滤波模板的大小为3*3
delta=0.5;
for x=1:1:3
for y=1:1:3
u=x-2;
v=y-2;
hg(x,y)=exp(-(u^2+v^2)/(2*pi*delta^2));
end
end
h=hg/sum(hg(:));
%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%读入图像%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%

f = imread('1111.tif'); % 读入图像文件
f=rgb2gray(im2double(f));
imshow(f)
title('原始图像');
[m,n]=size(f);
ftemp=zeros(m,n);
rowhigh=m-1;
colhigh=n-1;
%%%高斯滤波%%%
for x=2:1:rowhigh-1
for y=2:1:colhigh-1
mod=[f(x-1,y-1) f(x-1,y) f(x-1,y+1); f(x,y-1) f(x,y) f(x,y+1);f(x+1,y-1) f(x+1,y) f(x+1,y+1)];
A=h.*mod;
ftemp(x,y)=sum(A(:));
end
end
f=ftemp
figure,imshow(f)
title('通过高斯滤波器后的图像');

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%利用roberts算子进行边缘检测%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sx=[-1 -2 -1;0 0 0;1 2 1];
sy=[-1 0 1;-2 0 2;-1 0 1];%%%%%你可以替换成其他算子，这里是罗伯特算子

% sx=[-1 -2 -1;0 0 0;1 2 1];
% sy=[-1 0 1;-2 0 2;-1 0 1];这个是Sobel算子，类似的，你可以替换成canny算子等等
for x=2:1:rowhigh-1
for y=2:1:colhigh-1
mod=[f(x-1,y-1) f(x-1,y) f(x-1,y+1); f(x,y-1) f(x,y) f(x,y+1);f(x+1,y-1) f(x+1,y) f(x+1,y+1)];
fsx=sx.*mod;
fsy=sy.*mod;
ftemp(x,y)=sqrt((sum(fsx(:)))^2+(sum(fsy(:)))^2);
end
end
fr=im2uint8(ftemp);
figure,imshow(fr)
title('用roberts算子边缘检测的原始图像');

%%%域值分割%%%
TH1=60; %设定阈值
for x=2:1:rowhigh-1
for y=2:1:colhigh-1
if (fr(x,y)>=TH1)&((fr(x,y-1) <= fr(x,y)) & (fr(x,y) > fr(x,y+1)) )
fr(x,y)=200;
elseif(fr(x,y)>=TH1)&( (fr(x-1,y) <=fr(x,y)) & (fr(x,y) >fr(x+1,y)))
fr(x,y)=200;
else fr(x,y)=50;
end
end
end
figure,imshow(fr)
title('用roberts算子边缘检测并细化后的图像'); </code></pre>

<h4><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">2. Sobel算子</span></span></h4>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">Sobel算子是边缘检测器中最常用的算子之一。采用3×3邻域可以避免在像素之间内插点上计算梯度。考虑如图10-5所示的点周围点的排列。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">edge函数实现的语法格式如下：</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I, ‘sobel’)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I, ‘sobel’,thresh)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge (I, ‘sobel’, thresh,direction)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">[BW, thresh]=edge (I, ‘sobel’…)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I, ‘sobel’)自动选择阈值用Sobel算子进行边缘检测。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I,’sobel’,thresh)根据所指定的敏感度阈值thresh，用Sobel算子进行边缘检测，它忽略了所有小于阈值的边缘。当thresh为空时，自动选择阈值。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge (I, ‘sobel’, thresh,direction)根据所指定的敏感度阈值thresh，在所指定的方向direction上，用Sobel算子进行边缘检测。Direction可取的字符串值为horizontal(水平方向)、vertical(垂直方向)或both(两个方向)。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">[BW, thresh]=edge (I,’sobel’…)返回阈值。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span></span></p>
<pre><code class="language-plain">f=imread('1.jpg');
f=rgb2gray(f);%转化成灰度图
f=im2double(f);%函数im2double 将其值归一化到0～1之间
%使用垂直Sobcl箅子．自动选择阈值
[VSFAT Threshold]=edge(f, 'sobel','vertical'); %边缘探测
figure,imshow(f),title(' 原始图像，');%显示原始图像
figure,imshow(VSFAT),title( '垂直图像边缘检测');
%显示边缘探测图像
%使用水平和垂直Sobel算子，自动选择阈值
SFST=edge(f,'sobel',Threshold);
figure,imshow(SFST),title('水平和垂直图像边缘检测');
%显示边缘探测图像
%使用指定45度角Sobel算子滤波器，指定阂值
s45=[-2 -1 0;-1 0 1;0 1 2];
SFST45=imfilter(f,s45,'replicate');%功能：对任意类型数组或多维图像进行滤波。
SFST45=SFST45>=Threshold;
figure,imshow(SFST45),title('45度角图像边缘检测') ;</code></pre>

<h4><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">3. Prewitt算子</span></span></h4>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">Prewitt于1970年左右提出了Prewitt算子。由上面对Sobel算子的推导，同时也得出了Prewitt算子。Prewitt算子和Sobel算子的方程完全一样，不同的是只是<em>a</em>和<em>b</em>的系数不同。以下是Prewitt的两个算子：</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">edge函数实现的语法格式如下：</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I, ‘prewitt’)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge (I, ‘prewitt’,thresh)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge (I, ‘prewitt’, thresh,direction)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">[BW, thresh]=edge (I,’prewitt’…)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I, ‘prewitt’)自动选择阈值用Prewitt算子进行边缘检测。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I,’prewitt’,thresh)根据所指定的敏感度阈值thresh，用Prewitt算子进行边缘检测，它忽略了所有小于阈值的边缘。当thresh为空时，自动选择阈值。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge (I, ‘prewitt’, thresh,direction)根据所指定的敏感度阈值thresh，在所指定的方向direction上，用Prewitt 算子进行边缘检测。Direction可取的字符串值为horizontal(水平方向)、vertical(垂直方向)或both(两个方向)。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">[BW, thresh]=edge (I, ‘prewitt’…)返回阈值。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span></span></p>
<pre><code class="language-plain">I = imread('1.BMP');

BW1 = edge(I,'prewitt',0.04);             % 0.04为梯度阈值

figure(1);

imshow(I);

figure(2);

imshow(BW1);</code></pre>
<p></p>
<h4><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">4. LOG 算子</span></span></h4>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">它是一个二阶算子，将在边缘处产生一个陡峭的零交叉。拉普拉斯算子是一个线性的、移不变的算子，它的传递函数在频域空间的圆点是零，因此经拉普拉斯滤波过的图像具有零平均灰度。LOG算子先用高斯低通滤波器将图像进行预先平滑，然后用拉普拉斯算子找出图像中的陡峭边缘，最后用零灰度值进行二值化产生闭合的、连通的轮廓，消除了所有内部点。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">edge函数实现的语法格式如下：</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I, ‘log’)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge (I, ‘log’,thresh)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge (I, ‘log’, thresh,sigma)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">[BW, thresh]=edge (I, ‘log’…)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I, ‘log’)自动选择阈值用LOG算子进行边缘检测。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I,’log’,thresh)根据所指定的敏感度阈值thresh，用LOG算子进行边缘检测，它忽略了所有小于阈值的边缘。当thresh为空时，自动选择阈值。当指定thresh为0时，输出图像具有闭合的轮廓，因为其中包含了输入图像中的所有零交叉点。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge (I, ‘log’, thresh,sigma)根据所指定的敏感度阈值thresh和标准偏差sigma，用LOG算子进行边缘检测，默认时sigma等于2，滤波器是n×n维的。其中</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">n=ceil(sigma×3)×2+1</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">[BW, thresh]=edge (I, ‘log’…)返回阈值。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span></span></p>
<pre><code class="language-plain">a = imread('1.png');
sigma=0.15;    %sigma=0.5（参数可以调不<span style="font-family:SimHei;">同的试一下</span>）;
[m,n]=size(a);
e=repmat(logical(uint8(0)),m,n);
rr=2:m-1;
cc=2:n-1;
fsize=ceil(sigma*7)*6+1;   %fsize=ceil(sigma*3)*2+1;
op=fspecial('log',fsize,sigma);
op=op-sum(op(:))/prod(size(op));</code></pre>

<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span></span></p>
<h3><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">5、Canny边缘检测</span></h3>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">Canny算子检测边缘的方法是寻找图像梯度的局部极大值，梯度是用高斯滤波器的导数计算的。Canny方法使用两个阈值来分别检测强边缘和弱边缘，而且仅当弱边缘与强边缘相连时，弱边缘才会包含在输出中。因此，此方法不容易受噪声的干扰，能够检测到真正的弱边缘。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I, ‘canny’)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge (I, ‘canny’,thresh)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge (I, ‘canny’, thresh,sigma)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">[BW, thresh]=edge (I, ‘canny’…)</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I, ‘canny’)自动选择阈值用Canny算子进行边缘检测。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge(I,’canny’,thresh)根据所指定的敏感度阈值thresh，用Canny算子进行边缘检测，thresh是一个含两个元素的矢量，第一个元素是低阈值，第二个元素是高阈值；如果只给thresh指定一个值，则此值作为高阈值，而0.4×thresh作为低阈值；当thresh为空时，自动选择低阈值和高阈值。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">BW=edge (I, ‘canny’, thresh,sigma)根据所指定的敏感度阈值thresh和标准偏差sigma，用Canny算子进行边缘检测，默认时sigma等于1，滤波器的尺寸sigma自动选择。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">[BW, thresh]=edge (I, ‘canny’…)返回含两个元素的阈值矢量。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span></span></p>
<pre><code class="language-plain">function can()

 

    I = imread('un.bmp');
   
    gray = rgb2gray(I);
   
    a = im2single(gray);
   
    [m,n] = size(a);
    % 用于输出的边界位图
    e = false(m,n);
   
    % Magic numbers
    GaussianDieOff = .0001; 
    PercentOfPixelsNotEdges = .7; % 用于阀值选择
    ThresholdRatio = .4;          % 低阀值相对高阀值的比值
    sigma = 1; %设置sigma
    thresh = [];
   
    % 设计滤波器 - a gaussian和它的导数
    pw = 1:30; % possible widths
    ssq = sigma^2;
    width = find(exp(-(pw.*pw)/(2*ssq))>GaussianDieOff,1,'last');%find函数很给力...
    if isempty(width)
    width = 1;  % the user entered a really small sigma
    end
   
    t = (-width:width);
    gau = exp(-(t.*t)/(2*ssq))/(2*pi*ssq);     % 高斯一维滤波
   
    % Find the directional derivative of 2D Gaussian (along X-axis)
    % Since the result is symmetric along X, we can get the derivative along
    % Y-axis simply by transposing the result for X direction.
    [x,y]=meshgrid(-width:width,-width:width);
    dgau2D=-x.*exp(-(x.*x+y.*y)/(2*ssq))/(pi*ssq);%二维高斯方向导数
   
    % Convolve the filters with the image in each direction
    % The canny edge detector first requires convolution with
    % 2D gaussian, and then with the derivitave of a gaussian.
    % Since gaussian filter is separable, for smoothing, we can use
    % two 1D convolutions in order to achieve the effect of convolving
    % with 2D Gaussian.  We convolve along rows and then columns.
   
    %用一阶高斯滤波器平滑图像
    aSmooth=imfilter(a,gau,'conv','replicate');   % run the filter accross rows
    aSmooth=imfilter(aSmooth,gau','conv','replicate'); % and then accross columns
   
    %应用方向导数
    ax = imfilter(aSmooth, dgau2D, 'conv','replicate');
    ay = imfilter(aSmooth, dgau2D', 'conv','replicate');
   
    %计算梯度幅值
    mag = sqrt((ax.*ax) + (ay.*ay));
    magmax = max(mag(:));
    if magmax>0
     mag = mag / magmax;   % normalize
    end
   
    % 选择高低两个阀值,用于双阀值算法检测和连接边缘.
    if isempty(thresh)
     counts=imhist(mag, 64);
     highThresh = find(cumsum(counts) > PercentOfPixelsNotEdges*m*n,...
                   1,'first') / 64;
     lowThresh = ThresholdRatio*highThresh;
     thresh = [lowThresh highThresh];
    elseif length(thresh)==1
     highThresh = thresh;
     if thresh>=1
      eid = sprintf('Images:%s:thresholdMustBeLessThanOne', mfilename);
      msg = 'The threshold must be less than 1.';
      error(eid,'%s',msg);
    end
     lowThresh = ThresholdRatio*thresh;
     thresh = [lowThresh highThresh];
     elseif length(thresh)==2
     lowThresh = thresh(1);
     highThresh = thresh(2);
     if (lowThresh >= highThresh) || (highThresh >= 1)
      eid = sprintf('Images:%s:thresholdOutOfRange', mfilename);
      msg = 'Thresh must be [low high], where low < high < 1.';
      error(eid,'%s',msg);
     end
    end
   
    % The next step is to do the non-maximum supression. 
    % We will accrue indices which specify ON pixels in strong edgemap
    % The array e will become the weak edge map.
    idxStrong = []; 
    for dir = 1:4
      idxLocMax = cannyFindLocalMaxima(dir,ax,ay,mag);
      idxWeak = idxLocMax(mag(idxLocMax) > lowThresh);
      e(idxWeak)=1;
      idxStrong = [idxStrong; idxWeak(mag(idxWeak) > highThresh)];
    end
   
    if ~isempty(idxStrong) % result is all zeros if idxStrong is empty
      rstrong = rem(idxStrong-1, m)+1;
      cstrong = floor((idxStrong-1)/m)+1;
      e = bwselect(e, cstrong, rstrong, 8);
      e = bwmorph(e, 'thin', 1);  % Thin double (or triple) pixel wide contours
    end
    
    imshow(e);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   Local Function : cannyFindLocalMaxima
%
function idxLocMax = cannyFindLocalMaxima(direction,ix,iy,mag)

 [m,n] = size(mag);
 
 % Find the indices of all points whose gradient (specified by the
 % vector (ix,iy)) is going in the direction we're looking at. 
   idx = find((iy<=0 & ix>-iy)  | (iy>=0 & ix<-iy));
 
   % Exclude the exterior pixels
 if ~isempty(idx)
   v = mod(idx,m);
   extIdx = find(v==1 | v==0 | idx<=m | (idx>(n-1)*m));
   idx(extIdx) = [];
 end
 
 ixv = ix(idx); 
 iyv = iy(idx);  
 gradmag = mag(idx);
 
 % Do the linear interpolations for the interior pixels
  d = abs(iyv./ixv);
  gradmag1 = mag(idx+m).*(1-d) + mag(idx+m-1).*d;
  gradmag2 = mag(idx-m).*(1-d) + mag(idx-m+1).*d;
 
 idxLocMax = idx(gradmag>=gradmag1 & gradmag>=gradmag2);</code></pre>

<h3><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">6、</span>Susan边缘检测</span></h3>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">Susan准则用一个圆形模板扫描图像，若模板内其他任意像素的灰度值与模板中心元素(核)的灰度值的差小于一定阈值，就认为该点与核具有相同(或相近)的灰度值，满足这样条件的像素组成的区域称为核值相似区(UnivalueSegment AssimilatingNucle2us，USAN)。把图像中的每个像素与具有相近灰度值的局部区域联系是Susan准则的基础。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">具体检测时，用圆形模板扫描整个图像，比较模板内每一个像素与中心像素的灰度值，并给定阈值来判别该像素是否属于USAN区域。如下式：</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">式中，<em>c</em>(<em>r</em>,<em>r</em><sub>0</sub>)为模板内属于USAN区域的像素的判别函数，<em>I</em>(<em>r</em><sub>0</sub>)是模板中心像素(核)的灰度值，<em>I</em>(<em>r</em>)为模板内其他任意像素的灰度值，<em>t</em>是灰度差门限。它影响检测到角点的个数。<em>t</em>减少，获得图像中更多精细的变化，从而给出相对较多信息，则图像中某一点的USAN区域大小可由下式表示：</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">USAN区域包含了图像局部许多重要的结构信息，它的大小反映了图像局部特征的强度，模板中的白色区域即为USAN区。在平坦区域USAN区最大，如模板e所示；在边缘处USAN 区大小降为一半，如模板b所示；而在角点附近USAN区变得更小，如模板a所示。由此可得到SUSAN 提取边缘和角点算法的基本原理：即在边缘和角点处的USAN 区最小。因此，可根据USAN区的大小和矩阵特性来检测图像边缘与角点等特征的位置和方向信息。当模板完全处于背景或目标中时，USAN区域最大，当模板移向目标边缘时，USAN区域逐渐变小；当模板中心处于角点时，USAN区域很小。得到每个像素对应的USAN区域大小之后，由上式可知，对于3×3大小的模板，USAN区的最大值<em>n</em><sub>max</sub> =8。根据试验分析可知，在实际噪声图像中如果核心点在边缘附近，<em>n</em>的值一般不会大于3<em>n</em><sub>max</sub>/4。因此，定义几何阈值<em>g</em>= 3<em>n</em><sub>max</sub>/4，利用下式产生边缘初始响应：</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">其中，<em>g</em>为几何门限，得到的边缘初始响应值大小符合SUSAN原理，即USAN区域越小，初始边缘响应就越大。</span></span></p>
<pre><code class="language-plain">function image_out =susan(im,threshold)

d = length(size(im));

if d==3

image=double(rgb2gray(im));

elseif d==2

image=double(im);

end

mask = ([ 0 0 1 1 1 0 0 ;0 1 1 1 11 0;1 1 1 1 1 1 1;1 1 1 1 1 1 1;1 1 1 1 1 1 1;0 1 1 1 1 1 0;0 0 1 11 0 0]);

R=zeros(size(image));

nmax = 3*37/4;

[a b]=size(image);

new=zeros(a+7,b+7);

[c d]=size(new);

new(4:c-4,4:d-4)=image;

for i=4:c-4

for j=4:d-4

current_image = new(i-3:i+3,j-3:j+3);

current_masked_image = mask.*current_image;

current_thresholded =susan_threshold(current_masked_image,threshold);

g=sum(current_thresholded(:));

if nmax<g

R(i,j)= g-nmax;

else

R(i,j)= 0;

end

end

end

image_out=R(4:c-4,4:d-4);

//程序

image_in=imread('rice.png');

image = susan(image_in,27);</code></pre>
<h3><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">7、</span>小波边缘检测</span></h3>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">除了以上介绍的边缘检测方法，其实在目前的边缘检测算法的研究过程中，小波技术在边缘检测中也成为一种主要的研究方向。这里简单地介绍一下。</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">基于内容的方法是近来研究的热点，利用小波进行边缘检测也是一种方法，它还可用于特征点的检测，Mexican Hatwavelet尺度交互方法最初由Manjunath等提出。通过识别发生在同一图像不同尺度版本显著强度变化来决定特征点。该方法应用MexicanHat wavelet的两个不同尺度到同一图像并且计算两个尺度图像的尺度交互图像，尺度差图像的局部极值决定了特征点。MexicanHat wavelet，也叫做Marrwavelet，具有旋转不变性，因为它有圆形对称频域响应。位于<em>x</em>的Mexican Hat wavelet定义为</span></span></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def"></span></span></p>
<p align="left"><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"><span data-amp-original-style="color:#000000;" class="amp-wp-9456def">其中尺度差图像由下列式子得到代表尺度为<em>i</em>的Mexican Hatwavelet在位置<em>x</em>的响应。是一个规范常数，代表不同尺度<em>i</em>和<em>j</em>的尺度差，的局部极值就决定了潜在的特征点集。这些点中强度超过一定阈值的就被认为是特征点。</span></span></p>
<pre><code class="language-plain">clear all;
load wbarb; %小波变换边缘提取程序
I = ind2gray(X,map);%检索图转成灰度图
imshow(I);
I1 = imadjust(I,stretchlim(I),[0,1]);%调整图像的像素值，可以改变对比度和颜色
figure;
imshow(I1);
[N,M] = size(I);
h = [0.125,0.375,0.375,0.125];
g = [0.5,-0.5];
delta = [1,0,0];
J = 3;
a(1:N,1:M,1,1:J+1) = 0;
dx(1:N,1:M,1,1:J+1) = 0;
dy(1:N,1:M,1,1:J+1) = 0;
d(1:N,1:M,1,1:J+1) = 0;
a(:,:,1,1) = conv2(h,h,I,'same'); %二维卷积
dx(:,:,1,1) = conv2(delta,g,I,'same');
dy(:,:,1,1) = conv2(g,delta,I,'same');
x = dx(:,:,1,1);
y = dy(:,:,1,1);
d(:,:,1,1) = sqrt(x.^2+y.^2);
I1 = imadjust(d(:,:,1,1),stretchlim(d(:,:,1,1)),[0 1]);figure;imshow(I1);
lh = length(h);
lg = length(g);
for j = 1:J+1
lhj = 2^j*(lh-1)+1;
lgj = 2^j*(lg-1)+1;
hj(1:lhj)=0;
gj(1:lgj)=0;
for n = 1:lh
hj(2^j*(n-1)+1)=h(n);
end
for n = 1:lg
gj(2^j*(n-1)+1)=g(n);
end
a(:,:,1,j+1) = conv2(hj,hj,a(:,:,1,j),'same');
dx(:,:,1,j+1) = conv2(delta,gj,a(:,:,1,j),'same');
dy(:,:,1,j+1) = conv2(gj,delta,a(:,:,1,j),'same');
x = dx(:,:,1,j+1);
y = dy(:,:,1,j+1);
dj(:,:,1,j+1) = sqrt(x.^2+y.^2);
I1 = imadjust(dj(:,:,1,j+1),stretchlim(dj(:,:,1,j+1)),[0 1]);figure;imshow(I1);
end</code></pre>
<p></p>
<p><span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978">8、用水线阈值法分割图像</span></p>

<pre><code class="language-plain">m = imread('afmsurf.tif');figure, imshow(afm);

se = strel('disk', 15);

Itop = imtophat(afm, se); % 高帽变换

Ibot = imbothat(afm, se); % 低帽变换

figure, imshow(Itop, []);   % 高帽变换，体现原始图像的灰度峰值

figure, imshow(Ibot, []);   % 低帽变换，体现原始图像的灰度谷值

Ienhance = imsubtract(imadd(Itop, afm), Ibot);% 高帽图像与低帽图像相减，增强图像

figure, imshow(Ienhance);

Iec = imcomplement(Ienhance); % 进一步增强图像

Iemin = imextendedmin(Iec, 20); figure,imshow(Iemin) % 搜索Iec中的谷值

Iimpose = imimposemin(Iec, Iemin);

wat = watershed(Iimpose); % 分水岭分割

rgb = label2rgb(wat); figure, imshow(rgb); % 用不同的颜色表示分割出的不同区域</code></pre>
<p>   <span data-amp-original-style="font-family:SimHei;font-size:14px;" class="amp-wp-b6ce978"></span> </p>
</blockquote></div>
</div>
	</div>

	<footer class="amp-wp-article-footer">
			<div class="amp-wp-meta amp-wp-tax-category">
		Categories: <a href="https://uzzz.org/category/tuxiangchuli/" rel="category tag">图像处理</a>, <a href="https://uzzz.org/category/jiqixuexi/" rel="category tag">机器学习</a>	</div>

	</footer>
</article>

<footer class="amp-wp-footer">
	<div>
		<h2>有组织在!</h2>
		<a href="#top" class="back-to-top">Back to top</a>
	</div>
</footer>




</body></html>
