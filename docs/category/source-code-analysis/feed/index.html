<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Source Code Analysis &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/category/source-code-analysis/feed" rel="self" type="application/rss+xml" />
	<link>https://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Tue, 25 Jun 2013 13:31:26 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>Source Code Analysis &#8211; 有组织在!</title>
	<link>https://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Tor源码分析十一 &#8212; 客户端执行流程（网络信息的下载续）</title>
		<link>https://uzzz.org/article/1066.html</link>
				<pubDate>Tue, 25 Jun 2013 13:31:26 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Source Code Analysis]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1066.html</guid>
				<description><![CDATA[　　通过上一节中我们对连接和链路的重新描述，我们可以继续进行源码的分析了。在本节中，我们会开始着重讲述链路的建立，以及链路所基于的OR连接的建立，同时还有部分Libevent调度的再度分析。大家会明白，进行到此处之时，我们已经开始接触Tor系统最底层，最深藏着的连接机制以及调度机制。这个部分，是整个系统的精髓。后期几乎所有的应用请求连接处理等，都是重复地使用]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>　　通过上一节中我们对连接和链路的重新描述，我们可以继续进行源码的分析了。在本节中，我们会开始着重讲述链路的建立，以及链路所基于的OR连接的建立，同时还有部分Libevent调度的再度分析。大家会明白，进行到此处之时，我们已经开始接触Tor系统最底层，最深藏着的连接机制以及调度机制。这个部分，是整个系统的精髓。后期几乎所有的应用请求连接处理等，都是重复地使用该部分的代码。</p>
<p></p>
<h2>1. 链路建立以及OR连接的开始，circuit_establish_circuit</h2>
<p>　　我们在此处重新分析下链路建立的函数：</p>
<pre><code class="language-cpp">/** Build a new circuit for &lt;b&gt;purpose&lt;/b&gt;. If &lt;b&gt;exit&lt;/b&gt;
 * is defined, then use that as your exit router, else choose a suitable
 * exit node.
 *
 * Also launch a connection to the first OR in the chosen path, if
 * it's not open already.
 */
origin_circuit_t *
circuit_establish_circuit(uint8_t purpose, extend_info_t *exit, int flags)
{
  origin_circuit_t *circ;
  int err_reason = 0;

  circ = origin_circuit_init(purpose, flags); //链路初始化；

  if (onion_pick_cpath_exit(circ, exit) &lt; 0 || //选取链路出口结点；
      onion_populate_cpath(circ) &lt; 0) { //选取链路入口结点及中间结点；
      ......
  }

 &nbsp;if ((err_reason = circuit_handle_first_hop(circ)) &lt; 0) { //开始向链路第一个结点发送建立OR连接的请求；（OR连接建立于TLS连接之上）
  ......
  }
  return circ;
}</code></pre>
<p>　　像之前我们所描述的那样，函数内部主用做的工作包括三点：初始化链路结构体；选择链路结点；建立到链路中第一个结点的连接。此处需要说明的是，初始化链路结构体和选择链路结点的操作均是简单的。所以我们在接下来的分析中，不再详细追究这两个部分操作的具体细则，而是将我们的重心放在链路建立的实际操作部分。如果对选择结点部分有疑问，可以细细分析上述的两个结点选择函数，相信在其中可以找到结点选择策略和相关机制。但是，结点如何选择并不是程序执行流程的重点，所以我们接下来还是要着重分析函数：circuit_handle_first_hop。 </p>
<p></p>
<h2>2. OR连接建立以及链路拓展，circuit_handle_first_hop</h2>
<p>　　在客户端完成链路的初始化和链路中结点的选择之后，即将开始建立到第一个链路结点的OR连接。但是这个时候还有个复用的问题，也就是我们前面提到过的多条链路可以共享一个OR连接的情况。试想一下，当一条链路选择完所有链路中的结点，此时它要向第一个链路结点发送OR连接的请求。如果客户端主机到选中的结点主机已经存在一条OR连接，是否需要重新相连呢？显然，没有必要。所以我们可以在一条OR连接上复用多条链路。于是我们将会看到代码中出现判断是否已经存在可用OR连接的部分操作。接下来我们直接看代码：</p>
<pre><code class="language-cpp">/** Start establishing the first hop of our circuit. Figure out what
 * OR we should connect to, and if necessary start the connection to
 * it. If we're already connected, then send the 'create' cell.
 * Return 0 for ok, -reason if circ should be marked-for-close. */
int
circuit_handle_first_hop(origin_circuit_t *circ)
{
  ......

  firsthop = onion_next_hop_in_cpath(circ-&gt;cpath); //按序选中链路中第一个未标记为打开的结点；在该函数中，实际上每次选中的都是链路入口结点；

  n_conn = connection_or_get_for_extend(firsthop-&gt;extend_info-&gt;identity_digest, //获得可以复用的OR连接；
                                        &amp;firsthop-&gt;extend_info-&gt;addr,
                                        &amp;msg,
                                        &amp;should_launch);

  if (!n_conn) { /* not currently connected in a useful way. */ //如果没有可以复用的OR连接，则重新建立到首结点的OR连接；
    circ-&gt;_base.n_hop = extend_info_dup(firsthop-&gt;extend_info);

    if (should_launch) {  //建立到首结点的OR连接执行函数：connection_or_connect
      n_conn = connection_or_connect(&amp;firsthop-&gt;extend_info-&gt;addr,
                                     firsthop-&gt;extend_info-&gt;port,
                                     firsthop-&gt;extend_info-&gt;identity_digest);
    }
    return 0;
  } else { /* it's already open. use it. */ //如果有可以复用的OR连接，则发送create包以告知远端结点开启一条新的链路；
    circ-&gt;_base.n_conn = n_conn;
    if ((err_reason = circuit_send_next_onion_skin(circ)) &lt; 0) {
      ......
    }
  }
  return 0;
}
</code></pre>
<p>　　我们可以理解，复用与否，是针对链路首节点的OR连接而言的。对于其他结点，本地客户端是不直接与他们进行OR层次上的沟通的，而是通过链路拓展来进行交流。所以，针对第一个结点，本地客户端既要实现OR层次的互联，又要完成链路层次的交流，就是发送create包以告知链路的开启。针对其他结点，本地客户端只是通过向第一个结点发送链路层的命令包，以实现链路层面上的沟通。 </p>
<p>　　从上述函数我们可以看到两个关键分支：向第一个结点发起OR连接请求的分支；复用OR连接，直接向第一个结点发起新链路开启命令的分支。我们这里按照系统的常规流程，先分析系统中一个OR连接都没有的情况。也就是说，我们此处默认系统中没有满足链路要求的OR连接，那么程序需要开始建立从本地到链路首结点的OR连接。</p>
<p></p>
<h2>3. OR连接建立的细节</h2>
<p>　　OR连接的建立是基于TLS连接的基础之上的，所以要想真正建立可用的OR连接，需要完成TLS握手。但是，握手过程需要通信双方经过数轮交换，很显然在一个函数中等待握手结束是极低效的。OR连接建立的细节部分，我们要将关注的重点放在系统是如何设计非阻塞式的TLS握手过程，从而实现高效运行。以下为代码分析：</p>
<pre><code class="language-cpp">/** Launch a new OR connection to &lt;b&gt;addr&lt;/b&gt;:&lt;b&gt;port&lt;/b&gt; and expect to
 * handshake with an OR with identity digest &lt;b&gt;id_digest&lt;/b&gt;.
 *
 * If &lt;b&gt;id_digest&lt;/b&gt; is me, do nothing. If we're already connected to it,
 * return that connection. If the connect() is in progress, set the
 * new conn's state to 'connecting' and return it. If connect() succeeds,
 * call connection_tls_start_handshake() on it.
 *
 * This function is called from router_retry_connections(), for
 * ORs connecting to ORs, and circuit_establish_circuit(), for
 * OPs connecting to ORs. //此处的注释可以说明本函数的重要性；
 *
 * Return the launched conn, or NULL if it failed.
 */
or_connection_t *
connection_or_connect(const tor_addr_t *_addr, uint16_t port,
                      const char *id_digest)
{
  ......

  conn = or_connection_new(tor_addr_family(&amp;addr));

  /* set up conn so it's got all the data we need to remember */
  connection_or_init_conn_from_address(conn, &amp;addr, port, id_digest, 1);
  conn-&gt;_base.state = OR_CONN_STATE_CONNECTING;
  conn-&gt;is_outgoing = 1;

  /* If we are using a proxy server, find it and use it. */
  r = get_proxy_addrport(&amp;proxy_addr, &amp;proxy_port, &amp;proxy_type, TO_CONN(conn));
  if (r == 0) { //不使用代理；
    ......
  } else {      //使用代理
    ......//这个部分牵涉到代理的操作，暂时略去，后期会有代理和Bridge专题；
  }

  switch (connection_connect(TO_CONN(conn), conn-&gt;_base.address, //OR连接socket层次的建立操作；
                             &amp;addr, port, &amp;socket_error)) {
    case -1://建立失败
      /* If the connection failed immediately, and we're using
       * a proxy, our proxy is down. Don't blame the Tor server. */
      ......
      return NULL;
    case 0://建立进行中，此情况为一般情况；
      connection_watch_events(TO_CONN(conn), READ_EVENT | WRITE_EVENT); //将OR连接的读写事件加入Libevent事件监听队列；
      return conn;
    /* case 1: fall through *///建立完成，如果socket连接能够非常迅速地建立，则直接进入TLS握手阶段；
  }

  //此处开始TLS握手阶段，本函数中只有上述socket连接非常迅速地成功完成连接才会执行到此处；
  if (connection_or_finished_connecting(conn) &lt; 0) {
    /* already marked for close */
    return NULL;
  }
  return conn;
}</code></pre>
<p>　　上述函数中，最重要的部分就是函数connetion_connect。该函数的作用是进行socket的建立，但是建立的结果因为进行的是非阻塞式的，所以会有三种结果：建立失败-1，正在建立中0，建立完成1。因为socket连接是非阻塞的，所以正在建立中和建立已完成两种情况均有可能出现。若建立完成，则可以直接开始TLS的握手连接；若建立正在进行中，则需要将连接加入Libevent的事件监听列表，以进行监听和后续操作。实际上，这个部分的重点，就是在连接无法马上完成之时的操作：将正在建立中的连接加入到Libevent事件监听队列。此处，我们就隐约感觉到了Tor系统是如何处理需要一定时间才能完成的连接建立操作的。实际上，Tor系统甚至将连接建立的过程都用Libevent事件调度系统来进行调度。当非阻塞的连接建立过程返回时并未完成连接建立操作，则系统将这样的连接加入到Libevent事件池中，下次事件主循环开始时发现该连接可以被操作，则继续该连接的建立和握手操作等。 </p>
<p></p>
<p>　　介绍到此处，我们将OR连接的建立过程介绍完毕。在这个过程中，最重要的部分，就是对于socket连接建立返回值的处理。此时大家可能还没有见到如何对Libevent事件队列中被激活事件进行处理的主要过程，在后面的文章中，我们会再进入主循环的事件处理分析。实际上，就是对读写函数的分析：</p>
<p>　　1, conn_write_callback;</p>
<p>　　2, conn_read_callback;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Tor源码分析十 &#8212; 连接和链路</title>
		<link>https://uzzz.org/article/1071.html</link>
				<pubDate>Fri, 21 Jun 2013 14:01:00 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Source Code Analysis]]></category>
		<category><![CDATA[c]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[tor]]></category>
		<category><![CDATA[网络]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1071.html</guid>
				<description><![CDATA[　　源码分析到这个部分，为了让大家明白源码中的编码逻辑，不得不开始从头梳理程序内部的复杂连接和链接组织形式。否则大家后期会更加一头雾水。笔者开始分析源码之时，没有这些宏观的概念，只能死嚼代码，硬猜硬想，再加以检查代码进行验证，才得以明白程序的主要框架逻辑。如果再以猜测验证的模式向大家讲述源码，必定会越来越混乱。所以，在本节之中，我们会将系统中所有的连接类型，]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>　　源码分析到这个部分，为了让大家明白源码中的编码逻辑，不得不开始从头梳理程序内部的复杂连接和链接组织形式。否则大家后期会更加一头雾水。笔者开始分析源码之时，没有这些宏观的概念，只能死嚼代码，硬猜硬想，再加以检查代码进行验证，才得以明白程序的主要框架逻辑。如果再以猜测验证的模式向大家讲述源码，必定会越来越混乱。所以，在本节之中，我们会将系统中所有的连接类型，链路类型和他们之间的关系和代码之中的关联方式尽量讲明。若大家遇到不明晰的部分，可以参照代码进行查阅。</p>
<p>　　在我们进行详细分析之前，先再次给出连接和链接的框架位置图。这个简单的层次图帮助我们理解不同连接和链接所处层次的位置关系，其实已经在我们分析OR连接源码之时给出，之时当时没有进行过多的深入介绍。</p>
</p>
<p>　　　　　　　　　　　　　　　　DIR连接，LISTENER连接　　　　　　　　　　　　　　&nbsp;&nbsp;&nbsp; |</p>
<p>　　　　　　　　　　　　　　－－－－－－－－－－－－－－－－－　　　　　　　　　　　&nbsp;&nbsp; |</p>
<p>　　　　　　　　　　　　　　　　AP连接，EXIT连接……　　　　　　　 Tor协议上层&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>
<p>　　　　　　　　　　　　　　－－－－－－－－－－－－－－－－－－－－－－－－－－－－&nbsp;&nbsp; |　　应用层</p>
<p>　　　　　　　　　　　　　　　　Circuit链路……　　　　　　　　　　　Tor协议中层&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>
<p>　　　　　　　　　　　　　　－－－－－－－－－－－－－－－－－－－－－－－－－－－－&nbsp;&nbsp; |</p>
<p>　　　　　　　　　　　　　　　　OR连接……　　　　　　　　　　　&nbsp;&nbsp;&nbsp;&nbsp; Tor协议下层&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>
<p>　　　　　　　　　　　　　　－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<p>　　　　　　　　　　　　　　　　TLS连接　　　　　　　　　　　　　　传输层</p>
<p></p>
<h2>1. 连接</h2>
<p>　　很明显，系统中的连接类型多种多样，各有各自的不同职能。在此处，我们先罗列出所有系统中存在的连接，其后再对一些我们比较重视的连接类型进行相关说明。</p>
<pre><code class="language-cpp">//OR监听连接：本地用于监听远端传来的OR请求，为每个新请求建立一个OR连接；OR监听连接本地全局只有一个；
#define CONN_TYPE_OR_LISTENER 3
//OR连接：基于TLS连接的，主要负责Tor系统内主机之间相互通信的连接；OR连接数量表征本地与多少台主机建立了互联关系，因为他们是一一对应的；
#define CONN_TYPE_OR 4
//EXIT连接：翻译为出口连接是因为该连接会与远端服务器建立socket连接并传递数据；
#define CONN_TYPE_EXIT 5
//AP监听连接：本地用于监听本地应用程序的服务请求而设立的监听连接，为每个服务请求建立一个AP连接；AP监听连接本地全局只有一个；
#define CONN_TYPE_AP_LISTENER 6
//AP连接：基于链路的，主要负责为客户端请求寻找合适链路和传递数据；AP连接数量表征本地应用程序发出的连接请求数量，因为他们是一一对应的；
#define CONN_TYPE_AP 7
//DIR监听连接：Tor系统目录服务器用于监听Tor系统内主机发出的目录相关请求，也就是说该类型连接只在目录服务器上存在；
#define CONN_TYPE_DIR_LISTENER 8
//DIR连接：Tor客户端向Tor目录服务器发送目录请求时需要新建的连接，该连接需要通过AP连接为其转发请求，也就是说类似于普通应用程序的请求连接；
#define CONN_TYPE_DIR 9
//CPUWORKER连接：用于在程序开启多进程解密服务的时候提供进程间通信，详细过程可以参看前面分析过的cpuworker部分文章；正常情况下未被使用；
#define CONN_TYPE_CPUWORKER 10
//CONTROL监听连接：本地用于监听本地应用程序传递的控制指令或请求；（后期专门讲述，此处暂略）
#define CONN_TYPE_CONTROL_LISTENER 11
//CONTROL连接：本地用于控制消息处理的连接；（后期专门讲述，此处暂略）
#define CONN_TYPE_CONTROL 12
//以下三种连接由于非常少见，此处我们暂时略去；
#define CONN_TYPE_AP_TRANS_LISTENER 13
#define CONN_TYPE_AP_NATD_LISTENER 14
#define CONN_TYPE_AP_DNS_LISTENER 15
</code></pre>
<p>　　很明显地，通过分析上面这些连接类型我们发现，对于客户端而言，最重要的连接类型无非就是DIR,AP,OR三种连接。这些连接之间的相互关联和作用帮助客户端应用程序将应用请求送入Tor系统，并再通过Tor系统的封装等操作将数据成功送出到远端目的地。下面我们来简要描述下整个系统运转的过程。 </p>
<h3>　　1. 应用请求的发送</h3>
<p>　　　　应用程序在想要使用Tor程序提供的匿名服务之时，需要通过Tor客户端程序进行数据发送的代理。这里我们使用最简单的浏览器作为例子。当浏览器想要实现匿名浏览网页时，就要修改其代理服务配置，通过本机的代理进行请求的发送。一般情况下，我们知道，此时代理会被设置为IP:Port。而这里所选用的IP和端口号，就是Tor程序配置文件内部所写入的监听应用程序请求的IP和端口号。在配置文件中，配置它们的参数名为SocksListenAddress与SocksPort。</p>
<p>　　　　显然，这里的IP和端口号意味着Tor程序一定会开启监听连接来对该地址该端口进行持续监听。而执行此处监听的连接类型，就是AP监听连接。</p>
<p>　　　　如果观察仔细，我们还会在默认配置文件之中注意到配置参数ControlPort。该参数指定Tor程序监听的控制端口号。同理，我们可以知道Tor程序一定会开启监听连接监听控制端口接收到的请求。而执行此监听的连接类型，就是CONTROL监听连接。</p>
<p>　　　　通过以上的描述，我们知道为什么AP监听连接和CONTROL监听连接全局只能有一个。因为他们无非就是基于本地地址的socket监听连接，只需要各有一个。并且我们也可以知道，就像服务器接收连接获得socket一样，Tor程序也会获得每个监听到的请求所相对应的socket连接。对这些连接的封装就形成了AP连接和CONTROL连接。</p>
<h3>　　2. 应用请求的处理</h3>
<p>　　　　应用请求的发送是通过本地socket进行的操作。如果大家对socket编程不陌生的话，想必在上述部分描述完之后，已经不会再有疑问。现在的问题是，获得了AP连接之后，数据向哪里转发，如何转发。此时我们假设AP连接已经收到了应用程序发送而来的数据，它需要将这些数据通过Tor系统匿名地发送出去。那么此时，我们就要问，Tor系统的消息是如何传递的呢？回顾Tor的论文，Tor的技术文档，Tor的相关介绍，我们能回忆起Tor系统的流复用机制，链路复用机制。相关框架如下：</p>
<p>　　　　　　　　　　　　　　　AP Stream 1 &nbsp;&nbsp; &lt;&#8211;&gt;</p>
<p>　　　　　　　　　　　　　　　AP Stream 2 &nbsp;&nbsp; &lt;&#8211;&gt; &nbsp;&nbsp; Circuit 1&nbsp; &lt;-&gt;</p>
<p>　　　　　　　　　　　　　　　AP Stream 3&nbsp; &nbsp; &lt;&#8211;&gt;</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　&nbsp;&nbsp;&nbsp;&nbsp; Circuit 2 &nbsp; &lt;-&gt;&nbsp;&nbsp;&nbsp; Local OR Connection&nbsp; &lt;=====&gt;&nbsp; Remote OR Connection</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　&nbsp;&nbsp;&nbsp;&nbsp; Circuit 3 &nbsp; &lt;-&gt;</p>
<p> 　　　　多个AP连接对应的AP流复用同一条链路；多条链路，复用同一个OR连接。是的，系统就是这样设计的。但是，我们想知道的是这样的设计对于代码而言意味着什么，对于程序员而言，需要关心的又是什么。我们先从每个部分所代表的宏观含义开始说起。 </p>
<p>　　　　AP Stream：AP连接接收到应用程序请求之后形成的数据流，该数据流向是可以双向的。也就是说，这是一个应用程序的一次数据请求，例如浏览器上一张网页内的一次数据请求。对于程序员而言，这就意味着AP连接需要有读写缓冲区以临时存放数据，并随时准备发出数据。重要的是，流的建立基于链路的建立。</p>
<p>　　　　Circuit：Tor系统链路。链路一般情况下是由三个洋葱路由组成，形成Tor网络中的一条私有通道。整条通道的完整路径只有客户端自己知道，因为链路内的所有路由结点，均是由客户端挑选而来的。链路中的结点，只知道其前驱和后继结点，而不知道其他任何结点，这样就保障了系统的匿名性。对程序员而言，链路的建立一定需要选择三个链路结点，向第一个结点发送链路建立请求，之后通过向第一个结点发送链路拓展请求建立整条链路。而链路请求的发送，基于OR连接的建立。</p>
<p>　　　　OR Connection：Tor系统内两主机之间形成的保密连接，建立于TLS连接之上。</p>
<p>　　　　上述三者描述完之后，我们就更加希望知道，这三者所对应的代码的对应内容以及他们之间是如何交互，如何交互数据的。那么，此时我们就需要用到在前边的章节之中已经出现过的<a href="http://blog.csdn.net/winscar/article/details/8909958" rel="nofollow" data-token="3e75aa3b0145ccc1047c9b9f68df6178">系统框图</a>。大家此时再回顾整个系统框图，应该会有豁然开朗的感觉了。系统框图的详细说明，此处就不再展开，代码细节过于繁多。要往细节里描述的内容太过繁杂，以至于笔者都没有信心往下写，所以代码还是期待大家自己一点点看完吧。</p>
<p>　　　　但是我们的问题还没有完全说清，所以此处再重新描述一遍请求的处理过程。实际上，在应用程序请求传进Tor程序之后，只是暂存在AP连接的缓冲区之内。AP连接需要找到合适的链接以发送数据，所以需要选择现有链接中的最优一条或者新建一条链接。这就是为什么我们在前面的分析之中会出现类似的代码逻辑的原因。此处，我们更关心在没有链接的情况下，是如何新建链接的。事实上在链接未完成建立之前，应用程序请求数据一直呆在AP连接的缓冲区内部。而在此期间，链路开始建立。链路建立的首要工作，就是选择三个结点，之后是向第一个结点发送OR连接请求，最后再从高层建立整个链路。有了这样的基本思路，我们便可以开始链路建立基本过程的代码分析了。</p>
<p></p>
<h2>2. 链路</h2>
<p>　　在分析代码之前，我们还想再次详细地描述链路的相关内容。因为链路似乎是整个Tor系统的核心。不论从链路结点的选择，链路的加密的过程，链路建立的协议等任何一方面来说，我们都没有详细地深入探讨过是如何在代码中成功实现的。在这里，我们仅仅针对链路的加密的过程做一些描述，不再对结点选择和协议深入讲解。因为结点选择策略对程序的执行流程而言，并未起到关键的作用；协议的内容，我们也已经在前面的握手协议部分做过详细讲解。</p>
<p>　　那么，链路的存在，是如何实现洋葱路由式的加密呢？该问题也能陈述为，链路对层层加密和层层解密的相关操作是如何简便地实现的？在这里我们分情况讨论，首先我们讨论链路为原始链路的情况，也就是说先讨论由客户端持有的链路结构体origin_circuit。</p>
<p>　　在原始链路的结构体中，我们发现了这样一个成员变量：crypt_path_t *cpath。通过分析这个成员变量，我们发现他形成了一个双向链表。为了说明清晰，我们将该结构体的代码贴于此处：</p>
<pre><code class="language-cpp">/** Holds accounting information for a single step in the layered encryption
 * performed by a circuit. Used only at the client edge of a circuit. */
//从注释可以看出，这个结构体，只有在客户端上的链路结构体才会使用，也就是说只有origin_circuit用到了他；
//而目的，我们在此时已然可以猜到：维护链路结点双向链表，存储所有结点相关的加解密，摘要，流量控制，简要身份信息等；
//以上说到的相关信息，均可以在结构体中找到对应项：
typedef struct crypt_path_t {
  uint32_t magic; //唯一标识码；

  /* crypto environments */
  //远离客户端为后向，接近客户端为前向；
 &nbsp;/** Encryption key and counter for cells heading towards the OR at this step. */
  //前向加密资料，包括密钥，IV等信息；（尾节点无后向加密资料-forward）
 &nbsp;crypto_cipher_t *f_crypto;
  /** Encryption key and counter for cells heading back from the OR at this step. */
  //后向加密资料，包括密钥，IV等信息；（首节点无前向加密资料-backward）
 &nbsp;crypto_cipher_t *b_crypto;

  /** Digest state for cells heading towards the OR at this step. */
  //前向摘要资料，哈希算法和状态等；
 &nbsp;crypto_digest_t *f_digest; /* for integrity checking */
  /** Digest state for cells heading away from the OR at this step. */
  //后向摘要资料，哈希算法和状态等；
 &nbsp;crypto_digest_t *b_digest;

  /** Current state of Diffie-Hellman key negotiation with the OR at this step. */
  //客户端与该节点的DH密钥协商状态；
 &nbsp;crypto_dh_t *dh_handshake_state;
  
  ......

  /** Information to extend to the OR at this step. */
  //该节点的相关信息；
 &nbsp;extend_info_t *extend_info;

  /** Is the circuit built to this step?  Must be one of:
   *    - CPATH_STATE_CLOSED (The circuit has not been extended to this step)
   *    - CPATH_STATE_AWAITING_KEYS (We have sent an EXTEND/CREATE to this step
   *      and not received an EXTENDED/CREATED)
   *    - CPATH_STATE_OPEN (The circuit has been extended to this step) */
  //当前该节点在链路中的状态；
 &nbsp;uint8_t state;
#define CPATH_STATE_CLOSED 0
#define CPATH_STATE_AWAITING_KEYS 1
#define CPATH_STATE_OPEN 2

  //该节点在链路中的下一个节点的对应结构体；
 &nbsp;struct crypt_path_t *next; /**&lt; Link to next crypt_path_t in the circuit.
                              * (The list is circular, so the last node
                              * links to the first.) */
  //该节点在链路中的上一个节点的对应结构体；
 &nbsp;struct crypt_path_t *prev; /**&lt; Link to previous crypt_path_t in the
                              * circuit. */

  //客户端用于针对该节点的流量控制，写控制；
  int package_window; /**&lt; How many cells are we allowed to originate ending
                       * at this step? */
  //客户端用于针对该节点的流量控制，读控制；
 &nbsp;int deliver_window; /**&lt; How many cells are we willing to deliver originating
                       * at this step? */
} crypt_path_t;
</code></pre>
<p>　　有了上面这个接头体，客户端的Tor程序就可以很随意的组织链路，控制加解密，摘要等。后面的链路操作代码也变得相对容易看懂了。这就是原始链路的情况，下面我们简要说明中间链路的情况。实际上，中间链路的结构体名为or_circuit。所谓的中间链路的结构体，指的是在链路的中间结点或末尾结点上所使用的链路结构体。该链路结构体，不需要知道链路的完整信息，而只要知道本节点到前后两结点的密码环境和摘要环境即可。因为说到底，中间链路的结构体，只不过是起到转发的作用，不需要过多的信息。这里所说的一切，均可以在代码中窥见端倪，请大家有兴趣的话查阅代码，自行体会。 </p>
<p>　　自此大家应该能自行回答关于详细在链路中洋葱式加解密的问题。当链路建立完成，客户端中所有的crypt_path_t结构体都会被成功填充，也就拥有了与每个节点之间共享的前后向密钥。消息传出时，客户端先按照从近及远的次序用各结点后向密钥层层加密消息，然后发出。发送出去的消息经过层层后向密钥解密，最终会在最后一个节点被完全解密，送出链路。消息传回时，每个经过的结点利用前向密钥加密，到达客户端之后，客户端按照从近及远的次序用各节点前向密钥层层解密消息，最终得到传回的消息。这个过程，也就是大家所熟悉的洋葱加解密过程了。</p>
<p>　　讲完这个部分，大家阅读代码时候所遇到的关于加解密的部分，应该就不会再困惑。接下去的章节中，我们就要继续分析代码，接着讲客户端的执行流程分析完毕。</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Tor源码分析九 &#8212; 客户端执行流程（网络信息的下载）</title>
		<link>https://uzzz.org/article/1064.html</link>
				<pubDate>Tue, 28 May 2013 06:58:24 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Source Code Analysis]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1064.html</guid>
				<description><![CDATA[　　源码分析到这里，大家应该已经大致了解到Tor系统的前期启动没有做任何的下载操作。前期启动的最关键环节，就是正常开启Libevent的调度机制，从而有条不紊地进行系统内所有子模块的维护等。我们需要再次强调的是，系统的主进程内，是没有做任何直接的获取网络状态，获取路由描述符，获取额外路由信息的操作。系统将这些操作视为需要实时维护的工作，因为所有这些网络信息都]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>　　源码分析到这里，大家应该已经大致了解到Tor系统的前期启动没有做任何的下载操作。前期启动的最关键环节，就是正常开启Libevent的调度机制，从而有条不紊地进行系统内所有子模块的维护等。我们需要再次强调的是，系统的主进程内，是没有做任何直接的获取网络状态，获取路由描述符，获取额外路由信息的操作。系统将这些操作视为需要实时维护的工作，因为所有这些网络信息都有其时限。所以，对这些网络信息的获取，全部置于秒回调函数之后进行。秒回调函数能够控制对这些信息的检测和获取，这些在前一节中已经有部分描述。</p>
<p>　　我们将在本文中再次重申秒回调函数中最重要的执行线路，以弄清Tor系统是如何获取网络信息，从而开启链路以至于完成整个系统的成功建立。由于本文中所提到的许多函数嵌套层次非常之多，我们只针对最重要的函数加以说明；同时，我们会略去许多不被执行的函数。这些不被执行的函数，大多情况下是因为执行条件不满足而未能够通过函数内部执行前检测，或更甚者未能通过函数外部的判断语句检测。关于这些情况，请大家自行查看函数细节，此处就不再一个一个详细解释。</p>
<p></p>
<h2>1. update_networkstatus_downloads</h2>
<p>　　前面介绍的秒回调函数之中最重要的维护函数即为事件调度函数。事件调度函数中，大部分的内容由于与时间相关而不会在短期内执行。具体的执行间隔可以参照之前章节中源码的注释。在简要的对该函数进行分析之后，我们发现，客户端系统刚刚启动之时，最终重点调用的代码如下：</p>
<pre><code class="language-cpp">static void
run_scheduled_events(time_t now)
{
  ......
 &nbsp;/* 2b. Once per minute, regenerate and upload the descriptor if the old
   * one is inaccurate. */
  ......

&nbsp; if (time_to_check_descriptor &lt; now &amp;&amp; !options-&gt;DisableNetwork) {  //每一分钟进行一次网络状态的下载检测
&nbsp;&nbsp;&nbsp; ......
&nbsp;&nbsp;&nbsp; time_to_check_descriptor = now + CHECK_DESCRIPTOR_INTERVAL;
    ......

    /* Also, once per minute, check whether we want to download any
     * networkstatus documents.
     */
    update_networkstatus_downloads(now);  //开启网络状态的下载
  }
  ......
} 
</code></pre>
<p>　　以下为网络状态下载函数的函数体：</p>
<pre><code class="language-cpp">/** Launch requests for networkstatus documents and authority certificates as
 * appropriate. */
void
update_networkstatus_downloads(time_t now)
{
  const or_options_t *options = get_options();
  if (should_delay_dir_fetches(options))  //使用Bridge的情况下，若不知道任何可用Bridge的信息，则延迟下载
    return;
  if (authdir_mode_any_main(options) || options-&gt;FetchV2Networkstatus)  //权威服务器适当地下载V2网络状态信息，客户端不需要
    update_v2_networkstatus_cache_downloads(now);
  update_consensus_networkstatus_downloads(now);  //首先下载网络共识
  update_certificate_downloads(now);  //其次下载权威服务器证书，没有需要验证的网络共识之前不会执行
}</code></pre>
<p>　　依据这样的执行流程，系统开始进入网络共识的下载。值得说明的是，开启了第一次下载之后，当下一次秒回调函数重新执行到此处之时，会发现已经有向权威服务器请求网络共识的连接存在，于是此处的函数便不再执行。接下来我们详细分析获取网络共识所需网络连接的建立：</p>
<pre><code class="language-cpp">/** If we want to download a fresh consensus, launch a new download as
 * appropriate. */
static void
update_consensus_networkstatus_downloads(time_t now)
{
  int i;
  const or_options_t *options = get_options();

  for (i=0; i &lt; N_CONSENSUS_FLAVORS; ++i) {
    /* XXXX need some way to download unknown flavors if we are caching. */
    ......

    if (! we_want_to_fetch_flavor(options, i))  //一般作为当前版本的客户端，只希望获取FLAV_MICRODESC类型的网络共识，其他类型全部跳过
      continue;

    c = networkstatus_get_latest_consensus_by_flavor(i);  //当前无最新网络共识则返回为空
    if (! (c &amp;&amp; c-&gt;valid_after &lt;= now &amp;&amp; now &lt;= c-&gt;valid_until)) {
      /* No live consensus? Get one now!*/
      time_to_download_next_consensus[i] = now;  //更新需求下载网络共识的时间
    }

    if (time_to_download_next_consensus[i] &gt; now)
      return; /* Wait until the current consensus is older. */

    resource = networkstatus_get_flavor_name(i);  //要发送给目录服务器的请求内容，针对FLAV_MICRODESC类型的网络共识，其值为microdesc

    if (!download_status_is_ready(&amp;consensus_dl_status[i], now,  //网络共识下载状态正常
                                  CONSENSUS_NETWORKSTATUS_MAX_DL_TRIES))
      continue; /* We failed downloading a consensus too recently. */
    if (connection_dir_get_by_purpose_and_resource(  //没有当前正在下载网络共识的连接
                                DIR_PURPOSE_FETCH_CONSENSUS, resource))
      continue; /* There's an in-progress download.*/

    waiting = &amp;consensus_waiting_for_certs[i];  //若有正在等待证书的网络共识，则尽量延长时间以等待证书的获取，以处理该网络共识成为可用状态的情况
    if (waiting-&gt;consensus) {
      /* XXXX make sure this doesn't delay sane downloads. */
      if (waiting-&gt;set_at + DELAY_WHILE_FETCHING_CERTS &gt; now) {
        continue; /* We're still getting certs for this one. */
      } else {
        if (!waiting-&gt;dl_failed) {
          download_status_failed(&amp;consensus_dl_status[i], 0);
          waiting-&gt;dl_failed=1;
        }
      }
    }

    log_info(LD_DIR, "Launching %s networkstatus consensus download.",
             networkstatus_get_flavor_name(i));

    //网络共识获取函数
    directory_get_from_dirserver(DIR_PURPOSE_FETCH_CONSENSUS,
                                 ROUTER_PURPOSE_GENERAL, resource,
                                 PDS_RETRY_IF_NO_SERVERS);
  }
}
</code></pre>
<p></p>
<h2>2. directory_get_from_dirserver</h2>
<p>　　上面讲述了这么多之后，其实下载网络状态说到底都是从目录服务器下载数据。从目录服务器下载数据的操作，统一使用下述函数：</p>
<pre><code class="language-cpp">/** Start a connection to a random running directory server, using
 * connection purpose &lt;b&gt;dir_purpose&lt;/b&gt;, intending to fetch descriptors
 * of purpose &lt;b&gt;router_purpose&lt;/b&gt;, and requesting &lt;b&gt;resource&lt;/b&gt;.
 * Use &lt;b&gt;pds_flags&lt;/b&gt; as arguments to router_pick_directory_server()
 * or router_pick_trusteddirserver().
 */
void
directory_get_from_dirserver(uint8_t dir_purpose, uint8_t router_purpose,
                             const char *resource, int pds_flags)
{
    // dir_purpose：向目录服务器建立连接的目的；
　　// router_purpose：向目录服务器建立连接的目的之中，与路由相关的目的；（General，Bridge）
    // resource：请求字符串
    // pds_flags：选择目录服务器的标示符（pick directory server）
    ......
}</code></pre>
<p>　　该函数篇幅略长，但是其核心的流程较为直观：找到合适的服务器，向服务器发送请求。而寻找合适的服务器这个过程，根据各种条件判断，可能调用以下两个函数中的一个，从而获得服务器的网络状态结构体。该结构体的获得是为了发送服务器请求服务的。两个调用的函数如下：</p>
<pre><code class="language-cpp">    rs = router_pick_trusteddirserver(type, pds_flags);
    rs = router_pick_directory_server(type, pds_flags);</code></pre>
<p>　　我们不再针对以上两个函数进行分析。因为这两个函数的最终目的我们比较明确。但是，如果希望找到固化在Tor源码内部的9个权威目录服务器的IP地址等信息，则可以深入分析第一个函数。我们可以简单猜测，此处服务器的选择过程应该是基本随机的。回到我们的故事主线，我们发现现在我们需要向一台服务器请求网络共识。而此时除了固化在代码内部的9个权威目录服务器被我们知道以外，其他的服务器信息我们一无所知。所以，这里一定是调用了获取trusteddirserver的函数获取9台权威目录服务器其中一台的IP地址等相关信息。 </p>
<p>　　选定需要发送请求的目录服务器之后，我们就需要向其发起连接，建立连接完毕之后，尝试发送请求。建立连接和发起请求的整个过程需要经历一个较为复杂的Tor系统内部连接处理的过程。我们不打算将这整个过程的代码一步一步进行分析，而是从比较宏观的角度对整个连接建立的过程进行描述。这里给出整个过程的入口部分，有兴趣的读者可以自行验证和详细分析：</p>
<pre><code class="language-cpp">  if (rs)
    directory_initiate_command_routerstatus(rs, dir_purpose,
                                            router_purpose,
                                            get_via_tor,
                                            resource, NULL, 0,
                                            if_modified_since);</code></pre>
<p></p>
<h2>3. directory_initiate_command_routerstatus（Dir连接与OR连接的建立）</h2>
<p>　　该函数是一个更加通用函数的包裹，大家利用代码查看工具往下深究会返现最终的重点函数其实是：directory_initiate_command_rend()</p>
<p>　　大家看到这里一般都会对其参数的内容感到头疼，我们此处先将其第一次执行时所用参数简要介绍，然后再详细说明函数内部的实现功能：</p>
<pre><code class="language-cpp">/** Same as directory_initiate_command(), but accepts rendezvous data to
 * fetch a hidden service descriptor. */
static void
directory_initiate_command_rend(const char *address, const tor_addr_t *_addr,
                                uint16_t or_port, uint16_t dir_port,
                                int supports_conditional_consensus,
                                int supports_begindir, const char *digest,
                                uint8_t dir_purpose, uint8_t router_purpose,
                                int anonymized_connection,
                                const char *resource,
                                const char *payload, size_t payload_len,
                                time_t if_modified_since,
                                const rend_data_t *rend_query)
{
　　// address：发送请求所选取的权威服务器的字符串地址信息；
　　// _addr：真正用于发起连接的权威服务器的IP地址等信息；
　　// or_port：权威服务器开放的or端口号，用于发起OR连接；
　　// dir_port：权威服务器开放的dir端口号，用于请求目录信息；
　　// supports_conditional_consensus：与服务器配置有关，指示服务器是否支持有条件的网络共识？这里没有详细理解；
　　// supports_begindir：与服务器配置有关，指示权威服务器是否支持直接连接DIR端口；
　　// digest：权威服务器身份摘要
　　// dir_purpose：前面出现过的目录服务器请求目的；
　　// router_purpose：前面出现过的路由请求目的，general或者bridge；
　　// anonymized_connection：标志连接是否为匿名的，一般值为0；
　　// resource：向目录服务器请求的内容，此处值为microdesc；
　　// payload：NULL；
　　// payload_len：0；
　　// if_modified_since：一般情况下值为0；
　　// rend_query：NULL
　　......
}
</code></pre>
<p>　　这个函数的内部主要执行流程是根据链路的连接选项，尝试新建到服务器的连接。此处我们依据默认情况下，anonymized_connection值为0，support_begindir值为1，进行函数具体执行流程的分析，我们略去许多不执行的内容，有兴趣的朋友可以自行分析：</p>
<pre><code class="language-cpp">  //函数先利用已知参数建立DIR连接
  conn = dir_connection_new(tor_addr_family(&amp;addr));

  /* set up conn so it's got all the data we need to remember */
  tor_addr_copy(&amp;conn-&gt;_base.addr, &amp;addr);
  conn-&gt;_base.port = use_begindir ? or_port : dir_port;
  conn-&gt;_base.address = tor_strdup(address);
  memcpy(conn-&gt;identity_digest, digest, DIGEST_LEN);

  conn-&gt;_base.purpose = dir_purpose;
  conn-&gt;router_purpose = router_purpose;

  /* give it an initial state */
  conn-&gt;_base.state = DIR_CONN_STATE_CONNECTING;

  /* decide whether we can learn our IP address from this conn */
  conn-&gt;dirconn_direct = !anonymized_connection;

  /* copy rendezvous data, if any */
  if (rend_query)
    conn-&gt;rend_data = rend_data_dup(rend_query);</code></pre>
<p>　　在成功建立Dir连接之后，我们执行如下代码：</p>
<pre><code class="language-cpp">  if{
    ......
  } else { /* we want to connect via a tor connection */
    entry_connection_t *linked_conn;
    ......

    /* make an AP connection
     * populate it and add it at the right state
     * hook up both sides
     */
   //建立一个AP连接，为DIR连接服务，所以这两个连接要关联起来；
   //在该函数内部要做的工作非常之多，需要建立一个OR连接为AP连接服务，同时要关联DIR和AP连接等；
   //该函数是连接重点函数！
  &nbsp;linked_conn =
      connection_ap_make_link(TO_CONN(conn),
                              conn-&gt;_base.address, conn-&gt;_base.port,
                              digest,
                              SESSION_GROUP_DIRCONN, iso_flags,
                              use_begindir, conn-&gt;dirconn_direct);
    ......

    //将DIR连接加入连接池；
    if (connection_add(TO_CONN(conn)) &lt; 0) {
      log_warn(LD_NET,"Unable to add connection for link to dirserver.");
      connection_mark_for_close(TO_CONN(conn));
      return;
    }
    conn-&gt;_base.state = DIR_CONN_STATE_CLIENT_SENDING;
    /* queue the command on the outbuf */
    directory_send_command(conn, dir_purpose, 0, resource,
                           payload, payload_len,
                           supports_conditional_consensus,
                           if_modified_since);

    //激活DIR连接与AP连接的读写事件，以便两者之间可以开始读写数据。
    connection_watch_events(TO_CONN(conn), READ_EVENT|WRITE_EVENT);
    IF_HAS_BUFFEREVENT(ENTRY_TO_CONN(linked_conn), {
      connection_watch_events(ENTRY_TO_CONN(linked_conn),
                              READ_EVENT|WRITE_EVENT);
    }) ELSE_IF_NO_BUFFEREVENT
      connection_start_reading(ENTRY_TO_CONN(linked_conn));
  }</code></pre>
<p>　　通过以上的分析我们可以发现，大量的工作被函数connection_ap_make_link完成。该函数从名字上来看仅仅是个简单的链接函数。但是，实际上，函数的内部还做了许多关于OR连接的操作：建立连接，开启连接等。在这个部分，我们知道了Dir连接和AP连接是怎么被建立和关联起来的，而下个部分，我们将要解释的则是OR连接和AP连接是如何关联在一起的。</p>
<p></p>
<h2>4. connection_ap_make_link</h2>
<p>　　实际上该函数体很短，主要的操作流程就是对AP连接的新建与初始化；针对AP连接与DIR连接进行关联；最后再给新建的AP连接分配一个合适的链路。其中，当AP连接无法找到合适的链路与之相关联之时，系统就会接着进行下一步骤：建立新的链路以满足需求。链路的建立过程，就牵涉到了OR连接的建立。因为链路是建立在OR连接之上的，AP连接是建立在链路之上的。因此才会最终实现OR连接对链路的复用，链路对AP连接的复用。此处我们不打算非常详细的分析每一个连接参数的初始化等繁琐的过程，还是将主要的精力集中在程序主执行流程之中：</p>
<pre><code class="language-cpp">/** Make an AP connection_t linked to the connection_t &lt;b&gt;partner&lt;/b&gt;. make a
 * new linked connection pair, and attach one side to the conn, connection_add
 * it, initialize it to circuit_wait, and call
 * connection_ap_handshake_attach_circuit(conn) on it.
 *
 * Return the newly created end of the linked connection pair, or -1 if error.
 */
entry_connection_t *
connection_ap_make_link(connection_t *partner,
                        char *address, uint16_t port,
                        const char *digest,
                        int session_group, int isolation_flags,
                        int use_begindir, int want_onehop)
{
  entry_connection_t *conn;
  connection_t *base_conn;

  log_info(LD_APP,"Making internal %s tunnel to %s:%d ...",
           want_onehop ? "direct" : "anonymized",
           safe_str_client(address), port);

  //新建AP连接，以下对其进行初始化赋值；
  conn = entry_connection_new(CONN_TYPE_AP, tor_addr_family(&amp;partner-&gt;addr));
  base_conn = ENTRY_TO_CONN(conn);
  base_conn-&gt;linked = 1; /* so that we can add it safely below. */

  /* populate conn-&gt;socks_request */

  /* leave version at zero, so the socks_reply is empty */
  conn-&gt;socks_request-&gt;socks_version = 0;
  conn-&gt;socks_request-&gt;has_finished = 0; /* waiting for 'connected' */
  strlcpy(conn-&gt;socks_request-&gt;address, address,
          sizeof(conn-&gt;socks_request-&gt;address));
  conn-&gt;socks_request-&gt;port = port;
  conn-&gt;socks_request-&gt;command = SOCKS_COMMAND_CONNECT;
  conn-&gt;want_onehop = want_onehop;
  conn-&gt;use_begindir = use_begindir;
  if (use_begindir) {
    conn-&gt;chosen_exit_name = tor_malloc(HEX_DIGEST_LEN+2);
    conn-&gt;chosen_exit_name[0] = '$';
    tor_assert(digest);
    base16_encode(conn-&gt;chosen_exit_name+1,HEX_DIGEST_LEN+1,
                  digest, DIGEST_LEN);
  }

  /* Populate isolation fields. */
  conn-&gt;socks_request-&gt;listener_type = CONN_TYPE_DIR_LISTENER;
  conn-&gt;original_dest_address = tor_strdup(address);
  conn-&gt;session_group = session_group;
  conn-&gt;isolation_flags = isolation_flags;

  base_conn-&gt;address = tor_strdup("(Tor_internal)");
  tor_addr_make_unspec(&amp;base_conn-&gt;addr);
  base_conn-&gt;port = 0;

  //在AP连接初始化完毕之后，将AP连接与DIR连接相关联；
  //实际上，连接partner也未必是DIR连接，但是在我们初步分析系统的时候，用到的主要的连接为DIR连接；
 &nbsp;connection_link_connections(partner, base_conn);

  //将新建的AP连接加入到连接池之中以统一管理；
  if (connection_add(base_conn) &lt; 0) { /* no space, forget it */
    connection_free(base_conn);
    return NULL;
  }

  base_conn-&gt;state = AP_CONN_STATE_CIRCUIT_WAIT;

  control_event_stream_status(conn, STREAM_EVENT_NEW, 0);

  /* attaching to a dirty circuit is fine */
  //最核心的AP连接与Circuit链路的关联函数，即为AP连接分配相应链路；
 &nbsp;if (connection_ap_handshake_attach_circuit(conn) &lt; 0) {
    if (!base_conn-&gt;marked_for_close)
      connection_mark_unattached_ap(conn, END_STREAM_REASON_CANT_ATTACH);
    return NULL;
  }

  log_info(LD_APP,"... application connection created and linked.");
  return conn;
}</code></pre>
<p>　　经过这个函数的分析和以往的分析，我们简要地看到了系统整个网络请求的初步请求流程：系统对网络共识存在下载需求，那么就建立DIR连接连接目录服务器；而建立DIR连接之后，需要进一步建立与之关联的AP连接辅助其进行请求的发送；而AP连接又需要借助链路发送请求，所以链路的加载又必不可少。而后文又会提到，链路的建立，又是基于OR连接，所以最终会导致系统建立OR连接。OR连接，又是建立于TLS连接的基础之上，所以要想完成OR连接的建立，又要先建立TLS连接。这整个流程，就是客户端请求目录服务器服务的流程。实际上这个流程从AP连接段开始，也是所有其他需要发送请求的客户端连接的后半段流程，所以非常的重要。下面我们就往后再分析AP连接是如何选中或建立一个与之相对应的链路。当然，链路的建立，就意味着需要建立链路的基础：OR连接。 </p>
<p></p>
<h2>5. connection_ap_handshake_attach_circuit</h2>
<p>　　通常情况下，系统包括两大类的需要关联链路的连接：普通连接；隐藏服务相关连接。所以该函数内部的大逻辑就是根据连接类型的不同进行不同的操作。我们此时只针对普通连接进行分析，暂时不牵涉隐藏服务连接部分的内容。这样的话，我们可以省略函数内部很大一部分的内容：</p>
<pre><code class="language-cpp">/** Try to find a safe live circuit for CONN_TYPE_AP connection conn. If
 * we don't find one: if conn cannot be handled by any known nodes,
 * warn and return -1 (conn needs to die, and is maybe already marked);
 * else launch new circuit (if necessary) and return 0.
 * Otherwise, associate conn with a safe live circuit, do the
 * right next step, and return 1.
 */
/* XXXX this function should mark for close whenever it returns -1;
 * its callers shouldn't have to worry about that. */
int
connection_ap_handshake_attach_circuit(entry_connection_t *conn)
{
  ......

  if (!connection_edge_is_rendezvous_stream(ENTRY_TO_EDGE_CONN(conn))) {
    /* we're a general conn */
    origin_circuit_t *circ=NULL;

    if (conn-&gt;chosen_exit_name) {
      ...... //对出口结点有要求的连接，需要判断选定的出口结点是否被本机支持等；
    }

    /* find the circuit that we should use, if there is one. */
    retval = circuit_get_open_circ_or_launch(  //获得可用链接，或者开启一条新的链接；
        conn, CIRCUIT_PURPOSE_C_GENERAL, &amp;circ);
    if (retval &lt; 1) // XXX023 if we totally fail, this still returns 0 -RD
      return retval;

    //往下部分是当上一步直接有可用链接的时候执行；
    //也就是说，之前的函数返回值大于等于1之时，代表有现成的链接可供AP连接使用，那么直接关联两者即可；
    log_debug(LD_APP|LD_CIRC,
              "Attaching apconn to circ %d (stream %d sec old).",
              circ-&gt;_base.n_circ_id, conn_age);
    /* print the circ's path, so people can figure out which circs are
     * sucking. */
    circuit_log_path(LOG_INFO,LD_APP|LD_CIRC,circ);

    /* We have found a suitable circuit for our conn. Hurray. */
    return connection_ap_handshake_attach_chosen_circuit(conn, circ, NULL);

  } else { /* we're a rendezvous conn */
    ......
    return 0;
  }
}
</code></pre>
<p>　　看完此处，大家可能会有困惑：没有可用链接的时候，会开启可用链接，但是，开启会那么快吗？链接不是意味着OR连接的建立吗？OR连接的建立不是意味着客户端和服务器成功完成TLS握手吗？这样复杂的过程，怎么能在一个函数当中做完？问题是，怎么能在单进程情况下这么做！关于这些困惑的解答，就是分析函数circuit_get_open_circ_or_launch之中所要关心的问题。带着这些问题，我们接着来看链接打开或建立函数。 </p>
<p></p>
<h2>6. circuit_get_open_circ_or_launch</h2>
<p>　　从函数名我们就可以简单进行猜测，该函数的主要作用，就是根据要求进行链路的选择，或者进行链路的建立。所以，本函数之中一定包含两个最重要的部分：链路选择；链路建立。此时，我们就可以对函数进行分析：</p>
<pre><code class="language-cpp">/** Find an open circ that we're happy to use for &lt;b&gt;conn&lt;/b&gt; and return 1. If
 * there isn't one, and there isn't one on the way, launch one and return
 * 0. If it will never work, return -1.
 *
 * Write the found or in-progress or launched circ into *circp.
 */
static int
circuit_get_open_circ_or_launch(entry_connection_t *conn,
                                uint8_t desired_circuit_purpose,
                                origin_circuit_t **circp)
{
  ...... //变量和判断等；

  //获取合适链路
  circ = circuit_get_best(conn, 1, desired_circuit_purpose,
                          need_uptime, need_internal);

  if (circ) { //若已经成功找到合适链路，则直接在此处返回；
    *circp = circ;
    return 1; /* we're happy */
  }

  if (!want_onehop &amp;&amp; !router_have_minimum_dir_info()) {
    ...... //若函数运行至此处，说明无合适链路，并且当前路由信息不够建立合适链路，则做相应获取路由信息的操作；
    return 0;
  }

  ......//对出口策略有要求时做的相关操作，一般情况下无策略要求；

  //经过上面的操作之后，重新尝试获取合适链路；（之前无合适链路，未必现在无合适链路）
  /* is one already on the way? */
  circ = circuit_get_best(conn, 0, desired_circuit_purpose,
                          need_uptime, need_internal);

 &nbsp;if (circ)
    log_debug(LD_CIRC, "one on the way!");
  if (!circ) {
    ...... //直到此处还没有有效的链路可用或正在被开启，恼羞成怒，自力更生开启链路；
           //开启链路的第一步，就是要指定链路中结点，在这个部分就是选中链路出口结点；

　　　//自行开启链路建立过程；
      circ = circuit_launch_by_extend_info(new_circ_purpose, extend_info,
                                           flags);
  } /* endif (!circ) */

  //结束处理
 &nbsp;if (circ) {
    connection_edge_update_circuit_isolation(conn, circ, 0);
  } else {
    log_info(LD_APP,"No safe circuit (purpose %d) ready for edge ""connection; delaying.",desired_circuit_purpose);
  }
  *circp = circ;
  return 0;
}
</code></pre>
<p>　　根据我们之前的判断，到此处我们发现：该函数中最重要的起功能性作用的函数为：circuit_get_best；circuit_launch_by_extend_info。前者为在众多链路中选择最合适的链路，后者则为在没有合适链路的情况下开启链路的建立过程。我们这里先对如何选择合适的链路进行简要阐述：链路的选择需要遍历全局链路列表，在遍历的过程中不断比对最好的最合适的链路，一旦链路遍历完成，返回最好的链路选择。若无任何链路被视为合适，则返回为空。大家可能会关心其中的所谓合适是何种含义，但是这并不是程序执行主要流程的重点部分，所以若对该部分感兴趣的读者，可以参看函数：circuit_is_acceptable；circuit_is_better。其中一定有你们希望得到的答案！ </p>
<p>　　之后，我们再来看看链路建立函数circuit_launch_by_extend_info。那么既然程序流程运行到了这一步，我们也必然能够大致猜测到这个函数的功能了。因为该函数的参数和返回值我们都已经可以明晰地看到。下一个部分我们详细地分析链路建立过程。</p>
<p></p>
<h2>7. circuit_launch_by_extend_info</h2>
<p>　　在开始这个函数的分析之前，我们先要谈谈建立一条Tor链路都需要些什么。我们知道，普通的链路建立，需要三个结点：入口结点，中间结点，出口结点。Tor系统在选择三个结点的时候分别有其各自的需求。对于入口结点，根据客户端的选择和相关配置，可能会被固定为一个或多个固定的结点；对于中间结点，可能会根据客户端对结点的参数需求进行相应选择；对于出口结点，选择的规则则更多，也相对复杂。虽然选择上有这些繁琐的部分，但是对于整个系统的执行过程来说，我们只需要知道，在建立链路的过程中，Tor系统需要通过各种各样选中的配置进行结点的选择。而选择的规则则可以从链路建立的结点选择过程当中看到端倪。</p>
<p>　　该函数的操作之中，将参数extend_info用作出口结点，将purpose用作链路建立的目的，将flags用作链路建立的基本指示符。标示符的内容可以包括很多，有兴趣的读者可以翻看具体的函数操作来查看标示符的所有标志及其作用。在这个部分的分析中，我们只将重点的链路建立过程进行分析，不再拘泥于一些细枝末节，以避免妨碍到程序主要流程的清晰表述。</p>
<p>　　查看源代码之后，我们发现该函数的内容较少。主要处理分支发生在对链路建立的目标和链路的出口结点是否被指定的判断上。在此处，我们暂时先默认认为单跳链路的建立不需要负责的处理操作，而非单跳的普通连接则可能需要在结点选择上做更多的判断。无论如何，在网络信息下载时，该处的链路是单跳链路，用于客户端直接连接目录服务器获取目录信息，所以必然是单跳的链路。于是乎我们发现，该函数对于单跳链路来说，主要是简单地调用了circuit_establish_circuit函数来进行后续处理。当然，非单跳函数最后也会调用上述函数进行处理。</p>
<p></p>
<h2>8.circuit_establish_circuit</h2>
<p>　　到了这一步，我们终于从繁琐的判断和小处理中解脱出来，要进行真正的链接建立的核心操作。核心操作主要分为四步：建立基础链路；添加链路出口结点标识；添加链路其他结点标识；开始向链路第一个结点发送连接请求。具体的代码如下：</p>
<pre><code class="language-cpp">/** Build a new circuit for &lt;b&gt;purpose&lt;/b&gt;. If &lt;b&gt;exit&lt;/b&gt;
 * is defined, then use that as your exit router, else choose a suitable
 * exit node.
 *
 * Also launch a connection to the first OR in the chosen path, if
 * it's not open already.
 */
origin_circuit_t *
circuit_establish_circuit(uint8_t purpose, extend_info_t *exit, int flags)
{
  ......

  circ = origin_circuit_init(purpose, flags); //初始化链路结构体；

  if (onion_pick_cpath_exit(circ, exit) &lt; 0 || //选择链路出口结点；
      onion_populate_cpath(circ) &lt; 0) { //选择链路其他结点；
    ......
  }

  ......

  if ((err_reason = circuit_handle_first_hop(circ)) &lt; 0) { //完成到链路中第一个结点的链接的建立工作；
    ......
  }
  return circ;
}
</code></pre>
<p>　　本文讲到此处，本应该接着往下分析链路结构体，链路的初始化和结点选择，以及链路的具体建立过程。但是这些部分非常繁杂，大家在没有宏观概念的情况下，未必在看完代码之后能够马上明白。所以此处，暂时先讲到链路开始建立的部分。接下来我们要做的事情，就是重新梳理，并讲清楚我们为什么要为了下载一个普通的网络信息而做这么复杂的嵌套函数操作，为什么我们需要一种又一种的连接，一个又一个的链接，以及往下的OR连接。这些为什么，只有在我们宏观地讲述完系统构架之后，才会变得明了起来。我们将这个部分的内容，放在下一节中。本节过于冗长，写到后半部分，已经很大程度上跟前述部分隔了许多层的关系。所以，在下一节中，我们通过重新梳理系统连接和链接框架，来更好地讲述连接和链接，以及继续分析链接的建立过程。</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Tor源码文件分析 &#8212; Cpuworker</title>
		<link>https://uzzz.org/article/1036.html</link>
				<pubDate>Fri, 24 May 2013 04:12:28 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Source Code Analysis]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1036.html</guid>
				<description><![CDATA[　　我们知道，对于Tor的服务器来说，有的时候因为其访问量巨大，不得不采取一些相应机制来保证服务的正常提供。在服务器编程里，我们经常可以用到的技术，例如线程池，多路复用等。Tor程序，在大多数情况下，都是单进程运行的，几乎没有哪里用到多线程的操作。正因为如此，Tor的主进程才绝对不允许出现阻塞式的操作。但是，唯独在一处，Tor为了提高自身效率，利用了线程池类]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>　　我们知道，对于Tor的服务器来说，有的时候因为其访问量巨大，不得不采取一些相应机制来保证服务的正常提供。在服务器编程里，我们经常可以用到的技术，例如线程池，多路复用等。Tor程序，在大多数情况下，都是单进程运行的，几乎没有哪里用到多线程的操作。正因为如此，Tor的主进程才绝对不允许出现阻塞式的操作。但是，唯独在一处，Tor为了提高自身效率，利用了线程池类似的机制。这个部分就是Cpuworker。本文就主要介绍该模块的作用和实现机制。</p>
<p>　　简单的说，Cpuworker存在的目的，是为了利用线程池的机制分担Tor主进程的压力，帮助其在接收到CREATE请求时计算对称密钥。下面进行具体的过程描述：</p>
<p>　　1. 系统启动时根据主机CPU数量，初始化cpuworker线程池；（linux中线程和进程基本无差别）</p>
<p>　　　　cpuworkers_rotate()</p>
<p>　　　　1.1 根据配置文件配置选项，自适应地检测CPU数量或固定设置CPU数量；</p>
<p>　　　　　　spawn_enough_cpuworkers()</p>
<p>　　　　1.2 根据CPU数量，开启cpuworker线程；（最大数目为16，最小数目为1）</p>
<p>　　　　　　spawn_cpuworker()</p>
<p>　　　　1.3 开启线程之前，创建sockpair，创建cpuworker连接，关联cpuworker连接与sockpair[0]；</p>
<p>　　　　1.4 开启线程之时，设置线程执行函数cpuworker_main，关联线程与sockpair[1]；</p>
<p>　　　　1.5 开启线程之后，将cpuworker连接加入系统连接池，同时从此线程与Tor主进程之间的通信方式为sockpair，类似socket的读写操作；</p>
<p>　　2. 在成功完成以上操作之后，系统达到如下效果：</p>
<p>　　　　2.1 当Tor主进程收到某主机发来的CREATE包时，检查连接池内是否有空闲的cpuworker连接；</p>
<p>　　　　　　assign_onionskin_to_cpuworker()</p>
<p>　　　　2.2 若有空闲cpuworker连接，则将CREATE包内容写入该连接；</p>
<p>　　　　　　connection_write_to_buf()</p>
<p>　　　　　　2.2.1 写入该连接则会激活该连接，使其将数据进一步写到sockpair[0]内，亦即传递给对应的线程，线程利用sockpair[1]来读取数据；</p>
<p>　　　　　　2.2.2 线程的主函数是阻塞式得等待数据，一旦数据到达，则开始处理，并在处理完毕之后，将结果写回sockpair[1]，亦即传递回主进程cpuworker连接；</p>
<p>　　　　　　cpuworker_main()</p>
<p>　　　　　　2.2.3 主进程处理cpuworker读事件就是根据对应的链路返回对应的CREATED包，其中包括DH密钥交换协议第二部分密钥和生成的对称密钥的摘要等；</p>
<p>　　　　2.3 若无空闲cpuworker连接，则将CREATE包挂起，在适当时候再写入空闲连接；</p>
<p>　　　　　　onion_pending_add()</p>
<p></p>
<p>　　上述整个过程，省略了很多细节部分，大家各自参照原函数进行进一步分析和理解。此处对几点再进行强调：Tor系统的连接多种多样，我们前面提过AP连接等内部连接，实际上Cpuworker连接也是内部连接，虽然他是用sockpair来完成的；sockpair是一种进程间通信机制，在众多的通信机制中，这种机制对Tor系统最为合适，所以选用了这种方式；Cpuworker线程的主要工作内容是对称密钥的生成。</p>
<p>　　这里我们再对称密钥的生成进行说明：</p>
<p>　　1. 在链路建立的过程中，Tor服务器应该首先接收到CREATE包。CREATE包的负载部分具有如下格式：（针对TAP握手方式）</p>
<p>　　　　　Payload := PK(Padding || Symmetric key || First part of g^x) || SK(Second part of g^x)</p>
<p>　　　　　PK：利用服务器的Onion Key进行公钥加密；</p>
<p>　　　　　SK：利用Symmetric Key进行对称加密；</p>
<p>　　　　　Padding：填充字节，长度一般为42B</p>
<p>　　　　　Symmetric Key：用于加密第二部分内容的对称密钥；</p>
<p>　　　　　g^x：DH密钥交换协议第一部分密钥材料。</p>
<p>　　2. 服务器接收到CREATE包之后，就要决定DH密钥交换协议的第二部分密钥材料g^y，从而计算出对称密钥。就是因为这个部分的密钥操作过程稍微会耗上一部分的时间，不适合在Tor主进程中进行操作，所以Tor程序利用cpuworker机制，开启线程专门为这种操作提供服务。在处理玩这些操作之后，Tor主进程生成CREATED包，返回给指定的链路。CREATED包的结构如下：</p>
<p>　　　　　Payload := DH_key || Digest</p>
<p>　　　　　DH_key：DH密钥交换协议第二部分密钥材料g^y；</p>
<p>　　　　　Digest：对称密钥首20字节作为摘要；</p>
<p>　　3. 其实，对称密钥生成之后被作为材料，截断成五个部分：</p>
<p>　　　　　Key Material := Digest || f_digest || b_digest || f_crypto || b_crypto</p>
<p>　　　第一部分20字节，被用作对称密钥摘要做为CREATED包负载的一个部分；</p>
<p>　　　第二部分20字节，被用作前向数据摘要计算的密钥；</p>
<p>　　　第三部分20字节，被用作后向数据摘要计算的密钥；</p>
<p>　　　第四部分16字节，被用作前向数据加密的密钥；</p>
<p>　　　第五部分16字节，被用作后向数据加密的密钥。</p>
<p>　　　前向和后向的不同，在于数据是远离OP还是靠近OP。若是远离OP，则称为前向；若是靠近OP，则称为后向。这里的这些密钥，是针对OP与OR之间而言的，不是OR与OR之间的密钥。也就是说，这些密钥是洋葱密钥，用于层层包裹数据，或者层层解密数据。我们可以知道的是，前向密钥，是用于数据远离OP时，所以是用来层层解密的；后向密钥，是用于数据靠近OP时，所以是用来层层加密的。OP端存有链路中所有OR的所有这些前后向密钥，所以它可以完成全加密和全解密。总的来说，也就是不要忘记，这里的密钥协商，是OP建立链路之时，OP与OR之间进行的协商。</p>
<p>　　4. 另外，在cpuworker的使用过程中，规定了一些请求和应答的格式。这个部分很简单，就不再多说，大家可以参照cpuworker_main函数开头部分的注释进行理解。此处只再对TAG进行简单说明。TAG的作用是进行连接ID和链路ID的记录，方便请求处理完成之后，快速找到对应的原始链路。快速查询方法就是利用之前我们提到过的哈希映射表，这里就不再多说：</p>
<p>　　　　　Map(circ_id, or_conn)&nbsp; &#8211;&gt;&nbsp; circ</p>
<p></p>
<p>　　因为通过上述的讲解之后，Cpuworker.c源码部分没有任何的理解起来的难度，所以此处就不再多源文件进行冗余的描述，大家可以遵循上述思路进行代码的浏览。应该来说，很快的就可以将cpuworker的工作和整个Tor系统的工作机制联系到一起。那么，关于cpuworker我们就解释到这里。</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Tor源码文件分析 &#8212; Log</title>
		<link>https://uzzz.org/article/1053.html</link>
				<pubDate>Wed, 22 May 2013 12:29:11 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Source Code Analysis]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1053.html</guid>
				<description><![CDATA[　　日志模块是Tor系统中一个非常重要的部件。它将Tor系统中的所有事件，分成不同的严重级别，分成不同的系统域，进行统一的日志处理。同时它还维护着一个日志记录链表。日志记录链表内存储的是所有日志需要输出的目标日志文件或目标日志输出位置。下文中我们会详细地对日志模块进行分析，并简要说明源文件中的各函数的简单作用。 1. 严重等级和域 　　日志模块内定义了5个严]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>　　日志模块是Tor系统中一个非常重要的部件。它将Tor系统中的所有事件，分成不同的严重级别，分成不同的系统域，进行统一的日志处理。同时它还维护着一个日志记录链表。日志记录链表内存储的是所有日志需要输出的目标日志文件或目标日志输出位置。下文中我们会详细地对日志模块进行分析，并简要说明源文件中的各函数的简单作用。</p>
<p></p>
<h2>1. 严重等级和域</h2>
<p>　　日志模块内定义了5个严重等级，其具体的设定如下：</p>
<pre><code class="language-cpp">/** Debug-level severity: for hyper-verbose messages of no interest to
 * anybody but developers. */
#define LOG_DEBUG   7
/** Info-level severity: for messages that appear frequently during normal
 * operation. */
#define LOG_INFO    6
/** Notice-level severity: for messages that appear infrequently
 * during normal operation; that the user will probably care about;
 * and that are not errors.
 */
#define LOG_NOTICE  5
/** Warn-level severity: for messages that only appear when something has gone
 * wrong. */
#define LOG_WARN    4
/** Error-level severity: for messages that only appear when something has gone
 * very wrong, and the Tor process can no longer proceed. */
#define LOG_ERR     3</code></pre>
<p>　　五个严重等级所对应的数字越小，说明他们的严重性越高。 </p>
<p>　　日志模块内同时定义了许多个域，用于记录日志时标记日志是系统中哪个域输出的日志：</p>
<pre><code class="language-cpp">/* Logging domains */

/** Catch-all for miscellaneous events and fatal errors. */
#define LD_GENERAL  (1u&lt;&lt;0)
/** The cryptography subsystem. */
#define LD_CRYPTO   (1u&lt;&lt;1)
/** Networking. */
#define LD_NET      (1u&lt;&lt;2)
/** Parsing and acting on our configuration. */
#define LD_CONFIG   (1u&lt;&lt;3)
/** Reading and writing from the filesystem. */
#define LD_FS       (1u&lt;&lt;4)
/** Other servers' (non)compliance with the Tor protocol. */
#define LD_PROTOCOL (1u&lt;&lt;5)
/** Memory management. */
#define LD_MM       (1u&lt;&lt;6)
/** HTTP implementation. */
#define LD_HTTP     (1u&lt;&lt;7)
/** Application (socks) requests. */
#define LD_APP      (1u&lt;&lt;8)
/** Communication via the controller protocol. */
#define LD_CONTROL  (1u&lt;&lt;9)
/** Building, using, and managing circuits. */
#define LD_CIRC     (1u&lt;&lt;10)
/** Hidden services. */
#define LD_REND     (1u&lt;&lt;11)
/** Internal errors in this Tor process. */
#define LD_BUG      (1u&lt;&lt;12)
/** Learning and using information about Tor servers. */
#define LD_DIR      (1u&lt;&lt;13)
/** Learning and using information about Tor servers. */
#define LD_DIRSERV  (1u&lt;&lt;14)
/** Onion routing protocol. */
#define LD_OR       (1u&lt;&lt;15)
/** Generic edge-connection functionality. */
#define LD_EDGE     (1u&lt;&lt;16)
#define LD_EXIT     LD_EDGE
/** Bandwidth accounting. */
#define LD_ACCT     (1u&lt;&lt;17)
/** Router history */
#define LD_HIST     (1u&lt;&lt;18)
/** OR handshaking */
#define LD_HANDSHAKE (1u&lt;&lt;19)
/** Heartbeat messages */
#define LD_HEARTBEAT (1u&lt;&lt;20)
/** Number of logging domains in the code. */
#define N_LOGGING_DOMAINS 21

/** This log message is not safe to send to a callback-based logger
 * immediately.  Used as a flag, not a log domain. */
#define LD_NOCB (1u&lt;&lt;31)</code></pre>
<p>　　每个域由其所占用的比特位来标识。 </p>
<p>　　在定义了严重等级与域之后，日志模块又定义了域掩码和域掩码数组：</p>
<pre><code class="language-cpp">/** Mask of zero or more log domains, OR'd together. */
typedef uint32_t log_domain_mask_t;

/** Configures which severities are logged for each logging domain for a given
 * log target. */
typedef struct log_severity_list_t {
  /** For each log severity, a bitmask of which domains a given logger is
   * logging. */
  log_domain_mask_t masks[LOG_DEBUG-LOG_ERR+1];
} log_severity_list_t;</code></pre>
<p>　　通过以上这三部分的说明，我们大致可以猜测，日志模块的分级分域输出的实现，就是根据严重级别以及域掩码的判断来实现的。作为一个普通的日志模块，其大致的功能只要是能将需要输出的日志信息，存放在一定的位置，方便管理员查看即可。按照这种简单的想法，似乎日志模块也就是如此这般便可。但是，实际上Tor系统内部的日志模块所具有的功能还相对复杂：临时日志功能；多重日志输出功能；日志回调功能。所以，我们还需要进一步分析。 </p>
<p></p>
<h2>2. 概述</h2>
<p>　　Tor系统的日志模块维护着一个日志输出列表，用于存储所有需要输出的日志存储位置。当一个日志消息到达，日志模块会遍历列表，一个一个比对其严重等级与域掩码是否符合对应输出的要求，如果符合，则输出，若不符合则跳过。多重日志输出功能就是通过这样的方式进行实现的。临时日志功能是Tor系统刚刚启动之时，还未读取配置文件中需要记录日志的日志文件信息，用于临时输出系统信息的功能。默认情况下，临时日志会被直接输出到终端上，也就是说其输出位置是stdout。而在系统成功启动日志系统，读取日志配置文件信息之后，就会关闭临时输出日志信息的位置，开启配置文件中要求记录日志的位置。</p>
<p>　　我们先针对以上两个功能进行举例说明：</p>
<p>　　系统刚刚启动之时，日志模块还未初始化完全，使用临时日志功能。日志输出列表如下：</p>
<p>　　　　　　logfile&nbsp; =&nbsp; stdout(old)&nbsp; &#8211;&gt;&nbsp; NULL</p>
<p>　　系统成功读取配置文件，利用配置文件信息初始化日志模块之后，日志输出列表如下：</p>
<p>　　　　　　logfile&nbsp; =&nbsp; stdout(new)&nbsp; &#8211;&gt;&nbsp; file2&nbsp; &#8211;&gt;&nbsp; file1 &#8211;&gt;&nbsp; NULL</p>
<p>　　其相对应的配置文件关于日志管理部分的内容为：</p>
<p>　　　　Log debug file1</p>
<p>　　　　Log notice file2</p>
<p>　　　　Log warn stdout</p>
<p>　　也就是说，系统会通过配置文件内的配置，往日志输出列表内加入输出位置；删除临时输出位置。此处我们没有具体说出是先添加输出位置还是先删除临时输出位置，凭猜测应该是先添加输出位置，再删除临时输出位置。具体的先后请大家自行参看源码。</p>
<p>　　当有日志消息需要输出只是，系统会遍历以上的logfile链表，匹配严重等级与域掩码，然后相应地输出日志到对应的文件或位置。</p>
<p></p>
<p>　　以上谈论的是日志模块的两个主要功能，还有一个是日志信息的回调功能。这个功能和Tor系统的控制模块相关，在下文当中我们简要的描述，不会多讲，等到具体介绍控制模块的时候，我们会再深入地进行说明。</p>
<p></p>
<h2>3. 全局变量</h2>
<p>　　日志模块的全局变量有一些，但是其中有部分是没有多大作用的。我们这里只列举出那些对日志模块功能起着很大作用的全局变量，对他们进行部分分析：</p>
<pre><code class="language-cpp">/** A mutex to guard changes to logfiles and logging. */
static tor_mutex_t log_mutex;　　　　　　　　　　　　　　　　　//日志锁，用于互斥操作
/** True iff we have initialized log_mutex */
static int log_mutex_initialized = 0;                        //日志锁标志，用于标记日志锁是否初始化

/** Linked list of logfile_t. */
static logfile_t *logfiles = NULL;                           //日志输出位置链表
/** Boolean: do we report logging domains? */
static int log_domains_are_logged = 0;                       //日志输出时是否输出相对应的日志域</code></pre>
<pre><code class="language-cpp">/** Log messages waiting to be replayed onto callback-based logs */
static smartlist_t *pending_cb_messages = NULL;              //延迟输出的回调消息链表，用于系统控制模块</code></pre>
<pre><code class="language-cpp">/** NULL-terminated array of names for log domains such that domain_list[dom]
 * is a description of &lt;b&gt;dom&lt;/b&gt;. */
static const char *domain_list[] = {                         //域列表，用于字符串与域对应数字之间的转换
  "GENERAL", "CRYPTO", "NET", "CONFIG", "FS", "PROTOCOL", "MM",
  "HTTP", "APP", "CONTROL", "CIRC", "REND", "BUG", "DIR", "DIRSERV",
  "OR", "EDGE", "ACCT", "HIST", "HANDSHAKE", "HEARTBEAT", NULL
};</code></pre>
<p>　　通过以上的解释，应该只对pending_cb_messages不大理解。为什么需要有这样的链表？为什么需要挂起日志？回调日志又是怎么回事？这个部分，我们留到之后分析控制模块之时回答。这里只做简要的说明：系统的控制模块有的时候对一些日志消息有浓厚的兴趣，他需要日志模块在某些日志产生的时候提醒他。如何进行提醒呢？控制模块在日志模块注册一个日志输出位置，其实不是真正的输出位置，他同时提供一个回调函数。当日志模块接收到对应的日志之时，就会通过回调函数通知控制模块，相应的日志已经出现。于是控制模块就可以进行控制操作。 </p>
<p></p>
<h2>4.函数说明</h2>
<p>　　init_logging</p>
<p>　　parse_log_level</p>
<p>　　parse_log_severity_config</p>
<p>　　set_log_severity_config</p>
<p>　　log_level_to_string</p>
<p>　　初始化日志模块及基本工具函数；</p>
<p></p>
<p>　　add_sys_log</p>
<p>　　add_callback_log</p>
<p>　　add_temp_log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8211;&gt;&nbsp; add_stream_log</p>
<p>　　add_file_log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8211;&gt;&nbsp; add_stream_log</p>
<p> 　　往系统输出链表内添加日志输出位置的函数。由上述这些函数我们可以将输出位置的类型分为3类：sys，callback，stream。其中我们最常见的就是流类型。因为该类型就指代了我们平时所常见的输出位置：文件，标准输入输出等。 </p>
<p></p>
<p>　　flush_pending_log_callbacks</p>
<p>　　处理挂起的回调日志的函数，分析控制模块之时我们会再次详细讲述这个部分。</p>
<p></p>
<p>　　其他余下的函数其实大致都是对日志模块的小部分操作，与工具函数基本类似，分析到此处不必在过多得分析函数功能。我们可以凭照我们平时开发系统的经验，大致猜测出还需要什么函数或小功能以完善整个日志系统。最重要的函数，应该就是记录日志的操作函数。日志模块根据不同的严重等级，提供了不同的记录日志函数：</p>
<p>　　log_debug</p>
<p>　　log_info</p>
<p>　　log_notice</p>
<p>　　log_warn</p>
<p>　　log_err</p>
<p>　　但是其实，他们也只是对一个核心日志记录函数的上层封装，该函数就是：logv</p>
<p>　　有兴趣的朋友可以自行查看logv函数的核心实现，其实现过程简单的说，就是根据不同的输出位置类型，执行不同的输出操作。</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Tor源码文件分析 &#8212; Control</title>
		<link>https://uzzz.org/article/1060.html</link>
				<pubDate>Wed, 22 May 2013 08:13:03 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Source Code Analysis]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1060.html</guid>
				<description><![CDATA[传统上我们所指的系统信号，就是系统传递给进程的控制信号。例如，SIGINT，SIGTERM等等。这些信号的传递，通常都是指示相关进程完成相应的操作，或暂停或终止，或其他一些操作。在Tor系统中，信号分为两种：传统信号，控制器信号。下面代码段是这些信号的简单罗列： /* These signals are defined to help handle_cont]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
   传统上我们所指的系统信号，就是系统传递给进程的控制信号。例如，SIGINT，SIGTERM等等。这些信号的传递，通常都是指示相关进程完成相应的操作，或暂停或终止，或其他一些操作。在Tor系统中，信号分为两种：传统信号，控制器信号。下面代码段是这些信号的简单罗列：</p>
<pre><code class="language-cpp">/* These signals are defined to help handle_control_signal work.
 */
#ifndef SIGHUP
#define SIGHUP 1
#endif
#ifndef SIGINT
#define SIGINT 2
#endif
#ifndef SIGUSR1
#define SIGUSR1 10
#endif
#ifndef SIGUSR2
#define SIGUSR2 12
#endif
#ifndef SIGTERM
#define SIGTERM 15
#endif
/* Controller signals start at a high number so we don't
 * conflict with system-defined signals. */
#define SIGNEWNYM 129
#define SIGCLEARDNSCACHE 130</code></pre>
<p>　　这些信号，是程序最主要关心的信号。他们都有相应的响应处理，其处理函数均为信号回调函数中调用的process_signal函数。在前面的小节中，我们已经提到过了关于信号事件的处理机制，这里就不再多说。但是，值得注意的是，当时的信号事件注册，并没有注册SIGNEWNYM信号和SIGCLEARDNSCACHE信号。也就是说，这两个信号并非由信号处理事件激活的。那他们是出现在何处的呢？答案是控制连接信号传递。<br />
  </p>
<p>　　我们暂且将这个部分的内容搁置在这里，标题改成Control。在后期分析完成控制连接之后，将这个系统控制连接的主要作用和用法在这里进行详细描述。</p>
<p></p>
<p></p>
<p>未完待续&#8230;&#8230;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Tor源码文件分析 &#8212; Hibernation</title>
		<link>https://uzzz.org/article/1056.html</link>
				<pubDate>Tue, 21 May 2013 10:32:36 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Source Code Analysis]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1056.html</guid>
				<description><![CDATA[　　本篇会介绍Tor系统的休眠模块。休眠模块的代码处于源文件Hibernation.c之中。简单的说，其主要作用就是在适当的时机将系统进入休眠状态以保护系统资源被过度消耗；或者在适当的时机重新唤醒系统以达到重新为全局服务的目的。在默认的系统配置下，客户端的休眠模块是被关闭的，也就是说客户端永远不会进入休眠态。而Tor系统中的工作路由服务器则并非如此。他们很多]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>　　本篇会介绍Tor系统的休眠模块。休眠模块的代码处于源文件Hibernation.c之中。简单的说，其主要作用就是在适当的时机将系统进入休眠状态以保护系统资源被过度消耗；或者在适当的时机重新唤醒系统以达到重新为全局服务的目的。在默认的系统配置下，客户端的休眠模块是被关闭的，也就是说客户端永远不会进入休眠态。而Tor系统中的工作路由服务器则并非如此。他们很多时候需要设置一些为网络服务的策略和带宽，那么他们就需要对自己为Tor系统做出的贡献做一定的限制。单纯从流量角度来说，或许有一些OR服务器不愿意在一段时间内，允许流过自身的数据量超过一个非常大的范围。所以，OR服务器运行其自身的Tor程序时，进行了相关配置，要求其检查固定时间内流过的数据量。如果该数据量较小，则服务器可以忍受；若数据量非常大，则服务器会让其Tor程序进入休眠状态，提供少量服务，甚至最后不提供服务。</p>
<p>　　在讲休眠机制之前，需要关注配置文件中的两个配置选项：AccountingMax，AccountingStart。服务器就是通过这两个配置项，来配置他们所能接受的流量范围。我们以默认情况举例。一台Tor路由服务器，一般情况下统计其流量的周期为一个月，一个月内允许通过其自身的Tor网络的流量为1G，则上述两个配置项可以根据周期为月，流量为1G这些需求进行配置。具体在配置文件中如何具体配置，请参照Tor Manual中的选项说明。</p>
<p>　　这里我们先来分析休眠模块的源文件的全局变量及部分函数。</p>
<p></p>
<h2>0. 概述</h2>
<p>　　概述部分我们只简单地贴出来源文件头部对文件的说明，因为其已经相对清晰地描述了文件所要处理的事件和主要工作内容。</p>
<pre><code class="language-cpp">/**
 * \file hibernate.c
 * \brief Functions to close listeners, stop allowing new circuits,
 * etc in preparation for closing down or going dormant; and to track
 * bandwidth and time intervals to know when to hibernate and when to
 * stop hibernating.
 **/

/*
hibernating, phase 1: // soft limit 将要耗尽流量之时产生的反应
  - send destroy in response to create cells
  - send end (policy failed) in response to begin cells
  - close an OR conn when it has no circuits

hibernating, phase 2: // hard limit 流量耗尽之时产生的反应
  (entered when bandwidth hard limit reached)
  - close all OR/AP/exit conns)
*/</code></pre>
<p>　　简而言之，系统是否休眠取决于在指定的时间段内，系统的流量多少。源文件中的注释中给出了如下的关于休眠和统计流量的简要解释：</p>
<pre><code class="language-cpp">/* Fields for accounting logic.  Accounting overview:
 *
 * Accounting is designed to ensure that no more than N bytes are sent in
 * either direction over a given interval (currently, one month, one week, or
 * one day) We could
 * try to do this by choking our bandwidth to a trickle, but that
 * would make our streams useless.  Instead, we estimate what our
 * bandwidth usage will be, and guess how long we'll be able to
 * provide that much bandwidth before hitting our limit.  We then
 * choose a random time within the accounting interval to come up (so
 * that we don't get 50 Tors running on the 1st of the month and none
 * on the 30th).
 *
 * Each interval runs as follows:
 *
 * 1. We guess our bandwidth usage, based on how much we used
 *     last time.  We choose a "wakeup time" within the interval to come up. //随机选择时间段内的一个时间点；
 * 2. Until the chosen wakeup time, we hibernate.                            //在时间点之前一直保持休眠状态，达到时间点时，唤醒系统；
 * 3. We come up at the wakeup time, and provide bandwidth until we are
 *    "very close" to running out.                                           //系统被唤醒之后不断提供服务，知道流量快要被耗尽；
 * 4. Then we go into low-bandwidth mode, and stop accepting new
 *    connections, but provide bandwidth until we run out.                   //流量快要被耗尽之时，不再接受新连接，而持续为现有连接服务，直到流量耗尽；
 * 5. Then we hibernate until the end of the interval.                       //流量耗尽之后，系统进入休眠态，直到下一个周期决定系统唤醒时间点。
 *
 * If the interval ends before we run out of bandwidth, we go back to
 * step one.
 */</code></pre>
<p></p>
<h2>1. 全局变量</h2>
</p>
<pre><code class="language-cpp">/** Are we currently awake, asleep, running out of bandwidth, or shutting
 * down? */
static hibernate_state_t hibernate_state = HIBERNATE_STATE_INITIAL; //当前休眠模块所指示的系统当前所处的状态
/** If are hibernating, when do we plan to wake up? Set to 0 if we
 * aren't hibernating. */
static time_t hibernate_end_time = 0;                               //当前休眠结束的时间，当前若不处于休眠状态，则其值为0
/** If we are shutting down, when do we plan finally exit? Set to 0 if
 * we aren't shutting down. */
static time_t shutdown_time = 0;                                    //当前处于将要关闭状态之时，最终的退出时间</code></pre>
<p>　　以下的所有全局变量，都是为了能够很好的控制和记录统计流量的周期和各相关时间。在明白了概述中周期运行及流量统计的规则之后，下面这些全局变量的用处应该并不难理解。此处仅仅将其进行简单罗列。他们各自的具体用途，可以从英文注释中简要地弄明白。<br />
  </p>
<pre><code class="language-cpp">/** How many bytes have we read in this accounting interval? */
static uint64_t n_bytes_read_in_interval = 0;
/** How many bytes have we written in this accounting interval? */
static uint64_t n_bytes_written_in_interval = 0;
/** How many seconds have we been running this interval? */
static uint32_t n_seconds_active_in_interval = 0;
/** How many seconds were we active in this interval before we hit our soft
 * limit? */
static int n_seconds_to_hit_soft_limit = 0;
/** When in this interval was the soft limit hit. */
static time_t soft_limit_hit_at = 0;
/** How many bytes had we read/written when we hit the soft limit? */
static uint64_t n_bytes_at_soft_limit = 0;
/** When did this accounting interval start? */
static time_t interval_start_time = 0;
/** When will this accounting interval end? */
static time_t interval_end_time = 0;
/** How far into the accounting interval should we hibernate? */
static time_t interval_wakeup_time = 0;
/** How much bandwidth do we 'expect' to use per minute?  (0 if we have no
 * info from the last period.) */
static uint64_t expected_bandwidth_usage = 0;
/** What unit are we using for our accounting? */
static time_unit_t cfg_unit = UNIT_MONTH;

/** How many days,hours,minutes into each unit does our accounting interval
 * start? */
/** @{ */
static int cfg_start_day = 0,
           cfg_start_hour = 0,
           cfg_start_min = 0;
/** @} */</code></pre>
<p></p>
<h2>2. 接口函数</h2>
<h3>　　2.1. Accounting</h3>
<p>　　Accounting部分的代码，完全是为了判断系统是否应该进入休眠态或者是否应该被唤醒而服务的，所以他们处于同一个文件之中。</p>
<p></p>
<p>　　configure_accounting</p>
<p>　　初始化流量统计子模块函数；</p>
<p></p>
<p>　　accounting_parse_options</p>
<p>　　accounting_is_enabled</p>
<p>　　accounting_get_interval_length</p>
<p>　　流量统计子模块功能函数：利用配置选项初始化函数；判断是否启用流量统计模块函数；获取流量统计时间区间函数；</p>
<p></p>
<p>　　accounting_run_housekeeping&nbsp; &#8211;&gt;&nbsp; accounting_record_bandwidth_usage</p>
<p>　　流量统计子模块维护函数：主要功能是适当时机重启子系统，每隔600秒更行服务器状态并写回硬盘（mark dirty）；</p>
<p></p>
<p>　　accounting_add_bytes</p>
<p>　　流量统计子模块的主要流量统计功能函数：对流量增加的处理；</p>
<p></p>
<p>　　getinfo_helper_accounting</p>
<p>　　流量统计子模块对外提供的消息询问函数：利用该函数可以得到整个子模块的当前各种状态；</p>
<p></p>
<h3>　　2.2. Hibernation</h3>
<p>　　consider_hibernation</p>
<p>　　休眠主控函数：调用该函数判断系统当前流量统计的情况是否需要系统进入休眠状态，或要求从休眠状态中被唤醒；</p>
<p></p>
<p>　　we_are_hibernating</p>
<p>　　休眠判断函数：返回系统当初是否处于休眠态；</p>
<p></p>
<p>　　hibernate_begin_shutdown</p>
<p>　　关闭系统的函数：系统接收到SIGINT信号时，关闭整个系统（当然包括流量统计模块）。</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Tor源码分析八 &#8212; 客户端执行流程（second_elapsed_callback函数）</title>
		<link>https://uzzz.org/article/1072.html</link>
				<pubDate>Mon, 13 May 2013 07:16:42 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Source Code Analysis]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1072.html</guid>
				<description><![CDATA[　　在之前的客户端源码分析中，我们讲述了整个客户端的事件集和相关调度规则。每一类事件的激活都有相应的条件，要么是socket可读写，要么是收到信号，要么是定时事件到达，还有手动的事件激活。总而言之，系统中添加的所有事件经过Libevent的调度，使得整个系统有条不紊的运行起来。同时，每个事件均有其对应的事件处理函数，在系统运行起来之后，一旦事件被激活，就会调]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>　　在<a href="http://blog.csdn.net/winscar/article/details/8904737" rel="nofollow" data-token="fc9ee50f9ad8615bb7f2a6ca20cfb09a">之前的客户端源码分析</a>中，我们讲述了整个客户端的事件集和相关调度规则。每一类事件的激活都有相应的条件，要么是socket可读写，要么是收到信号，要么是定时事件到达，还有手动的事件激活。总而言之，系统中添加的所有事件经过Libevent的调度，使得整个系统有条不紊的运行起来。同时，每个事件均有其对应的事件处理函数，在系统运行起来之后，一旦事件被激活，就会调用相应的回调函数进行处理。</p>
<p>　　本文我们着重介绍秒回调事件的事件处理函数second_elapsed_callback。该函数所做的工作非常之多，但是总的说来，是对系统的正常运行的维护和保障。之所以要最先介绍这个函数，是因为新安装的Tor系统在正常启动之后，没有任何事件会先于该秒回调事件被激活，也就是说，系统最先执行的回调函数是秒回调函数。在这个函数中，运行Tor系统的许多必要信息被获取或维护，保障了系统能够在正常地启动，最终为用户提供服务。下面，我们采取代码中加注释的方法，介绍函数的主要过程。英文注释已经描述地很清楚的部分就不再多说了。</p>
<p></p>
<h2>1. second_elapsed_callback()</h2>
</p>
<pre><code class="language-cpp">/** Libevent callback: invoked once every second. */
static void
second_elapsed_callback(periodic_timer_t *timer, void *arg) // 本函数的两个参数没有任何用处
{
 &nbsp;static time_t current_second = 0; // 静态的当前时间，每次进入该函数时，该值就是上次执行该函数时的时间；
  time_t now;                       // 真正的当前时间；
  size_t bytes_written;
  size_t bytes_read;
  int seconds_elapsed;
  const or_options_t *options = get_options();
  (void)timer;
  (void)arg;

  n_libevent_errors = 0;

  /* log_notice(LD_GENERAL, "Tick."); */
  now = time(NULL);
  update_approx_time(now);

  /* the second has rolled over. check more stuff. */
  seconds_elapsed = current_second ? (int)(now - current_second) : 0; // 之前进入本函数与本次进入本函数的时间差seconds_elapsed

#ifdef USE_BUFFEREVENTS
  ...... // 我们暂时不讨论使用BUFFEREVENTS的情况；
#else
  // stats_n_bytes_read, stats_prev_n_read, stats_n_bytes_written, stats_prev_n_written
  // 这四个变量是全局变量，分别用来存储系统当前读写的字节数；
  // 开始时，四个全局变量值相等；
  // 当有数据读写的时候，相应增加stats_n_bytes_read,stats_n_bytes_written两个全局变量记录当前读取的字节数；
  // 当本回调函数被调用，利用他们前后数据差来计算两次本回调执行之间所读写的数据量：
 &nbsp;bytes_read = (size_t)(stats_n_bytes_read - stats_prev_n_read);
  bytes_written = (size_t)(stats_n_bytes_written - stats_prev_n_written);
  // 最后时，更新相应前置读写数据为当前系统读写数据，以为下次计算两次回调函数之间读写数据量做准备：
 &nbsp;stats_prev_n_read = stats_n_bytes_read;
  stats_prev_n_written = stats_n_bytes_written;
  // 总而言之，此处这么做的最终目的，就是为了每次均可以有效算出两次回调函数执行之间（过去的一秒内）读写数据的总字节数；
#endif

  // 下面两个函数与控制连接相关，暂不讨论
  control_event_bandwidth_used((uint32_t)bytes_read,(uint32_t)bytes_written);
  control_event_stream_bandwidth_used();

  // 该判断成立的条件为：
  // 1.Tor程序运行身份为服务器；
  // 2.网络没有被禁用；
  // 3.前后两次回调函数的执行不是无时间间隔的，也就是的确有时间流逝；
  // 4.系统曾成功开启过链路，也就是说估计系统当前应该处理连接正常状态；
  // 5.系统运行时间大概增加了20分钟；
 &nbsp;if (server_mode(options) &amp;&amp;
      !net_is_disabled() &amp;&amp;
      seconds_elapsed &gt; 0 &amp;&amp;
      can_complete_circuit &amp;&amp;
      stats_n_seconds_working / TIMEOUT_UNTIL_UNREACHABILITY_COMPLAINT !=
      (stats_n_seconds_working+seconds_elapsed) / TIMEOUT_UNTIL_UNREACHABILITY_COMPLAINT) {
    /* every 20 minutes, check and complain if necessary */
    const routerinfo_t *me = router_get_my_routerinfo(); // 获取自身路由信息结构体；
    if (me &amp;&amp; !check_whether_orport_reachable()) {       // 检测自身OR端口是否从外界可达，即OR服务是否有效可用；如果不可用，则产生抱怨= =：
      log_warn(LD_CONFIG,"Your server (%s:%d) has not managed to confirm that "
               "its ORPort is reachable. Please check your firewalls, ports, "
               "address, /etc/hosts file, etc.",
               me-&gt;address, me-&gt;or_port);
      control_event_server_status(LOG_WARN,
                                  "REACHABILITY_FAILED ORADDRESS=%s:%d",
                                  me-&gt;address, me-&gt;or_port);
    }

    if (me &amp;&amp; !check_whether_dirport_reachable()) {      // 检测自身DIR端口是否从外界可达，即DIR服务是否有效可用；如果不可用，则产生抱怨：
      log_warn(LD_CONFIG,
               "Your server (%s:%d) has not managed to confirm that its "
               "DirPort is reachable. Please check your firewalls, ports, "
               "address, /etc/hosts file, etc.",
               me-&gt;address, me-&gt;dir_port);
      control_event_server_status(LOG_WARN,
                                  "REACHABILITY_FAILED DIRADDRESS=%s:%d",
                                  me-&gt;address, me-&gt;dir_port);
    }
  }

/** If more than this many seconds have elapsed, probably the clock
 * jumped: doesn't count. */
#define NUM_JUMPED_SECONDS_BEFORE_WARN 100
  if (seconds_elapsed &lt; -NUM_JUMPED_SECONDS_BEFORE_WARN ||
      seconds_elapsed &gt;= NUM_JUMPED_SECONDS_BEFORE_WARN) { // 此处进行时间异常的处理，也就是当逝去的时间出现不可能的情况之时，进行如下操作：
    circuit_note_clock_jumped(seconds_elapsed);
    /* XXX if the time jumps *back* many months, do our events in
     * run_scheduled_events() recover? I don't think they do. -RD */
  } else if (seconds_elapsed &gt; 0)                          // 无时间异常时，增加系统运行的时间：
    stats_n_seconds_working += seconds_elapsed;

  run_scheduled_events(now); // !!!!!主要的维护函数!!!!!

  current_second = now; /* remember which second it is, for next time */ // 记住本次进入函数的时间，为下一次计算时间差做准备。
}</code></pre>
<p></p>
<h2>2. run_scheduled_events()</h2>
<p>　　这个函数非常之长，此处我们按功能，分段分析。</p>
<p>　　下面的主要静态变量的分析说明一定有错误的地方，笔者没有太仔细地去看每个部分的详细说明的情况下就写出了下面的简要介绍，会在后面每个部分的介绍里，详细的准确的说明每个部分的功能和执行大致流程。</p>
<pre><code class="language-cpp">/** Perform regular maintenance tasks.  This function gets run once per
 * second by second_elapsed_callback().
 */
static void
run_scheduled_events(time_t now)
{
  // 以下所有变量全为静态变量，每一次变量的修改都会影响下一次函数执行时候变量的值；他们大多都表示下一次需要执行某操作的时间：
  // 每1分钟之内进行的维护：
  static time_t time_to_check_listeners = 0;                        // 每60秒，检查监听端口是否正常监听；
  static time_t time_to_check_descriptor = 0;                       // 每60秒，检查自身描述符是否被修改并需要重新上载；
  static time_t time_to_shrink_memory = 0;                          // 每60秒，尝试缩小系统使用的内存空间；
  static time_t time_to_try_getting_descriptors = 0;                // 每10秒或60秒，根据需要尝试下载所有路由描述符与额外信息；
  static time_t time_to_check_port_forwarding = 0;                  // 每5秒，服务器进行的端口映射检查；
  static time_t time_to_launch_reachability_tests = 0;              // 每10秒，权威目录服务器发起的到Tor网络的连接测试；
  static time_t time_to_next_heartbeat = 0;                         // 每隔一定时间，输出心跳日志；一般为1秒一次；

  // 每10小时之内进行的维护：
  static time_t time_to_check_v3_certificate = 0;                   // 每5分钟，V3权威服务器检查自身V3证书是否过期；
  static time_t time_to_check_ipaddress = 0;                        // 每15分钟，检查地址是否发生改变；
  static time_t time_to_reset_descriptor_failures = 0;              // 每60分钟，重置下载描述符发生错误的次数；
  static time_t time_to_add_entropy = 0;                            // 每60分钟，增加OpenSSL随机数生成器的熵；
  static time_t time_to_write_bridge_status_file = 0;               // 每30分钟，将bridge networkstatus文件写回硬盘；
  static time_t time_to_downrate_stability = 0;                     // 每30分钟，？
  static time_t time_to_save_stability = 0;                         // 每30分钟，？
  static time_t time_to_clean_caches = 0;                           // 每30分钟，清理临时数据；
  static time_t time_to_check_for_expired_networkstatus = 0;        // 每2分钟，检查networkstatus是否过期；
  static time_t time_to_retry_dns_init = 0;                         // 每10分钟，服务器重新尝试初始化DNS服务；
  static time_t time_to_write_stats_files = 0;                      // 每60分钟，将系统数据写回硬盘；
  static time_t last_rotated_x509_certificate = 0;                  // 每120分钟，更新系统TLS上下文；

  // 每1天之内进行的维护：
  static time_t time_to_recheck_bandwidth = 0;                      // 每12小时，检查带宽；
  static time_t time_to_write_bridge_stats = 0;                     // 每24小时，将bridge数据写回硬盘；

  ......
} 
</code></pre>
<p></p>
<h3>　　0. Hibernation, NewNym, Log<br /></h3>
</p>
<pre><code class="language-cpp">  /** 0. See if we've been asked to shut down and our timeout has
   * expired; or if our bandwidth limits are exhausted and we
   * should hibernate; or if it's time to wake up from hibernation.
   */
  //休眠子模块代码位置：Hibernate.c
  //分析该函数时，注意hibernate_state的转换规则。
  consider_hibernation(now);
  //主机是否休眠取决于主机的带宽是否剩余不多，实际上休眠的判断就是判断当前主机读写数据量是否超过一定数值。
  //Tor配置参数内的AccountingMax参数就决定了主机所能读写的数据量。
  //AccountingMax == 0：主机不进行读写数据量的控制操作，也就永远不会休眠；
  //AccountingMax == n：主机每秒关注自身读写数据是否超过一定数值，超过则进入低带宽状态，更甚者进入休眠态。
  //AccountingStart配置参数用于指示系统控制读写量的周期，默认值为一个月。
  //通过以上两个参数，我们可以大致了解，Tor系统监测整个系统的读写数据量，在一个监测周期内，如果数据量过多，则进入低带宽或休眠态。
  //低带宽状态：维护现有连接，不再接受任何连接；（关闭监听端口）
  //休眠状态：关闭所有连接，不再接受任何连接。

  /** 0b. If we've deferred a signewnym, make sure it gets handled
   * eventually. */
  //系统的信号分为两种，一种的普通的系统信号，一种是Tor控制信号。
  //SIGNEWNYM信号就属于Tor控制信号的一种。它是通过控制连接进行信号传递的，并非普通的系统信号传递方式。
  if (signewnym_is_pending &amp;&amp;
      time_of_last_signewnym + MAX_SIGNEWNYM_RATE &lt;= now) {
    log(LOG_INFO, LD_CONTROL, "Honoring delayed NEWNYM request");
    signewnym_impl(now);
  }
  //SIGNEWNYM信号处理子模块代码位置：Main.
  //处理系统收到的更换新假名的信号：一般来说，就是要求之后新建的应用连接使用新的链路。
  //假名更换的周期为MAX_SIGNEWNYM_RATE

  /** 0c. If we've deferred log messages for the controller, handle them now */
  //日志子模块代码位置：Log.c
  flush_pending_log_callbacks();
  //简单地将挂起的日志信息输出到logfile
  //日志模块维护着一个日志文件链表logfile，每当输出一个日志消息时，遍历链表，将消息写到所有的日志文件之中。
  //实际上，系统刚刚启动之时，即在还未解析配置文件和命令行参数之前，系统也需要记录日志信息。
  //此时的日志信息，会被输出到默认输出stdout，而不被输入到日志文件内部。
  //直到系统配置文件及命令行参数被完全解析之后，系统日志模块进入正常工作状态，记录全部日志消息。
</code></pre>
<p>　　上述代码片段，主要用到的子模块包括：Log.c, Hibernation.c. </p>
<p>　　上述部分代码牵涉到系统中的几个主要的子模块。子模块的功能和操作规则均可以通过子模块源代码观察得出。分析子模块代码时，从头文件入手，清晰地分明子模块对外接口以及内部自身实现操作之间的关系与区别。对子模块对外接口的分析，有助于帮助我们理解其提供的主要功能和使用方式。每个子模块会在后面的文章中一一介绍，此处不做过多详细说明。</p>
<p></p>
<h3>　　1. Onion Key, Cpuworker, TLS, Statistics, DNS</h3>
<pre><code class="language-cpp">  /** 1a. Every MIN_ONION_KEY_LIFETIME seconds, rotate the onion keys,
   *  shut down and restart all cpuworkers, and update the directory if
   *  necessary.
   */
  //每周更新一次洋葱密钥，洋葱密钥主要用于服务器之间建立TLS连接之时保护DH密钥交换协议的部分参数：g^x。
  //洋葱密钥是路由器自身描述符的一个重要部分，若其发生改变，则需要重新上传描述符。
  //cpuworker子模块主要用于完成系统的多线程操作，一般情况下用于服务器，源代码位置：Cpuworker.c
 &nbsp;if (is_server &amp;&amp;
      get_onion_key_set_at()+MIN_ONION_KEY_LIFETIME &lt; now) {
    log_info(LD_GENERAL,"Rotating onion key.");
    rotate_onion_key();
    cpuworkers_rotate();
    if (router_rebuild_descriptor(1)&lt;0) {
      log_info(LD_CONFIG, "Couldn't rebuild router descriptor");
    }
    if (advertised_server_mode() &amp;&amp; !options-&gt;DisableNetwork)
      router_upload_dir_desc_to_dirservers(0);
  }

  //获取新的网络路由描述符和额外信息
  if (!options-&gt;DisableNetwork &amp;&amp; time_to_try_getting_descriptors &lt; now) {
    update_all_descriptor_downloads(now);
    update_extrainfo_downloads(now);
    if (router_have_minimum_dir_info())
      time_to_try_getting_descriptors = now + LAZY_DESCRIPTOR_RETRY_INTERVAL;
    else
      time_to_try_getting_descriptors = now + GREEDY_DESCRIPTOR_RETRY_INTERVAL;
  }

  //重置描述符下载错误信息
  //每种网络共识都有一个网络共识下载状态标记，记录着下载失败的次数等信息；
  //每个路由信息都有一个路由描述符下载状态标记，记录着下载失败的次数等信息；
  //重置这些标志，意味着系统重新尝试下载相关信息。
 &nbsp;if (time_to_reset_descriptor_failures &lt; now) {
    router_reset_descriptor_download_failures();
    time_to_reset_descriptor_failures =
      now + DESCRIPTOR_FAILURE_RESET_INTERVAL;
  }

  //获取网桥描述符信息，要么直接从相关网桥获取，要么从网桥权威认证服务器获取。
  if (options-&gt;UseBridges)
    fetch_bridge_descriptors(options, now);

  /** 1b. Every MAX_SSL_KEY_LIFETIME_INTERNAL seconds, we change our
   * TLS context. */
  //重置TLS上下文的工作很简单，不再过多叙述。
 &nbsp;if (!last_rotated_x509_certificate)
    last_rotated_x509_certificate = now;
  if (last_rotated_x509_certificate+MAX_SSL_KEY_LIFETIME_INTERNAL &lt; now) {
    log_info(LD_GENERAL,"Rotating tls context.");
    if (router_initialize_tls_context() &lt; 0) {
      log_warn(LD_BUG, "Error reinitializing TLS context");
      /* XXX is it a bug here, that we just keep going? -RD */
    }
    last_rotated_x509_certificate = now;
    /* We also make sure to rotate the TLS connections themselves if they've
     * been up for too long -- but that's done via is_bad_for_new_circs in
     * connection_run_housekeeping() above. */
  }

  //重新生成随机数种子，令随机数更加随机。
  //生成随机数种子的方式各种各样，主要是利用函数和随机数文件，具体可参看函数详细内容。
 &nbsp;if (time_to_add_entropy &lt; now) {
    if (time_to_add_entropy) {
      /* We already seeded once, so don't die on failure. */
      crypto_seed_rng(0);
    }
/** How often do we add more entropy to OpenSSL's RNG pool? */
#define ENTROPY_INTERVAL (60*60)
    time_to_add_entropy = now + ENTROPY_INTERVAL;
  }

  /** 1c. If we have to change the accounting interval or record
   * bandwidth used in this accounting interval, do so. */
  //执行时间段内的统计操作。
  //统计操作是用于判断系统是否进入休眠状态的重要指标，主要由AccountingMax与AccountingStart两个参数进行统计数量和统计时间的指定。
  //这个部分的操作还是主要与休眠子模块相关，所以代码部分仍然是出于Hibernation.c
 &nbsp;if (accounting_is_enabled(options))
    accounting_run_housekeeping(now);

  //发起测试网络是否可用的操作。主要用于权威目录服务器测试所有其他Tor网络结点是否可达。
  //每10秒测试一组结点，共128组结点，共需大约20分钟时间测试完成。
 &nbsp;//子模块代码处于源文件Dirserv.c
 &nbsp;if (time_to_launch_reachability_tests &lt; now &amp;&amp;
      (authdir_mode_tests_reachability(options)) &amp;&amp;
       !net_is_disabled()) {
    time_to_launch_reachability_tests = now + REACHABILITY_TEST_INTERVAL;
    /* try to determine reachability of the other Tor relays */
    dirserv_test_reachability(now);
  }

  /** 1d. Periodically, we discount older stability information so that new
   * stability info counts more, and save the stability information to disk as
   * appropriate. */
  //Tor系统包含许多统计数据，对他们进行的记录我们称之为reputation history。
  //这些统计数据包含很多种：or，bw，link，conn……
  //此处的统计处理是针对or路由历史信息进行的处理，并将其平均故障间隔时间的统计结果写回硬盘文件中。
  //我们不多做介绍，后边在源文件分析中再详细描述。
 &nbsp;//源文件内容出于Rephist.c
 &nbsp;if (time_to_downrate_stability &lt; now)
    time_to_downrate_stability = rep_hist_downrate_old_runs(now);
  if (authdir_mode_tests_reachability(options)) {
    if (time_to_save_stability &lt; now) {
      if (time_to_save_stability &amp;&amp; rep_hist_record_mtbf_data(now, 1)&lt;0) {
        log_warn(LD_GENERAL, "Couldn't store mtbf data.");
      }
#define SAVE_STABILITY_INTERVAL (30*60)
      time_to_save_stability = now + SAVE_STABILITY_INTERVAL;
    }
  }

  /* 1e. Periodically, if we're a v3 authority, we check whether our cert is
   * close to expiring and warn the admin if it is. */
  //每五分钟，作为V3目录服务器的主机检查自身服务器证书是否过时。
  //只检查并报告，不做任何额外处理。
&nbsp; if (time_to_check_v3_certificate &lt; now) {
    v3_authority_check_key_expiry();
#define CHECK_V3_CERTIFICATE_INTERVAL (5*60)
    time_to_check_v3_certificate = now + CHECK_V3_CERTIFICATE_INTERVAL;
  }

  /* 1f. Check whether our networkstatus has expired.
   */
  //检查自身拥有的网络共识是否过期，若过期则做相应操作。具体的说，该操作就是更新目录信息。
 &nbsp;if (time_to_check_for_expired_networkstatus &lt; now) {
    networkstatus_t *ns = networkstatus_get_latest_consensus();
    /*XXXX RD: This value needs to be the same as REASONABLY_LIVE_TIME in
     * networkstatus_get_reasonably_live_consensus(), but that value is way
     * way too high.  Arma: is the bridge issue there resolved yet? -NM */
#define NS_EXPIRY_SLOP (24*60*60)
    if (ns &amp;&amp; ns-&gt;valid_until &lt; now+NS_EXPIRY_SLOP &amp;&amp;
        router_have_minimum_dir_info()) {
      router_dir_info_changed();
    }
#define CHECK_EXPIRED_NS_INTERVAL (2*60)
    time_to_check_for_expired_networkstatus = now + CHECK_EXPIRED_NS_INTERVAL;
  }

  /* 1g. Check whether we should write statistics to disk.
   */
  //在一定时间结束之后（一般为一个小时），将系统统计的数据写回硬盘。
  //写回操作主要分成两个子模块处理：Rephist.c，Geoip.c
  //模块具体功能和内容后边会在源码文件的分析中详细描述。
 &nbsp;if (time_to_write_stats_files &lt; now) {
#define CHECK_WRITE_STATS_INTERVAL (60*60)
    time_t next_time_to_write_stats_files = (time_to_write_stats_files &gt; 0 ?
           time_to_write_stats_files : now) + CHECK_WRITE_STATS_INTERVAL;
    if (options-&gt;CellStatistics) {
      time_t next_write =
          rep_hist_buffer_stats_write(time_to_write_stats_files);
      if (next_write &amp;&amp; next_write &lt; next_time_to_write_stats_files)
        next_time_to_write_stats_files = next_write;
    }
    if (options-&gt;DirReqStatistics) {
      time_t next_write = geoip_dirreq_stats_write(time_to_write_stats_files);
      if (next_write &amp;&amp; next_write &lt; next_time_to_write_stats_files)
        next_time_to_write_stats_files = next_write;
    }
    if (options-&gt;EntryStatistics) {
      time_t next_write = geoip_entry_stats_write(time_to_write_stats_files);
      if (next_write &amp;&amp; next_write &lt; next_time_to_write_stats_files)
        next_time_to_write_stats_files = next_write;
    }
    if (options-&gt;ExitPortStatistics) {
      time_t next_write = rep_hist_exit_stats_write(time_to_write_stats_files);
      if (next_write &amp;&amp; next_write &lt; next_time_to_write_stats_files)
        next_time_to_write_stats_files = next_write;
    }
    if (options-&gt;ConnDirectionStatistics) {
      time_t next_write = rep_hist_conn_stats_write(time_to_write_stats_files);
      if (next_write &amp;&amp; next_write &lt; next_time_to_write_stats_files)
        next_time_to_write_stats_files = next_write;
    }
    if (options-&gt;BridgeAuthoritativeDir) {
      time_t next_write = rep_hist_desc_stats_write(time_to_write_stats_files);
      if (next_write &amp;&amp; next_write &lt; next_time_to_write_stats_files)
        next_time_to_write_stats_files = next_write;
    }
    time_to_write_stats_files = next_time_to_write_stats_files;
  }

  /* 1h. Check whether we should write bridge statistics to disk.
   */
  //将网桥数据写回硬盘，这个部分应该是作为网桥的服务器进行数据统计，其他服务器并不做过多操作。
  //作为网桥的服务器要对使用它的客户端进行按国别的统计，以测算某些国家被阻塞的严重性等数据。
  //这个部分的源码也主要处于Geoip.c
 &nbsp;if (should_record_bridge_info(options)) {
    if (time_to_write_bridge_stats &lt; now) {
      if (should_init_bridge_stats) {
        /* (Re-)initialize bridge statistics. */
        geoip_bridge_stats_init(now);
        time_to_write_bridge_stats = now + WRITE_STATS_INTERVAL;
        should_init_bridge_stats = 0;
      } else {
        /* Possibly write bridge statistics to disk and ask when to write
         * them next time. */
        time_to_write_bridge_stats = geoip_bridge_stats_write(
                                           time_to_write_bridge_stats);
      }
    }
  } else if (!should_init_bridge_stats) {
    /* Bridge mode was turned off. Ensure that stats are re-initialized
     * next time bridge mode is turned on. */
    should_init_bridge_stats = 1;
  }

  /* Remove old information from rephist and the rend cache. */
  //清空系统内缓存的各种数据。
  //主要源代码出处：Rephist.c,Rendcommon.c
 &nbsp;if (time_to_clean_caches &lt; now) {
    rep_history_clean(now - options-&gt;RephistTrackTime);
    rend_cache_clean(now);
    rend_cache_clean_v2_descs_as_dir(now);
    microdesc_cache_rebuild(NULL, 0);
#define CLEAN_CACHES_INTERVAL (30*60)
    time_to_clean_caches = now + CLEAN_CACHES_INTERVAL;
  }

#define RETRY_DNS_INTERVAL (10*60)
 &nbsp;/* If we're a server and initializing dns failed, retry periodically. */
  //服务器用于重新尝试初始化DNS服务。
  //服务源代码主要出处：DNS.c
 &nbsp;if (time_to_retry_dns_init &lt; now) {
    time_to_retry_dns_init = now + RETRY_DNS_INTERVAL;
    if (is_server &amp;&amp; has_dns_init_failed())
      dns_init();
  }
</code></pre>
<p>　　这个代码片段，主要用到的子模块包括：Rephist.c, Rendcommon.c, Dirserv.c, Dns.c, Geoip.c, Cpuworker.c, Hibernation.c. </p>
<p>　　上述代码，在普通的客户端身份下，要么是执行频率较低，要么是身份不正确，因此不会频繁被执行或甚至不会执行。主要在短期内有可能会执行是下载路由器描述符与额外信息的代码段。但是由于系统在第一次执行之时，网络共识还未获取，无从获取路由描述符与额外信息，所以会延后执行。</p>
<p></p>
<h3>　　2. Route, NetworkConsensus, Dirvote<br /></h3>
</p>
<pre><code class="language-cpp">  /** 2. Periodically, we consider force-uploading our descriptor
   * (if we've passed our internal checks). */

/** How often do we check whether part of our router info has changed in a way
 * that would require an upload? */
#define CHECK_DESCRIPTOR_INTERVAL (60)
/** How often do we (as a router) check whether our IP address has changed? */
#define CHECK_IPADDRESS_INTERVAL (15*60)

  /* 2b. Once per minute, regenerate and upload the descriptor if the old
   * one is inaccurate. */
  //每一分钟和每十五分钟，检查系统带宽和IP地址是否发生改变
 &nbsp;if (time_to_check_descriptor &lt; now &amp;&amp; !options-&gt;DisableNetwork) {
    static int dirport_reachability_count = 0;
    time_to_check_descriptor = now + CHECK_DESCRIPTOR_INTERVAL;
    check_descriptor_bandwidth_changed(now);
    if (time_to_check_ipaddress &lt; now) {
      time_to_check_ipaddress = now + CHECK_IPADDRESS_INTERVAL;
      check_descriptor_ipaddress_changed(now);
    }
    mark_my_descriptor_dirty_if_too_old(now);
    consider_publishable_server(0);            //作为服务器尝试上次自身新的描述符
    /* also, check religiously for reachability, if it's within the first
     * 20 minutes of our uptime. */
    if (is_server &amp;&amp;
        (can_complete_circuit || !any_predicted_circuits(now)) &amp;&amp;
        !we_are_hibernating()) {
      if (stats_n_seconds_working &lt; TIMEOUT_UNTIL_UNREACHABILITY_COMPLAINT) {
        consider_testing_reachability(1, dirport_reachability_count==0);  //作为服务器尝试检测自身ORPort与DirPort是否可达
        if (++dirport_reachability_count &gt; 5)
          dirport_reachability_count = 0;
      } else if (time_to_recheck_bandwidth &lt; now) {
        /* If we haven't checked for 12 hours and our bandwidth estimate is
         * low, do another bandwidth test. This is especially important for
         * bridges, since they might go long periods without much use. */
        const routerinfo_t *me = router_get_my_routerinfo();
        if (time_to_recheck_bandwidth &amp;&amp; me &amp;&amp;
            me-&gt;bandwidthcapacity &lt; me-&gt;bandwidthrate &amp;&amp;
            me-&gt;bandwidthcapacity &lt; 51200) {
          reset_bandwidth_test();
        }
#define BANDWIDTH_RECHECK_INTERVAL (12*60*60)
        time_to_recheck_bandwidth = now + BANDWIDTH_RECHECK_INTERVAL;
      }
    }

    /* If any networkstatus documents are no longer recent, we need to
     * update all the descriptors' running status. */
    /* purge obsolete entries */
    networkstatus_v2_list_clean(now);
    /* Remove dead routers. */
    routerlist_remove_old_routers();

    /* Also, once per minute, check whether we want to download any
     * networkstatus documents.
     */
    //系统成功启动最重要的函数。
    //该函数在系统没有网络共识时尝试新建连接对网络共识进行下载。
    //在此之后，系统会针对网络共识内的所有注册服务器进行微描述符的获取，
    //直到获取完毕之时，系统才开始尝试新建第一条用于通信连接的链路，并开始正常接收用户应用程序请求。
   &nbsp;update_networkstatus_downloads(now);
  }

  /** 2c. Let directory voting happen. */
  //作为权威服务器进行的投票操作，Tor系统服务器协议在文件dir_spec.txt中可以找到详细解释，此处略去。
 &nbsp;if (authdir_mode_v3(options))
    dirvote_act(options, now);</code></pre>
<p>　　此处略去许多子模块的描述，只是简单的进行操作目的的描述。我们会在后期有时间的情况下，对每一个子模块进行详细地说明。例如，服务器操作，权威服务器操作，桥服务器操作等。在这个部分，我们只要求简单的理解整个秒回调函数的大致目标：保证系统的正常运行，以及定期的系统维护，数据操作等。</p>
<p></p>
<h3>　　3. Circuit, Stream, Connection<br /></h3>
</p>
<pre><code class="language-cpp">  /** 3a. Every second, we examine pending circuits and prune the
   *    ones which have been pending for more than a few seconds.
   *    We do this before step 4, so it can try building more if
   *    it's not comfortable with the number of available circuits.
   */
  /* (If our circuit build timeout can ever become lower than a second (which
   * it can't, currently), we should do this more often.) */
  //对系统中不符合要求的链路进行删减操作。
  //由于种种原因，一些链路在新建之后，要么一直无法成功建立，要么长期无人使用等，
  //在这些情况下，系统需要对链路进行裁剪，删除无用无效的链路，以便后边重新尝试新建新链路。
 &nbsp;circuit_expire_building();

  /** 3b. Also look at pending streams and prune the ones that 'began'
   *     a long time ago but haven't gotten a 'connected' yet.
   *     Do this before step 4, so we can put them back into pending
   *     state to be picked up by the new circuit.
   */
  //对系统中不符合要求的流进行删减操作。
  //由于一些原因，一些流连接在发出连接请求之后，一直无法得到正常响应，使得连接无法正常开启，
  //在这种情况下，系统需要对流连接进行裁剪，删除无用无效的流连接，以便后边重新尝试新建流连接。
 &nbsp;connection_ap_expire_beginning();

  /** 3c. And expire connections that we've held open for too long.
   */
  //关闭长时间无数据操作的被标记为关闭的连接
 &nbsp;connection_expire_held_open();

  /** 3d. And every 60 seconds, we relaunch listeners if any died. */
  //每分钟进行监听连接的检查，开启非正常关闭的针对需要监听的端口的监听连接。
 &nbsp;if (!net_is_disabled() &amp;&amp; time_to_check_listeners &lt; now) {
    retry_all_listeners(NULL, NULL, 0);
    time_to_check_listeners = now+60;
  }</code></pre>
<p>　　该部分的代码是针对系统内的流，链路，连接进行的维护操作，以保证整个系统内的各重要功能能正常地顺利地进行。这个部分的内容应该非常容易理解，此处就不再多做说明。 </p>
<p></p>
<h3>　　4. Ideal Circuit<br /></h3>
</p>
<pre><code class="language-cpp">  /** 4. Every second, we try a new circuit if there are no valid
   *    circuits. Every NewCircuitPeriod seconds, we expire circuits
   *    that became dirty more than MaxCircuitDirtiness seconds ago,
   *    and we make a new circ if there are no clean circuits.
   */
  //系统在拥有足够的信息用以建立链路之时，要求至少需要存在一些空闲链接用来接收新请求。
  //默认情况下，要求有2条空闲链接用于处理出口要求为80端口的请求，要求有2条空闲链接用于处理隐藏服务请求。
  //系统第一次开启时，一旦拥有了足够的网络信息之后，此处的函数会被成功调用4次，从而开启2+2条空闲链路用于满足上述需求。
 &nbsp;have_dir_info = router_have_minimum_dir_info();
  if (have_dir_info &amp;&amp; !net_is_disabled())
    circuit_build_needed_circs(now);

  /* every 10 seconds, but not at the same second as other such events */
  if (now % 10 == 5)
    circuit_expire_old_circuits_serverside(now);  //关闭未使用过久的非本地发起的链路。</code></pre>
<p>　　该部分的代码是针对系统内的链路进行维护操作：保证系统总有足够的空闲链路以满足用户的需求。 </p>
<p></p>
<h3>　　5. Connection<br /></h3>
</p>
<pre><code class="language-cpp">  /** 5. We do housekeeping for each connection... */
  //每条连接的定时维护操作，无难度所以细节略，请大家自行查阅。
 &nbsp;connection_or_set_bad_connections(NULL, 0);
  for (i=0;i&lt;smartlist_len(connection_array);i++) {
    run_connection_housekeeping(i, now);
  }
  if (time_to_shrink_memory &lt; now) {
    SMARTLIST_FOREACH(connection_array, connection_t *, conn, {
        if (conn-&gt;outbuf)
          buf_shrink(conn-&gt;outbuf);
        if (conn-&gt;inbuf)
          buf_shrink(conn-&gt;inbuf);
      });
    clean_cell_pool();
    buf_shrink_freelists(0);
/** How often do we check buffers and pools for empty space that can be
 * deallocated? */
#define MEM_SHRINK_INTERVAL (60)
    time_to_shrink_memory = now + MEM_SHRINK_INTERVAL;
  }</code></pre>
</p>
<p></p>
<h3>　　6. Close Mark Circuit</h3>
</p>
<pre><code class="language-cpp">  /** 6. And remove any marked circuits... */
  //关闭被标记为关闭的链路。
 &nbsp;circuit_close_all_marked();</code></pre>
<p></p>
<h3>　　7. Hidden Service Descriptor</h3>
</p>
<pre><code class="language-cpp">  /** 7. And upload service descriptors if necessary. */
  //适当地上传自身提供的服务的描述符，需要在配置文件中配置发布HiddenService相关的选项。
  //关于HS服务的细则我们没有进行过说明，此处也不准备进行描述，后边会在分析源文件时适当地进行详细分析。
 &nbsp;if (can_complete_circuit &amp;&amp; !net_is_disabled()) {
    rend_consider_services_upload(now);
    rend_consider_descriptor_republication();
  }</code></pre>
<p></p>
<h3>　　8.Close Mark Connection</h3>
</p>
<pre><code class="language-cpp">  /** 8. and blow away any connections that need to die. have to do this now,
   * because if we marked a conn for close and left its socket -1, then
   * we'll pass it to poll/select and bad things will happen.
   */
  //关闭已经被标记为关闭的连接。
 &nbsp;close_closeable_connections();

  /** 8b. And if anything in our state is ready to get flushed to disk, we
   * flush it. */
  //将系统状态信息等写回硬盘。
 &nbsp;or_state_save(now);</code></pre>
<p></p>
<h3>　　9.DNS</h3>
</p>
<pre><code class="language-cpp">  /** 9. and if we're a server, check whether our DNS is telling stories to
   * us. */
  //服务器检查DNS，其所处模块也是Dns.c，会在后边找机会进行详细地介绍。
 &nbsp;if (!net_is_disabled() &amp;&amp;
      public_server_mode(options) &amp;&amp; time_to_check_for_correct_dns &lt; now) {
    if (!time_to_check_for_correct_dns) {
      time_to_check_for_correct_dns = now + 60 + crypto_rand_int(120);
    } else {
      dns_launch_correctness_checks();
      time_to_check_for_correct_dns = now + 12*3600 +
        crypto_rand_int(12*3600);
    }
  }</code></pre>
<p></p>
<h3>　　10. Bridge</h3>
</p>
<pre><code class="language-cpp">  /** 10. write bridge networkstatus file to disk */
 &nbsp;//关注Bridge信息的权威服务器在适当的时候将网络内的Bridge信息写回硬盘。
  if (options-&gt;BridgeAuthoritativeDir &amp;&amp;
      time_to_write_bridge_status_file &lt; now) {
    networkstatus_dump_bridge_status_to_file(now);
#define BRIDGE_STATUSFILE_INTERVAL (30*60)
    time_to_write_bridge_status_file = now+BRIDGE_STATUSFILE_INTERVAL;
  }</code></pre>
<p></p>
<h3>　　11. Proxy</h3>
</p>
<pre><code class="language-cpp">  /** 11. check the port forwarding app */
  if (!net_is_disabled() &amp;&amp;
      time_to_check_port_forwarding &lt; now &amp;&amp;
      options-&gt;PortForwarding &amp;&amp;
      is_server) {
#define PORT_FORWARDING_CHECK_INTERVAL 5
    /* XXXXX this should take a list of ports, not just two! */
    tor_check_port_forwarding(options-&gt;PortForwardingHelper,
                              get_primary_dir_port(),
                              get_primary_or_port(),
                              now);
    time_to_check_port_forwarding = now+PORT_FORWARDING_CHECK_INTERVAL;
  }

  /** 11b. check pending unconfigured managed proxies */
  if (!net_is_disabled() &amp;&amp; pt_proxies_configuration_pending())
    pt_configure_remaining_proxies();</code></pre>
<p>　　此处部分牵涉到代理及防火墙等方面的操作，笔者暂时不甚了解，暂时略去，后期找机会再详细分析。 </p>
<p></p>
<h3>　　12. Heartbeat</h3>
</p>
<pre><code class="language-cpp">  /** 12. write the heartbeat message */
  //默认情况下1秒钟一次的心跳信息输出。
 &nbsp;if (options-&gt;HeartbeatPeriod &amp;&amp;
      time_to_next_heartbeat &lt;= now) {
    log_heartbeat(now);
    time_to_next_heartbeat = now+options-&gt;HeartbeatPeriod;
  }</code></pre>
</p>
<p>　　此处许多部分都没有进行更加详尽地分析，有待后期在源代码文件中进行分别的说明。</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Tor源码分析七 &#8212; 握手协议</title>
		<link>https://uzzz.org/article/1038.html</link>
				<pubDate>Sat, 11 May 2013 07:33:09 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Source Code Analysis]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1038.html</guid>
				<description><![CDATA[　　本节主要讲述Tor系统中所用到的握手协议。握手协议分三层：TCP握手；TLS握手；Tor握手。其中Tor握手又分为三个层次：OR握手；链路建立；流建立。 　　TCP的三次握手我想应该学计算机方向的朋友无人不知了，所以此处就略去。而TLS是SSL的升级版本，其握手过程与SSLv3几乎一致。同时由于TLS根据客户端的不同握手选择，会有些许握手过程中的差别，我]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>　　本节主要讲述Tor系统中所用到的握手协议。握手协议分三层：TCP握手；TLS握手；Tor握手。其中Tor握手又分为三个层次：OR握手；链路建立；流建立。</p>
<p>　　TCP的三次握手我想应该学计算机方向的朋友无人不知了，所以此处就略去。而TLS是SSL的升级版本，其握手过程与SSLv3几乎一致。同时由于TLS根据客户端的不同握手选择，会有些许握手过程中的差别，我们希望大家能够找到TLS相关的书籍翻阅。此处就不再过多的叙述TLS的握手过程。</p>
<p>　　本文的重心着眼于描述Tor握手全过程，更甚者是描述整个Tor协议。协议的主要内容包括协议使用的主要数据结构，连接的建立和初始化，连接的协商，链路管理，流管理以及流量控制等部分。在本文描述完全之后，大家会有个对Tor系统中结点之间如何进行交流的一个比较完整的印象。当然，可以说本文中几乎全部内容都来自tor-spec.txt，也就是Tor Protocol Specification。有兴趣的朋友可以参看原文，原文必定比笔者讲的要详细清楚。</p>
<p></p>
<h2>1. 系统概述<br /></h2>
<p>　　Tor是一个用以保证用户匿名性的分布式网络。其主要的服务对象是用户所使用的基于TCP连接的应用。在使用Tor系统之时，客户端会选择一系列的结点建立Tor链路。链路中的结点，只知道其前继结点和后继结点，不知道链路中的其他结点信息。这样从某种程度上保证了坏结点存在对链路匿名性的破坏。链路中的数据流是以Cell数据包的形式进行传输的。Cell数据包的负载符合洋葱路由的特性，即由原点出发的负载被多层加密，传输过程中被层层解密；而由出口结点返回的数据在传输过程中层层加密，到原点后由原点一次性解密。而在这个加解密过程中所使用到的密钥，则是由Tor协议提供机制来协商生成的。下面先简要描述系统中所使用到的最常见的密钥：</p>
<p>　　1）Identity Key（非对称密钥的公钥）：系统中的结点均有其自身所对应的ID密钥，该密钥的作用是用以证书签名或标识路由身份。实际上，在前面的文章中我们也提到过，Tor结点根据自身的身份不同，会使用不同的Identity Key。但是，要说明的是，在目录服务器已注册的结点，不可以随意更改其Identity Key，否则就无法正常提供服务。</p>
<p>　　2）Onion Key（非对称密钥的公钥）：系统中提供中继服务的结点，即OR结点，均有一个比ID密钥更短期的一周一换的洋葱密钥。该密钥的主要作用是用来保护OP与OR之间进行DH密钥交换协议的前半部分信息（g^x）的安全性。利用Onion Key，OP与OR之间可以教安全的实行DH密钥交换协议从而协商出洋葱对称密钥。</p>
<p>　　3）Connection Key（对称密钥）：洋葱对称密钥，是OP与各个OR之间协商的临时对称密钥，用来完成上文中叙述的层层加解密功能。</p>
<p>　　另外，由于结点之间的通信都是由TLS连接来保障的，所以必定会在TLS那个层次中有一对保障TLS通信安全的对称密钥。这并非Tor系统所关心的密钥，所以略去。</p>
<p>　　注：这个部分的说明和Tor Protocol Specification之中的说明或许有所不同，大家请自行参照更多其它材料来进行分析。最终目标就是理解整个Tor系统的密钥组织结构及其使用。下面会再对整个系统的密码学相关过程做更详细的分析。</p>
<p></p>
<p align="center">　　<img src="https://uzshare.com/_p?https://img-blog.csdn.net/20130511121538743" alt=""></p>
<p align="left">　　</p>
<p align="left">　　上图中给出了Tor系统建立链路的整个过程，下面我们对它进行深入的分析。</p>
<p align="left">　　1. Alice(OP)开启Tor系统之后，需要建立第一条可用链路，她选择了OR1作为链路第一跳，并与OR1建立起了TLS连接；（TLS的建立与上层系统关系极小）</p>
<p align="left">　　2. Alice成功与OR1建立TLS连接之后，他们之间的通信就是被TLS连接保障的加密通信。此时，Alice开始执行Tor握手协议第一步：OR握手；（OR握手的过程图中并未给出，而此过程与TLS握手密切相关，我们可以暂且认为OR握手就包含于TLS握手之中）</p>
<p align="left">　　3. Alice成功与OR1完成OR握手之后，他们相互之间交换了彼此的信息。此时，Alice开始执行Tor握手协议第二步：链路建立；</p>
<p align="left">　　　　1）Tor协议中的协议数据交换使用的是固定长度的Cell，以下为Cell的简单框图：</p>
<p align="center"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20130511121549118" alt=""></p>
<p align="left">　　　　　　实际上现有版本的Cell结构已经发生了些许改变，但是此处我们用最原始的Cell结构进行说明。下面我们用稍微形式化的方式来描述上述结构：</p>
<p align="left"></p>
<p align="left">　　　　　　Cell&nbsp; ::=&nbsp; Control Cell&nbsp; |&nbsp; Relay Cell</p>
<p align="left"></p>
<p align="left">　　　　　　Control Cell&nbsp; ::=&nbsp; Control Header&nbsp; ||&nbsp; Control Payload&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Length = 2B + 1B + 509B = 512B</p>
<p align="left">　　　　　　Control Header&nbsp; ::=&nbsp; CircID&nbsp; ||&nbsp; Control CMD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Length = 2B + 1B = 3B</p>
<p align="left">　　　　　　Control Payload&nbsp; ::=&nbsp; Control DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Length = 509B</p>
<p align="left">　　　　　　Control CMD ::=&nbsp; padding&nbsp; |&nbsp; create&nbsp; |&nbsp; created&nbsp; |&nbsp; relay&nbsp; |&nbsp; destory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Length = 1B</p>
<p align="left"></p>
<p align="left">　　　　　　Relay Cell&nbsp; ::=&nbsp; Control Header&nbsp; ||&nbsp; Relay Header&nbsp; ||&nbsp; Relay Payload&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Length = 3B + 11B + 498B = 512B</p>
<p align="left">　　　　　　Relay Header&nbsp; ::=&nbsp; StreamID&nbsp; ||&nbsp; Digest&nbsp; ||&nbsp; Len&nbsp; ||&nbsp; Relay CMD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Length = 2B + 6B + 2B + 1B = 11B</p>
<p align="left">　　　　　　Relay Payload&nbsp; ::=&nbsp; Relay DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Length = 498B</p>
<p align="left">　　　　　　Relay CMD&nbsp; ::=&nbsp; data&nbsp; |&nbsp; extend&nbsp; |&nbsp; extended&nbsp; |&nbsp; truncate&nbsp; |&nbsp; truncated&nbsp; |&nbsp; begin&nbsp; |&nbsp; connected&nbsp; |&nbsp; end&nbsp; |&nbsp; teardown&nbsp; |&nbsp; sendme&nbsp; |&nbsp; drop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Length = 1B</p>
<p align="left"></p>
<p align="left">　　　　　　上述这些定义是第一版本的定义，与框图中的定义相符。而现用的Tor系统中的Cell框图在类型上和格式上都稍有区别。此处并没有给出框图，只是对原来的Relay Header的改变做一定说明。因为由于Relay Header的修改，Tor源代码中的Stream ID控制部分变得更加简化。</p>
<p align="left"></p>
<p align="left">　　　　　　Relay Header v2&nbsp; ::=&nbsp; Relay CMD&nbsp; ||&nbsp; &#8216;Recognized&#8217;&nbsp; ||&nbsp; StreamID&nbsp; ||&nbsp; Digest&nbsp; ||&nbsp; Length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Length = 1B + 2B + 2B + 4B + 2B = 11B</p>
<p align="left"></p>
<p align="left">　　　　　　由此可知，后续版本的Relay头部有了位置的变化，同时缩短了Digest的长度，增加了&#8217;Recognized&#8217;字段。我们会知道，&#8217;Recognized&#8217;字段是极其重要的字段。</p>
<p align="left">　　　　　　下面我们利用先前定义的格式来具体地描述链路建立过程与其中的数据传递细节。</p>
<p align="left"></p>
<p align="left">　　　　2）Alice与OR1建立链路</p>
<p align="left">　　　　　　首先，Alice通过查找先前获得的路由信息表来获取OR1的Onion Key 1，后边简称OK1。利用OK1，Alice构造如下的Cell传送到OR1，试图开启链路：</p>
<p align="left"></p>
<p align="left">　　　　　　　　Control Cell (Create c1)&nbsp; =&nbsp; CircID&nbsp; ||&nbsp; Control CMD&nbsp; ||&nbsp; Control Payload</p>
<p align="left">　　　　　　　　CircID&nbsp; =&nbsp; Random picked CircID （随机选取的数字a1）</p>
<p align="left">　　　　　　　　Control CMD&nbsp; =&nbsp; create</p>
<p align="left">　　　　　　　　Control Payload&nbsp; =&nbsp; AE(OK1, g^x1)&nbsp; ||&nbsp; padding if neccessary （用公钥OK1加密的DH密钥交换协议参数g^x1，再串联上填充字节）</p>
<p align="left"></p>
<p align="left">　　　　　　而后，OR1检查收取到的Cell，发现是命令为create的Control Cell。他记录下对应的CircID a1，用自己的OK1私钥解密并取出DH密钥交换协议参数g^x1，同时选取DH密钥交换协议第二部分参数g^y1，计算出DH密钥交换协议生成的对称密钥SK1，构造如下的Cell发送回Alice，试图告诉Alice链路可以成功开启：</p>
<p align="left"></p>
<p align="left">　　　　　　　　Control Cell (Created c1)&nbsp; =&nbsp; CircID&nbsp; ||&nbsp; Control CMD&nbsp; ||&nbsp; Control Payload</p>
<p align="left">　　　　　　　　CircID&nbsp; =&nbsp; a1</p>
<p align="left">　　　　　　　　Control CMD&nbsp; =&nbsp; created</p>
<p align="left">　　　　　　　　Control Payload&nbsp; =&nbsp; g^y1&nbsp; ||&nbsp; H(SK1)&nbsp; ||&nbsp; padding if neccessary （明文形式的DH密钥交换协议参数g^y1，串联上DH密钥交换协议生成的密钥SK1的哈希值，最后再串联上必要的填充字节）</p>
<p align="left"></p>
<p align="left">　　　　　　其后，Alice根据接收Cell的CircID a1能够确认她收到的是OR1的回复。她检测Cell的命令是created，则得知链路创建成功，于是就取出DH密钥交换协议的第二部分参数g^y1，计算出DH密钥交换协议生成的对称密钥SK1。利用该SK1，Alice就可以有效地构造洋葱数据了。</p>
<p align="left"></p>
<p align="left">　　　　3）Alice与OR2建立链路</p>
<p align="left">　　　　　　这个部分确切的说应该是Alice通过OR1与OR2建立链路。若是仅仅的Alice与OR2建立链路，那么链路的建立过程与上述的过程完全一致，没有差别。所以这个小部分说的是Alice实现链路的拓展。</p>
<p align="left">　　　　　　首先，Alice明确自己要通过OR1实现链路的拓展，并且选定了OR2作为拓展链路的目标结点，那么此时，她构造如下的Cell发送给OR1，要求OR1为其实现链路拓展的目标：</p>
<p align="left"></p>
<p align="left">　　　　　　　　Relay Cell (Extend e1)&nbsp; =&nbsp; CircID&nbsp; ||&nbsp; Control CMD&nbsp; ||&nbsp; SE(SK1, Relay Header&nbsp; ||&nbsp; Relay Payload) （利用对称密钥SK1对数据进行的对称加密）</p>
<p align="left">　　　　　　　　CircID&nbsp; =&nbsp; a1</p>
<p align="left">　　　　　　　　Control CMD&nbsp; =&nbsp; relay</p>
<p align="left">　　　　　　　　Relay Header&nbsp; =&nbsp; Relay CMD&nbsp; ||&nbsp; &#8216;Recognized&#8217;&nbsp; ||&nbsp; StreamID&nbsp; ||&nbsp; Digest&nbsp; ||&nbsp; Length</p>
<p align="left">　　　　　　　　Relay CMD&nbsp; =&nbsp; extend</p>
<p align="left">　　　　　　　　StreamID&nbsp; =&nbsp; 0 （其实随意什么值均可，extend命令下的StreamID没有实际用处）</p>
<p align="left">　　　　　　　　Relay Payload&nbsp; =&nbsp; OR2&nbsp; ||&nbsp; AE(OK2, g^x2)&nbsp; ||&nbsp; padding if neccessary</p>
<p align="left"></p>
<p align="left">　　　　　　其后，OR1接收到了上述Cell，打开Cell头部看到CircID a1，并且是个Relay Cell，就用之前与Alice生成的对称密钥SK1对负载部分进行解密。解密之后，认出了Relay Header中的’Recognized‘，此时发现，OR1被要求做的工作是extend。于是，OR1查看Relay Payload找到需要拓展链路的目标为OR2，取出AE(OK2, g^x2)。之后就像Alice与OR1建立链路的过程一样，OR1发起与OR2建立链路的过程。构造的Cell如下：</p>
<p align="left"></p>
<p align="left">
<p align="left">　　　　　　　　Control Cell (Create c2)&nbsp; =&nbsp; CircID&nbsp; ||&nbsp; Control CMD&nbsp; ||&nbsp; Control Payload</p>
<p align="left">　　　　　　　　CircID&nbsp; =&nbsp; Random picked CircID （随机选取的数字a2，关联a1与a2）</p>
<p align="left">　　　　　　　　Control CMD&nbsp; =&nbsp; create</p>
<p align="left">　　　　　　　　Control Payload&nbsp; =&nbsp; AE(OK2, g^x2)&nbsp; ||&nbsp; padding if neccessary （Alice传递而来的协议数据，再串联上填充字节）</p>
<p align="left"></p>
<p align="left">　　　　　　而后，OR2的操作与上轮中OR1反馈Alice建立链路的操作一模一样。OR2返回数据之后，OR1将数据用对称密钥SK1加密，返回Alice。构造如下形式的Cell：</p>
<p align="left"></p>
<p align="left">
<p align="left">　　　　　　　　Relay Cell (Extended e1)&nbsp; =&nbsp; CircID&nbsp; ||&nbsp; Control CMD&nbsp; ||&nbsp; SE(SK1, Relay Header&nbsp; ||&nbsp; Relay Payload) （利用对称密钥SK1对数据进行的对称加密）</p>
<p align="left">　　　　　　　　CircID&nbsp; =&nbsp; a1</p>
<p align="left">　　　　　　　　Control CMD&nbsp; =&nbsp; relay</p>
<p align="left">　　　　　　　　Relay Header&nbsp; =&nbsp; Relay CMD&nbsp; ||&nbsp; &#8216;Recognized&#8217;&nbsp; ||&nbsp; StreamID&nbsp; ||&nbsp; Digest&nbsp; ||&nbsp; Length</p>
<p align="left">　　　　　　　　Relay CMD&nbsp; =&nbsp; extended</p>
<p align="left">　　　　　　　　StreamID&nbsp; =&nbsp; 0 （其实随意什么值均可，extended命令下的StreamID没有实际用处）</p>
<p align="left">　　　　　　　　Relay Payload&nbsp; =&nbsp; g^y2&nbsp; ||&nbsp; H(SK2)&nbsp; ||&nbsp; padding if neccessary</p>
<p></p>
<p align="left">　　　　　　最后，Alice拿到数据包，对应上CircID，解密发现识别成功，并且数据命令为拓展链路成功，于是计算出Alice与OR2的对称密钥SK2。</p>
<p align="left"></p>
<p align="left">　　4. 至此，Alice想要建立的链路建立完毕。此时，Alice开始Tor握手连接第三步：流建立；最后发送数据。</p>
<p align="left">　　　　Alice在建立完链路之后，她希望向外发送请求数据。但是，她需要先在给定链路中开启一个数据流。也就是说她需要选定一个数据流的出口位置，是OR1，还是OR2？图中假定她所选定的数据流出口为OR2，则她此时需要向OR2发送命令，要求OR2开启对应的流为其服务。那么她需要构造如下的命令包：</p>
<p align="left">　　　　　　</p>
<p align="left">　　　　　　Relay Cell (begin b1)&nbsp; =&nbsp; CircID&nbsp; ||&nbsp; Control CMD&nbsp; ||&nbsp; SE(SK1, SE(SK2, Relay Header&nbsp; ||&nbsp; Relay Payload)) （利用对称密钥SK1对数据进行的对称加密）</p>
<p align="left">　　　　　　CircID&nbsp; =&nbsp; a1</p>
<p align="left">　　　　　　Control CMD&nbsp; =&nbsp; relay</p>
<p align="left">　　　　　　Relay Header&nbsp; =&nbsp; Relay CMD&nbsp; ||&nbsp; &#8216;Recognized&#8217;&nbsp; ||&nbsp; StreamID&nbsp; ||&nbsp; Digest&nbsp; ||&nbsp; Length （OR1看不到）</p>
<p align="left">　　　　　　Relay CMD&nbsp; =&nbsp; begin （OR1看不到）</p>
<p align="left">　　　　　　StreamID&nbsp; =&nbsp; s1 （OR1看不到）</p>
<p align="left">　　　　　　Relay Payload&nbsp; =&nbsp; request （OR1看不到）</p>
<p></p>
<p>　　　　OR1收取数据之后，经过解密之后，发现无法辨认&#8217;Recognized&#8217;。因为此时&#8217;Recognized&#8217;还被一层对称加密所包裹。所以他断定此Cell的目的地并非自己，于是找到a1对应的CircID a2，发送到对应目标OR2。构造的数据如下：</p>
<p></p>
</p>
<p align="left">　　　　　　Relay Cell (begin b1)&nbsp; =&nbsp; CircID&nbsp; ||&nbsp; Control CMD&nbsp; ||&nbsp; SE(SK2, Relay Header&nbsp; ||&nbsp; Relay Payload) （利用对称密钥SK1对数据进行的对称加密）</p>
<p align="left">　　　　　　CircID&nbsp; =&nbsp; a2</p>
<p align="left">　　　　　　Control CMD&nbsp; =&nbsp; relay</p>
<p align="left">　　　　　　Relay Header&nbsp; =&nbsp; Relay CMD&nbsp; ||&nbsp; &#8216;Recognized&#8217;&nbsp; ||&nbsp; StreamID&nbsp; ||&nbsp; Digest&nbsp; ||&nbsp; Length</p>
<p align="left">　　　　　　Relay CMD&nbsp; =&nbsp; begin</p>
<p align="left">　　　　　　StreamID&nbsp; =&nbsp; s1</p>
<p align="left">　　　　　　Relay Payload&nbsp; =&nbsp; request(host, port)</p>
<p align="left"></p>
<p align="left">　　　　OR2收到了上述数据，解密发现被认出，获取begin命令，则其开启向目标服务器的TCP连接。重要的是，他记录了该StreamID与其目标服务器之间的对应关系。之后，只要来次该CircID,StreamID的数据，全部一致性抛出给对应的目标服务器。数据回传的过程与数据传出的过程类似，应用数据传输的过程与上述传输的过程类似，所以下面就将其他部分的说明略去。</p>
<p></p>
<h2>2. TLS握手与OR握手</h2>
<p align="left">　　在系统概述部分我们也简单提到了TLS握手与OR握手之间的密切关系，但是到底是如何的关系呢？又为什么要有OR握手这么奇怪的协议呢？我们知道，TLS握手的过程中，通信双方交换的信息并非只为了协商出最后的通信对称密钥，还有更多的信息。例如说，TLS握手的过程中，通信双方需要确定各自使用的版本，需要明确是否在和正确的对象进行交换，还需要交换写时间戳等信息。这些信息的交换，使得TLS握手是双方能够确信他们之间交互的可行性，可信性和安全性。OR握手，其实也有与TLS握手的目标差不多，只不过他是出于Tor系统OR层上的。也就是说，OR握手的目的，是确信自己与一个Tor系统内的中继服务器进行交换，同时交换各自版本信息，验证身份，再交换些许额外信息。因为TLS握手与OR握手的所处层次还是有差别的，所以两者不能相互替代。</p>
<p align="left">　　我们说，OR握手是建立在TLS握手基础上的。Tor系统中双方在通信TLS握手完成之后，立即进行相对应的OR握手。而在这个过程中，使用到的TLS握手方式也是不一定相同的。Tor系统会根据版本的不同，而实行不同的握手方式，下面我们就来详细地描述整个过程。</p>
<h3 align="left">　　1）概要</h3>
<p align="left">　　　　Tor系统中主机之间所使用到的协议为TLS/SSLv3。所有版本的Tor系统的实现，都必须能够支持SSLv3的密码工具集&#8221;SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA&#8221;，同时应该能够支持TLS的密码工具集&#8221;TLS_DHE_RSA_WITH_AES_128_CBC_SHA&#8221;。</p>
<p align="left">　　　　Tor系统中，TLS握手的完成有三种方式：&#8221;certificate-up-front&#8221;；&#8221;renegotiation&#8221;；&#8221;in-protocol&#8221;。</p>
<p align="left">
<p align="left"></p>
<h3 align="left">　　2）三种方式细则</h3>
<p align="left">　　　　“certificate-up-front” (a.k.a &#8220;the v1 handshake&#8221;)：连接的发起者通常会发送包含两个证书的证书链。这两个证书分别为用短期连接公钥加密的X.509证书与其自签名的包含其自身identity key的X.509证书。连接的接收者通常也会发送类似的证书链。这种握手方式下，连接的发起者只允许使用固定的密码工具集：（TLS握手初期有发起者给定，详见TLS握手）</p>
<p align="left">　　　　　　　　TLS_DHE_RSA_WITH_AES_256_CBC_SHA</p>
<p align="left">　　　　　　　　TLS_DHE_RSA_WITH_AES_128_CBC_SHA</p>
<p align="left">　　　　　　　　SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA</p>
<p align="left"></p>
<p align="left">　　　　“renegotiation” (a.k.a &#8220;the v2 handshake&#8221;)：连接的发起者不再发送任何证书，而连接的接受者发送一个单独的连接证书。一旦TLS连接完成，连接双方利用包含两个证书的证书链重新协商连接。这种握手方式下，连接的发起者至少要使用比上述固定的密码工具集多一种方式的工具集。一般情况下，我们要求使用该握手方式的连接发起者至少使用扩大的固定密码工具集，包括20多种密码套件（包括上述三种），我们称之为&#8221;Fixed Ciphercuite List&#8221;。如果发起者使用扩大的固定密码工具集，那么接受者仅能挑选固定密码工具集中的密码套件；如果发起者使用比扩大的固定密码工具集还大的工具集，那么接受者有理由相信连接发起者支持所有他所声称的密码套件。</p>
<p align="left"></p>
<p align="left">　　　　&#8221;in-protocol&#8221; (a.k.a &#8220;the v3 handshake&#8221;)：与v2握手方式几乎一致，只是通信双方没有再使用证书链重新协商连接，而是在单证书中包含了些限制来指示双方需要使用的握手版本为v3以上版本，并且使用了比较特别的重新协商的方式。这些证书中的限制包括：</p>
<p align="left">　　　　　　* The certificate is self-signed</p>
<p align="left">　　　　　　* Component other than &#8220;commonName&#8221; is in the subject or issuer DN of the certificate</p>
<p align="left">　　　　　　* The commonName of the subject or issuer ends with a suffix other than &#8220;.net&#8221;</p>
<p align="left">　　　　　　* The certificate&#8217;s public key modules is longer than 1024 bits</p>
<p align="left">　　　　特殊的重新协商方式是三次单向交互（*代表客户端希望自身验证时需要发出的信息）：</p>
<p align="left">&nbsp;&nbsp; 　　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　　　　　　Client&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Server</p>
<p align="left">　　　　　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　　　VERSION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8212;&#8212;&#8212;&#8212;&#8212;&gt;</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VERSION</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&#8212;&#8212;&#8212;&#8212;&#8212;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; AUTH-CHALLENGE</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NETINFO</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NETINFO</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8212;&#8212;&#8212;&#8212;&#8212;&gt;</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AUTHENTICATE*</p>
<p></p>
<h2 align="left">3. 流量控制</h2>
<p>　　Tor系统包含了三个层次的流量控制：OR层；Circuit层；Stream层。这里只做简要描述，就不再贴出代码进行分析。笔者今天心力交瘁= =。下面为基本层次结构：</p>
<p></p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　Stream Layer</p>
<p>　　　　　　　　　　　　　　　　　　　　　　－－－－－－－－－－－－－－－－－－－－</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　Circuit Layer</p>
<p>　　　　　　　　　　　　　　　　　　　　　　－－－－－－－－－－－－－－－－－－－－</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　OR Layer</p>
<p>　　　　　　　　　　　　　　　　　　　　　　－－－－－－－－－－－－－－－－－－－－</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　TLS Layer</p>
<p></p>
<p>　　在这三层的流量控制之中，OR层的流量控制利用的是令牌桶机制，而另外两层所用的是类似简化的滑动窗口机制。</p>
<h3>　　1）令牌桶机制<br /></h3>
<p>　　　　令牌桶机制的大致原理是，系统维护一个令牌桶，每隔一段时间往里添加令牌，而每个需要发出的消息需要抓取到一个令牌之后才可以发出。也就是说，发出消息消耗令牌，而每隔一段时间，系统会补充令牌。这样，通过控制令牌桶中令牌的数量，来限制消息发出的速度和流量。在稳定状态下，消息流出的速度至多是系统填充令牌的速度。而系统填充令牌的速度是可以通过配置文件进行配置的，所以也就是说，稳定时消息流出的最大速度也是可配置的。我们可以在代码中很容易地找到关于控制令牌数的全局变量。他们分别是控制经过自身的全部数据的读写令牌桶，以及控制以自身为传递结点的数据的读写令牌桶：</p>
<pre><code class="language-cpp">int global_read_bucket; /**&lt; Max number of bytes I can read this second. */
int global_write_bucket; /**&lt; Max number of bytes I can write this second. */

/** Max number of relayed (bandwidth class 1) bytes I can read this second. */
int global_relayed_read_bucket;
/** Max number of relayed (bandwidth class 1) bytes I can write this second. */
int global_relayed_write_bucket;</code></pre>
<p>　　　　系统在收到或发出相应数据的时候，会对令牌桶内令牌数进行删减，利用函数connection_buckets_decrement()。系统每隔refilltime时间便对令牌桶进行填充，利用函数connection_bucket_refill_helper()。我们知道refill时间是可以有配置文件或命令行参数进行配置的，他的默认值为100msec。</p>
<h3>　　2）简化滑动窗口机制</h3>
<p>　　　　Circuit层与Stream层的流量控制机制则要稍微复杂些。滑窗机制的大致过程是：一开始系统维护一个滑窗，允许消息发送者发送滑窗容量多的消息。随着消息的发送，滑窗容量减小，最终会使得滑窗容量降为零。此时，消息发送方需要等待消息接收方给其发来一个继续发送消息的请求。接收到该请求之后，消息发送方增加适当大小的滑窗容量。于是，消息发送方又可以继续发送消息，知道窗口容量用完。当然，在窗口未降为零时，消息发送方自然也是可以返回要求消息发送方继续发消息的请求，这样可以保持滑窗始终有容量。</p>
<p>　　　　Tor系统中Circuit层与Stream层使用的滑窗由circuit_t与edge_connection_t两个结构体中的package_window和deliver_window来表示。我们此处先针对Circuit层的情况进行分析，因为他与Stream层的处理方式一模一样，但是又有些特别之处。大致的框图结构如下：</p>
<p></p>
<p>　　　　　　　　　　1.　　&#8212;&#8211;&gt;&nbsp; OP package window&nbsp; ======================&gt;&nbsp; EXIT deliver window&nbsp; &#8212;&#8211;&gt;</p>
<p>　　　　　　　　　　2.　　&lt;&#8212;&#8211;&nbsp; OP delivery window&nbsp;&nbsp; &lt;======================&nbsp; EXIT package window&nbsp; &lt;&#8212;&#8211;　　　　</p>
<p></p>
<p>　　　　上述描述图中，1中为应用请求数据进入OP主机，并从OP主机流出，经过Tor链路，到达EXIT主机，最终流出Tor网络的过程；2中为应用响应数据进入EXIT主机，并从EXIT主机流出，经过Tor链路，达到OP主机，最终被返回到指定应用程序的过程。我们来讨论这两个在Tor系统中最普遍的过程执行之中的窗口变化情况。</p>
<p>　　　　针对1过程，数据从OP主机流出，耗费了其打包窗口的容量，例如从1000降到900；数据流入EXIT主机并流出网络，耗费了其传递窗口的容量，例如从1000降到900；此时，EXIT传递窗口的大小下降到了一定的值，但他觉得他还可以处理更多数据，于是就向OP发送sendme请求，告诉OP他可以接收更多数据；请求发送出之前，EXIT就先增加自己的传递窗口大小，例如从900增加到1000；请求发出之后，被OP收到，OP则相应地增加自己的打包窗口大小，例如从900增加到1000。</p>
<p>　　　　针对2过程，其实完全是1过程进行了反向而已。在此过程中，数据主要由EXIT发往OP，而命令sendme是由OP发往EXIT。</p>
<p>　　　　注意：</p>
<p>　　　　　　i）整个过程之中，没有提到中间OR结点。实际上，中间结点在Circuit层与Stream层不做任何流量控制的处理，他们只负责传递消息。相应的在代码中会发现，所有的关于流量控制的部分，都是在自身的应用数据要发出之前，以及接收到的Relay数据被识别之后进行的。所以，这两个部分根本和OR中间结点没有关系。因为OR中间结点无法插入自身应用数据，更不可能识别任何Relay数据。</p>
<p>　　　　　　ii）OP端需要为每一条链路的每个可能出口准备窗口记录；EXIT需要为每一条链路准备窗口记录。我们研究整个系统的时候会发现，链路建立完成之后，OP可以随意选择链路之中的出口，以建立数据流。所以，对于OP来说，他所进行的端到端链路流量控制必须依照链路数据出口或入口结点进行控制。具体的说，OP的链路流量控制，利用的是结构体crypt_path_t。origin_circuit_t结构体中含有包含链路中所有结点的crypt_path_t双向循环列表，以此可以很容易地管理package_window和deliver_window两个变量。对于EXIT来说，他只需要处理好每个链路内的package_window和deliver_window变量即可，这两变量在circuit_t结构体内也能找到。</p>
<p>　　　　　　iii）Stream层的流量控制与Circuit层几乎一致，package_window和deliver_window在edge_connection_t结构体内，其他不再多说。</p>
<h2 align="left">4. 额外的说明<br /></h2>
<p align="left">　　本文中进行的介绍，加入了许多笔者自己的分析，大家可以先看Tor Protocol Specification，之后根据自己的想法与笔者的相比较。当然必然存在错误，请大家批评指正。同时，此文中删去了很多关于消息格式，各种包的格式等具体细则，请大家参看tor_spec.txt。</p>
<p align="left"></p>
<p align="left"></p>
<p align="left"></p>
<p align="left"></p>
<p align="left"></p>
<p align="left">未完待续</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Tor源码分析六 &#8212; 总体框架图</title>
		<link>https://uzzz.org/article/1063.html</link>
				<pubDate>Fri, 10 May 2013 03:36:46 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Source Code Analysis]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1063.html</guid>
				<description><![CDATA[1. 客户端的总体框图 　　由于画框图的过程稍微繁琐，所以框图给出的稍慢了些，请大家见谅。同时，框图画的比较急促，一定会有错误的地方，请大家指正。 　　框图中给出了客户端Tor系统所使用到的最重要的结构体以及其成员变量，有兴趣的朋友可以自行比对，这里就不便多说了。 2. 服务器端的总体框图（2合1） 　　服务器端的框图将两种身份的服务器所使用到的主要结构体均]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<h2>1. 客户端的总体框图</h2>
<p>　　由于画框图的过程稍微繁琐，所以框图给出的稍慢了些，请大家见谅。同时，框图画的比较急促，一定会有错误的地方，请大家指正。</p>
<p>　　框图中给出了客户端Tor系统所使用到的最重要的结构体以及其成员变量，有兴趣的朋友可以自行比对，这里就不便多说了。</p>
<p align="center"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20130510112149311" alt=""></p>
<p></p>
<h2>2. 服务器端的总体框图（2合1）</h2>
<p>　　服务器端的框图将两种身份的服务器所使用到的主要结构体均画了出来。也就是说该框图中展现服务器的两种功能：Relay OR，EXIT OR.</p>
<p align="center"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20130510113426224" alt=""></p>
<p align="left"></p>
<h2 align="left">3. 一些额外的说明</h2>
<p align="center"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20130510113614361" alt=""></p>
</p></div>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
