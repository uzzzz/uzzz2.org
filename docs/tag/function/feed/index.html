<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>function &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/tag/function/feed" rel="self" type="application/rss+xml" />
	<link>https://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Fri, 11 Sep 2009 03:41:00 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>function &#8211; 有组织在!</title>
	<link>https://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Flex Deep Link(深链接) BrowserManager</title>
		<link>https://uzzz.org/article/1714.html</link>
				<pubDate>Fri, 11 Sep 2009 03:41:00 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[application]]></category>
		<category><![CDATA[flash]]></category>
		<category><![CDATA[flex]]></category>
		<category><![CDATA[function]]></category>
		<category><![CDATA[url]]></category>
		<category><![CDATA[浏览器]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1714.html</guid>
				<description><![CDATA[最近做游戏的时候，发现退出登陆时URL上会自动加上一个“#”字符，很奇怪，Google+Baidu无数次都没有找到答案。今天无意间看到几个群友在说通过“BrowserManager”获取URL，于是仔细查看了API，又发现了“HistoryManager”，这个问题终于明白了。 我们通常看的Web页面 可以通过浏览器的“前进”“后退”来查看刚才看过的页面，同]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>最近做游戏的时候，发现退出登陆时URL上会自动加上一个“#”字符，很奇怪，Google+Baidu无数次都没有找到答案。今天无意间看到几个群友在说通过“BrowserManager”获取URL，于是仔细查看了API，又发现了“HistoryManager”，这个问题终于明白了。</p>
<p>我们通常看的Web页面 可以通过浏览器的“前进”“后退”来查看刚才看过的页面，同样，嵌入的页面中的flash也可以实现这样的功能。方法是通过HistoryManageer类和BrowserManager类两种方法来实现。HistoryManageer类主要是用在Flex2，Flex3后很少用了。待会我将分别介绍这两种方法。</p>
<p>回到刚才说URL上自动加“#”号的问题：原因是Application 默认historyManagementEnabled属性是ture，也就是说HistoryManageer类功能自动开启了，Application 里面通过程序控制addChild或removeChild任何组件所导致的变化，将会记录在flash的history中，导致重写url，加上“#”字符。故有了这个奇怪的“#”号。在Flex3中，HistoryManager功能在Flex项目中默认打开的还有Accordion 和 TabNavigator组件。对于没有默认打开该功能的组件，如果要实现该功能，则需要另外注册。下面引用两片文章加以说明：<br />对于一个网站来说，其是有若干个网页组成的。而各个网页之间的链接叫做超链接。链接成为网页和网页之间的桥梁。那么，对于一个Flash整站来说，有没有一个办法来实现Flash各页面（更恰当的说是各功能模块）之间的链接呢。比如，我想在浏览器中输入一个链接便可以链到Flash整站中的一页—一个功能模块，而不是每次都要通过Flash整站的第一个页面的功能导航进入。把Flash的各个功能块页面化，那么我们该怎么实现呢。到底能不能实现呢？<br />&nbsp; 答案是肯定的，通过Flex Deep Link 便能实现上述功能。<br />&nbsp; &lt;script language=javascript type=text/javascript&gt;&lt;/script&gt; </p>
<fieldset id="catalog">
<legend>目录 <span class="on-off" id="hideOrshow"><a id="doccatalog_hide_show">[隐藏]</a> </span></legend>
<ul class="link_black" id="full" style="display:block;">
<li><a href="http://writeblog.csdn.net/wiki/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29#1" rel="nofollow" data-token="e3f5d7e86ad81a1d0a8ff7bccf13784a">1 第一，Deep Link 简介。</a> </li>
<li><a href="http://writeblog.csdn.net/wiki/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29#3" rel="nofollow" data-token="8a7a8a2193018c29fc1cb74d53cc8915">2 &nbsp; 第二，HistoryManager。</a> </li>
<li><a href="http://writeblog.csdn.net/wiki/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29#5" rel="nofollow" data-token="a694f9cc82d7e3a7ac76cb14e53b9320">3 方法：</a> </li>
<li><a href="http://writeblog.csdn.net/wiki/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29#7" rel="nofollow" data-token="016195c1d7f1bdb581c708db900d1bdf">4 属性：</a> </li>
<li><a href="http://writeblog.csdn.net/wiki/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29#9" rel="nofollow" data-token="e8b23dbbb08c76046255fb8c41a0f5f5">5 &nbsp; 如何分析URl</a> </li>
<li><a href="http://writeblog.csdn.net/wiki/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29#11" rel="nofollow" data-token="9dad0cae07a63be7b8422a66f2a5d70a">6 &nbsp; 获得链接信息</a> </li>
</ul>
</fieldset>
<div class="content_h2">
<h2>Flex Deep Link(深链接)-第一，Deep Link 简介。</h2>
<p>   <span><a class="mceItemAnchor" name="1">&nbsp;</a> </span>
  </div>
<p>&nbsp; Deep Link其实也是依赖Flash和浏览器的交互来实现的，通过获取链接地址中#后面的参数来实现页面标记，当你在Flex Bulid3发布一个项目时，其会自动你发布的目录生成一个名为History的文件夹，里面有History.js,HistoryFrame.html,history.css这三个文件，可见Deep Link也是通过和浏览器交互来实现的.如果浏览器不支持JavaScript或者禁用JavaScript，那么Deep LinK肯定是不能用的。<br />&nbsp; 对于Deep Link应用，最重要的就是学会应用BrowserManager和HistoryManager这两个类。我们由简单到困难，先讲一讲HistoryManager这个类的应用。</p>
<div class="content_h2">
<h2>Flex Deep Link(深链接)-&nbsp; 第二，HistoryManager。</h2>
<p>   <span>&nbsp;<a href="http://writeblog.csdn.net/editsectionauth/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29/3" rel="nofollow" data-token="48dd4cc1bfb43134e3ca3d157f9b9535">&nbsp;</a><a href="http://writeblog.csdn.net/#catalog" rel="nofollow" data-token="f1db0e193720074bc010856f9b17911c"> </a></span>
  </div>
<p>&nbsp; HistoryManager功能在Flex项目中是默认打开的，比如在使用Accordion 和 TabNavigator组件时，在不同区域切换时，Flex会自动记录下各个状态，我们可以通过点击浏览器的“前进”和“后退”按钮来前进和倒退，在你切换这些组件的区域时，Flex会自动你在网页链接的后面加写参数，以便记录当前页面的状态。<br />&nbsp; 默认情况下HistoryManager的功能是打开的，你可以通过设置各个组件或Application的historyManagementEnabled属性为false（默认为TRUE）来关闭此功能。<br />&nbsp; 这些都没什么好讲的。关键是怎么在一些普通组建上使用HistoryManager功能，默认的navigator container组建都是支持该功能的。要使一些普通组建也支持此功能，必须：<br />&nbsp; 1.实现mx.managers.IHistoryManagerClient接口。<br />&nbsp; 2.用HistoryManager&#8217;的register()方法为组建注册。<br />&nbsp; 3.当组件状态改变时保存组件的状态。<br />&nbsp; 4.通过实施IHistoryManagerClient的saveState() 和 loadState()方法来保存和读取组件状态。</p>
<p>&nbsp;<br />&nbsp;拿CheckBox为例：</p>
<p>&nbsp;<br />&lt;?xml version=&#8221;1.0&#8243;?&gt;<br />&lt;mx:CheckBox&nbsp;<br />&nbsp; xmlns:mx=&#8221;http://www.adobe.com/2006/mxml&#8221;<br />&nbsp; label=&#8221;Check me&#8221;&nbsp;<br />&nbsp; &nbsp;<br />&nbsp; implements=&#8221;mx.managers.IHistoryManagerClient&#8221; //关键步骤1，实现接口<br />&nbsp; creationComplete=&#8221;mx.managers.HistoryManager.register(this);&#8221;//关键步骤2，注册组件<br />&nbsp; change=&#8221;boxChanged(event)&#8221;//关键步骤3，当组件发生变化时保存状态<br />&gt;</p>
<p>&nbsp; &lt;mx:Script&gt;&lt;![CDATA[<br />&nbsp; import mx.managers.HistoryManager;<br />&nbsp; //实施IHistoryManagerClient的saveState()方法保存状态<br />&nbsp; public function saveState():Object {<br />return {selected:selected};<br />&nbsp; }<br />&nbsp; //实施IHistoryManagerClient的loadState()方法读取状态<br />public function loadState(state:Object):void {<br />var newState:Boolean = state;</p>
<p>if (newState != selected) {<br />&nbsp; selected = newState;<br />} else {<br />&nbsp; if (newState) {<br />&nbsp; ;<br />&nbsp; } else {<br />&nbsp; selected = true;<br />&nbsp; }<br />}<br />&nbsp; }<br />&nbsp; &nbsp;<br />&nbsp; // 保存状态<br />&nbsp; private function boxChanged(e:Event):void {<br />HistoryManager.save();<br />&nbsp; } &nbsp;<br />&nbsp; ]]&gt;&lt;/mx:Script&gt;</p>
<p>&lt;/mx:CheckBox&gt;<br />&nbsp; 注意：如果你把实现HistoryManager功能的组件放到module中，再在主程序中调用，那么HistoryManager功能是没用的。<br />&nbsp; 麻雀虽小，五脏俱全。上面例子就是如何让任意组件实现HistoryManager的典型案例。点击浏览器的“前进”和“后退”来恢复上个或下个状态。<br />BrowserManager类要比HistoryManager类更复杂些。BrowserManager类好比就是Flex程序和浏览器之间的一个代理。当浏览地址栏的地址发生变化时，浏览器通过BrowserManager类告知Flex程序。&nbsp;<br />&nbsp; 可以通过BrowserManager类的getInstance()方法来获得其一个实施了IBrowserManager接口的实例。这样就可以访问其setTitle()和setFragment()方法和属性了。下面我就来介绍一下BrowserManager类的一些属性和方法。<br />&nbsp; </p>
<div class="content_h2">
<h2>Flex Deep Link(深链接)-方法：</h2>
</p></div>
<p>&nbsp; 1.init(fragment,title)<br />&nbsp; 该方法可以定义默认的链接参数和网页标题。一般在初始化时用到。例如：<br />&nbsp; browserManager.init(&#8220;&#8221;, &#8220;Test Deep Linking&#8221;);定义了参数为空，标题为Test Deep Linking的网页。<br />&nbsp; 2.setTitle(title)<br />&nbsp; 该方法用来设置网页标题。例如：<br />&nbsp; browserManager.setTitle(&#8220;The New Title&#8221;) 设置网页标题为“The New Title”。<br />&nbsp; 3.setFragment(fragment)<br />&nbsp;该方法用来设置网页参数。例如：<br />&nbsp;browserManager.setFragment(&#8220;id=3&#8221;) 设置参数“id=3”。<br />&nbsp; </p>
<div class="content_h2">
<h2>Flex Deep Link(深链接)-属性：</h2>
</p></div>
<p>&nbsp; 1.url<br />&nbsp; browserManager.url获得页面完整链接。<br />&nbsp; 2.base<br />&nbsp; browserManager.base获得页面基地址。<br />&nbsp; 3.fragment<br />&nbsp; browserManager.fragment获得页面链接#后的参数。<br />&nbsp; 4.lastURL<br />&nbsp; browserManager.lastURL获得上一个页面链接——IE6我获得是失败的，火狐正确。大家可以自己试试。</p>
<p>&nbsp; 注意：上面的browserManager便是BrowserManager类的一个实例。实例化过程如下：<br />&nbsp; import mx.events.BrowserChangeEvent;<br />&nbsp; import mx.managers.IBrowserManager;<br />&nbsp; import mx.managers.BrowserManager;<br />&nbsp; private var browserManager:IBrowserManager;<br />&nbsp; private function initApp():void {<br />&nbsp; browserManager = BrowserManager.getInstance();<br />&nbsp; browserManager.addEventListener(BrowserChangeEvent.BROWSER_URL_CHANGE, parseURL);<br />&nbsp; browserManager.init(&#8220;&#8221;, &#8220;Test Deep Linking&#8221;);<br />}</p>
<div class="content_h2">
<h2>Flex Deep Link(深链接)-&nbsp; 如何分析URl</h2>
</p></div>
<p>&nbsp; 可以用URLUtil类方便的分析Url<br />&nbsp; 类路径mx.utils.URLUtil，例如链接：http://127.0.0.1/index.html#a=3&amp;b=1<br />&nbsp; var o:Object = URLUtil.stringToObject(browserManager.fragment,&#8221;&amp;&#8221;);<br />&nbsp; trace(o.a,o.b)<br />&nbsp; 反过来设置地址栏链接：<br />&nbsp; o.a=5；o.b=7；<br />&nbsp; var s:String = URLUtil.objectToString(o,&#8221;&amp;&#8221;);<br />&nbsp; browserManager.setFragment(s);<br />&nbsp; 注意：如果 URLUtil.objectToString()方法第二个参数为空，那么默认的参数分隔符为&#8221;；&#8221;号。<br />&nbsp;<br />&nbsp; BrowserManager类的事件<br />&nbsp; BrowserManager类有三种事件：<br />&nbsp; 1.applicationURLChange事件；<br />&nbsp; 当在程序执行时调用setFragment()等方法改变URL时派发此事件。<br />&nbsp; 2.browserURLChange事件；<br />&nbsp; 当手动改变浏览器链接或点击“前进”或“后退”时派发此事件。<br />&nbsp; 3.urlChange事件；<br />&nbsp; applicationURLChange事件或browserURLChange事件派发时，都将触发该事件。</p>
<div class="content_h2">
<h2>Flex Deep Link(深链接)-&nbsp; 获得链接信息</h2>
</p></div>
<p>&nbsp; 可以通过BrowserManager类的属性和URLUtil的一些方法来获得链接信息，例如：<br />&nbsp; var url:String = browserManager.url;<br />&nbsp; baseURL = browserManager.base;<br />&nbsp; fragment = browserManager.fragment; &nbsp;<br />&nbsp; previousURL = e.lastURL; &nbsp;</p>
<p>&nbsp; fullURL = mx.utils.URLUtil.getFullURL(url, url);<br />&nbsp; port = mx.utils.URLUtil.getPort(url);<br />&nbsp; protocol = mx.utils.URLUtil.getProtocol(url);<br />&nbsp; serverName = mx.utils.URLUtil.getServerName(url);<br />&nbsp; isSecure = mx.utils.URLUtil.isHttpsurl(/url);</p>
<p>&nbsp; 具体含义也很清楚，我也就不多讲了。<br />&nbsp; 关于BrowserManager类大致也就上面的内容。要注意的是BrowserManager类和HistoryManager类不能同时使用，也就是说用了BrowserManager类就不能再用HistoryManager类了，当你用了BrowserManager类后，系统会自动禁用HistoryManager类。<br />&nbsp; 既然能获得了参数，那么实现文章开头那些功能也就没什么了。通过在初始化程序中获取相应的参数，再根据这些参数控制程序显示。和.net,asp,php类似，万物皆规律。有了BrowserManager类的帮助，加上一些程序控制，现在我在浏览器输入http://127.0.0.1/news.html#id=20便能在Flash整站中显示某个新闻页面了。</p>
</p></div>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
