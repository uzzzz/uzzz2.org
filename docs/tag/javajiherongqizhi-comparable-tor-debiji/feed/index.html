<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>java集合容器至 Comparable/tor 的笔记 &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/tag/javajiherongqizhi-comparable-tor-debiji/feed" rel="self" type="application/rss+xml" />
	<link>https://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Tue, 11 Dec 2018 06:52:34 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>java集合容器至 Comparable/tor 的笔记 &#8211; 有组织在!</title>
	<link>https://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>java集合容器至 Comparable/tor 的笔记</title>
		<link>https://uzzz.org/article/1087.html</link>
				<pubDate>Tue, 11 Dec 2018 06:52:34 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>
		<category><![CDATA[java集合容器至 Comparable/tor 的笔记]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1087.html</guid>
				<description><![CDATA[================ ArrayList 查的快======================== 主要的索引的方法： index对应元素的 1： 存取的是一致： 2： 有索引 3： 可存取重复 注意：就是 关于 索引的 越界的异常 &#8212;&#8212;&#8212;-。主要的方法 add（加一个） addAll（全加） remove 删除]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div id="content_views" class="markdown_views prism-atom-one-dark">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<p>================ ArrayList 查的快========================<br /> 主要的索引的方法： index对应元素的<br /> 1： 存取的是一致：<br /> 2： 有索引<br /> 3： 可存取重复<br /> 注意：就是 关于 索引的 越界的异常<br /> &#8212;&#8212;&#8212;-。主要的方法<br /> add（加一个） addAll（全加）<br /> remove 删除指定一个的 removeAll（删除指定全部的）</p>
<p>get（获取 ） set（替换） 返回的是以替换的 位置</p>
<p>ArrayList 的底层 是 数组扩容的<br /> ######list集合的几个遍历的方法<br /> 1：普通for、 2：增强 for 3：迭代器Iteration</p>
<p>====<mark><mark><mark><mark><mark><mark><mark>linkdeList 增删改的快</mark></mark></mark></mark></mark></mark></mark><br /> lastAdd（）lastAddAll（）<br /> endAdd（）endAddAll（）</p>
<p>linkdeList：底层是 双循环 链表结构</p>
<p>节点的原因：看源码&#8212;&#8211; 数组转 链表<br /> add linkedlast类里的 函数</p>
<p>—遍历慢— 每次 都是<br /> 加速的功能 的 —》在里面找get方法 里nodenode方法 里<br /> 在 长度大于二分之一的就 会 从头往后找 往 小于 ， 就从后往头找<br /> 现在问的都是 1.7 的 hashMap 1.8 的就会很少的<br /> 比如&#8212;&#8212;过时的单线程的线程安全模式&#8212;&#8212;&#8212;查的也是慢</p>
<p>=<mark><mark><mark><mark>==============set ===================<br /> 唯一 无序的 没有索引 是原始简单的集合<br /> 查询 快 的优势</mark></mark>用hash表来实现的<br /> 没有索引值的</mark></mark>》不能普通的for循环</p>
<p>底层的hash表结构<br /> @@@ ==》普通for循环是不行的 ： 因为没有索引值 的<br /> 迭代器 增强for 都可以的 需要Collcetion 的 Iteractor<br /> &#8212;&#8212;&#8212;&#8212;&#8212;&#8211;hash 太常见 了 因为继承于 Object</p>
<p>哈希表的最大的特点：查询快 哈希表本质 就是 一个Map集合</p>
<p>hash 是什么 对象的地址值 系统随机给出的十进制的<br /> 重写hascode 的方法<br /> 模拟了地址值 ：列举 当hash值一样 物理地址值 就有不一样的<br /> 所以就要有 qrulse 来比较重复的值<br /> equlse 的比较 有重复的就不存<br /> hashSet：JDK8之前 ：数组+链表<br /> JDK8之后 ：数组+ 链表 还有 + 红黑树：<br /> 链表长度超过8位的就转为红黑树 的快查机制</p>
<p>数组 把元素 做为 数组里的分组 （相同的元素为一组）<br /> 然后再把相同的一组 ：用 链表与红黑树 来进行<br /> 而链表在过于长的时候就查是的慢了 这时候<br /> 链表长度超过8位的就转为红黑树 的快查接力</p>
<p>set集合的存储机制：避免重复元素的 原理</p>
<p>横为数组 竖 为链表 或红黑树</p>
<ul>
<li>hash表是模拟物理地址的 有可重复的元素</li>
<li>在通过equals 就决定了比较怕重复的不予存储的 去重<br /> 最终追溯 源码的<br />
<hr> </li>
</ul>
<p>哈希表 就是 一个Map集合</p>
<p>================ Collections 集合工具类 &#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br /> Collections 集合工具类 util 对于集合的操作<br /> 都是 静态方法<br /> public static boolean addAll: 往集合里添加一些元素<br /> publictatic void shuffle（List&lt;?&gt; list）: 打乱集合的元素&#8212;&#8212;-比如打牌游戏 的 洗牌 就是一个shuffle<br /> public static void sort(List list):将集合元素按照 默认的规则来排序<br /> public static void sort（List list，comparator&lt;? superT&gt;）:<br /> 按照指定的（自定义的）=规则来排序</p>
<p>====》通过分析方法定义的参数：指定专属 List 类型的 使用的就是 参数里有List的<br /> sort’方法的参数 的底层 是实现了 1：comparable接口里的compareTo方法 compraeTo（）方法里定义了 比较的规则<br /> ===&gt;泛型里类型 就实现了 这个方法 于是 就查看这个泛型的源码</p>
<p>public final class Integer extends Numble implements Comparable{}</p>
<p>也就是 集合里的泛型 包装类 的 都是实现了 comparable比较器<br /> String实现了 内比较器 ：采用的是 JDK提供 源码的定义的规则<br /> 同在 Java.lang 系统的<br /> public final class String implements Java.io.Serializable,Comparable<br /> ,CharSequence{}</p>
<p>举例说： 集合里 存储的是 person类 有name 与age的属性</p>
<p>索引的0减一 根据一个差值 来决定 二分叉的<br /> sort 方法参数 2：<br /> 按照首字母进行排序 使用匿名类进行的不太理解</p>
<p>——————————————————————————————————</p>
<p>比较器的接口 分为： 内比较器 comparable （内ble） 外比较器 comparator （外tor）</p>
<p>=======&gt;内比较器 comparable 内部的就写的是固定的版本方法 所以通过源码的 比较器<br /> =======&gt;外比较器 comparator 外部 的自定义的来进行 降序 与升序的编码<br /> ====》这是 要学的 编码</p>
<h2><a id="_comparator___105"></a>@@@@@外比较器 comparator— 自定义 的</h2>
<p>这是 要学写的编码 灵活的使用在 你要比较的地方直接的实现比较的规则就可以<br /> 多用于匿名类的方式 来实现灵活的完成<br /> 匿名类依赖 产生的接口：Comparator 大括号里重写 compare（）</p>
<h2><a id="
_______
_______

___________
_________
_______111"></a>数字的是：<br /> 前减后 ：升序 前要减的 为升—前减为升<br /> 后减前 ：降序 后要减的 为降— 后减为降<br /> 对象的引用的是：<br /> 前 调用 后的==》 为升 &#8212;&#8211;前调 为升<br /> 后 调用 前的==》 为降序 &#8212;&#8211; 后调 为降<br /> 你可以转成 接口的实现类里来完成 理解后 在进行 匿名类的方式</h2>
<p>comparator 外比较器 与 Comparable内比较器的区别</p>
<p>Comparable：内比较器：是直接就实行了整体排序 自动的排序无需指定 只能用一次 写死的硬编码的<br /> compareTo（）<br /> 类在定义的时候就已产生了比较的规则：升序了Comparable 并完成compareTo方法 你可以设置你的排序 降序与升序 天生就具</p>
<h2><a id="_125"></a>备了比较的规则</h2>
<p>Comparator ：外比较器：作为sort里的参数 以匿名实现类的方式 进行<br /> 重写方法里的 控制 降序 或 升序 的 还可以控制 数据结构 和 为没有自然排序的对象提供排序<br /> compare（）<br /> 在类 没有实现 内比较器 的时候 我们在 测试类里 使用<br /> &#8212;&#8212;》外比较器 用于 已经实现 内比较器的使用<br /> @@@ 还可以在 你的使用了（实现）内比较器 的方式 还可以在 测试类里 完成 外比较器的 再次设置</p>
<p>在内部类里 的匿名类的使用率高的 要记住掌握 匿名类<br /> 匿名内部类的 范围： 大括号里的<br /> 集合里的线程<br /> ArrayList 与linkedList 是多线程的 线程是安全吗？？</p>
<p>########################### Map #####################################</p>
<p>先讲的出 增加激情 与自信 做的好</p>
<p>key 的值是不可重复的： 键找值的方法 keySet（）；<br /> 添add重复的key 就是要更新 对应的 value 值 然后替换（覆盖）==》还是唯一了</p>
<p>最常用的就是=====》HashMap<br /> JDK 1.8与1.8 之前 ：<br /> 每个集合 对用的 常用的集合类：3个代表： Arraylist HashSet HashMap</p>
<p>@@@ map 不适用 普通的for 与Intarator迭代器</p>
<p>增强for的遍历是：使用类型==》 数组 Collection 接口<br /> map 中的键与值的映射关系<br /> put 方法里 就是通过键 值的依赖作用来更新对应 认识达到了<br /> 、 键找值的 和值找键 的方式<br /> 加上 遍历的循环查找<br /> put 的认识是 和add不同的是 在map键与值的映射的特点里、<br /> 可以 键找值 与值找 键的映射 依赖的关系 来 （更新 获取） 彼此<br /> put（） remove（） get（） containsKey（）</p>
<p>get（） ：直接的get （）就可以获取 键 与 值 彼此的 映射</p>
<p>&#8212;-》键 与 值的一对 还可以是个Entry 对象<br /> 也可以说map集合里的泛型就是一个Entry对象</p>
<p>hash 表就是 Map集合？？？？？</p>
<p>Map的获取 直接是的输出 就是一对一对的 键 值 或者 Entry</p>
<p>其中基于Map 键与值 的 映射中的获取<br /> &#8212;&#8211;》这两种获取 的区别<br /> 单纯的通过键找值的==》 keySet（）理解记忆key就是键 键存储在Set里确保唯一<br /> 值找 键==》values<br /> Entry对象的获取 的 getKey（） getValue（）<br /> Entry 就是map的内部类的</p>
<p>HashMap hash确保 键与值各自 唯一<br /> 创建实体类 在测试类里进行存取 的Demo 发现了 存与获取的顺序是不一致的</p>
<p>LinkedHashMap 增加了 Linked可以确保存取的顺序是一致是的</p>
<hr>
<p>&#8212;&#8212;&#8212;&#8212;-map&#8212;&#8212;&#8211;<br /> hashMap ： key 值唯一的 ，value 为null<br /> hashset 的：<br /> 底层是 使用的code值 唯一的 要说 hash 肯还会问的<br /> Entry 对象数据<br /> hashMap—看源码：当前编辑器里 ctrl+N 搜索–看源码</p>
<p>到了这个阶段我们应该需要 怎样 的目标的 感觉</p>
<p>总结：<br /> 1 利用 key的hashcode &#8212;&#8212;&#8211;理论唯一 并不代表 实现是唯一的<br /> Entry 数组是的默认的大小16 0.75 12 到原来的 长度的0.75 就加载 =<mark>必问<br /> Load加载因子</mark>=扩容机制<br /> 再看put 就多了<br /> 扩容 2的幂次方 一千个 &#8211;2048<br /> 扩容的问题： 在进行扩容机制是非常损耗资源的 &#8212;-因为 数组 对象 还要节点<br /> 所以 最好要给与一个新的 已知 map好你的初始化 的数组</p>
<p>hashMap 不安全的 加了一整把锁 效果差一点把<br /> 解决 —ConcurrentHashMap 分段锁 机制<br /> 默认16个段（就是锁 ： HashMap）然后分段的存储的 解耦 的锁机制还可以扩容</p>
<p>笔试题：&#8212;&#8212;&#8211;》手写单项列表</p>
<p>拍的技术的核心就是原理&#8212;-大公司 的就是不需要有多大的项目</p>
<p>== 与 equals 是没有区别的 &#8212;-普通认知是的 误区<br /> 源码里有一个的<br /> return==obj<br /> GC 机制 的<br /> 单例模式</p>
<p>====================集合之间的转换,存储元素的 转存 ========================<br /> Set paihao = new HashSet&lt;&gt;();&#8212;&#8212;&gt;<br /> ArrayList pokerhao=new ArrayList&lt;&gt;();<br /> pokerhao.addAll(paihao)</p>
<h1><a id="map_
_
1___Scanner___
_2fori_____
3__
4map_containsKey_
______map_put__1_
elsemapgetkye_value__
______mapput_
5mapEntry__
___map2_1for__2_Intrator_222"></a>=<mark><mark><mark><mark><mark><mark>》使用map方法的 的案例应用《</mark></mark></mark></mark></mark></mark>========<br /> 的思路：<br /> 1：字符串的获取 ： Scanner 的键盘输入<br /> 2：手动的fori 生成 循环 将 获取的字符串对象 遍历<br /> 3：字符串对象 调用 字符的获取方法，返回字符变量<br /> 4：使用map 调用的containsKey（）的参数是这个字符变量 &#8211;》进行否定的判断<br /> map 调用put方法 传入字符变量与 次数为1<br /> else：map调用get（）获取kye键字符 返回value数量的对象 这个次数 自增<br /> map调用put 传入字符与自增的变量<br /> 5：map获取Entry对象类遍历 打印输出<br /> map遍历2种方法 1：增强for与 2： Intrator迭代器</h1>
<p>map 键找值的认知：<br /> 1：键找值的方法遍历map ,必须要用上keySet 、可以不用get（）<br /> :2：HashMap存储自定义练习的键值对 的说法：<br /> 可以存储自定义 放在键或者 值的对方 在键上的就必须重写 hashcode()yu<br /> 与equals() 来确 唯一<br /> 3：map存储的是键值对的数据 双列集合 键与值 的数据类型都可以 但是键的唯一 是必须的<br /> 4：键值对的找键和值 对于map 遍历说法：<br /> 5： Map的键key 只能是引用类型的数据 value值 也存放基本数据 引用类型的<br /> map集合是通过entrySet()来获取键值对 对象的<br /> map是 不能用普通for来遍历的 要在获取对象之后 就可以用：增强for与迭代器Intarator</p>
<p>1： null 0<br /> 2： 键找值的 不只要键找值的 还可以get（）<br /> 3： key是可以的 存放 引用的 基本的都可以</p>
<p>@#@@@ next（只 读到有效的 字符）不管是 nextInt 还是 NextDuble 都会有问题的<br /> nextline(读到 Enter键) 一行一行的读</p>
<p>注意：集合 双方的《泛型》数据类型要一致</p>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e9f16cbbc2.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
